
CM530.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000134  08003000  08003000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000052ac  08003134  08003134  00003134  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         000004e0  20000000  080083e0  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00001538  200004e0  080088c0  000104e0  2**2
                  ALLOC
  4 ._usrstack    00000100  20001a18  08009df8  000104e0  2**0
                  ALLOC
  5 .comment      000004a0  00000000  00000000  000104e0  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000004b0  00000000  00000000  00010980  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00003821  00000000  00000000  00010e30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0000da6d  00000000  00000000  00014651  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000038d5  00000000  00000000  000220be  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000033f0  00000000  00000000  00025993  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00002684  00000000  00000000  00028d84  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000051b7  00000000  00000000  0002b408  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00004cf5  00000000  00000000  000305bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .ARM.attributes 00000031  00000000  00000000  000352b4  2**0
                  CONTENTS, READONLY
 15 .debug_ranges 00000388  00000000  00000000  000352e8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .isr_vector:

08003000 <g_pfnVectors>:
 8003000:	20010000 	.word	0x20010000
 8003004:	08007a2d 	.word	0x08007a2d
 8003008:	0800344d 	.word	0x0800344d
 800300c:	08003451 	.word	0x08003451
 8003010:	08003455 	.word	0x08003455
 8003014:	08003459 	.word	0x08003459
 8003018:	0800345d 	.word	0x0800345d
	...
 800302c:	08003465 	.word	0x08003465
 8003030:	08003461 	.word	0x08003461
 8003034:	00000000 	.word	0x00000000
 8003038:	08003469 	.word	0x08003469
 800303c:	08003575 	.word	0x08003575
 8003040:	0800346d 	.word	0x0800346d
 8003044:	08003471 	.word	0x08003471
 8003048:	08003475 	.word	0x08003475
 800304c:	08003479 	.word	0x08003479
 8003050:	0800347d 	.word	0x0800347d
 8003054:	08003481 	.word	0x08003481
 8003058:	08003485 	.word	0x08003485
 800305c:	08003489 	.word	0x08003489
 8003060:	0800348d 	.word	0x0800348d
 8003064:	08003491 	.word	0x08003491
 8003068:	08003495 	.word	0x08003495
	...
 8003088:	080034b5 	.word	0x080034b5
 800308c:	080034b9 	.word	0x080034b9
 8003090:	080034bd 	.word	0x080034bd
 8003094:	080034c1 	.word	0x080034c1
 8003098:	080034c5 	.word	0x080034c5
 800309c:	080034c9 	.word	0x080034c9
 80030a0:	080034cd 	.word	0x080034cd
 80030a4:	080034d1 	.word	0x080034d1
 80030a8:	080034d5 	.word	0x080034d5
 80030ac:	080034d9 	.word	0x080034d9
 80030b0:	080034dd 	.word	0x080034dd
 80030b4:	080034e1 	.word	0x080034e1
 80030b8:	080034e5 	.word	0x080034e5
 80030bc:	080034e9 	.word	0x080034e9
 80030c0:	080034ed 	.word	0x080034ed
 80030c4:	080034f1 	.word	0x080034f1
 80030c8:	080034f5 	.word	0x080034f5
 80030cc:	080034f9 	.word	0x080034f9
 80030d0:	080034fd 	.word	0x080034fd
 80030d4:	08003569 	.word	0x08003569
 80030d8:	08003501 	.word	0x08003501
 80030dc:	0800355d 	.word	0x0800355d
 80030e0:	08003505 	.word	0x08003505
 80030e4:	08003509 	.word	0x08003509
 80030e8:	0800350d 	.word	0x0800350d
 80030ec:	08003511 	.word	0x08003511
 80030f0:	08003515 	.word	0x08003515
 80030f4:	08003519 	.word	0x08003519
 80030f8:	0800351d 	.word	0x0800351d
 80030fc:	08003521 	.word	0x08003521
 8003100:	08003525 	.word	0x08003525
 8003104:	08003529 	.word	0x08003529
 8003108:	0800352d 	.word	0x0800352d
 800310c:	08003531 	.word	0x08003531
 8003110:	08003535 	.word	0x08003535
 8003114:	08003551 	.word	0x08003551
 8003118:	08003539 	.word	0x08003539
 800311c:	0800353d 	.word	0x0800353d
 8003120:	08003541 	.word	0x08003541
 8003124:	08003545 	.word	0x08003545
 8003128:	08003549 	.word	0x08003549
 800312c:	0800354d 	.word	0x0800354d
 8003130:	0000f85f 	.word	0x0000f85f

Disassembly of section .text:

08003134 <_exit>:
    PrintString("CM-530 Experimental Example         ");
    //Buzzed(150, 2300);    // 217 Hz ~ A_4

}

void _exit(void) {
 8003134:	e7fe      	b.n	8003134 <_exit>
 8003136:	46c0      	nop			(mov r8, r8)

08003138 <main>:
#include "button.h"
#include "mic.h"
#include "motion_f.h"
//#include <stdlib.h>

int main(void) {
 8003138:	b5f0      	push	{r4, r5, r6, r7, lr}
 800313a:	b081      	sub	sp, #4

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
 800313c:	f002 fd60 	bl	8005c00 <SysInit>

	byte	ReceivedData;
	char    tmpComm[128];
	char * ReceivedCommand;
	ReceivedCommand = tmpComm;
	PrintString("Starting Program by turning on POWER LED!\r\n");
 8003140:	48a1      	ldr	r0, [pc, #644]	(80033c8 <main+0x290>)
 8003142:	f000 fc83 	bl	8003a4c <PrintString>
	SetLED(POWER, 1);
 8003146:	2000      	movs	r0, #0
 8003148:	2101      	movs	r1, #1
 800314a:	f002 f9c1 	bl	80054d0 <SetLED>
/*
		PrintString("Battery Voltage: ");
		Printu32d((u32)ReadAnalog(VBUS)>>4);
		PrintString("e-1 [Volts]\n");
*/
		Battery_Monitor_Alarm();
 800314e:	f002 f96b 	bl	8005428 <Battery_Monitor_Alarm>

		    PrintString("PCU:");
 8003152:	489e      	ldr	r0, [pc, #632]	(80033cc <main+0x294>)
 8003154:	f000 fc7a 	bl	8003a4c <PrintString>
		#ifdef USING_PC_UART
		    Printu32d(Baudrate_PCU);
 8003158:	4b9d      	ldr	r3, [pc, #628]	(80033d0 <main+0x298>)
		    PrintString("Not in use\n");
		#endif

		    PrintString("DXL:");
		#ifdef USING_DYNAMIXEL
		    Printu32d(Baudrate_DXL);
 800315a:	4c9e      	ldr	r4, [pc, #632]	(80033d4 <main+0x29c>)
*/
		Battery_Monitor_Alarm();

		    PrintString("PCU:");
		#ifdef USING_PC_UART
		    Printu32d(Baudrate_PCU);
 800315c:	6818      	ldr	r0, [r3, #0]
 800315e:	f000 fc3d 	bl	80039dc <Printu32d>
		    PrintString("(bps)\n");
 8003162:	489d      	ldr	r0, [pc, #628]	(80033d8 <main+0x2a0>)
 8003164:	f000 fc72 	bl	8003a4c <PrintString>
		#else
		    PrintString("Not in use\n");
		#endif

		    PrintString("ZIG:");
 8003168:	489c      	ldr	r0, [pc, #624]	(80033dc <main+0x2a4>)
 800316a:	f000 fc6f 	bl	8003a4c <PrintString>
		#ifdef USING_ZIGBEE
		    Printu32d(Baudrate_ZIG);
 800316e:	4b9c      	ldr	r3, [pc, #624]	(80033e0 <main+0x2a8>)
 8003170:	6818      	ldr	r0, [r3, #0]
 8003172:	f000 fc33 	bl	80039dc <Printu32d>
		    PrintString("(bps)\n");
 8003176:	4898      	ldr	r0, [pc, #608]	(80033d8 <main+0x2a0>)
 8003178:	f000 fc68 	bl	8003a4c <PrintString>
		#else
		    PrintString("Not in use\n");
		#endif

		    PrintString("DXL:");
 800317c:	4899      	ldr	r0, [pc, #612]	(80033e4 <main+0x2ac>)
 800317e:	f000 fc65 	bl	8003a4c <PrintString>
		#ifdef USING_DYNAMIXEL
		    Printu32d(Baudrate_DXL);
 8003182:	6820      	ldr	r0, [r4, #0]
 8003184:	f000 fc2a 	bl	80039dc <Printu32d>
		    PrintString("(bps)\n");
 8003188:	4893      	ldr	r0, [pc, #588]	(80033d8 <main+0x2a0>)
 800318a:	f000 fc5f 	bl	8003a4c <PrintString>
		#endif

//		Buzzed(150, 200);    // 2500 Hz ~ Ds_7/Eb_7


		ReceivedData = std_getchar();;
 800318e:	f000 fd25 	bl	8003bdc <std_getchar>
 8003192:	b2c0      	uxtb	r0, r0

		//if(strcmp(ReceivedCommand, "led on") == 0){
		if(ReceivedData == 'l'){
 8003194:	286c      	cmp	r0, #108
 8003196:	d113      	bne.n	80031c0 <main+0x88>
			std_putchar(ReceivedData);
 8003198:	f000 fb62 	bl	8003860 <std_putchar>
			PrintString(" * \t* Turn on LEDs!\r\n");
 800319c:	4892      	ldr	r0, [pc, #584]	(80033e8 <main+0x2b0>)
 800319e:	f000 fc55 	bl	8003a4c <PrintString>
			SetLED(POWER, 1);
 80031a2:	2000      	movs	r0, #0
 80031a4:	2101      	movs	r1, #1
 80031a6:	f002 f993 	bl	80054d0 <SetLED>
			SetLED(PLAY, 1);
 80031aa:	2003      	movs	r0, #3
 80031ac:	2101      	movs	r1, #1
 80031ae:	f002 f98f 	bl	80054d0 <SetLED>
			SetLED(MANAGE, 1);
 80031b2:	2001      	movs	r0, #1
 80031b4:	2101      	movs	r1, #1
 80031b6:	f002 f98b 	bl	80054d0 <SetLED>
			SetLED(PROGRAM, 1);
 80031ba:	2002      	movs	r0, #2
 80031bc:	2101      	movs	r1, #1
 80031be:	e014      	b.n	80031ea <main+0xb2>
		}
		else if(ReceivedData == 'o'){
 80031c0:	286f      	cmp	r0, #111
 80031c2:	d115      	bne.n	80031f0 <main+0xb8>
		//else if(strcmp(ReceivedCommand, "led off")){
			std_putchar(ReceivedData);
 80031c4:	f000 fb4c 	bl	8003860 <std_putchar>
			PrintString(" * \t* Turn off LEDs!\r\n");
 80031c8:	4888      	ldr	r0, [pc, #544]	(80033ec <main+0x2b4>)
 80031ca:	f000 fc3f 	bl	8003a4c <PrintString>
			SetLED(POWER, 0);
 80031ce:	2000      	movs	r0, #0
 80031d0:	2100      	movs	r1, #0
 80031d2:	f002 f97d 	bl	80054d0 <SetLED>
			SetLED(PLAY, 0);
 80031d6:	2003      	movs	r0, #3
 80031d8:	2100      	movs	r1, #0
 80031da:	f002 f979 	bl	80054d0 <SetLED>
			SetLED(MANAGE, 0);
 80031de:	2001      	movs	r0, #1
 80031e0:	2100      	movs	r1, #0
 80031e2:	f002 f975 	bl	80054d0 <SetLED>
			SetLED(PROGRAM, 0);
 80031e6:	2002      	movs	r0, #2
 80031e8:	2100      	movs	r1, #0
 80031ea:	f002 f971 	bl	80054d0 <SetLED>
 80031ee:	e0e6      	b.n	80033be <main+0x286>
		}
		//else if(strcmp(ReceivedCommand, "motors report")){
		else if(ReceivedData == 'm'){
 80031f0:	286d      	cmp	r0, #109
 80031f2:	d166      	bne.n	80032c2 <main+0x18a>
			u8 id, num=0;
			u16 wdata, error, pdata, perror;
			dxl_initialize(Baudrate_DXL);
 80031f4:	6820      	ldr	r0, [r4, #0]
 80031f6:	f001 f813 	bl	8004220 <dxl_initialize>
 80031fa:	2700      	movs	r7, #0
 80031fc:	2501      	movs	r5, #1
 80031fe:	b2ee      	uxtb	r6, r5
			for (id=1; id<(250); id++)
			{
				wdata = (dxl_read_byte(id, P_ID)&0x00FF);
 8003200:	2103      	movs	r1, #3
 8003202:	4630      	mov	r0, r6
 8003204:	f000 ffbc 	bl	8004180 <dxl_read_byte>
				if (wdata==id)
 8003208:	b2ab      	uxth	r3, r5
 800320a:	b280      	uxth	r0, r0
 800320c:	4298      	cmp	r0, r3
 800320e:	d14d      	bne.n	80032ac <main+0x174>
				{
					wdata=0;
					num++;
					PrintString("{");
 8003210:	4877      	ldr	r0, [pc, #476]	(80033f0 <main+0x2b8>)
 8003212:	f000 fc1b 	bl	8003a4c <PrintString>
					Printu32d(id);
 8003216:	4628      	mov	r0, r5
 8003218:	f000 fbe0 	bl	80039dc <Printu32d>
					PrintString(", ");
 800321c:	4875      	ldr	r0, [pc, #468]	(80033f4 <main+0x2bc>)
 800321e:	f000 fc15 	bl	8003a4c <PrintString>

					// Read present position
					wdata = dxl_read_word(id, P_MODEL_NUMBER_L);
 8003222:	2100      	movs	r1, #0
 8003224:	4630      	mov	r0, r6
 8003226:	f000 ff5d 	bl	80040e4 <dxl_read_word>
 800322a:	4604      	mov	r4, r0
					error = dxl_get_result();
 800322c:	f000 fd04 	bl	8003c38 <dxl_get_result>


					if (!(error&DXL_RXSUCCESS))
 8003230:	f010 0f02 	tst.w	r0, #2	; 0x2
 8003234:	d102      	bne.n	800323c <main+0x104>
						PrintCommStatus(error);
 8003236:	f000 fc0f 	bl	8003a58 <PrintCommStatus>
 800323a:	e00b      	b.n	8003254 <main+0x11c>
					else{
						PrintString(",* ");
 800323c:	486e      	ldr	r0, [pc, #440]	(80033f8 <main+0x2c0>)
 800323e:	f000 fc05 	bl	8003a4c <PrintString>
						Printu32d(dxl_read_word( id, AXM_PRESENT_POSITION_L ));
 8003242:	2124      	movs	r1, #36
 8003244:	4630      	mov	r0, r6
 8003246:	f000 ff4d 	bl	80040e4 <dxl_read_word>
 800324a:	f000 fbc7 	bl	80039dc <Printu32d>
						PrintString("*, ");
 800324e:	486b      	ldr	r0, [pc, #428]	(80033fc <main+0x2c4>)
 8003250:	f000 fbfc 	bl	8003a4c <PrintString>
					}
					Printu32d(wdata);
 8003254:	4620      	mov	r0, r4
 8003256:	f000 fbc1 	bl	80039dc <Printu32d>
					if (wdata==MODEL_AX12)
 800325a:	2c0c      	cmp	r4, #12
					{
						PrintString(" (AX-12)");
 800325c:	bf08      	it	eq
 800325e:	4868      	ldreq	r0, [pc, #416]	(8003400 <main+0x2c8>)
						PrintString(",* ");
						Printu32d(dxl_read_word( id, AXM_PRESENT_POSITION_L ));
						PrintString("*, ");
					}
					Printu32d(wdata);
					if (wdata==MODEL_AX12)
 8003260:	d014      	beq.n	800328c <main+0x154>
					{
						PrintString(" (AX-12)");
					}
					else if (wdata==MODEL_AX18)
 8003262:	2c12      	cmp	r4, #18
					{
						PrintString(" (AX-18)");
 8003264:	bf08      	it	eq
 8003266:	4867      	ldreq	r0, [pc, #412]	(8003404 <main+0x2cc>)
					Printu32d(wdata);
					if (wdata==MODEL_AX12)
					{
						PrintString(" (AX-12)");
					}
					else if (wdata==MODEL_AX18)
 8003268:	d010      	beq.n	800328c <main+0x154>
					{
						PrintString(" (AX-18)");
					}
					else if (wdata==MODEL_AXS1)
 800326a:	2c0d      	cmp	r4, #13
					{
						PrintString(" (AX-S1)");
 800326c:	bf08      	it	eq
 800326e:	4866      	ldreq	r0, [pc, #408]	(8003408 <main+0x2d0>)
					}
					else if (wdata==MODEL_AX18)
					{
						PrintString(" (AX-18)");
					}
					else if (wdata==MODEL_AXS1)
 8003270:	d00c      	beq.n	800328c <main+0x154>
					{
						PrintString(" (AX-S1)");
					}
					else if (wdata==MODEL_AXS20)
 8003272:	2cd4      	cmp	r4, #212
					{
						PrintString(" (AX-S20)");
 8003274:	bf08      	it	eq
 8003276:	4865      	ldreq	r0, [pc, #404]	(800340c <main+0x2d4>)
					}
					else if (wdata==MODEL_AXS1)
					{
						PrintString(" (AX-S1)");
					}
					else if (wdata==MODEL_AXS20)
 8003278:	d008      	beq.n	800328c <main+0x154>
					{
						PrintString(" (AX-S20)");
					}
					else if (wdata==MODEL_JHFPS)
 800327a:	f244 330b 	movw	r3, #17163	; 0x430b
 800327e:	429c      	cmp	r4, r3
					{
						PrintString(" (JH-FPS)");
 8003280:	bf08      	it	eq
 8003282:	4863      	ldreq	r0, [pc, #396]	(8003410 <main+0x2d8>)
					}
					else if (wdata==MODEL_AXS20)
					{
						PrintString(" (AX-S20)");
					}
					else if (wdata==MODEL_JHFPS)
 8003284:	d002      	beq.n	800328c <main+0x154>
					{
						PrintString(" (JH-FPS)");
					}
					else if (wdata==MODEL_MX28)
 8003286:	2c1d      	cmp	r4, #29
 8003288:	d102      	bne.n	8003290 <main+0x158>
					{
						PrintString(" (MX-28)");
 800328a:	4862      	ldr	r0, [pc, #392]	(8003414 <main+0x2dc>)
 800328c:	f000 fbde 	bl	8003a4c <PrintString>
			{
				wdata = (dxl_read_byte(id, P_ID)&0x00FF);
				if (wdata==id)
				{
					wdata=0;
					num++;
 8003290:	1c7b      	adds	r3, r7, #1
					else if (wdata==MODEL_MX28)
					{
						PrintString(" (MX-28)");
					}

					PrintString(", ");
 8003292:	4858      	ldr	r0, [pc, #352]	(80033f4 <main+0x2bc>)
			{
				wdata = (dxl_read_byte(id, P_ID)&0x00FF);
				if (wdata==id)
				{
					wdata=0;
					num++;
 8003294:	b2df      	uxtb	r7, r3
					else if (wdata==MODEL_MX28)
					{
						PrintString(" (MX-28)");
					}

					PrintString(", ");
 8003296:	f000 fbd9 	bl	8003a4c <PrintString>
					Printu32d(dxl_read_byte(id, P_FIRMWARE_VERSION));
 800329a:	2102      	movs	r1, #2
 800329c:	4630      	mov	r0, r6
 800329e:	f000 ff6f 	bl	8004180 <dxl_read_byte>
 80032a2:	f000 fb9b 	bl	80039dc <Printu32d>

					PrintString("} \n");
 80032a6:	485c      	ldr	r0, [pc, #368]	(8003418 <main+0x2e0>)
 80032a8:	f000 fbd0 	bl	8003a4c <PrintString>
 80032ac:	3501      	adds	r5, #1
		//else if(strcmp(ReceivedCommand, "motors report")){
		else if(ReceivedData == 'm'){
			u8 id, num=0;
			u16 wdata, error, pdata, perror;
			dxl_initialize(Baudrate_DXL);
			for (id=1; id<(250); id++)
 80032ae:	2dfa      	cmp	r5, #250
 80032b0:	d1a5      	bne.n	80031fe <main+0xc6>
					Printu32d(dxl_read_byte(id, P_FIRMWARE_VERSION));

					PrintString("} \n");
				}
			}
			PrintString("\nDXL DEVICES:");
 80032b2:	485a      	ldr	r0, [pc, #360]	(800341c <main+0x2e4>)
 80032b4:	f000 fbca 	bl	8003a4c <PrintString>
			Printu32d(num);
 80032b8:	4638      	mov	r0, r7
 80032ba:	f000 fb8f 	bl	80039dc <Printu32d>
			PrintString("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
 80032be:	4858      	ldr	r0, [pc, #352]	(8003420 <main+0x2e8>)
 80032c0:	e07b      	b.n	80033ba <main+0x282>
		}
		else if(ReceivedData == 'b'){
 80032c2:	2862      	cmp	r0, #98
 80032c4:	d105      	bne.n	80032d2 <main+0x19a>
			PrintString("\nPlaying Some music\n");
 80032c6:	4857      	ldr	r0, [pc, #348]	(8003424 <main+0x2ec>)
 80032c8:	f000 fbc0 	bl	8003a4c <PrintString>
			Buzzed(150, 200);    // 2500 Hz ~ Ds_7/Eb_7
 80032cc:	2096      	movs	r0, #150
 80032ce:	21c8      	movs	r1, #200
 80032d0:	e00a      	b.n	80032e8 <main+0x1b0>
		}
		else if(ReceivedData == 's'){
 80032d2:	2873      	cmp	r0, #115
 80032d4:	d10b      	bne.n	80032ee <main+0x1b6>
			executeMotion(26);
 80032d6:	201a      	movs	r0, #26
 80032d8:	f001 facc 	bl	8004874 <executeMotion>
			Buzzed(200,150);
 80032dc:	20c8      	movs	r0, #200
 80032de:	2196      	movs	r1, #150
 80032e0:	f002 f90c 	bl	80054fc <Buzzed>
			Buzzed(150,150);
 80032e4:	2096      	movs	r0, #150
 80032e6:	2196      	movs	r1, #150
 80032e8:	f002 f908 	bl	80054fc <Buzzed>
 80032ec:	e067      	b.n	80033be <main+0x286>
		}
		else if(ReceivedData == 'w'){
 80032ee:	2877      	cmp	r0, #119
 80032f0:	d101      	bne.n	80032f6 <main+0x1be>
			executeMotion(25);
 80032f2:	2019      	movs	r0, #25
 80032f4:	e002      	b.n	80032fc <main+0x1c4>
		}
		else if(ReceivedData == 'a'){
 80032f6:	2861      	cmp	r0, #97
 80032f8:	d103      	bne.n	8003302 <main+0x1ca>
			executeMotion(5);
 80032fa:	2005      	movs	r0, #5
 80032fc:	f001 faba 	bl	8004874 <executeMotion>
 8003300:	e05d      	b.n	80033be <main+0x286>
		}
		else if(ReceivedData == 'i'){
 8003302:	2869      	cmp	r0, #105
 8003304:	d126      	bne.n	8003354 <main+0x21c>
			PrintString("\n(IR_L, IR_R, DMS):\t(");
 8003306:	4848      	ldr	r0, [pc, #288]	(8003428 <main+0x2f0>)
 8003308:	f000 fba0 	bl	8003a4c <PrintString>
			Prints32d(ReadIR(EPORT1A));
 800330c:	2000      	movs	r0, #0
 800330e:	f002 f8ad 	bl	800546c <ReadIR>
 8003312:	f000 fb29 	bl	8003968 <Prints32d>
			//Printu32d(ReadIR(EPORT1A));
			PrintString(", ");
 8003316:	4837      	ldr	r0, [pc, #220]	(80033f4 <main+0x2bc>)
 8003318:	f000 fb98 	bl	8003a4c <PrintString>
			Prints32d(ReadIR(EPORT6A));
 800331c:	2005      	movs	r0, #5
 800331e:	f002 f8a5 	bl	800546c <ReadIR>
 8003322:	f000 fb21 	bl	8003968 <Prints32d>
			PrintString(", ");
 8003326:	4833      	ldr	r0, [pc, #204]	(80033f4 <main+0x2bc>)
 8003328:	f000 fb90 	bl	8003a4c <PrintString>
			Prints32d(ReadIR(EPORT5A));
 800332c:	2004      	movs	r0, #4
 800332e:	f002 f89d 	bl	800546c <ReadIR>
 8003332:	f000 fb19 	bl	8003968 <Prints32d>
			PrintString(")\n");
 8003336:	483d      	ldr	r0, [pc, #244]	(800342c <main+0x2f4>)
 8003338:	f000 fb88 	bl	8003a4c <PrintString>
			PlayNote(300, NOTE_E, 1);    // 2500 Hz ~ Ds_7/Eb_7
 800333c:	f44f 7096 	mov.w	r0, #300	; 0x12c
 8003340:	f645 61ce 	movw	r1, #24270	; 0x5ece
 8003344:	2201      	movs	r2, #1
 8003346:	f002 f8f7 	bl	8005538 <PlayNote>
			mDelay(2000);
 800334a:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800334e:	f002 f91b 	bl	8005588 <mDelay>
 8003352:	e034      	b.n	80033be <main+0x286>
		}
		else if(ReadButton(UP)){
 8003354:	2000      	movs	r0, #0
 8003356:	f002 f8a9 	bl	80054ac <ReadButton>
 800335a:	b108      	cbz	r0, 8003360 <main+0x228>
			PrintString("\nUP UP UP is pressed!\n");
 800335c:	4834      	ldr	r0, [pc, #208]	(8003430 <main+0x2f8>)
 800335e:	e02c      	b.n	80033ba <main+0x282>
			//Buzzed(150, 200);    // 2500 Hz ~ Ds_7/Eb_7
		}
		else if(ReadButton(DOWN)){
 8003360:	2001      	movs	r0, #1
 8003362:	f002 f8a3 	bl	80054ac <ReadButton>
 8003366:	b108      	cbz	r0, 800336c <main+0x234>
			PrintString("\nDOWN DOWN DOWN is pressed!\n");
 8003368:	4832      	ldr	r0, [pc, #200]	(8003434 <main+0x2fc>)
 800336a:	e026      	b.n	80033ba <main+0x282>
		}
		else if(ReadButton(LEFT)){
 800336c:	2002      	movs	r0, #2
 800336e:	f002 f89d 	bl	80054ac <ReadButton>
 8003372:	b108      	cbz	r0, 8003378 <main+0x240>
			PrintString("\nLEFT LEFT LEFT is pressed!\n");
 8003374:	4830      	ldr	r0, [pc, #192]	(8003438 <main+0x300>)
 8003376:	e020      	b.n	80033ba <main+0x282>
		}
		else if(ReadButton(RIGHT)){
 8003378:	2003      	movs	r0, #3
 800337a:	f002 f897 	bl	80054ac <ReadButton>
 800337e:	b108      	cbz	r0, 8003384 <main+0x24c>
			PrintString("\nRIGHT RIGHT RIGHT is pressed!\n");
 8003380:	482e      	ldr	r0, [pc, #184]	(800343c <main+0x304>)
 8003382:	e01a      	b.n	80033ba <main+0x282>
		}
		else if(ReadButton(START)){
 8003384:	2004      	movs	r0, #4
 8003386:	f002 f891 	bl	80054ac <ReadButton>
 800338a:	b118      	cbz	r0, 8003394 <main+0x25c>
			PrintString("\nSTART START START is pressed!\n");
 800338c:	482c      	ldr	r0, [pc, #176]	(8003440 <main+0x308>)
 800338e:	f000 fb5d 	bl	8003a4c <PrintString>
 8003392:	e00a      	b.n	80033aa <main+0x272>
			PlayNote(200, NOTE_A, 1);    // 2500 Hz ~ Ds_7/Eb_7
		}
		else if(ReadButton(MIC)){
 8003394:	2005      	movs	r0, #5
 8003396:	f002 f889 	bl	80054ac <ReadButton>
 800339a:	b168      	cbz	r0, 80033b8 <main+0x280>
			PrintString("\nMIC MIC MIC MIC MIC MIMIC MIC MIMIC MIC MIMIC MIC MIMIC MIC MIMIC MIC MIMIC MIC MIMIC MIC MIMIC MIC MIMIC MIC MIis pressed!\n");
 800339c:	4829      	ldr	r0, [pc, #164]	(8003444 <main+0x30c>)
 800339e:	f000 fb55 	bl	8003a4c <PrintString>
			SetLED(MANAGE, 1);
 80033a2:	2001      	movs	r0, #1
 80033a4:	2101      	movs	r1, #1
 80033a6:	f002 f893 	bl	80054d0 <SetLED>
			PlayNote(200, NOTE_A, 1);    // 2500 Hz ~ Ds_7/Eb_7
 80033aa:	20c8      	movs	r0, #200
 80033ac:	f244 7106 	movw	r1, #18182	; 0x4706
 80033b0:	2201      	movs	r2, #1
 80033b2:	f002 f8c1 	bl	8005538 <PlayNote>
 80033b6:	e002      	b.n	80033be <main+0x286>
			//mDelay(300);
			//SetLED(MANAGE, 0);
			//mDelay(2000);
		}
		else{
			PrintString("\nWait for command\n");
 80033b8:	4823      	ldr	r0, [pc, #140]	(8003448 <main+0x310>)
 80033ba:	f000 fb47 	bl	8003a4c <PrintString>
//				std_puts(ReceivedCommand);
//				PrintString("\n");
//			}
		}
		//mDelay(1000);
		mDelay(1000);
 80033be:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80033c2:	f002 f8e1 	bl	8005588 <mDelay>
 80033c6:	e6c2      	b.n	800314e <main+0x16>
 80033c8:	08007c90 	.word	0x08007c90
 80033cc:	08007cbc 	.word	0x08007cbc
 80033d0:	200000d4 	.word	0x200000d4
 80033d4:	200000cc 	.word	0x200000cc
 80033d8:	08007cc1 	.word	0x08007cc1
 80033dc:	08007cc8 	.word	0x08007cc8
 80033e0:	200000d0 	.word	0x200000d0
 80033e4:	08007ccd 	.word	0x08007ccd
 80033e8:	08007cd2 	.word	0x08007cd2
 80033ec:	08007ce8 	.word	0x08007ce8
 80033f0:	08007cff 	.word	0x08007cff
 80033f4:	08007d06 	.word	0x08007d06
 80033f8:	08007d01 	.word	0x08007d01
 80033fc:	08007d05 	.word	0x08007d05
 8003400:	08007d09 	.word	0x08007d09
 8003404:	08007d12 	.word	0x08007d12
 8003408:	08007d1b 	.word	0x08007d1b
 800340c:	08007d24 	.word	0x08007d24
 8003410:	08007d2e 	.word	0x08007d2e
 8003414:	08007d38 	.word	0x08007d38
 8003418:	08007d41 	.word	0x08007d41
 800341c:	08007d45 	.word	0x08007d45
 8003420:	08007d53 	.word	0x08007d53
 8003424:	08007d7e 	.word	0x08007d7e
 8003428:	08007d93 	.word	0x08007d93
 800342c:	08007cc5 	.word	0x08007cc5
 8003430:	08007da9 	.word	0x08007da9
 8003434:	08007dc0 	.word	0x08007dc0
 8003438:	08007ddd 	.word	0x08007ddd
 800343c:	08007dfa 	.word	0x08007dfa
 8003440:	08007e1a 	.word	0x08007e1a
 8003444:	08007e3a 	.word	0x08007e3a
 8003448:	08007eb8 	.word	0x08007eb8

0800344c <NMIException>:
* Output         : None
* Return         : None
*******************************************************************************/
void NMIException(void)
{
}
 800344c:	4770      	bx	lr
 800344e:	46c0      	nop			(mov r8, r8)

08003450 <HardFaultException>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void HardFaultException(void)
{
 8003450:	e7fe      	b.n	8003450 <HardFaultException>
 8003452:	46c0      	nop			(mov r8, r8)

08003454 <MemManageException>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void MemManageException(void)
{
 8003454:	e7fe      	b.n	8003454 <MemManageException>
 8003456:	46c0      	nop			(mov r8, r8)

08003458 <BusFaultException>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void BusFaultException(void)
{
 8003458:	e7fe      	b.n	8003458 <BusFaultException>
 800345a:	46c0      	nop			(mov r8, r8)

0800345c <UsageFaultException>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void UsageFaultException(void)
{
 800345c:	e7fe      	b.n	800345c <UsageFaultException>
 800345e:	46c0      	nop			(mov r8, r8)

08003460 <DebugMonitor>:
* Output         : None
* Return         : None
*******************************************************************************/
void DebugMonitor(void)
{
}
 8003460:	4770      	bx	lr
 8003462:	46c0      	nop			(mov r8, r8)

08003464 <SVCHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void SVCHandler(void)
{
}
 8003464:	4770      	bx	lr
 8003466:	46c0      	nop			(mov r8, r8)

08003468 <PendSVC>:
* Output         : None
* Return         : None
*******************************************************************************/
void PendSVC(void)
{
}
 8003468:	4770      	bx	lr
 800346a:	46c0      	nop			(mov r8, r8)

0800346c <WWDG_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void WWDG_IRQHandler(void)
{
}
 800346c:	4770      	bx	lr
 800346e:	46c0      	nop			(mov r8, r8)

08003470 <PVD_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void PVD_IRQHandler(void)
{
}
 8003470:	4770      	bx	lr
 8003472:	46c0      	nop			(mov r8, r8)

08003474 <TAMPER_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TAMPER_IRQHandler(void)
{
}
 8003474:	4770      	bx	lr
 8003476:	46c0      	nop			(mov r8, r8)

08003478 <RTC_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void RTC_IRQHandler(void)
{
}
 8003478:	4770      	bx	lr
 800347a:	46c0      	nop			(mov r8, r8)

0800347c <FLASH_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void FLASH_IRQHandler(void)
{
}
 800347c:	4770      	bx	lr
 800347e:	46c0      	nop			(mov r8, r8)

08003480 <RCC_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_IRQHandler(void)
{
}
 8003480:	4770      	bx	lr
 8003482:	46c0      	nop			(mov r8, r8)

08003484 <EXTI0_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void EXTI0_IRQHandler(void)
{
}
 8003484:	4770      	bx	lr
 8003486:	46c0      	nop			(mov r8, r8)

08003488 <EXTI1_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void EXTI1_IRQHandler(void)
{
}
 8003488:	4770      	bx	lr
 800348a:	46c0      	nop			(mov r8, r8)

0800348c <EXTI2_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void EXTI2_IRQHandler(void)
{
}
 800348c:	4770      	bx	lr
 800348e:	46c0      	nop			(mov r8, r8)

08003490 <EXTI3_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void EXTI3_IRQHandler(void)
{
}
 8003490:	4770      	bx	lr
 8003492:	46c0      	nop			(mov r8, r8)

08003494 <EXTI4_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void EXTI4_IRQHandler(void)
{
}
 8003494:	4770      	bx	lr
 8003496:	46c0      	nop			(mov r8, r8)

08003498 <DMA1_Channel1_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA1_Channel1_IRQHandler(void)
{
}
 8003498:	4770      	bx	lr
 800349a:	46c0      	nop			(mov r8, r8)

0800349c <DMA1_Channel2_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA1_Channel2_IRQHandler(void)
{
}
 800349c:	4770      	bx	lr
 800349e:	46c0      	nop			(mov r8, r8)

080034a0 <DMA1_Channel3_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA1_Channel3_IRQHandler(void)
{
}
 80034a0:	4770      	bx	lr
 80034a2:	46c0      	nop			(mov r8, r8)

080034a4 <DMA1_Channel4_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA1_Channel4_IRQHandler(void)
{
}
 80034a4:	4770      	bx	lr
 80034a6:	46c0      	nop			(mov r8, r8)

080034a8 <DMA1_Channel5_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA1_Channel5_IRQHandler(void)
{
}
 80034a8:	4770      	bx	lr
 80034aa:	46c0      	nop			(mov r8, r8)

080034ac <DMA1_Channel6_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA1_Channel6_IRQHandler(void)
{
}
 80034ac:	4770      	bx	lr
 80034ae:	46c0      	nop			(mov r8, r8)

080034b0 <DMA1_Channel7_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA1_Channel7_IRQHandler(void)
{
}
 80034b0:	4770      	bx	lr
 80034b2:	46c0      	nop			(mov r8, r8)

080034b4 <ADC1_2_IRQHandler>:
* Return         : None
*******************************************************************************/

void ADC1_2_IRQHandler(void)
{
}
 80034b4:	4770      	bx	lr
 80034b6:	46c0      	nop			(mov r8, r8)

080034b8 <USB_HP_CAN_TX_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void USB_HP_CAN_TX_IRQHandler(void)
{
}
 80034b8:	4770      	bx	lr
 80034ba:	46c0      	nop			(mov r8, r8)

080034bc <USB_LP_CAN_RX0_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void USB_LP_CAN_RX0_IRQHandler(void)
{
}
 80034bc:	4770      	bx	lr
 80034be:	46c0      	nop			(mov r8, r8)

080034c0 <CAN_RX1_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void CAN_RX1_IRQHandler(void)
{
}
 80034c0:	4770      	bx	lr
 80034c2:	46c0      	nop			(mov r8, r8)

080034c4 <CAN_SCE_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void CAN_SCE_IRQHandler(void)
{
}
 80034c4:	4770      	bx	lr
 80034c6:	46c0      	nop			(mov r8, r8)

080034c8 <EXTI9_5_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void EXTI9_5_IRQHandler(void)
{
}
 80034c8:	4770      	bx	lr
 80034ca:	46c0      	nop			(mov r8, r8)

080034cc <TIM1_BRK_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM1_BRK_IRQHandler(void)
{
}
 80034cc:	4770      	bx	lr
 80034ce:	46c0      	nop			(mov r8, r8)

080034d0 <TIM1_UP_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM1_UP_IRQHandler(void)
{
}
 80034d0:	4770      	bx	lr
 80034d2:	46c0      	nop			(mov r8, r8)

080034d4 <TIM1_TRG_COM_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM1_TRG_COM_IRQHandler(void)
{
}
 80034d4:	4770      	bx	lr
 80034d6:	46c0      	nop			(mov r8, r8)

080034d8 <TIM1_CC_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM1_CC_IRQHandler(void)
{
}
 80034d8:	4770      	bx	lr
 80034da:	46c0      	nop			(mov r8, r8)

080034dc <TIM2_IRQHandler>:
* Return         : None
*******************************************************************************/
void TIM2_IRQHandler(void)
{
//	ISR_Timer_1ms();
}
 80034dc:	4770      	bx	lr
 80034de:	46c0      	nop			(mov r8, r8)

080034e0 <TIM3_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM3_IRQHandler(void)
{
}
 80034e0:	4770      	bx	lr
 80034e2:	46c0      	nop			(mov r8, r8)

080034e4 <TIM4_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM4_IRQHandler(void)
{
}
 80034e4:	4770      	bx	lr
 80034e6:	46c0      	nop			(mov r8, r8)

080034e8 <I2C1_EV_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void I2C1_EV_IRQHandler(void)
{
}
 80034e8:	4770      	bx	lr
 80034ea:	46c0      	nop			(mov r8, r8)

080034ec <I2C1_ER_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void I2C1_ER_IRQHandler(void)
{
}
 80034ec:	4770      	bx	lr
 80034ee:	46c0      	nop			(mov r8, r8)

080034f0 <I2C2_EV_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void I2C2_EV_IRQHandler(void)
{
}
 80034f0:	4770      	bx	lr
 80034f2:	46c0      	nop			(mov r8, r8)

080034f4 <I2C2_ER_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void I2C2_ER_IRQHandler(void)
{
}
 80034f4:	4770      	bx	lr
 80034f6:	46c0      	nop			(mov r8, r8)

080034f8 <SPI1_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void SPI1_IRQHandler(void)
{
}
 80034f8:	4770      	bx	lr
 80034fa:	46c0      	nop			(mov r8, r8)

080034fc <SPI2_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void SPI2_IRQHandler(void)
{
}
 80034fc:	4770      	bx	lr
 80034fe:	46c0      	nop			(mov r8, r8)

08003500 <USART2_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void USART2_IRQHandler(void)
{
}
 8003500:	4770      	bx	lr
 8003502:	46c0      	nop			(mov r8, r8)

08003504 <EXTI15_10_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void EXTI15_10_IRQHandler(void)
{
}
 8003504:	4770      	bx	lr
 8003506:	46c0      	nop			(mov r8, r8)

08003508 <RTCAlarm_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void RTCAlarm_IRQHandler(void)
{
}
 8003508:	4770      	bx	lr
 800350a:	46c0      	nop			(mov r8, r8)

0800350c <USBWakeUp_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void USBWakeUp_IRQHandler(void)
{
}
 800350c:	4770      	bx	lr
 800350e:	46c0      	nop			(mov r8, r8)

08003510 <TIM8_BRK_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM8_BRK_IRQHandler(void)
{
}
 8003510:	4770      	bx	lr
 8003512:	46c0      	nop			(mov r8, r8)

08003514 <TIM8_UP_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM8_UP_IRQHandler(void)
{
}
 8003514:	4770      	bx	lr
 8003516:	46c0      	nop			(mov r8, r8)

08003518 <TIM8_TRG_COM_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM8_TRG_COM_IRQHandler(void)
{
}
 8003518:	4770      	bx	lr
 800351a:	46c0      	nop			(mov r8, r8)

0800351c <TIM8_CC_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM8_CC_IRQHandler(void)
{
}
 800351c:	4770      	bx	lr
 800351e:	46c0      	nop			(mov r8, r8)

08003520 <ADC3_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void ADC3_IRQHandler(void)
{
}
 8003520:	4770      	bx	lr
 8003522:	46c0      	nop			(mov r8, r8)

08003524 <FSMC_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void FSMC_IRQHandler(void)
{
}
 8003524:	4770      	bx	lr
 8003526:	46c0      	nop			(mov r8, r8)

08003528 <SDIO_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void SDIO_IRQHandler(void)
{
}
 8003528:	4770      	bx	lr
 800352a:	46c0      	nop			(mov r8, r8)

0800352c <TIM5_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM5_IRQHandler(void)
{
}
 800352c:	4770      	bx	lr
 800352e:	46c0      	nop			(mov r8, r8)

08003530 <SPI3_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void SPI3_IRQHandler(void)
{
}
 8003530:	4770      	bx	lr
 8003532:	46c0      	nop			(mov r8, r8)

08003534 <UART4_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void UART4_IRQHandler(void)
{
}
 8003534:	4770      	bx	lr
 8003536:	46c0      	nop			(mov r8, r8)

08003538 <TIM6_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM6_IRQHandler(void)
{
}
 8003538:	4770      	bx	lr
 800353a:	46c0      	nop			(mov r8, r8)

0800353c <TIM7_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void TIM7_IRQHandler(void)
{
}
 800353c:	4770      	bx	lr
 800353e:	46c0      	nop			(mov r8, r8)

08003540 <DMA2_Channel1_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA2_Channel1_IRQHandler(void)
{
}
 8003540:	4770      	bx	lr
 8003542:	46c0      	nop			(mov r8, r8)

08003544 <DMA2_Channel2_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA2_Channel2_IRQHandler(void)
{
}
 8003544:	4770      	bx	lr
 8003546:	46c0      	nop			(mov r8, r8)

08003548 <DMA2_Channel3_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA2_Channel3_IRQHandler(void)
{
}
 8003548:	4770      	bx	lr
 800354a:	46c0      	nop			(mov r8, r8)

0800354c <DMA2_Channel4_5_IRQHandler>:
* Output         : None
* Return         : None
*******************************************************************************/
void DMA2_Channel4_5_IRQHandler(void)
{
}
 800354c:	4770      	bx	lr
 800354e:	46c0      	nop			(mov r8, r8)

08003550 <UART5_IRQHandler>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void UART5_IRQHandler(void)
{
 8003550:	b500      	push	{lr}
 8003552:	b081      	sub	sp, #4
#ifdef USING_ZIGBEE
	RxD_ZIG_Interrupt();
 8003554:	f002 fd7c 	bl	8006050 <RxD_ZIG_Interrupt>
#endif
}
 8003558:	b001      	add	sp, #4
 800355a:	bd00      	pop	{pc}

0800355c <USART3_IRQHandler>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void USART3_IRQHandler(void)
{
 800355c:	b500      	push	{lr}
 800355e:	b081      	sub	sp, #4
#ifdef USING_PC_UART
	RxD_PCU_Interrupt();
 8003560:	f002 fe2e 	bl	80061c0 <RxD_PCU_Interrupt>
#endif
}
 8003564:	b001      	add	sp, #4
 8003566:	bd00      	pop	{pc}

08003568 <USART1_IRQHandler>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void USART1_IRQHandler(void)
{
 8003568:	b500      	push	{lr}
 800356a:	b081      	sub	sp, #4
#ifdef USING_DYNAMIXEL
	RxD_DXL_Interrupt();
 800356c:	f002 fc42 	bl	8005df4 <RxD_DXL_Interrupt>
#endif
}
 8003570:	b001      	add	sp, #4
 8003572:	bd00      	pop	{pc}

08003574 <SysTickHandler>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void SysTickHandler(void)
{
 8003574:	b500      	push	{lr}
 8003576:	b081      	sub	sp, #4
	ISR_Delay_Base();
 8003578:	f002 f872 	bl	8005660 <ISR_Delay_Base>
}
 800357c:	b001      	add	sp, #4
 800357e:	bd00      	pop	{pc}

08003580 <CheckPCNewArrive>:
#include "usart.h"

#ifdef USING_PC_UART

byte CheckPCNewArrive(void) {
	if (gbPcuRead != gbPcuWrite)
 8003580:	4b03      	ldr	r3, [pc, #12]	(8003590 <CheckPCNewArrive+0x10>)
 8003582:	881a      	ldrh	r2, [r3, #0]
 8003584:	4b03      	ldr	r3, [pc, #12]	(8003594 <CheckPCNewArrive+0x14>)
 8003586:	8818      	ldrh	r0, [r3, #0]
 8003588:	1a80      	subs	r0, r0, r2
 800358a:	bf18      	it	ne
 800358c:	2001      	movne	r0, #1
		return 1;
	else
		return 0;
}
 800358e:	4770      	bx	lr
 8003590:	200008e2 	.word	0x200008e2
 8003594:	200008e0 	.word	0x200008e0

08003598 <RxDByte_PC>:
byte RxDByte_PC(void) {
	byte bTemp;

	while (1) {
		if (gbPcuRead != gbPcuWrite)
 8003598:	f8df c020 	ldr.w	ip, [pc, #32]	; 80035bc <RxDByte_PC+0x24>
 800359c:	4808      	ldr	r0, [pc, #32]	(80035c0 <RxDByte_PC+0x28>)
 800359e:	f8bc 2000 	ldrh.w	r2, [ip]
 80035a2:	8803      	ldrh	r3, [r0, #0]
 80035a4:	4905      	ldr	r1, [pc, #20]	(80035bc <RxDByte_PC+0x24>)
 80035a6:	4293      	cmp	r3, r2
 80035a8:	d0f9      	beq.n	800359e <RxDByte_PC+0x6>
			break;
	}

	bTemp = gbpPcuBuffer[gbPcuRead];
 80035aa:	880b      	ldrh	r3, [r1, #0]
 80035ac:	4a05      	ldr	r2, [pc, #20]	(80035c4 <RxDByte_PC+0x2c>)
 80035ae:	b29b      	uxth	r3, r3
 80035b0:	5cd0      	ldrb	r0, [r2, r3]
	gbPcuRead++;
 80035b2:	880b      	ldrh	r3, [r1, #0]
 80035b4:	3301      	adds	r3, #1
 80035b6:	b29b      	uxth	r3, r3
 80035b8:	800b      	strh	r3, [r1, #0]
	return bTemp;
}
 80035ba:	4770      	bx	lr
 80035bc:	200008e2 	.word	0x200008e2
 80035c0:	200008e0 	.word	0x200008e0
 80035c4:	200004e0 	.word	0x200004e0

080035c8 <TxD_Dec_S32>:
    }
}

//##############################################################################
void TxD_Dec_S32(s32 lLong)
{
 80035c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    u8 bCount, bPrinted;
    s32 lTmp,lDigit;
    bPrinted = 0;
    if(lLong < 0)
 80035ca:	2800      	cmp	r0, #0
    }
}

//##############################################################################
void TxD_Dec_S32(s32 lLong)
{
 80035cc:	b083      	sub	sp, #12
 80035ce:	4604      	mov	r4, r0
    u8 bCount, bPrinted;
    s32 lTmp,lDigit;
    bPrinted = 0;
    if(lLong < 0)
 80035d0:	da04      	bge.n	80035dc <TxD_Dec_S32+0x14>
    {
        lLong = -lLong;
 80035d2:	f1c0 0400 	rsb	r4, r0, #0	; 0x0
        pcu_put_byte(  '-');
 80035d6:	202d      	movs	r0, #45
 80035d8:	f002 fdf8 	bl	80061cc <pcu_put_byte>
 80035dc:	2700      	movs	r7, #0
 80035de:	4e13      	ldr	r6, [pc, #76]	(800362c <TxD_Dec_S32+0x64>)
 80035e0:	9701      	str	r7, [sp, #4]
    }
    lDigit = 1000000000L;
    for(bCount = 0; bCount < 9; bCount++)
    {
        lTmp = (u8)(lLong/lDigit);
 80035e2:	fb94 f3f6 	sdiv	r3, r4, r6
 80035e6:	b2dd      	uxtb	r5, r3
        if(lTmp)
 80035e8:	b13d      	cbz	r5, 80035fa <TxD_Dec_S32+0x32>
        {
            pcu_put_byte( ((u8)lTmp)+'0');
 80035ea:	f105 0030 	add.w	r0, r5, #48	; 0x30
 80035ee:	b2c0      	uxtb	r0, r0
 80035f0:	f002 fdec 	bl	80061cc <pcu_put_byte>
 80035f4:	2101      	movs	r1, #1
 80035f6:	9101      	str	r1, [sp, #4]
 80035f8:	e004      	b.n	8003604 <TxD_Dec_S32+0x3c>
            bPrinted = 1;
        }
        else if(bPrinted) pcu_put_byte( ((u8)lTmp)+'0');
 80035fa:	9b01      	ldr	r3, [sp, #4]
 80035fc:	b113      	cbz	r3, 8003604 <TxD_Dec_S32+0x3c>
 80035fe:	2030      	movs	r0, #48
 8003600:	f002 fde4 	bl	80061cc <pcu_put_byte>
        lLong -= ((u32)lTmp)*lDigit;
        lDigit = lDigit/10;
 8003604:	490a      	ldr	r1, [pc, #40]	(8003630 <TxD_Dec_S32+0x68>)
        {
            pcu_put_byte( ((u8)lTmp)+'0');
            bPrinted = 1;
        }
        else if(bPrinted) pcu_put_byte( ((u8)lTmp)+'0');
        lLong -= ((u32)lTmp)*lDigit;
 8003606:	fb06 4415 	mls	r4, r6, r5, r4
        lDigit = lDigit/10;
 800360a:	fb86 2301 	smull	r2, r3, r6, r1
 800360e:	17f1      	asrs	r1, r6, #31
 8003610:	ebc1 06a3 	rsb	r6, r1, r3, asr #2
    {
        lLong = -lLong;
        pcu_put_byte(  '-');
    }
    lDigit = 1000000000L;
    for(bCount = 0; bCount < 9; bCount++)
 8003614:	1c7b      	adds	r3, r7, #1
 8003616:	b2df      	uxtb	r7, r3
 8003618:	2f09      	cmp	r7, #9
 800361a:	d1e2      	bne.n	80035e2 <TxD_Dec_S32+0x1a>
        else if(bPrinted) pcu_put_byte( ((u8)lTmp)+'0');
        lLong -= ((u32)lTmp)*lDigit;
        lDigit = lDigit/10;
    }
    lTmp = (u8)(lLong/lDigit);
    /*if(lTmp)*/ pcu_put_byte(  ((u8)lTmp)+'0');
 800361c:	fb94 f0f6 	sdiv	r0, r4, r6
 8003620:	3030      	adds	r0, #48
 8003622:	b2c0      	uxtb	r0, r0
 8003624:	f002 fdd2 	bl	80061cc <pcu_put_byte>
}
 8003628:	b003      	add	sp, #12
 800362a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800362c:	3b9aca00 	.word	0x3b9aca00
 8003630:	66666667 	.word	0x66666667

08003634 <TxD_Dec_S16>:
        wDigit /= 10;
    }
}
//##############################################################################
void TxD_Dec_S16(s16 wData)
{
 8003634:	b5f0      	push	{r4, r5, r6, r7, lr}
    u16 wTmp,wDigit;
    u8 bMinus = 0;

    bPrinted = 0;

    if (wData&0x8000) {
 8003636:	2800      	cmp	r0, #0
        wDigit /= 10;
    }
}
//##############################################################################
void TxD_Dec_S16(s16 wData)
{
 8003638:	b083      	sub	sp, #12
 800363a:	4605      	mov	r5, r0
    u16 wTmp,wDigit;
    u8 bMinus = 0;

    bPrinted = 0;

    if (wData&0x8000) {
 800363c:	db02      	blt.n	8003644 <TxD_Dec_S16+0x10>
 800363e:	2100      	movs	r1, #0
 8003640:	9101      	str	r1, [sp, #4]
 8003642:	e004      	b.n	800364e <TxD_Dec_S16+0x1a>
        bMinus = 1;
        wData = -wData;
 8003644:	f1c0 0300 	rsb	r3, r0, #0	; 0x0
 8003648:	2201      	movs	r2, #1
 800364a:	b21d      	sxth	r5, r3
 800364c:	9201      	str	r2, [sp, #4]
 800364e:	2700      	movs	r7, #0
 8003650:	9700      	str	r7, [sp, #0]
 8003652:	f242 7610 	movw	r6, #10000	; 0x2710

    wDigit = 10000;
    for(bCount = 0; bCount < 5; bCount++)
    {
        wTmp = (wData/wDigit);
        if(wTmp && !bPrinted)
 8003656:	9900      	ldr	r1, [sp, #0]
    }

    wDigit = 10000;
    for(bCount = 0; bCount < 5; bCount++)
    {
        wTmp = (wData/wDigit);
 8003658:	fb95 f3f6 	sdiv	r3, r5, r6
 800365c:	b29c      	uxth	r4, r3
        if(wTmp && !bPrinted)
 800365e:	f081 0301 	eor.w	r3, r1, #1	; 0x1
 8003662:	2c00      	cmp	r4, #0
 8003664:	bf0c      	ite	eq
 8003666:	2300      	moveq	r3, #0
 8003668:	f003 0301 	andne.w	r3, r3, #1	; 0x1
 800366c:	b163      	cbz	r3, 8003688 <TxD_Dec_S16+0x54>
        {
            if (bMinus) pcu_put_byte( '-');
 800366e:	9a01      	ldr	r2, [sp, #4]
 8003670:	b112      	cbz	r2, 8003678 <TxD_Dec_S16+0x44>
 8003672:	202d      	movs	r0, #45
 8003674:	f002 fdaa 	bl	80061cc <pcu_put_byte>
            pcu_put_byte( ((u8)wTmp)+'0');
 8003678:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800367c:	b2c0      	uxtb	r0, r0
 800367e:	f002 fda5 	bl	80061cc <pcu_put_byte>
 8003682:	2301      	movs	r3, #1
 8003684:	9300      	str	r3, [sp, #0]
 8003686:	e00c      	b.n	80036a2 <TxD_Dec_S16+0x6e>
            bPrinted = 1;
        }
        else
        {
            if(bPrinted) pcu_put_byte( ((u8)wTmp)+'0');
 8003688:	9900      	ldr	r1, [sp, #0]
 800368a:	b119      	cbz	r1, 8003694 <TxD_Dec_S16+0x60>
 800368c:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8003690:	b2c0      	uxtb	r0, r0
 8003692:	e004      	b.n	800369e <TxD_Dec_S16+0x6a>
            else
            {
                if(bCount < 4) pcu_put_byte( ' ');
 8003694:	2f04      	cmp	r7, #4
 8003696:	d001      	beq.n	800369c <TxD_Dec_S16+0x68>
 8003698:	2020      	movs	r0, #32
 800369a:	e000      	b.n	800369e <TxD_Dec_S16+0x6a>
                else pcu_put_byte(  '0');
 800369c:	2030      	movs	r0, #48
 800369e:	f002 fd95 	bl	80061cc <pcu_put_byte>
        bMinus = 1;
        wData = -wData;
    }

    wDigit = 10000;
    for(bCount = 0; bCount < 5; bCount++)
 80036a2:	1c7b      	adds	r3, r7, #1
 80036a4:	b2df      	uxtb	r7, r3
 80036a6:	2f05      	cmp	r7, #5
 80036a8:	d008      	beq.n	80036bc <TxD_Dec_S16+0x88>
            {
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte(  '0');
            }
        }
        wData -= wTmp*wDigit;
 80036aa:	fb06 5314 	mls	r3, r6, r4, r5
        wDigit /= 10;
 80036ae:	4904      	ldr	r1, [pc, #16]	(80036c0 <TxD_Dec_S16+0x8c>)
            {
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte(  '0');
            }
        }
        wData -= wTmp*wDigit;
 80036b0:	b21d      	sxth	r5, r3
        wDigit /= 10;
 80036b2:	fba6 2301 	umull	r2, r3, r6, r1
 80036b6:	08db      	lsrs	r3, r3, #3
 80036b8:	b29e      	uxth	r6, r3
 80036ba:	e7cc      	b.n	8003656 <TxD_Dec_S16+0x22>
    }
}
 80036bc:	b003      	add	sp, #12
 80036be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80036c0:	cccccccd 	.word	0xcccccccd

080036c4 <TxD_Dec_S8>:
    }
}

//##############################################################################
void TxD_Dec_S8(s8 wData)
{
 80036c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    u16 wTmp,wDigit;
    u8 bMinus = 0;

    bPrinted = 0;

    if (wData&0x80) {
 80036c6:	2800      	cmp	r0, #0
    }
}

//##############################################################################
void TxD_Dec_S8(s8 wData)
{
 80036c8:	b083      	sub	sp, #12
 80036ca:	4605      	mov	r5, r0
    u16 wTmp,wDigit;
    u8 bMinus = 0;

    bPrinted = 0;

    if (wData&0x80) {
 80036cc:	db02      	blt.n	80036d4 <TxD_Dec_S8+0x10>
 80036ce:	2100      	movs	r1, #0
 80036d0:	9101      	str	r1, [sp, #4]
 80036d2:	e004      	b.n	80036de <TxD_Dec_S8+0x1a>
        bMinus = 1;
        wData = -wData;
 80036d4:	f1c0 0300 	rsb	r3, r0, #0	; 0x0
 80036d8:	2201      	movs	r2, #1
 80036da:	b25d      	sxtb	r5, r3
 80036dc:	9201      	str	r2, [sp, #4]
 80036de:	2300      	movs	r3, #0
 80036e0:	9300      	str	r3, [sp, #0]
 80036e2:	2700      	movs	r7, #0
 80036e4:	2664      	movs	r6, #100
    }

    wDigit = 100;
    for(bCount = 0; bCount < 3; bCount++)
    {
        wTmp = (wData/wDigit);
 80036e6:	fb95 f3f6 	sdiv	r3, r5, r6
 80036ea:	b29c      	uxth	r4, r3
        if(wTmp && !bPrinted)
 80036ec:	f087 0301 	eor.w	r3, r7, #1	; 0x1
 80036f0:	2c00      	cmp	r4, #0
 80036f2:	bf0c      	ite	eq
 80036f4:	2300      	moveq	r3, #0
 80036f6:	f003 0301 	andne.w	r3, r3, #1	; 0x1
 80036fa:	b15b      	cbz	r3, 8003714 <TxD_Dec_S8+0x50>
        {
            if (bMinus) pcu_put_byte( '-');
 80036fc:	9901      	ldr	r1, [sp, #4]
 80036fe:	b111      	cbz	r1, 8003706 <TxD_Dec_S8+0x42>
 8003700:	202d      	movs	r0, #45
 8003702:	f002 fd63 	bl	80061cc <pcu_put_byte>
            pcu_put_byte( ((u8)wTmp)+'0');
 8003706:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800370a:	b2c0      	uxtb	r0, r0
 800370c:	f002 fd5e 	bl	80061cc <pcu_put_byte>
 8003710:	2701      	movs	r7, #1
 8003712:	e007      	b.n	8003724 <TxD_Dec_S8+0x60>
            bPrinted = 1;
        }
        else
        {
            if(bPrinted) pcu_put_byte( ((u8)wTmp)+'0');
 8003714:	b11f      	cbz	r7, 800371e <TxD_Dec_S8+0x5a>
 8003716:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800371a:	b2c0      	uxtb	r0, r0
 800371c:	e000      	b.n	8003720 <TxD_Dec_S8+0x5c>
            else
            {
                if(bCount < 4) pcu_put_byte( ' ');
 800371e:	2020      	movs	r0, #32
 8003720:	f002 fd54 	bl	80061cc <pcu_put_byte>
        bMinus = 1;
        wData = -wData;
    }

    wDigit = 100;
    for(bCount = 0; bCount < 3; bCount++)
 8003724:	9a00      	ldr	r2, [sp, #0]
 8003726:	1c53      	adds	r3, r2, #1
 8003728:	b2db      	uxtb	r3, r3
 800372a:	2b03      	cmp	r3, #3
 800372c:	9300      	str	r3, [sp, #0]
 800372e:	d008      	beq.n	8003742 <TxD_Dec_S8+0x7e>
            {
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte(  '0');
            }
        }
        wData -= wTmp*wDigit;
 8003730:	fb06 5314 	mls	r3, r6, r4, r5
        wDigit /= 10;
 8003734:	4904      	ldr	r1, [pc, #16]	(8003748 <TxD_Dec_S8+0x84>)
            {
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte(  '0');
            }
        }
        wData -= wTmp*wDigit;
 8003736:	b25d      	sxtb	r5, r3
        wDigit /= 10;
 8003738:	fba6 2301 	umull	r2, r3, r6, r1
 800373c:	08db      	lsrs	r3, r3, #3
 800373e:	b29e      	uxth	r6, r3
 8003740:	e7d1      	b.n	80036e6 <TxD_Dec_S8+0x22>
    }
}
 8003742:	b003      	add	sp, #12
 8003744:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003746:	46c0      	nop			(mov r8, r8)
 8003748:	cccccccd 	.word	0xcccccccd

0800374c <TxD_Dec_U32>:
    }
}

//##############################################################################
void TxD_Dec_U32(u32 wData)
{
 800374c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800374e:	2600      	movs	r6, #0
 8003750:	b083      	sub	sp, #12
 8003752:	4c12      	ldr	r4, [pc, #72]	(800379c <TxD_Dec_U32+0x50>)
 8003754:	4607      	mov	r7, r0
 8003756:	9601      	str	r6, [sp, #4]

    wDigit = 1000000000;

    for(bCount = 0; bCount < 10; bCount++)
    {
        wTmp = (wData/wDigit);
 8003758:	fbb7 f5f4 	udiv	r5, r7, r4
        if(wTmp)
 800375c:	b13d      	cbz	r5, 800376e <TxD_Dec_U32+0x22>
        {
            pcu_put_byte( ((u8)wTmp)+'0');
 800375e:	f105 0030 	add.w	r0, r5, #48	; 0x30
 8003762:	b2c0      	uxtb	r0, r0
 8003764:	f002 fd32 	bl	80061cc <pcu_put_byte>
 8003768:	2101      	movs	r1, #1
 800376a:	9101      	str	r1, [sp, #4]
 800376c:	e008      	b.n	8003780 <TxD_Dec_U32+0x34>
            bPrinted = 1;
        }
        else
        {
            if(bPrinted) pcu_put_byte( ((u8)wTmp)+'0');
 800376e:	9b01      	ldr	r3, [sp, #4]
 8003770:	b91b      	cbnz	r3, 800377a <TxD_Dec_U32+0x2e>
            else
            {
                if(bCount < 4) pcu_put_byte( ' ');
 8003772:	2e03      	cmp	r6, #3
 8003774:	d801      	bhi.n	800377a <TxD_Dec_U32+0x2e>
 8003776:	2020      	movs	r0, #32
 8003778:	e000      	b.n	800377c <TxD_Dec_U32+0x30>
                else pcu_put_byte( '0');
 800377a:	2030      	movs	r0, #48
 800377c:	f002 fd26 	bl	80061cc <pcu_put_byte>
    u32 wTmp,wDigit;
    bPrinted = 0;

    wDigit = 1000000000;

    for(bCount = 0; bCount < 10; bCount++)
 8003780:	1c73      	adds	r3, r6, #1
 8003782:	b2de      	uxtb	r6, r3
 8003784:	2e0a      	cmp	r6, #10
 8003786:	d006      	beq.n	8003796 <TxD_Dec_U32+0x4a>
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte( '0');
            }
        }
        wData -= wTmp*wDigit;
        wDigit /= 10;
 8003788:	4905      	ldr	r1, [pc, #20]	(80037a0 <TxD_Dec_U32+0x54>)
            {
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte( '0');
            }
        }
        wData -= wTmp*wDigit;
 800378a:	fb04 7715 	mls	r7, r4, r5, r7
        wDigit /= 10;
 800378e:	fba4 2301 	umull	r2, r3, r4, r1
 8003792:	08dc      	lsrs	r4, r3, #3
 8003794:	e7e0      	b.n	8003758 <TxD_Dec_U32+0xc>
    }
}
 8003796:	b003      	add	sp, #12
 8003798:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800379a:	46c0      	nop			(mov r8, r8)
 800379c:	3b9aca00 	.word	0x3b9aca00
 80037a0:	cccccccd 	.word	0xcccccccd

080037a4 <TxD_Dec_U16>:
    pcu_put_byte( bByte - bTmp*10+'0');
}

//##############################################################################
void TxD_Dec_U16(u16 wData)
{
 80037a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80037a6:	2600      	movs	r6, #0
 80037a8:	b083      	sub	sp, #12
 80037aa:	4607      	mov	r7, r0
 80037ac:	9601      	str	r6, [sp, #4]
 80037ae:	f242 7410 	movw	r4, #10000	; 0x2710
    bPrinted = 0;

    wDigit = 10000;
    for(bCount = 0; bCount < 5; bCount++)
    {
        wTmp = (wData/wDigit);
 80037b2:	fbb7 f5f4 	udiv	r5, r7, r4
        if(wTmp)
 80037b6:	b13d      	cbz	r5, 80037c8 <TxD_Dec_U16+0x24>
        {
            pcu_put_byte( ((u8)wTmp)+'0');
 80037b8:	f105 0030 	add.w	r0, r5, #48	; 0x30
 80037bc:	b2c0      	uxtb	r0, r0
 80037be:	f002 fd05 	bl	80061cc <pcu_put_byte>
 80037c2:	2101      	movs	r1, #1
 80037c4:	9101      	str	r1, [sp, #4]
 80037c6:	e008      	b.n	80037da <TxD_Dec_U16+0x36>
            bPrinted = 1;
        }
        else
        {
            if(bPrinted) pcu_put_byte( ((u8)wTmp)+'0');
 80037c8:	9b01      	ldr	r3, [sp, #4]
 80037ca:	b91b      	cbnz	r3, 80037d4 <TxD_Dec_U16+0x30>
            else
            {
                if(bCount < 4) pcu_put_byte( ' ');
 80037cc:	2e04      	cmp	r6, #4
 80037ce:	d001      	beq.n	80037d4 <TxD_Dec_U16+0x30>
 80037d0:	2020      	movs	r0, #32
 80037d2:	e000      	b.n	80037d6 <TxD_Dec_U16+0x32>
                else pcu_put_byte( '0');
 80037d4:	2030      	movs	r0, #48
 80037d6:	f002 fcf9 	bl	80061cc <pcu_put_byte>
    u8 bCount, bPrinted;
    u16 wTmp,wDigit;
    bPrinted = 0;

    wDigit = 10000;
    for(bCount = 0; bCount < 5; bCount++)
 80037da:	1c73      	adds	r3, r6, #1
 80037dc:	b2de      	uxtb	r6, r3
 80037de:	2e05      	cmp	r6, #5
 80037e0:	d008      	beq.n	80037f4 <TxD_Dec_U16+0x50>
            {
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte( '0');
            }
        }
        wData -= wTmp*wDigit;
 80037e2:	fb04 7315 	mls	r3, r4, r5, r7
        wDigit /= 10;
 80037e6:	4904      	ldr	r1, [pc, #16]	(80037f8 <TxD_Dec_U16+0x54>)
            {
                if(bCount < 4) pcu_put_byte( ' ');
                else pcu_put_byte( '0');
            }
        }
        wData -= wTmp*wDigit;
 80037e8:	b29f      	uxth	r7, r3
        wDigit /= 10;
 80037ea:	fba4 2301 	umull	r2, r3, r4, r1
 80037ee:	08db      	lsrs	r3, r3, #3
 80037f0:	b29c      	uxth	r4, r3
 80037f2:	e7de      	b.n	80037b2 <TxD_Dec_U16+0xe>
    }
}
 80037f4:	b003      	add	sp, #12
 80037f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80037f8:	cccccccd 	.word	0xcccccccd

080037fc <TxD_Dec_U8>:

//##############################################################################
void TxD_Dec_U8(u8 bByte)
{
    u8 bTmp;
    bTmp = bByte/100;
 80037fc:	4a16      	ldr	r2, [pc, #88]	(8003858 <TxD_Dec_U8+0x5c>)
	return;
}

//##############################################################################
void TxD_Dec_U8(u8 bByte)
{
 80037fe:	b530      	push	{r4, r5, lr}
    u8 bTmp;
    bTmp = bByte/100;
 8003800:	fba0 2302 	umull	r2, r3, r0, r2
 8003804:	095c      	lsrs	r4, r3, #5
 8003806:	b2e4      	uxtb	r4, r4
	return;
}

//##############################################################################
void TxD_Dec_U8(u8 bByte)
{
 8003808:	4605      	mov	r5, r0
    u8 bTmp;
    bTmp = bByte/100;
    /*if(bTmp)*/ pcu_put_byte(bTmp+'0');
 800380a:	f104 0030 	add.w	r0, r4, #48	; 0x30
	return;
}

//##############################################################################
void TxD_Dec_U8(u8 bByte)
{
 800380e:	b081      	sub	sp, #4
    u8 bTmp;
    bTmp = bByte/100;
    /*if(bTmp)*/ pcu_put_byte(bTmp+'0');
 8003810:	b2c0      	uxtb	r0, r0
 8003812:	f002 fcdb 	bl	80061cc <pcu_put_byte>
    bByte -= bTmp*100;
 8003816:	ebc4 6344 	rsb	r3, r4, r4, lsl #25
 800381a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 800381e:	ebc4 04c3 	rsb	r4, r4, r3, lsl #3
 8003822:	eb05 0584 	add.w	r5, r5, r4, lsl #2
    bTmp = bByte/10;
 8003826:	4a0d      	ldr	r2, [pc, #52]	(800385c <TxD_Dec_U8+0x60>)
void TxD_Dec_U8(u8 bByte)
{
    u8 bTmp;
    bTmp = bByte/100;
    /*if(bTmp)*/ pcu_put_byte(bTmp+'0');
    bByte -= bTmp*100;
 8003828:	b2ed      	uxtb	r5, r5
    bTmp = bByte/10;
 800382a:	fba5 2302 	umull	r2, r3, r5, r2
 800382e:	08dc      	lsrs	r4, r3, #3
 8003830:	b2e4      	uxtb	r4, r4
    /*if(bTmp)*/ pcu_put_byte( bTmp+'0');
 8003832:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8003836:	b2c0      	uxtb	r0, r0
 8003838:	f002 fcc8 	bl	80061cc <pcu_put_byte>
    pcu_put_byte( bByte - bTmp*10+'0');
 800383c:	ebc4 7344 	rsb	r3, r4, r4, lsl #29
 8003840:	3530      	adds	r5, #48
 8003842:	ebc4 0483 	rsb	r4, r4, r3, lsl #2
 8003846:	eb05 0544 	add.w	r5, r5, r4, lsl #1
 800384a:	b2ed      	uxtb	r5, r5
 800384c:	4628      	mov	r0, r5
 800384e:	f002 fcbd 	bl	80061cc <pcu_put_byte>
}
 8003852:	b001      	add	sp, #4
 8003854:	bd30      	pop	{r4, r5, pc}
 8003856:	46c0      	nop			(mov r8, r8)
 8003858:	51eb851f 	.word	0x51eb851f
 800385c:	cccccccd 	.word	0xcccccccd

08003860 <std_putchar>:
	pcu_hal_close();
}

//##############################################################################
int std_putchar(char c) {
	if (c == '\n') {
 8003860:	280a      	cmp	r0, #10
void pcu_terminate(void) {
	pcu_hal_close();
}

//##############################################################################
int std_putchar(char c) {
 8003862:	b510      	push	{r4, lr}
 8003864:	4604      	mov	r4, r0
	if (c == '\n') {
		pcu_put_byte((u8) '\r'); //0x0D
		pcu_put_byte((u8) '\n'); //0x0A
	} else {
		pcu_put_byte((u8) c);
 8003866:	bf18      	it	ne
 8003868:	4600      	movne	r0, r0
	pcu_hal_close();
}

//##############################################################################
int std_putchar(char c) {
	if (c == '\n') {
 800386a:	d103      	bne.n	8003874 <std_putchar+0x14>
		pcu_put_byte((u8) '\r'); //0x0D
 800386c:	200d      	movs	r0, #13
 800386e:	f002 fcad 	bl	80061cc <pcu_put_byte>
		pcu_put_byte((u8) '\n'); //0x0A
 8003872:	200a      	movs	r0, #10
	} else {
		pcu_put_byte((u8) c);
 8003874:	f002 fcaa 	bl	80061cc <pcu_put_byte>
	}

	return c;
}
 8003878:	4620      	mov	r0, r4
 800387a:	bd10      	pop	{r4, pc}

0800387c <PrintChar>:
	if (dxl_get_rxpacket_error(ERRBIT_INSTRUCTION) == 1)
		std_puts("\nInstruction code error!\n");
}

//##############################################################################
int PrintChar(char c) {
 800387c:	b500      	push	{lr}
 800387e:	b081      	sub	sp, #4
	return std_putchar(c);
 8003880:	f7ff ffee 	bl	8003860 <std_putchar>
}
 8003884:	b001      	add	sp, #4
 8003886:	bd00      	pop	{pc}

08003888 <std_puts>:

	return c;
}

//##############################################################################
int std_puts(const char *str) {
 8003888:	b530      	push	{r4, r5, lr}
 800388a:	4605      	mov	r5, r0
 800388c:	b081      	sub	sp, #4
 800388e:	2400      	movs	r4, #0
 8003890:	e002      	b.n	8003898 <std_puts+0x10>
	int n = 0;
	while (str[n])
		std_putchar(str[n++]);
 8003892:	3401      	adds	r4, #1
 8003894:	f7ff ffe4 	bl	8003860 <std_putchar>
}

//##############################################################################
int std_puts(const char *str) {
	int n = 0;
	while (str[n])
 8003898:	5d28      	ldrb	r0, [r5, r4]
 800389a:	2800      	cmp	r0, #0
 800389c:	d1f9      	bne.n	8003892 <std_puts+0xa>
		std_putchar(str[n++]);

	return n;
}
 800389e:	4620      	mov	r0, r4
 80038a0:	b001      	add	sp, #4
 80038a2:	bd30      	pop	{r4, r5, pc}

080038a4 <Printu8h>:
	std_puts(out);
	return;
}

//##############################################################################
void Printu8h(u8 bNum) {
 80038a4:	b500      	push	{lr}
	char out[5];
	out[0] = '0';
 80038a6:	2330      	movs	r3, #48
	std_puts(out);
	return;
}

//##############################################################################
void Printu8h(u8 bNum) {
 80038a8:	b083      	sub	sp, #12
	char out[5];
	out[0] = '0';
 80038aa:	f88d 3003 	strb.w	r3, [sp, #3]
	out[1] = 'x';
 80038ae:	2378      	movs	r3, #120
 80038b0:	f88d 3004 	strb.w	r3, [sp, #4]
	out[4] = '\0';
 80038b4:	2300      	movs	r3, #0
 80038b6:	f88d 3007 	strb.w	r3, [sp, #7]

	out[2] = (char) ((bNum >> 4) & 0x0F) + 0x30;
 80038ba:	0903      	lsrs	r3, r0, #4
 80038bc:	3330      	adds	r3, #48
	if (out[2] > '9')
 80038be:	2b39      	cmp	r3, #57
	char out[5];
	out[0] = '0';
	out[1] = 'x';
	out[4] = '\0';

	out[2] = (char) ((bNum >> 4) & 0x0F) + 0x30;
 80038c0:	f88d 3005 	strb.w	r3, [sp, #5]
	if (out[2] > '9')
 80038c4:	d902      	bls.n	80038cc <Printu8h+0x28>
		out[2] += 7;
 80038c6:	3307      	adds	r3, #7
 80038c8:	f88d 3005 	strb.w	r3, [sp, #5]

	out[3] = (char) (bNum & 0x0F) + 0x30;
 80038cc:	f000 030f 	and.w	r3, r0, #15	; 0xf
 80038d0:	f103 0030 	add.w	r0, r3, #48	; 0x30
	if (out[3] > '9')
 80038d4:	2839      	cmp	r0, #57

	out[2] = (char) ((bNum >> 4) & 0x0F) + 0x30;
	if (out[2] > '9')
		out[2] += 7;

	out[3] = (char) (bNum & 0x0F) + 0x30;
 80038d6:	f88d 0006 	strb.w	r0, [sp, #6]
	if (out[3] > '9')
 80038da:	d902      	bls.n	80038e2 <Printu8h+0x3e>
		out[3] += 7;
 80038dc:	1dc3      	adds	r3, r0, #7
 80038de:	f88d 3006 	strb.w	r3, [sp, #6]

	std_puts(out);
 80038e2:	f10d 0003 	add.w	r0, sp, #3	; 0x3
 80038e6:	f7ff ffcf 	bl	8003888 <std_puts>
	return;
}
 80038ea:	b003      	add	sp, #12
 80038ec:	bd00      	pop	{pc}
 80038ee:	46c0      	nop			(mov r8, r8)

080038f0 <Printu16h>:
	std_puts(out);
	return;
}

//##############################################################################
void Printu16h(u16 wNum) {
 80038f0:	b500      	push	{lr}
	char out[7];
	out[0] = '0';
 80038f2:	2330      	movs	r3, #48
	std_puts(out);
	return;
}

//##############################################################################
void Printu16h(u16 wNum) {
 80038f4:	b083      	sub	sp, #12
	char out[7];
	out[0] = '0';
 80038f6:	f88d 3001 	strb.w	r3, [sp, #1]
	out[1] = 'x';
 80038fa:	2378      	movs	r3, #120
 80038fc:	f88d 3002 	strb.w	r3, [sp, #2]
	out[6] = '\0';
 8003900:	2300      	movs	r3, #0
 8003902:	f88d 3007 	strb.w	r3, [sp, #7]

	out[2] = (char) ((wNum >> 12) & 0x0F) + 0x30;
 8003906:	0b03      	lsrs	r3, r0, #12
 8003908:	3330      	adds	r3, #48
	if (out[2] > '9')
 800390a:	2b39      	cmp	r3, #57
	char out[7];
	out[0] = '0';
	out[1] = 'x';
	out[6] = '\0';

	out[2] = (char) ((wNum >> 12) & 0x0F) + 0x30;
 800390c:	f88d 3003 	strb.w	r3, [sp, #3]
	if (out[2] > '9')
 8003910:	d902      	bls.n	8003918 <Printu16h+0x28>
		out[2] += 7;
 8003912:	3307      	adds	r3, #7
 8003914:	f88d 3003 	strb.w	r3, [sp, #3]

	out[3] = (char) ((wNum >> 8) & 0x0F) + 0x30;
 8003918:	0a03      	lsrs	r3, r0, #8
 800391a:	f003 030f 	and.w	r3, r3, #15	; 0xf
 800391e:	3330      	adds	r3, #48
	if (out[3] > '9')
 8003920:	2b39      	cmp	r3, #57

	out[2] = (char) ((wNum >> 12) & 0x0F) + 0x30;
	if (out[2] > '9')
		out[2] += 7;

	out[3] = (char) ((wNum >> 8) & 0x0F) + 0x30;
 8003922:	f88d 3004 	strb.w	r3, [sp, #4]
	if (out[3] > '9')
 8003926:	d902      	bls.n	800392e <Printu16h+0x3e>
		out[3] += 7;
 8003928:	3307      	adds	r3, #7
 800392a:	f88d 3004 	strb.w	r3, [sp, #4]

	out[4] = (char) ((wNum >> 4) & 0x0F) + 0x30;
 800392e:	0903      	lsrs	r3, r0, #4
 8003930:	f003 030f 	and.w	r3, r3, #15	; 0xf
 8003934:	3330      	adds	r3, #48
	if (out[4] > '9')
 8003936:	2b39      	cmp	r3, #57

	out[3] = (char) ((wNum >> 8) & 0x0F) + 0x30;
	if (out[3] > '9')
		out[3] += 7;

	out[4] = (char) ((wNum >> 4) & 0x0F) + 0x30;
 8003938:	f88d 3005 	strb.w	r3, [sp, #5]
	if (out[4] > '9')
 800393c:	d902      	bls.n	8003944 <Printu16h+0x54>
		out[4] += 7;
 800393e:	3307      	adds	r3, #7
 8003940:	f88d 3005 	strb.w	r3, [sp, #5]

	out[5] = (char) (wNum & 0x0F) + 0x30;
 8003944:	f000 030f 	and.w	r3, r0, #15	; 0xf
 8003948:	f103 0030 	add.w	r0, r3, #48	; 0x30
	if (out[5] > '9')
 800394c:	2839      	cmp	r0, #57

	out[4] = (char) ((wNum >> 4) & 0x0F) + 0x30;
	if (out[4] > '9')
		out[4] += 7;

	out[5] = (char) (wNum & 0x0F) + 0x30;
 800394e:	f88d 0006 	strb.w	r0, [sp, #6]
	if (out[5] > '9')
 8003952:	d902      	bls.n	800395a <Printu16h+0x6a>
		out[5] += 7;
 8003954:	1dc3      	adds	r3, r0, #7
 8003956:	f88d 3006 	strb.w	r3, [sp, #6]

	std_puts(out);
 800395a:	f10d 0001 	add.w	r0, sp, #1	; 0x1
 800395e:	f7ff ff93 	bl	8003888 <std_puts>
	return;
}
 8003962:	b003      	add	sp, #12
 8003964:	bd00      	pop	{pc}
 8003966:	46c0      	nop			(mov r8, r8)

08003968 <Prints32d>:
	std_puts(out);
	return;
}

//##############################################################################
void Prints32d(s32 lNumS) {
 8003968:	b500      	push	{lr}
 800396a:	b085      	sub	sp, #20

	if (lNum < 0) {
		out[0] = '-';
		lNum = (u32) ((~lNumS) + 1);
	} else {
		out[0] = '+';
 800396c:	a904      	add	r1, sp, #16
 800396e:	232b      	movs	r3, #43
		lNum = (u32) (lNumS);
 8003970:	4a18      	ldr	r2, [pc, #96]	(80039d4 <Prints32d+0x6c>)
		temp = (lNum / div);
		lNum = (lNum % div);
//        lNum -= (u32) (temp*div);
//        out[i] = (char) (temp&0x0000000F)+0x30;
		out[i] = (char) ((temp & 0x0F) + 0x30);
		div /= 10;
 8003972:	f8df e064 	ldr.w	lr, [pc, #100]	; 80039d8 <Prints32d+0x70>

	if (lNum < 0) {
		out[0] = '-';
		lNum = (u32) ((~lNumS) + 1);
	} else {
		out[0] = '+';
 8003976:	f801 3d0c 	strb.w	r3, [r1, #-12]!
		lNum = (u32) (lNumS);
	}

	for (i = 1; i < 11; i++) {
 800397a:	f10d 0c0e 	add.w	ip, sp, #14	; 0xe
		temp = (lNum / div);
 800397e:	fbb0 f3f2 	udiv	r3, r0, r2
		lNum = (lNum % div);
 8003982:	fb02 0013 	mls	r0, r2, r3, r0
//        lNum -= (u32) (temp*div);
//        out[i] = (char) (temp&0x0000000F)+0x30;
		out[i] = (char) ((temp & 0x0F) + 0x30);
 8003986:	f003 030f 	and.w	r3, r3, #15	; 0xf
 800398a:	3330      	adds	r3, #48
 800398c:	f801 3f01 	strb.w	r3, [r1, #1]!
		div /= 10;
 8003990:	fba2 230e 	umull	r2, r3, r2, lr
 8003994:	08da      	lsrs	r2, r3, #3
	} else {
		out[0] = '+';
		lNum = (u32) (lNumS);
	}

	for (i = 1; i < 11; i++) {
 8003996:	4561      	cmp	r1, ip
 8003998:	d1f1      	bne.n	800397e <Prints32d+0x16>
//        lNum -= (u32) (temp*div);
//        out[i] = (char) (temp&0x0000000F)+0x30;
		out[i] = (char) ((temp & 0x0F) + 0x30);
		div /= 10;
	}
	out[i] = '\0';
 800399a:	2300      	movs	r3, #0
 800399c:	f88d 300f 	strb.w	r3, [sp, #15]
 80039a0:	2100      	movs	r1, #0

	for (i = 0; i < 11; i++) {
		if (out[0] == '0') {
 80039a2:	f10d 0005 	add.w	r0, sp, #5	; 0x5
 80039a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80039aa:	2b30      	cmp	r3, #48
 80039ac:	d108      	bne.n	80039c0 <Prints32d+0x58>
 80039ae:	4602      	mov	r2, r0
			for (j = 0; j < 11; j++) {
				out[j] = out[j + 1];
 80039b0:	7813      	ldrb	r3, [r2, #0]
 80039b2:	f802 3c01 	strb.w	r3, [r2, #-1]
				if (out[j] == '\0')
 80039b6:	b11b      	cbz	r3, 80039c0 <Prints32d+0x58>
					break;
 80039b8:	3201      	adds	r2, #1
	}
	out[i] = '\0';

	for (i = 0; i < 11; i++) {
		if (out[0] == '0') {
			for (j = 0; j < 11; j++) {
 80039ba:	ab04      	add	r3, sp, #16
 80039bc:	429a      	cmp	r2, r3
 80039be:	d1f7      	bne.n	80039b0 <Prints32d+0x48>
		out[i] = (char) ((temp & 0x0F) + 0x30);
		div /= 10;
	}
	out[i] = '\0';

	for (i = 0; i < 11; i++) {
 80039c0:	1c4b      	adds	r3, r1, #1
 80039c2:	b2d9      	uxtb	r1, r3
 80039c4:	290b      	cmp	r1, #11
 80039c6:	d1ee      	bne.n	80039a6 <Prints32d+0x3e>
					break;
			}
		}
	}

	std_puts(out);
 80039c8:	a801      	add	r0, sp, #4
 80039ca:	f7ff ff5d 	bl	8003888 <std_puts>
	return;
}
 80039ce:	b005      	add	sp, #20
 80039d0:	bd00      	pop	{pc}
 80039d2:	46c0      	nop			(mov r8, r8)
 80039d4:	3b9aca00 	.word	0x3b9aca00
 80039d8:	cccccccd 	.word	0xcccccccd

080039dc <Printu32d>:
char* GetString(char* s) {
	return std_gets(s);
}

//##############################################################################
void Printu32d(u32 lNum) {
 80039dc:	b500      	push	{lr}
 80039de:	4a19      	ldr	r2, [pc, #100]	(8003a44 <Printu32d+0x68>)
 80039e0:	b085      	sub	sp, #20
		temp = (char) (lNum / div);
		lNum = (lNum % div);
//        lNum -= (u32) (temp*div);
//        out[i] = (char) (temp&0x0000000F)+0x30;
		out[i] = (char) ((temp & 0x0F) + 0x30);
		div /= 10;
 80039e2:	f8df c064 	ldr.w	ip, [pc, #100]	; 8003a48 <Printu32d+0x6c>
char* GetString(char* s) {
	return std_gets(s);
}

//##############################################################################
void Printu32d(u32 lNum) {
 80039e6:	2100      	movs	r1, #0
	for (i = 0; i < 10; i++) {
		temp = (char) (lNum / div);
		lNum = (lNum % div);
//        lNum -= (u32) (temp*div);
//        out[i] = (char) (temp&0x0000000F)+0x30;
		out[i] = (char) ((temp & 0x0F) + 0x30);
 80039e8:	f10d 0e05 	add.w	lr, sp, #5	; 0x5
	u32 temp, div = 1000000000;
	char out[11];
	u8 i, j;

	for (i = 0; i < 10; i++) {
		temp = (char) (lNum / div);
 80039ec:	fbb0 f3f2 	udiv	r3, r0, r2
		lNum = (lNum % div);
 80039f0:	fb02 0013 	mls	r0, r2, r3, r0
//        lNum -= (u32) (temp*div);
//        out[i] = (char) (temp&0x0000000F)+0x30;
		out[i] = (char) ((temp & 0x0F) + 0x30);
 80039f4:	f003 030f 	and.w	r3, r3, #15	; 0xf
 80039f8:	3330      	adds	r3, #48
 80039fa:	f80e 3001 	strb.w	r3, [lr, r1]
		div /= 10;
 80039fe:	fba2 230c 	umull	r2, r3, r2, ip
 8003a02:	3101      	adds	r1, #1
 8003a04:	08da      	lsrs	r2, r3, #3
void Printu32d(u32 lNum) {
	u32 temp, div = 1000000000;
	char out[11];
	u8 i, j;

	for (i = 0; i < 10; i++) {
 8003a06:	290a      	cmp	r1, #10
 8003a08:	d1f0      	bne.n	80039ec <Printu32d+0x10>
//        lNum -= (u32) (temp*div);
//        out[i] = (char) (temp&0x0000000F)+0x30;
		out[i] = (char) ((temp & 0x0F) + 0x30);
		div /= 10;
	}
	out[i] = '\0';
 8003a0a:	2300      	movs	r3, #0
 8003a0c:	f88d 300f 	strb.w	r3, [sp, #15]
 8003a10:	2100      	movs	r1, #0

	for (i = 0; i < 10; i++) {
		if (out[0] == '0') {
 8003a12:	f10d 0006 	add.w	r0, sp, #6	; 0x6
 8003a16:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8003a1a:	2b30      	cmp	r3, #48
 8003a1c:	d108      	bne.n	8003a30 <Printu32d+0x54>
 8003a1e:	4602      	mov	r2, r0
			for (j = 0; j < 10; j++) {
				out[j] = out[j + 1];
 8003a20:	7813      	ldrb	r3, [r2, #0]
 8003a22:	f802 3c01 	strb.w	r3, [r2, #-1]
				if (out[j] == '\0')
 8003a26:	b11b      	cbz	r3, 8003a30 <Printu32d+0x54>
					break;
 8003a28:	3201      	adds	r2, #1
	}
	out[i] = '\0';

	for (i = 0; i < 10; i++) {
		if (out[0] == '0') {
			for (j = 0; j < 10; j++) {
 8003a2a:	ab04      	add	r3, sp, #16
 8003a2c:	429a      	cmp	r2, r3
 8003a2e:	d1f7      	bne.n	8003a20 <Printu32d+0x44>
		out[i] = (char) ((temp & 0x0F) + 0x30);
		div /= 10;
	}
	out[i] = '\0';

	for (i = 0; i < 10; i++) {
 8003a30:	1c4b      	adds	r3, r1, #1
 8003a32:	b2d9      	uxtb	r1, r3
 8003a34:	290a      	cmp	r1, #10
 8003a36:	d1ee      	bne.n	8003a16 <Printu32d+0x3a>
					break;
			}
		}
	}

	std_puts(out);
 8003a38:	f10d 0005 	add.w	r0, sp, #5	; 0x5
 8003a3c:	f7ff ff24 	bl	8003888 <std_puts>
	return;
}
 8003a40:	b005      	add	sp, #20
 8003a42:	bd00      	pop	{pc}
 8003a44:	3b9aca00 	.word	0x3b9aca00
 8003a48:	cccccccd 	.word	0xcccccccd

08003a4c <PrintString>:
int PrintChar(char c) {
	return std_putchar(c);
}

//##############################################################################
int PrintString(const char* s) {
 8003a4c:	b500      	push	{lr}
 8003a4e:	b081      	sub	sp, #4
	return std_puts(s);
 8003a50:	f7ff ff1a 	bl	8003888 <std_puts>
}
 8003a54:	b001      	add	sp, #4
 8003a56:	bd00      	pop	{pc}

08003a58 <PrintCommStatus>:

	return str;
}
//##############################################################################
void PrintCommStatus(u16 Status) {
	if (Status & DXL_TXFAIL)
 8003a58:	f010 0f04 	tst.w	r0, #4	; 0x4
	}

	return str;
}
//##############################################################################
void PrintCommStatus(u16 Status) {
 8003a5c:	b510      	push	{r4, lr}
 8003a5e:	4604      	mov	r4, r0
	if (Status & DXL_TXFAIL)
 8003a60:	d002      	beq.n	8003a68 <PrintCommStatus+0x10>
		std_puts("\nDXL_TXFAIL: Failed transmit instruction packet!\n");
 8003a62:	4817      	ldr	r0, [pc, #92]	(8003ac0 <PrintCommStatus+0x68>)
 8003a64:	f7ff ff10 	bl	8003888 <std_puts>

	if (Status & DXL_RXFAIL)
 8003a68:	f014 0f08 	tst.w	r4, #8	; 0x8
 8003a6c:	d002      	beq.n	8003a74 <PrintCommStatus+0x1c>
		std_puts("\nDXL_RXFAIL: Failed get status packet from device!\n");
 8003a6e:	4815      	ldr	r0, [pc, #84]	(8003ac4 <PrintCommStatus+0x6c>)
 8003a70:	f7ff ff0a 	bl	8003888 <std_puts>

	if (Status & DXL_TXERROR)
 8003a74:	f014 0f10 	tst.w	r4, #16	; 0x10
 8003a78:	d002      	beq.n	8003a80 <PrintCommStatus+0x28>
		std_puts("\nDXL_TXERROR: Incorrect instruction packet!\n");
 8003a7a:	4813      	ldr	r0, [pc, #76]	(8003ac8 <PrintCommStatus+0x70>)
 8003a7c:	f7ff ff04 	bl	8003888 <std_puts>

	if (Status & DXL_BAD_INST)
 8003a80:	f014 0f20 	tst.w	r4, #32	; 0x20
 8003a84:	d002      	beq.n	8003a8c <PrintCommStatus+0x34>
		std_puts("\nDXL_BAD_INST: Invalid Instruction byte\n");
 8003a86:	4811      	ldr	r0, [pc, #68]	(8003acc <PrintCommStatus+0x74>)
 8003a88:	f7ff fefe 	bl	8003888 <std_puts>

	if (Status & DXL_BAD_ID)
 8003a8c:	f014 0f40 	tst.w	r4, #64	; 0x40
 8003a90:	d002      	beq.n	8003a98 <PrintCommStatus+0x40>
		std_puts(
 8003a92:	480f      	ldr	r0, [pc, #60]	(8003ad0 <PrintCommStatus+0x78>)
 8003a94:	f7ff fef8 	bl	8003888 <std_puts>
				"\nDXL_BAD_ID: ID's not same for instruction and status packets\n");

	if (Status & DXL_RXWAITING)
 8003a98:	f414 7f00 	tst.w	r4, #512	; 0x200
 8003a9c:	d002      	beq.n	8003aa4 <PrintCommStatus+0x4c>
		std_puts("\nDXL_RXWAITING: Now receiving status packet!\n");
 8003a9e:	480d      	ldr	r0, [pc, #52]	(8003ad4 <PrintCommStatus+0x7c>)
 8003aa0:	f7ff fef2 	bl	8003888 <std_puts>

	if (Status & DXL_RXTIMEOUT)
 8003aa4:	f414 6f80 	tst.w	r4, #1024	; 0x400
 8003aa8:	d002      	beq.n	8003ab0 <PrintCommStatus+0x58>
		std_puts("\nDXL_RXTIMEOUT: There is no status packet!\n");
 8003aaa:	480b      	ldr	r0, [pc, #44]	(8003ad8 <PrintCommStatus+0x80>)
 8003aac:	f7ff feec 	bl	8003888 <std_puts>

	if (Status & DXL_RXCHECKSUM)
 8003ab0:	f414 5f80 	tst.w	r4, #4096	; 0x1000
 8003ab4:	d002      	beq.n	8003abc <PrintCommStatus+0x64>
		std_puts("\nDXL_RXCHECKSUM: Incorrect status packet checksum!\n");
 8003ab6:	4809      	ldr	r0, [pc, #36]	(8003adc <PrintCommStatus+0x84>)
 8003ab8:	f7ff fee6 	bl	8003888 <std_puts>

//    else
//        std_puts("\nThis is unknown error code!\n");
}
 8003abc:	bd10      	pop	{r4, pc}
 8003abe:	46c0      	nop			(mov r8, r8)
 8003ac0:	08007ecb 	.word	0x08007ecb
 8003ac4:	08007efd 	.word	0x08007efd
 8003ac8:	08007f31 	.word	0x08007f31
 8003acc:	08007f5e 	.word	0x08007f5e
 8003ad0:	08007f87 	.word	0x08007f87
 8003ad4:	08007fc6 	.word	0x08007fc6
 8003ad8:	08007ff4 	.word	0x08007ff4
 8003adc:	08008020 	.word	0x08008020

08003ae0 <PrintErrorCode>:

//##############################################################################
void PrintErrorCode(void) {
 8003ae0:	b500      	push	{lr}
	if (dxl_get_rxpacket_error(ERRBIT_VOLTAGE) == 1)
 8003ae2:	2001      	movs	r0, #1
//    else
//        std_puts("\nThis is unknown error code!\n");
}

//##############################################################################
void PrintErrorCode(void) {
 8003ae4:	b081      	sub	sp, #4
	if (dxl_get_rxpacket_error(ERRBIT_VOLTAGE) == 1)
 8003ae6:	f000 f8c5 	bl	8003c74 <dxl_get_rxpacket_error>
 8003aea:	2801      	cmp	r0, #1
 8003aec:	d102      	bne.n	8003af4 <PrintErrorCode+0x14>
		std_puts("\nInput voltage error!\n");
 8003aee:	481a      	ldr	r0, [pc, #104]	(8003b58 <PrintErrorCode+0x78>)
 8003af0:	f7ff feca 	bl	8003888 <std_puts>

	if (dxl_get_rxpacket_error(ERRBIT_ANGLE) == 1)
 8003af4:	2002      	movs	r0, #2
 8003af6:	f000 f8bd 	bl	8003c74 <dxl_get_rxpacket_error>
 8003afa:	2801      	cmp	r0, #1
 8003afc:	d102      	bne.n	8003b04 <PrintErrorCode+0x24>
		std_puts("\nAngle limit error!\n");
 8003afe:	4817      	ldr	r0, [pc, #92]	(8003b5c <PrintErrorCode+0x7c>)
 8003b00:	f7ff fec2 	bl	8003888 <std_puts>

	if (dxl_get_rxpacket_error(ERRBIT_OVERHEAT) == 1)
 8003b04:	2004      	movs	r0, #4
 8003b06:	f000 f8b5 	bl	8003c74 <dxl_get_rxpacket_error>
 8003b0a:	2801      	cmp	r0, #1
 8003b0c:	d102      	bne.n	8003b14 <PrintErrorCode+0x34>
		std_puts("\nOverheat error!\n");
 8003b0e:	4814      	ldr	r0, [pc, #80]	(8003b60 <PrintErrorCode+0x80>)
 8003b10:	f7ff feba 	bl	8003888 <std_puts>

	if (dxl_get_rxpacket_error(ERRBIT_RANGE) == 1)
 8003b14:	2008      	movs	r0, #8
 8003b16:	f000 f8ad 	bl	8003c74 <dxl_get_rxpacket_error>
 8003b1a:	2801      	cmp	r0, #1
 8003b1c:	d102      	bne.n	8003b24 <PrintErrorCode+0x44>
		std_puts("\nOut of range error!\n");
 8003b1e:	4811      	ldr	r0, [pc, #68]	(8003b64 <PrintErrorCode+0x84>)
 8003b20:	f7ff feb2 	bl	8003888 <std_puts>

	if (dxl_get_rxpacket_error(ERRBIT_CHECKSUM) == 1)
 8003b24:	2010      	movs	r0, #16
 8003b26:	f000 f8a5 	bl	8003c74 <dxl_get_rxpacket_error>
 8003b2a:	2801      	cmp	r0, #1
 8003b2c:	d102      	bne.n	8003b34 <PrintErrorCode+0x54>
		std_puts("\nChecksum error!\n");
 8003b2e:	480e      	ldr	r0, [pc, #56]	(8003b68 <PrintErrorCode+0x88>)
 8003b30:	f7ff feaa 	bl	8003888 <std_puts>

	if (dxl_get_rxpacket_error(ERRBIT_OVERLOAD) == 1)
 8003b34:	2020      	movs	r0, #32
 8003b36:	f000 f89d 	bl	8003c74 <dxl_get_rxpacket_error>
 8003b3a:	2801      	cmp	r0, #1
 8003b3c:	d102      	bne.n	8003b44 <PrintErrorCode+0x64>
		std_puts("\nOverload error!\n");
 8003b3e:	480b      	ldr	r0, [pc, #44]	(8003b6c <PrintErrorCode+0x8c>)
 8003b40:	f7ff fea2 	bl	8003888 <std_puts>

	if (dxl_get_rxpacket_error(ERRBIT_INSTRUCTION) == 1)
 8003b44:	2040      	movs	r0, #64
 8003b46:	f000 f895 	bl	8003c74 <dxl_get_rxpacket_error>
 8003b4a:	2801      	cmp	r0, #1
 8003b4c:	d102      	bne.n	8003b54 <PrintErrorCode+0x74>
		std_puts("\nInstruction code error!\n");
 8003b4e:	4808      	ldr	r0, [pc, #32]	(8003b70 <PrintErrorCode+0x90>)
 8003b50:	f7ff fe9a 	bl	8003888 <std_puts>
}
 8003b54:	b001      	add	sp, #4
 8003b56:	bd00      	pop	{pc}
 8003b58:	08008054 	.word	0x08008054
 8003b5c:	0800806b 	.word	0x0800806b
 8003b60:	08008080 	.word	0x08008080
 8003b64:	08008092 	.word	0x08008092
 8003b68:	080080a8 	.word	0x080080a8
 8003b6c:	080080ba 	.word	0x080080ba
 8003b70:	080080cc 	.word	0x080080cc

08003b74 <std_gets>:
//	}
//	return str;
//}

//##############################################################################
char* std_gets(char *str) {
 8003b74:	b570      	push	{r4, r5, r6, lr}
 8003b76:	4605      	mov	r5, r0
 8003b78:	2400      	movs	r4, #0
 8003b7a:	2680      	movs	r6, #128
	u8 c, len = 0;

	while (len < 128) {
		pcu_hal_set_timeout(10);
 8003b7c:	200a      	movs	r0, #10
 8003b7e:	f002 fb3d 	bl	80061fc <pcu_hal_set_timeout>
		while ((pcu_hal_timeout() == 0) && (pcu_get_qstate() == 0))
 8003b82:	f002 f853 	bl	8005c2c <pcu_hal_timeout>
 8003b86:	b918      	cbnz	r0, 8003b90 <std_gets+0x1c>
 8003b88:	f002 f898 	bl	8005cbc <pcu_get_qstate>
 8003b8c:	2800      	cmp	r0, #0
 8003b8e:	d0f8      	beq.n	8003b82 <std_gets+0xe>
			;
		if (pcu_get_qstate() == 0) {
 8003b90:	f002 f894 	bl	8005cbc <pcu_get_qstate>
 8003b94:	b910      	cbnz	r0, 8003b9c <std_gets+0x28>
			if (len == 0) {
 8003b96:	b1bc      	cbz	r4, 8003bc8 <std_gets+0x54>
				return 0; //NULL;
			} else {
				str[len] = '\0';
 8003b98:	5528      	strb	r0, [r5, r4]
 8003b9a:	e016      	b.n	8003bca <std_gets+0x56>
				return str;
			}
		}

		c = pcu_get_queue();
 8003b9c:	f002 f850 	bl	8005c40 <pcu_get_queue>
		if ((c == '\n') || (c == '\0')) {
 8003ba0:	f1d0 0301 	rsbs	r3, r0, #1	; 0x1
 8003ba4:	bf38      	it	cc
 8003ba6:	2300      	movcc	r3, #0
 8003ba8:	280a      	cmp	r0, #10
 8003baa:	bf08      	it	eq
 8003bac:	f043 0301 	orreq.w	r3, r3, #1	; 0x1
				str[len] = '\0';
				return str;
			}
		}

		c = pcu_get_queue();
 8003bb0:	3e01      	subs	r6, #1
		if ((c == '\n') || (c == '\0')) {
 8003bb2:	b11b      	cbz	r3, 8003bbc <std_gets+0x48>
			if (len == 0) {
 8003bb4:	b144      	cbz	r4, 8003bc8 <std_gets+0x54>
				return 0; //NULL;
			} else {
				str[len] = '\0';
 8003bb6:	2300      	movs	r3, #0
 8003bb8:	552b      	strb	r3, [r5, r4]
 8003bba:	e006      	b.n	8003bca <std_gets+0x56>
				return str;
			}
		} else
			str[len++] = (s8) c;
 8003bbc:	1c63      	adds	r3, r4, #1
 8003bbe:	5528      	strb	r0, [r5, r4]
 8003bc0:	b2dc      	uxtb	r4, r3

//##############################################################################
char* std_gets(char *str) {
	u8 c, len = 0;

	while (len < 128) {
 8003bc2:	2e00      	cmp	r6, #0
 8003bc4:	d1da      	bne.n	8003b7c <std_gets+0x8>
 8003bc6:	e000      	b.n	8003bca <std_gets+0x56>
 8003bc8:	2500      	movs	r5, #0
		} else
			str[len++] = (s8) c;
	}

	return str;
}
 8003bca:	4628      	mov	r0, r5
 8003bcc:	bd70      	pop	{r4, r5, r6, pc}
 8003bce:	46c0      	nop			(mov r8, r8)

08003bd0 <GetString>:
int GetChar(void) {
	return std_getchar();
}

//##############################################################################
char* GetString(char* s) {
 8003bd0:	b500      	push	{lr}
 8003bd2:	b081      	sub	sp, #4
	return std_gets(s);
 8003bd4:	f7ff ffce 	bl	8003b74 <std_gets>
}
 8003bd8:	b001      	add	sp, #4
 8003bda:	bd00      	pop	{pc}

08003bdc <std_getchar>:

	return n;
}

//##############################################################################
int std_getchar(void) {
 8003bdc:	b500      	push	{lr}
	char c;

	pcu_hal_set_timeout(10);
 8003bde:	200a      	movs	r0, #10

	return n;
}

//##############################################################################
int std_getchar(void) {
 8003be0:	b081      	sub	sp, #4
	char c;

	pcu_hal_set_timeout(10);
 8003be2:	f002 fb0b 	bl	80061fc <pcu_hal_set_timeout>
	while ((pcu_hal_timeout() == 0) && (pcu_get_qstate() == 0))
 8003be6:	f002 f821 	bl	8005c2c <pcu_hal_timeout>
 8003bea:	b918      	cbnz	r0, 8003bf4 <std_getchar+0x18>
 8003bec:	f002 f866 	bl	8005cbc <pcu_get_qstate>
 8003bf0:	2800      	cmp	r0, #0
 8003bf2:	d0f8      	beq.n	8003be6 <std_getchar+0xa>
		;
	if (pcu_get_qstate() == 0)
 8003bf4:	f002 f862 	bl	8005cbc <pcu_get_qstate>
 8003bf8:	b908      	cbnz	r0, 8003bfe <std_getchar+0x22>
 8003bfa:	20ff      	movs	r0, #255
 8003bfc:	e004      	b.n	8003c08 <std_getchar+0x2c>
		return 0xFF;

	c = pcu_get_queue();
 8003bfe:	f002 f81f 	bl	8005c40 <pcu_get_queue>

	if (c == '\r')
 8003c02:	280d      	cmp	r0, #13
 8003c04:	bf08      	it	eq
 8003c06:	200a      	moveq	r0, #10
		c = '\n';

	return c;
}
 8003c08:	b001      	add	sp, #4
 8003c0a:	bd00      	pop	{pc}

08003c0c <GetChar>:
int PrintString(const char* s) {
	return std_puts(s);
}

//##############################################################################
int GetChar(void) {
 8003c0c:	b500      	push	{lr}
 8003c0e:	b081      	sub	sp, #4
	return std_getchar();
 8003c10:	f7ff ffe4 	bl	8003bdc <std_getchar>
}
 8003c14:	b001      	add	sp, #4
 8003c16:	bd00      	pop	{pc}

08003c18 <pcu_terminate>:

	return 1;
}

//##############################################################################
void pcu_terminate(void) {
 8003c18:	b500      	push	{lr}
 8003c1a:	b081      	sub	sp, #4
	pcu_hal_close();
 8003c1c:	f002 f976 	bl	8005f0c <pcu_hal_close>
}
 8003c20:	b001      	add	sp, #4
 8003c22:	bd00      	pop	{pc}

08003c24 <pcu_initialize>:
	gbPcuRead++;
	return bTemp;
}

//##############################################################################
u8 pcu_initialize(u32 baudrate) {
 8003c24:	b500      	push	{lr}
 8003c26:	b081      	sub	sp, #4
	if (pcu_hal_open(baudrate) == 0)
 8003c28:	f002 f9e2 	bl	8005ff0 <pcu_hal_open>
 8003c2c:	3800      	subs	r0, #0
 8003c2e:	bf18      	it	ne
 8003c30:	2001      	movne	r0, #1
		return 0;

	return 1;
}
 8003c32:	b001      	add	sp, #4
 8003c34:	bd00      	pop	{pc}
 8003c36:	46c0      	nop			(mov r8, r8)

08003c38 <dxl_get_result>:
#endif
}

//##############################################################################
u16 dxl_get_result(void) {
	return gbCommStatus;
 8003c38:	4b01      	ldr	r3, [pc, #4]	(8003c40 <dxl_get_result+0x8>)
 8003c3a:	8818      	ldrh	r0, [r3, #0]
 8003c3c:	b280      	uxth	r0, r0
}
 8003c3e:	4770      	bx	lr
 8003c40:	20000000 	.word	0x20000000

08003c44 <dxl_set_txpacket_id>:

//##############################################################################
void dxl_set_txpacket_id(u8 id) {
	gbInstructionPacket[DXL_PKT_ID] = id;
 8003c44:	4b01      	ldr	r3, [pc, #4]	(8003c4c <dxl_set_txpacket_id+0x8>)
 8003c46:	7098      	strb	r0, [r3, #2]
}
 8003c48:	4770      	bx	lr
 8003c4a:	46c0      	nop			(mov r8, r8)
 8003c4c:	200008e4 	.word	0x200008e4

08003c50 <dxl_set_txpacket_instruction>:

//##############################################################################
void dxl_set_txpacket_instruction(u8 instruction) {
	gbInstructionPacket[DXL_PKT_INST] = instruction;
 8003c50:	4b01      	ldr	r3, [pc, #4]	(8003c58 <dxl_set_txpacket_instruction+0x8>)
 8003c52:	7118      	strb	r0, [r3, #4]
}
 8003c54:	4770      	bx	lr
 8003c56:	46c0      	nop			(mov r8, r8)
 8003c58:	200008e4 	.word	0x200008e4

08003c5c <dxl_set_txpacket_parameter>:

//##############################################################################
void dxl_set_txpacket_parameter(u8 index, u8 value) {
	gbInstructionPacket[DXL_PKT_PARA + index] = value;
 8003c5c:	4b01      	ldr	r3, [pc, #4]	(8003c64 <dxl_set_txpacket_parameter+0x8>)
 8003c5e:	181b      	adds	r3, r3, r0
 8003c60:	7159      	strb	r1, [r3, #5]
}
 8003c62:	4770      	bx	lr
 8003c64:	200008e4 	.word	0x200008e4

08003c68 <dxl_set_txpacket_length>:

//##############################################################################
void dxl_set_txpacket_length(u8 length) {
	gbInstructionPacket[DXL_PKT_LEN] = length;
 8003c68:	4b01      	ldr	r3, [pc, #4]	(8003c70 <dxl_set_txpacket_length+0x8>)
 8003c6a:	70d8      	strb	r0, [r3, #3]
}
 8003c6c:	4770      	bx	lr
 8003c6e:	46c0      	nop			(mov r8, r8)
 8003c70:	200008e4 	.word	0x200008e4

08003c74 <dxl_get_rxpacket_error>:

//##############################################################################
u8 dxl_get_rxpacket_error(u8 errbit) {
	if ((gbCommStatus & DXL_RXFAIL))
 8003c74:	4b06      	ldr	r3, [pc, #24]	(8003c90 <dxl_get_rxpacket_error+0x1c>)
 8003c76:	881b      	ldrh	r3, [r3, #0]
 8003c78:	f013 0f08 	tst.w	r3, #8	; 0x8
 8003c7c:	d001      	beq.n	8003c82 <dxl_get_rxpacket_error+0xe>
 8003c7e:	2080      	movs	r0, #128
 8003c80:	e005      	b.n	8003c8e <dxl_get_rxpacket_error+0x1a>
 8003c82:	4b04      	ldr	r3, [pc, #16]	(8003c94 <dxl_get_rxpacket_error+0x20>)
 8003c84:	791b      	ldrb	r3, [r3, #4]
 8003c86:	4218      	tst	r0, r3
 8003c88:	bf0c      	ite	eq
 8003c8a:	2000      	moveq	r0, #0
 8003c8c:	2001      	movne	r0, #1

	if (gbStatusPacket[DXL_PKT_ERR] & errbit)
		return 1;

	return 0;
}
 8003c8e:	4770      	bx	lr
 8003c90:	20000000 	.word	0x20000000
 8003c94:	20000984 	.word	0x20000984

08003c98 <dxl_get_rxpacket_length>:

//##############################################################################
u8 dxl_get_rxpacket_length(void) {
	if ((gbCommStatus & DXL_RXFAIL))
 8003c98:	4b04      	ldr	r3, [pc, #16]	(8003cac <dxl_get_rxpacket_length+0x14>)
 8003c9a:	881b      	ldrh	r3, [r3, #0]
 8003c9c:	f013 0f08 	tst.w	r3, #8	; 0x8
 8003ca0:	d001      	beq.n	8003ca6 <dxl_get_rxpacket_length+0xe>
 8003ca2:	2000      	movs	r0, #0
 8003ca4:	e001      	b.n	8003caa <dxl_get_rxpacket_length+0x12>
		return 0;

	return gbStatusPacket[DXL_PKT_LEN];
 8003ca6:	4b02      	ldr	r3, [pc, #8]	(8003cb0 <dxl_get_rxpacket_length+0x18>)
 8003ca8:	78d8      	ldrb	r0, [r3, #3]
}
 8003caa:	4770      	bx	lr
 8003cac:	20000000 	.word	0x20000000
 8003cb0:	20000984 	.word	0x20000984

08003cb4 <dxl_get_rxpacket_parameter>:

//##############################################################################
u8 dxl_get_rxpacket_parameter(u8 index) {
	if ((gbCommStatus & DXL_RXFAIL))
 8003cb4:	4b05      	ldr	r3, [pc, #20]	(8003ccc <dxl_get_rxpacket_parameter+0x18>)
 8003cb6:	881b      	ldrh	r3, [r3, #0]
 8003cb8:	f013 0f08 	tst.w	r3, #8	; 0x8
 8003cbc:	d001      	beq.n	8003cc2 <dxl_get_rxpacket_parameter+0xe>
 8003cbe:	2000      	movs	r0, #0
 8003cc0:	e002      	b.n	8003cc8 <dxl_get_rxpacket_parameter+0x14>
		return 0;

	return gbStatusPacket[DXL_PKT_PARA + index];
 8003cc2:	4b03      	ldr	r3, [pc, #12]	(8003cd0 <dxl_get_rxpacket_parameter+0x1c>)
 8003cc4:	181b      	adds	r3, r3, r0
 8003cc6:	7958      	ldrb	r0, [r3, #5]
}
 8003cc8:	4770      	bx	lr
 8003cca:	46c0      	nop			(mov r8, r8)
 8003ccc:	20000000 	.word	0x20000000
 8003cd0:	20000984 	.word	0x20000984

08003cd4 <dxl_makeword>:
//##############################################################################
u16 dxl_makeword(u8 lowbyte, u8 highbyte) {
	u16 word;

	word = highbyte;
	word = word << 8;
 8003cd4:	eb00 2001 	add.w	r0, r0, r1, lsl #8
 8003cd8:	b280      	uxth	r0, r0
	word = word + lowbyte;
	return word;
}
 8003cda:	4770      	bx	lr

08003cdc <dxl_get_lowbyte>:

//##############################################################################
u8 dxl_get_lowbyte(u16 word) {
 8003cdc:	b2c0      	uxtb	r0, r0
	u16 temp = (word & 0x00FF);
	return (u8) temp;
}
 8003cde:	4770      	bx	lr

08003ce0 <dxl_get_highbyte>:

//##############################################################################
u8 dxl_get_highbyte(u16 word) {
 8003ce0:	0a00      	lsrs	r0, r0, #8
	u16 temp = ((word & 0xFF00) >> 8);
	return (u8) temp;
}
 8003ce2:	4770      	bx	lr

08003ce4 <dxl_clear_statpkt>:
	return gbCommStatus;
}

//##############################################################################
void dxl_clear_statpkt(void) {
	u8 i, max = gbStatusPacket[DXL_PKT_LEN];
 8003ce4:	4a0c      	ldr	r2, [pc, #48]	(8003d18 <dxl_clear_statpkt+0x34>)
 8003ce6:	78d1      	ldrb	r1, [r2, #3]
	if ((max > 0) && (max < DXL_MAXNUM_RXPARAM)) {
 8003ce8:	1e4b      	subs	r3, r1, #1
 8003cea:	b2db      	uxtb	r3, r3
 8003cec:	2b4e      	cmp	r3, #78
 8003cee:	d80a      	bhi.n	8003d06 <dxl_clear_statpkt+0x22>
		for (i = 0; i < (max + 4); i++)
			gbStatusPacket[i] = 0;
 8003cf0:	4610      	mov	r0, r2
}

//##############################################################################
void dxl_clear_statpkt(void) {
	u8 i, max = gbStatusPacket[DXL_PKT_LEN];
	if ((max > 0) && (max < DXL_MAXNUM_RXPARAM)) {
 8003cf2:	2300      	movs	r3, #0
		for (i = 0; i < (max + 4); i++)
 8003cf4:	3103      	adds	r1, #3
			gbStatusPacket[i] = 0;
 8003cf6:	2200      	movs	r2, #0
 8003cf8:	e002      	b.n	8003d00 <dxl_clear_statpkt+0x1c>
 8003cfa:	54c2      	strb	r2, [r0, r3]

//##############################################################################
void dxl_clear_statpkt(void) {
	u8 i, max = gbStatusPacket[DXL_PKT_LEN];
	if ((max > 0) && (max < DXL_MAXNUM_RXPARAM)) {
		for (i = 0; i < (max + 4); i++)
 8003cfc:	3301      	adds	r3, #1
 8003cfe:	b2db      	uxtb	r3, r3
 8003d00:	4299      	cmp	r1, r3
 8003d02:	dafa      	bge.n	8003cfa <dxl_clear_statpkt+0x16>
 8003d04:	e006      	b.n	8003d14 <dxl_clear_statpkt+0x30>
			gbStatusPacket[i] = 0;
	} else {
		for (i = 0; i < 6; i++)
			gbStatusPacket[i] = 0;
 8003d06:	2300      	movs	r3, #0
 8003d08:	7013      	strb	r3, [r2, #0]
 8003d0a:	7053      	strb	r3, [r2, #1]
 8003d0c:	7093      	strb	r3, [r2, #2]
 8003d0e:	70d3      	strb	r3, [r2, #3]
 8003d10:	7113      	strb	r3, [r2, #4]
 8003d12:	7153      	strb	r3, [r2, #5]
	}
}
 8003d14:	4770      	bx	lr
 8003d16:	46c0      	nop			(mov r8, r8)
 8003d18:	20000984 	.word	0x20000984

08003d1c <dxl_rx_packet>:

	gbCommStatus = DXL_TXSUCCESS;
}

//##############################################################################
void dxl_rx_packet(void) {
 8003d1c:	b530      	push	{r4, r5, lr}
	u8 i, j, nRead;
	u8 checksum = 0;

	if (giBusUsing == 0)
 8003d1e:	495a      	ldr	r1, [pc, #360]	(8003e88 <dxl_rx_packet+0x16c>)

	gbCommStatus = DXL_TXSUCCESS;
}

//##############################################################################
void dxl_rx_packet(void) {
 8003d20:	b081      	sub	sp, #4
	u8 i, j, nRead;
	u8 checksum = 0;

	if (giBusUsing == 0)
 8003d22:	780b      	ldrb	r3, [r1, #0]
 8003d24:	2b00      	cmp	r3, #0
 8003d26:	f000 80ad 	beq.w	8003e84 <dxl_rx_packet+0x168>
		return;

	giBusUsing = 1;
 8003d2a:	2301      	movs	r3, #1
 8003d2c:	700b      	strb	r3, [r1, #0]

	if (gbInstructionPacket[DXL_PKT_ID] == BROADCAST_ID) {
 8003d2e:	4b57      	ldr	r3, [pc, #348]	(8003e8c <dxl_rx_packet+0x170>)
 8003d30:	4a57      	ldr	r2, [pc, #348]	(8003e90 <dxl_rx_packet+0x174>)
 8003d32:	789b      	ldrb	r3, [r3, #2]
 8003d34:	2bfe      	cmp	r3, #254
 8003d36:	f000 80a0 	beq.w	8003e7a <dxl_rx_packet+0x15e>
		gbCommStatus = DXL_RXSUCCESS;
		giBusUsing = 0;
		return;
	}

	if (gbCommStatus & DXL_TXSUCCESS) {
 8003d3a:	8813      	ldrh	r3, [r2, #0]
 8003d3c:	f013 0f01 	tst.w	r3, #1	; 0x1
 8003d40:	d005      	beq.n	8003d4e <dxl_rx_packet+0x32>
		gbRxGetLength = 0;
 8003d42:	4b54      	ldr	r3, [pc, #336]	(8003e94 <dxl_rx_packet+0x178>)
 8003d44:	2200      	movs	r2, #0
 8003d46:	701a      	strb	r2, [r3, #0]
		gbRxPacketLength = 6;
 8003d48:	4b53      	ldr	r3, [pc, #332]	(8003e98 <dxl_rx_packet+0x17c>)
 8003d4a:	2206      	movs	r2, #6
 8003d4c:	701a      	strb	r2, [r3, #0]
	}

	nRead = dxl_hal_rx((u8*) &gbStatusPacket[gbRxGetLength],
 8003d4e:	4d51      	ldr	r5, [pc, #324]	(8003e94 <dxl_rx_packet+0x178>)
 8003d50:	4c51      	ldr	r4, [pc, #324]	(8003e98 <dxl_rx_packet+0x17c>)
 8003d52:	782b      	ldrb	r3, [r5, #0]
 8003d54:	7821      	ldrb	r1, [r4, #0]
 8003d56:	4851      	ldr	r0, [pc, #324]	(8003e9c <dxl_rx_packet+0x180>)
 8003d58:	1ac9      	subs	r1, r1, r3
 8003d5a:	18c0      	adds	r0, r0, r3
 8003d5c:	b2c9      	uxtb	r1, r1
 8003d5e:	f002 f811 	bl	8005d84 <dxl_hal_rx>
			gbRxPacketLength - gbRxGetLength);

	gbRxGetLength += nRead;
 8003d62:	782b      	ldrb	r3, [r5, #0]
 8003d64:	18c0      	adds	r0, r0, r3
	if (gbRxGetLength < gbRxPacketLength) {
 8003d66:	7823      	ldrb	r3, [r4, #0]
	}

	nRead = dxl_hal_rx((u8*) &gbStatusPacket[gbRxGetLength],
			gbRxPacketLength - gbRxGetLength);

	gbRxGetLength += nRead;
 8003d68:	b2c0      	uxtb	r0, r0
	if (gbRxGetLength < gbRxPacketLength) {
 8003d6a:	4283      	cmp	r3, r0
	}

	nRead = dxl_hal_rx((u8*) &gbStatusPacket[gbRxGetLength],
			gbRxPacketLength - gbRxGetLength);

	gbRxGetLength += nRead;
 8003d6c:	7028      	strb	r0, [r5, #0]
	if (gbRxGetLength < gbRxPacketLength) {
 8003d6e:	d903      	bls.n	8003d78 <dxl_rx_packet+0x5c>
		if (dxl_hal_timeout() == 1) {
 8003d70:	f002 f836 	bl	8005de0 <dxl_hal_timeout>
 8003d74:	2801      	cmp	r0, #1
 8003d76:	d008      	beq.n	8003d8a <dxl_rx_packet+0x6e>
			return;
		}
	}

	// Find packet header
	for (i = 0; i < (gbRxGetLength - 1); i++) {
 8003d78:	4b46      	ldr	r3, [pc, #280]	(8003e94 <dxl_rx_packet+0x178>)
		if ((gbStatusPacket[i] == 0xFF) && (gbStatusPacket[i + 1] == 0xFF)) {
			break;
		} else if ((i == gbRxGetLength - 2)
 8003d7a:	2000      	movs	r0, #0
			return;
		}
	}

	// Find packet header
	for (i = 0; i < (gbRxGetLength - 1); i++) {
 8003d7c:	781a      	ldrb	r2, [r3, #0]
		if ((gbStatusPacket[i] == 0xFF) && (gbStatusPacket[i + 1] == 0xFF)) {
 8003d7e:	4947      	ldr	r1, [pc, #284]	(8003e9c <dxl_rx_packet+0x180>)
			return;
		}
	}

	// Find packet header
	for (i = 0; i < (gbRxGetLength - 1); i++) {
 8003d80:	f102 3cff 	add.w	ip, r2, #4294967295	; 0xffffffff
		if ((gbStatusPacket[i] == 0xFF) && (gbStatusPacket[i + 1] == 0xFF)) {
			break;
		} else if ((i == gbRxGetLength - 2)
 8003d84:	f1a2 0e02 	sub.w	lr, r2, #2	; 0x2
 8003d88:	e019      	b.n	8003dbe <dxl_rx_packet+0xa2>
			gbRxPacketLength - gbRxGetLength);

	gbRxGetLength += nRead;
	if (gbRxGetLength < gbRxPacketLength) {
		if (dxl_hal_timeout() == 1) {
			if (gbRxGetLength == 0)
 8003d8a:	782b      	ldrb	r3, [r5, #0]
 8003d8c:	4a40      	ldr	r2, [pc, #256]	(8003e90 <dxl_rx_packet+0x174>)
 8003d8e:	b913      	cbnz	r3, 8003d96 <dxl_rx_packet+0x7a>
				gbCommStatus = DXL_RXTIMEOUT;
 8003d90:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003d94:	e001      	b.n	8003d9a <dxl_rx_packet+0x7e>
			else
				gbCommStatus = DXL_RXLENGTH;
 8003d96:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003d9a:	8013      	strh	r3, [r2, #0]
 8003d9c:	e035      	b.n	8003e0a <dxl_rx_packet+0xee>
		}
	}

	// Find packet header
	for (i = 0; i < (gbRxGetLength - 1); i++) {
		if ((gbStatusPacket[i] == 0xFF) && (gbStatusPacket[i + 1] == 0xFF)) {
 8003d9e:	5c0b      	ldrb	r3, [r1, r0]
 8003da0:	2bff      	cmp	r3, #255
 8003da2:	d104      	bne.n	8003dae <dxl_rx_packet+0x92>
 8003da4:	eb01 0300 	add.w	r3, r1, r0
 8003da8:	785b      	ldrb	r3, [r3, #1]
 8003daa:	2bff      	cmp	r3, #255
 8003dac:	d009      	beq.n	8003dc2 <dxl_rx_packet+0xa6>
			break;
		} else if ((i == gbRxGetLength - 2)
 8003dae:	4570      	cmp	r0, lr
 8003db0:	d103      	bne.n	8003dba <dxl_rx_packet+0x9e>
 8003db2:	f811 300c 	ldrb.w	r3, [r1, ip]
 8003db6:	2bff      	cmp	r3, #255
 8003db8:	d003      	beq.n	8003dc2 <dxl_rx_packet+0xa6>
			return;
		}
	}

	// Find packet header
	for (i = 0; i < (gbRxGetLength - 1); i++) {
 8003dba:	1c43      	adds	r3, r0, #1
 8003dbc:	b2d8      	uxtb	r0, r3
 8003dbe:	4560      	cmp	r0, ip
 8003dc0:	dbed      	blt.n	8003d9e <dxl_rx_packet+0x82>
		} else if ((i == gbRxGetLength - 2)
				&& (gbStatusPacket[gbRxGetLength - 1] == 0xFF)) {
			break;
		}
	}
	if (i > 0) {
 8003dc2:	b188      	cbz	r0, 8003de8 <dxl_rx_packet+0xcc>
 8003dc4:	2100      	movs	r1, #0
		for (j = 0; j < (gbRxGetLength - i); j++)
 8003dc6:	ebc0 0c02 	rsb	ip, r0, r2
			gbStatusPacket[j] = gbStatusPacket[j + i];
 8003dca:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 8003e9c <dxl_rx_packet+0x180>
 8003dce:	e006      	b.n	8003dde <dxl_rx_packet+0xc2>
 8003dd0:	eb0e 0301 	add.w	r3, lr, r1
 8003dd4:	5c1b      	ldrb	r3, [r3, r0]
 8003dd6:	f80e 3001 	strb.w	r3, [lr, r1]
				&& (gbStatusPacket[gbRxGetLength - 1] == 0xFF)) {
			break;
		}
	}
	if (i > 0) {
		for (j = 0; j < (gbRxGetLength - i); j++)
 8003dda:	1c4b      	adds	r3, r1, #1
 8003ddc:	b2d9      	uxtb	r1, r3
 8003dde:	4561      	cmp	r1, ip
 8003de0:	dbf6      	blt.n	8003dd0 <dxl_rx_packet+0xb4>
			gbStatusPacket[j] = gbStatusPacket[j + i];

		gbRxGetLength -= i;
 8003de2:	4b2c      	ldr	r3, [pc, #176]	(8003e94 <dxl_rx_packet+0x178>)
 8003de4:	1a12      	subs	r2, r2, r0
 8003de6:	701a      	strb	r2, [r3, #0]
	}

	// Check if received full packet
	if (gbRxGetLength < gbRxPacketLength) {
 8003de8:	4d2a      	ldr	r5, [pc, #168]	(8003e94 <dxl_rx_packet+0x178>)
 8003dea:	4c2b      	ldr	r4, [pc, #172]	(8003e98 <dxl_rx_packet+0x17c>)
 8003dec:	f895 c000 	ldrb.w	ip, [r5]
 8003df0:	7823      	ldrb	r3, [r4, #0]
 8003df2:	4563      	cmp	r3, ip
 8003df4:	d826      	bhi.n	8003e44 <dxl_rx_packet+0x128>
		gbCommStatus = DXL_RXWAITING;
		return;
	}

	// Check id pairing
	if (gbInstructionPacket[DXL_PKT_ID] != gbStatusPacket[DXL_PKT_ID]) {
 8003df6:	4b25      	ldr	r3, [pc, #148]	(8003e8c <dxl_rx_packet+0x170>)
 8003df8:	4828      	ldr	r0, [pc, #160]	(8003e9c <dxl_rx_packet+0x180>)
 8003dfa:	789a      	ldrb	r2, [r3, #2]
 8003dfc:	7883      	ldrb	r3, [r0, #2]
 8003dfe:	429a      	cmp	r2, r3
 8003e00:	d007      	beq.n	8003e12 <dxl_rx_packet+0xf6>
		gbCommStatus = DXL_BAD_ID | DXL_RXFAIL;
 8003e02:	4b23      	ldr	r3, [pc, #140]	(8003e90 <dxl_rx_packet+0x174>)
 8003e04:	f04f 0248 	mov.w	r2, #72	; 0x48
 8003e08:	801a      	strh	r2, [r3, #0]
		giBusUsing = 0;
 8003e0a:	4b1f      	ldr	r3, [pc, #124]	(8003e88 <dxl_rx_packet+0x16c>)
 8003e0c:	2200      	movs	r2, #0
 8003e0e:	701a      	strb	r2, [r3, #0]
 8003e10:	e038      	b.n	8003e84 <dxl_rx_packet+0x168>
		return;
	}

	gbRxPacketLength = gbStatusPacket[DXL_PKT_LEN] + 4;
 8003e12:	78c3      	ldrb	r3, [r0, #3]
 8003e14:	3304      	adds	r3, #4
 8003e16:	b2d9      	uxtb	r1, r3
	if (gbRxGetLength < gbRxPacketLength) {
 8003e18:	458c      	cmp	ip, r1
		gbCommStatus = DXL_BAD_ID | DXL_RXFAIL;
		giBusUsing = 0;
		return;
	}

	gbRxPacketLength = gbStatusPacket[DXL_PKT_LEN] + 4;
 8003e1a:	7021      	strb	r1, [r4, #0]
	if (gbRxGetLength < gbRxPacketLength) {
 8003e1c:	d20c      	bcs.n	8003e38 <dxl_rx_packet+0x11c>
		nRead = dxl_hal_rx((u8*) &gbStatusPacket[gbRxGetLength],
 8003e1e:	ebcc 0101 	rsb	r1, ip, r1
 8003e22:	4460      	add	r0, ip
 8003e24:	b2c9      	uxtb	r1, r1
 8003e26:	f001 ffad 	bl	8005d84 <dxl_hal_rx>
				gbRxPacketLength - gbRxGetLength);
		gbRxGetLength += nRead;
 8003e2a:	782b      	ldrb	r3, [r5, #0]
 8003e2c:	18c0      	adds	r0, r0, r3
		if (gbRxGetLength < gbRxPacketLength) {
 8003e2e:	7823      	ldrb	r3, [r4, #0]

	gbRxPacketLength = gbStatusPacket[DXL_PKT_LEN] + 4;
	if (gbRxGetLength < gbRxPacketLength) {
		nRead = dxl_hal_rx((u8*) &gbStatusPacket[gbRxGetLength],
				gbRxPacketLength - gbRxGetLength);
		gbRxGetLength += nRead;
 8003e30:	b2c0      	uxtb	r0, r0
		if (gbRxGetLength < gbRxPacketLength) {
 8003e32:	4283      	cmp	r3, r0

	gbRxPacketLength = gbStatusPacket[DXL_PKT_LEN] + 4;
	if (gbRxGetLength < gbRxPacketLength) {
		nRead = dxl_hal_rx((u8*) &gbStatusPacket[gbRxGetLength],
				gbRxPacketLength - gbRxGetLength);
		gbRxGetLength += nRead;
 8003e34:	7028      	strb	r0, [r5, #0]
		if (gbRxGetLength < gbRxPacketLength) {
 8003e36:	d805      	bhi.n	8003e44 <dxl_rx_packet+0x128>
			return;
		}
	}

	// Check checksum
	for (i = 0; i < (gbStatusPacket[DXL_PKT_LEN] + 1); i++)
 8003e38:	4b18      	ldr	r3, [pc, #96]	(8003e9c <dxl_rx_packet+0x180>)
 8003e3a:	2100      	movs	r1, #0
 8003e3c:	78d8      	ldrb	r0, [r3, #3]
 8003e3e:	2200      	movs	r2, #0
 8003e40:	469c      	mov	ip, r3
 8003e42:	e00b      	b.n	8003e5c <dxl_rx_packet+0x140>
	if (gbRxGetLength < gbRxPacketLength) {
		nRead = dxl_hal_rx((u8*) &gbStatusPacket[gbRxGetLength],
				gbRxPacketLength - gbRxGetLength);
		gbRxGetLength += nRead;
		if (gbRxGetLength < gbRxPacketLength) {
			gbCommStatus = DXL_RXWAITING;
 8003e44:	4b12      	ldr	r3, [pc, #72]	(8003e90 <dxl_rx_packet+0x174>)
 8003e46:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003e4a:	801a      	strh	r2, [r3, #0]
 8003e4c:	e01a      	b.n	8003e84 <dxl_rx_packet+0x168>
		}
	}

	// Check checksum
	for (i = 0; i < (gbStatusPacket[DXL_PKT_LEN] + 1); i++)
		checksum += gbStatusPacket[i + 2];
 8003e4e:	eb0c 0301 	add.w	r3, ip, r1
 8003e52:	789b      	ldrb	r3, [r3, #2]
 8003e54:	4413      	add	r3, r2
 8003e56:	b2da      	uxtb	r2, r3
			return;
		}
	}

	// Check checksum
	for (i = 0; i < (gbStatusPacket[DXL_PKT_LEN] + 1); i++)
 8003e58:	1c4b      	adds	r3, r1, #1
 8003e5a:	b2d9      	uxtb	r1, r3
 8003e5c:	4288      	cmp	r0, r1
 8003e5e:	daf6      	bge.n	8003e4e <dxl_rx_packet+0x132>
		checksum += gbStatusPacket[i + 2];
	checksum = ~checksum;

	if (gbStatusPacket[gbStatusPacket[DXL_PKT_LEN] + 3] != checksum) {
 8003e60:	4b0e      	ldr	r3, [pc, #56]	(8003e9c <dxl_rx_packet+0x180>)
 8003e62:	ea6f 0202 	mvn.w	r2, r2
 8003e66:	181b      	adds	r3, r3, r0
 8003e68:	78db      	ldrb	r3, [r3, #3]
 8003e6a:	b2d2      	uxtb	r2, r2
 8003e6c:	4293      	cmp	r3, r2
 8003e6e:	4906      	ldr	r1, [pc, #24]	(8003e88 <dxl_rx_packet+0x16c>)
 8003e70:	4a07      	ldr	r2, [pc, #28]	(8003e90 <dxl_rx_packet+0x174>)
		gbCommStatus = DXL_RXCHECKSUM | DXL_RXFAIL;
 8003e72:	bf18      	it	ne
 8003e74:	f241 0308 	movwne	r3, #4104	; 0x1008
	// Check checksum
	for (i = 0; i < (gbStatusPacket[DXL_PKT_LEN] + 1); i++)
		checksum += gbStatusPacket[i + 2];
	checksum = ~checksum;

	if (gbStatusPacket[gbStatusPacket[DXL_PKT_LEN] + 3] != checksum) {
 8003e78:	d101      	bne.n	8003e7e <dxl_rx_packet+0x162>
		gbCommStatus = DXL_RXCHECKSUM | DXL_RXFAIL;
		giBusUsing = 0;
		return;
	}

	gbCommStatus = DXL_RXSUCCESS;
 8003e7a:	f04f 0302 	mov.w	r3, #2	; 0x2
 8003e7e:	8013      	strh	r3, [r2, #0]
	giBusUsing = 0;
 8003e80:	2300      	movs	r3, #0
 8003e82:	700b      	strb	r3, [r1, #0]
}
 8003e84:	b001      	add	sp, #4
 8003e86:	bd30      	pop	{r4, r5, pc}
 8003e88:	200009d6 	.word	0x200009d6
 8003e8c:	200008e4 	.word	0x200008e4
 8003e90:	20000000 	.word	0x20000000
 8003e94:	200009d5 	.word	0x200009d5
 8003e98:	200009d4 	.word	0x200009d4
 8003e9c:	20000984 	.word	0x20000984

08003ea0 <dxl_tx_packet>:
void dxl_terminate(void) {
	dxl_hal_close();
}

//##############################################################################
void dxl_tx_packet(void) {
 8003ea0:	b530      	push	{r4, r5, lr}
	u8 i;
	u8 TxNumByte, RealTxNumByte;
	u8 checksum = 0;

	if (giBusUsing == 1)
 8003ea2:	f8df c0ec 	ldr.w	ip, [pc, #236]	; 8003f90 <dxl_tx_packet+0xf0>
void dxl_terminate(void) {
	dxl_hal_close();
}

//##############################################################################
void dxl_tx_packet(void) {
 8003ea6:	b081      	sub	sp, #4
	u8 i;
	u8 TxNumByte, RealTxNumByte;
	u8 checksum = 0;

	if (giBusUsing == 1)
 8003ea8:	f89c 3000 	ldrb.w	r3, [ip]
 8003eac:	2b01      	cmp	r3, #1
 8003eae:	d06c      	beq.n	8003f8a <dxl_tx_packet+0xea>
		return;

	giBusUsing = 1;

	gbCommStatus = 0;
 8003eb0:	4838      	ldr	r0, [pc, #224]	(8003f94 <dxl_tx_packet+0xf4>)
	u8 checksum = 0;

	if (giBusUsing == 1)
		return;

	giBusUsing = 1;
 8003eb2:	2301      	movs	r3, #1

	gbCommStatus = 0;
 8003eb4:	f04f 0200 	mov.w	r2, #0	; 0x0
	u8 checksum = 0;

	if (giBusUsing == 1)
		return;

	giBusUsing = 1;
 8003eb8:	f88c 3000 	strb.w	r3, [ip]

	gbCommStatus = 0;
 8003ebc:	8002      	strh	r2, [r0, #0]

	if (gbInstructionPacket[DXL_PKT_LEN] > (DXL_MAXNUM_TXPARAM + 2)) {
 8003ebe:	4a36      	ldr	r2, [pc, #216]	(8003f98 <dxl_tx_packet+0xf8>)
	if (giBusUsing == 1)
		return;

	giBusUsing = 1;

	gbCommStatus = 0;
 8003ec0:	2400      	movs	r4, #0

	if (gbInstructionPacket[DXL_PKT_LEN] > (DXL_MAXNUM_TXPARAM + 2)) {
 8003ec2:	78d3      	ldrb	r3, [r2, #3]
 8003ec4:	2ba2      	cmp	r3, #162
 8003ec6:	d904      	bls.n	8003ed2 <dxl_tx_packet+0x32>
		gbCommStatus |= DXL_TXERROR;
 8003ec8:	8803      	ldrh	r3, [r0, #0]
 8003eca:	b29b      	uxth	r3, r3
 8003ecc:	f043 0310 	orr.w	r3, r3, #16	; 0x10
 8003ed0:	e012      	b.n	8003ef8 <dxl_tx_packet+0x58>
		giBusUsing = 0;
		return;
	}

	if ((gbInstructionPacket[DXL_PKT_INST] != INST_PING)
 8003ed2:	7911      	ldrb	r1, [r2, #4]
 8003ed4:	1e4a      	subs	r2, r1, #1
 8003ed6:	b2d2      	uxtb	r2, r2
 8003ed8:	f1b1 0383 	subs.w	r3, r1, #131	; 0x83
 8003edc:	bf18      	it	ne
 8003ede:	2301      	movne	r3, #1
 8003ee0:	2a05      	cmp	r2, #5
 8003ee2:	bf94      	ite	ls
 8003ee4:	2300      	movls	r3, #0
 8003ee6:	f003 0301 	andhi.w	r3, r3, #1	; 0x1
 8003eea:	b14b      	cbz	r3, 8003f00 <dxl_tx_packet+0x60>
 8003eec:	290e      	cmp	r1, #14
 8003eee:	d007      	beq.n	8003f00 <dxl_tx_packet+0x60>
			&& (gbInstructionPacket[DXL_PKT_INST] != INST_REG_WRITE)
			&& (gbInstructionPacket[DXL_PKT_INST] != INST_ACTION)
			&& (gbInstructionPacket[DXL_PKT_INST] != INST_RESET)
			&& (gbInstructionPacket[DXL_PKT_INST] != INST_SYNC_WRITE)
			&& (gbInstructionPacket[DXL_PKT_INST] != INST_CAP_REGION)) {
		gbCommStatus |= DXL_BAD_INST;
 8003ef0:	8803      	ldrh	r3, [r0, #0]
 8003ef2:	b29b      	uxth	r3, r3
 8003ef4:	f043 0320 	orr.w	r3, r3, #32	; 0x20
 8003ef8:	8003      	strh	r3, [r0, #0]
		giBusUsing = 0;
 8003efa:	f88c 4000 	strb.w	r4, [ip]
 8003efe:	e044      	b.n	8003f8a <dxl_tx_packet+0xea>
		return;
	}

	gbInstructionPacket[0] = 0xFF;
 8003f00:	4a25      	ldr	r2, [pc, #148]	(8003f98 <dxl_tx_packet+0xf8>)
 8003f02:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003f06:	7013      	strb	r3, [r2, #0]
	gbInstructionPacket[1] = 0xFF;
 8003f08:	7053      	strb	r3, [r2, #1]
	for (i = 0; i < (gbInstructionPacket[DXL_PKT_LEN] + 1); i++)
 8003f0a:	f892 c003 	ldrb.w	ip, [r2, #3]
 8003f0e:	2100      	movs	r1, #0
 8003f10:	2000      	movs	r0, #0
 8003f12:	e006      	b.n	8003f22 <dxl_tx_packet+0x82>
		checksum += gbInstructionPacket[i + 2];
 8003f14:	eb02 0301 	add.w	r3, r2, r1
 8003f18:	789b      	ldrb	r3, [r3, #2]
 8003f1a:	4403      	add	r3, r0
 8003f1c:	b2d8      	uxtb	r0, r3
		return;
	}

	gbInstructionPacket[0] = 0xFF;
	gbInstructionPacket[1] = 0xFF;
	for (i = 0; i < (gbInstructionPacket[DXL_PKT_LEN] + 1); i++)
 8003f1e:	1c4b      	adds	r3, r1, #1
 8003f20:	b2d9      	uxtb	r1, r3
 8003f22:	458c      	cmp	ip, r1
 8003f24:	daf6      	bge.n	8003f14 <dxl_tx_packet+0x74>
		checksum += gbInstructionPacket[i + 2];
	gbInstructionPacket[gbInstructionPacket[DXL_PKT_LEN] + 3] = ~checksum;
 8003f26:	4b1c      	ldr	r3, [pc, #112]	(8003f98 <dxl_tx_packet+0xf8>)
 8003f28:	ea6f 0200 	mvn.w	r2, r0
 8003f2c:	4463      	add	r3, ip
 8003f2e:	70da      	strb	r2, [r3, #3]

	if (gbCommStatus
 8003f30:	4b18      	ldr	r3, [pc, #96]	(8003f94 <dxl_tx_packet+0xf4>)
 8003f32:	881b      	ldrh	r3, [r3, #0]
 8003f34:	f423 7364 	bic.w	r3, r3, #912	; 0x390
 8003f38:	f023 0307 	bic.w	r3, r3, #7	; 0x7
 8003f3c:	04db      	lsls	r3, r3, #19
 8003f3e:	0cdb      	lsrs	r3, r3, #19
 8003f40:	b10b      	cbz	r3, 8003f46 <dxl_tx_packet+0xa6>
			& (DXL_RXFAIL | DXL_RXTIMEOUT | DXL_RXCHECKSUM | DXL_RXLENGTH
					| DXL_BAD_INST | DXL_BAD_ID)) {
		dxl_hal_clear();
 8003f42:	f001 ff09 	bl	8005d58 <dxl_hal_clear>
	}

	TxNumByte = gbInstructionPacket[DXL_PKT_LEN] + 4;
 8003f46:	4d14      	ldr	r5, [pc, #80]	(8003f98 <dxl_tx_packet+0xf8>)
 8003f48:	78ec      	ldrb	r4, [r5, #3]
	RealTxNumByte = dxl_hal_tx((u8*) gbInstructionPacket, TxNumByte);
 8003f4a:	4628      	mov	r0, r5
			& (DXL_RXFAIL | DXL_RXTIMEOUT | DXL_RXCHECKSUM | DXL_RXLENGTH
					| DXL_BAD_INST | DXL_BAD_ID)) {
		dxl_hal_clear();
	}

	TxNumByte = gbInstructionPacket[DXL_PKT_LEN] + 4;
 8003f4c:	3404      	adds	r4, #4
 8003f4e:	b2e4      	uxtb	r4, r4
	RealTxNumByte = dxl_hal_tx((u8*) gbInstructionPacket, TxNumByte);
 8003f50:	4621      	mov	r1, r4
 8003f52:	f001 ff95 	bl	8005e80 <dxl_hal_tx>

	if (TxNumByte != RealTxNumByte) {
 8003f56:	4284      	cmp	r4, r0
 8003f58:	d009      	beq.n	8003f6e <dxl_tx_packet+0xce>
		gbCommStatus |= DXL_TXFAIL;
 8003f5a:	4a0e      	ldr	r2, [pc, #56]	(8003f94 <dxl_tx_packet+0xf4>)
 8003f5c:	8813      	ldrh	r3, [r2, #0]
 8003f5e:	b29b      	uxth	r3, r3
 8003f60:	f043 0304 	orr.w	r3, r3, #4	; 0x4
 8003f64:	8013      	strh	r3, [r2, #0]
		giBusUsing = 0;
 8003f66:	4b0a      	ldr	r3, [pc, #40]	(8003f90 <dxl_tx_packet+0xf0>)
 8003f68:	2200      	movs	r2, #0
 8003f6a:	701a      	strb	r2, [r3, #0]
 8003f6c:	e00d      	b.n	8003f8a <dxl_tx_packet+0xea>
		return;
	}

	if (gbInstructionPacket[DXL_PKT_INST] == INST_READ_DATA)
 8003f6e:	792b      	ldrb	r3, [r5, #4]
 8003f70:	2b02      	cmp	r3, #2
 8003f72:	d103      	bne.n	8003f7c <dxl_tx_packet+0xdc>
		dxl_hal_set_timeout(gbInstructionPacket[DXL_PKT_PARA + 1] + 6);
 8003f74:	79a8      	ldrb	r0, [r5, #6]
 8003f76:	3006      	adds	r0, #6
 8003f78:	b2c0      	uxtb	r0, r0
 8003f7a:	e000      	b.n	8003f7e <dxl_tx_packet+0xde>
	else
		dxl_hal_set_timeout(6);
 8003f7c:	2006      	movs	r0, #6
 8003f7e:	f001 ff75 	bl	8005e6c <dxl_hal_set_timeout>

	gbCommStatus = DXL_TXSUCCESS;
 8003f82:	4b04      	ldr	r3, [pc, #16]	(8003f94 <dxl_tx_packet+0xf4>)
 8003f84:	f04f 0201 	mov.w	r2, #1	; 0x1
 8003f88:	801a      	strh	r2, [r3, #0]
}
 8003f8a:	b001      	add	sp, #4
 8003f8c:	bd30      	pop	{r4, r5, pc}
 8003f8e:	46c0      	nop			(mov r8, r8)
 8003f90:	200009d6 	.word	0x200009d6
 8003f94:	20000000 	.word	0x20000000
 8003f98:	200008e4 	.word	0x200008e4

08003f9c <dxl_txrx_packet>:
	gbCommStatus = DXL_RXSUCCESS;
	giBusUsing = 0;
}

//##############################################################################
void dxl_txrx_packet(void) {
 8003f9c:	b510      	push	{r4, lr}

	dxl_tx_packet();
 8003f9e:	f7ff ff7f 	bl	8003ea0 <dxl_tx_packet>

	if (!(gbCommStatus & DXL_TXSUCCESS))
 8003fa2:	4b14      	ldr	r3, [pc, #80]	(8003ff4 <dxl_txrx_packet+0x58>)
 8003fa4:	881b      	ldrh	r3, [r3, #0]
 8003fa6:	f013 0f01 	tst.w	r3, #1	; 0x1
 8003faa:	d021      	beq.n	8003ff0 <dxl_txrx_packet+0x54>
	return gbCommStatus;
}

//##############################################################################
void dxl_clear_statpkt(void) {
	u8 i, max = gbStatusPacket[DXL_PKT_LEN];
 8003fac:	4a12      	ldr	r2, [pc, #72]	(8003ff8 <dxl_txrx_packet+0x5c>)
 8003fae:	78d1      	ldrb	r1, [r2, #3]
	if ((max > 0) && (max < DXL_MAXNUM_RXPARAM)) {
 8003fb0:	1e4b      	subs	r3, r1, #1
 8003fb2:	b2db      	uxtb	r3, r3
 8003fb4:	2b4e      	cmp	r3, #78
 8003fb6:	d80a      	bhi.n	8003fce <dxl_txrx_packet+0x32>
		for (i = 0; i < (max + 4); i++)
			gbStatusPacket[i] = 0;
 8003fb8:	4610      	mov	r0, r2
}

//##############################################################################
void dxl_clear_statpkt(void) {
	u8 i, max = gbStatusPacket[DXL_PKT_LEN];
	if ((max > 0) && (max < DXL_MAXNUM_RXPARAM)) {
 8003fba:	2300      	movs	r3, #0
		for (i = 0; i < (max + 4); i++)
 8003fbc:	3103      	adds	r1, #3
			gbStatusPacket[i] = 0;
 8003fbe:	2200      	movs	r2, #0
 8003fc0:	e002      	b.n	8003fc8 <dxl_txrx_packet+0x2c>
 8003fc2:	54c2      	strb	r2, [r0, r3]

//##############################################################################
void dxl_clear_statpkt(void) {
	u8 i, max = gbStatusPacket[DXL_PKT_LEN];
	if ((max > 0) && (max < DXL_MAXNUM_RXPARAM)) {
		for (i = 0; i < (max + 4); i++)
 8003fc4:	3301      	adds	r3, #1
 8003fc6:	b2db      	uxtb	r3, r3
 8003fc8:	4299      	cmp	r1, r3
 8003fca:	dafa      	bge.n	8003fc2 <dxl_txrx_packet+0x26>
 8003fcc:	e006      	b.n	8003fdc <dxl_txrx_packet+0x40>
			gbStatusPacket[i] = 0;
	} else {
		for (i = 0; i < 6; i++)
			gbStatusPacket[i] = 0;
 8003fce:	2300      	movs	r3, #0
 8003fd0:	7013      	strb	r3, [r2, #0]
 8003fd2:	7053      	strb	r3, [r2, #1]
 8003fd4:	7093      	strb	r3, [r2, #2]
 8003fd6:	70d3      	strb	r3, [r2, #3]
 8003fd8:	7113      	strb	r3, [r2, #4]
 8003fda:	7153      	strb	r3, [r2, #5]

	dxl_clear_statpkt();
	do {
		dxl_rx_packet();
		uDelay(50);
	} while (gbCommStatus & DXL_RXWAITING);
 8003fdc:	4c05      	ldr	r4, [pc, #20]	(8003ff4 <dxl_txrx_packet+0x58>)
		PrintString("\n");
#endif

	dxl_clear_statpkt();
	do {
		dxl_rx_packet();
 8003fde:	f7ff fe9d 	bl	8003d1c <dxl_rx_packet>
		uDelay(50);
 8003fe2:	2032      	movs	r0, #50
 8003fe4:	f001 fab0 	bl	8005548 <uDelay>
	} while (gbCommStatus & DXL_RXWAITING);
 8003fe8:	8823      	ldrh	r3, [r4, #0]
 8003fea:	f413 7f00 	tst.w	r3, #512	; 0x200
 8003fee:	d1f6      	bne.n	8003fde <dxl_txrx_packet+0x42>
		PrintString("Dynamixel  --- dxl_txrx_packet ---\n");
		PrintString("RX Comm Status\n");
		TxD_Dec_U16(gbCommStatus);
		PrintString("\n");
#endif
}
 8003ff0:	bd10      	pop	{r4, pc}
 8003ff2:	46c0      	nop			(mov r8, r8)
 8003ff4:	20000000 	.word	0x20000000
 8003ff8:	20000984 	.word	0x20000984

08003ffc <dxl_set_goal_speed>:

	dxl_write_byte(id, 0, 0);
}
//################################################################################
void dxl_set_goal_speed( int NUM_ACTUATOR, const uint8 ids[], uint16 goal[], uint16 speed[] )
{
 8003ffc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003ffe:	4616      	mov	r6, r2
	int i = 0;

	// wait for the bus to be free
	while(giBusUsing);
 8004000:	4a26      	ldr	r2, [pc, #152]	(800409c <dxl_set_goal_speed+0xa0>)

	dxl_write_byte(id, 0, 0);
}
//################################################################################
void dxl_set_goal_speed( int NUM_ACTUATOR, const uint8 ids[], uint16 goal[], uint16 speed[] )
{
 8004002:	b081      	sub	sp, #4
 8004004:	460f      	mov	r7, r1
 8004006:	461d      	mov	r5, r3
	int i = 0;

	// wait for the bus to be free
	while(giBusUsing);
 8004008:	7813      	ldrb	r3, [r2, #0]
 800400a:	2b00      	cmp	r3, #0
 800400c:	d1fc      	bne.n	8004008 <dxl_set_goal_speed+0xc>

	// check how many actuators are to be broadcast to
	if (NUM_ACTUATOR == 0) {
 800400e:	2800      	cmp	r0, #0
 8004010:	d041      	beq.n	8004096 <dxl_set_goal_speed+0x9a>
	return gbCommStatus;
}

//##############################################################################
void dxl_set_txpacket_id(u8 id) {
	gbInstructionPacket[DXL_PKT_ID] = id;
 8004012:	4a23      	ldr	r2, [pc, #140]	(80040a0 <dxl_set_goal_speed+0xa4>)
 8004014:	3b02      	subs	r3, #2
 8004016:	7093      	strb	r3, [r2, #2]
}

//##############################################################################
void dxl_set_txpacket_instruction(u8 instruction) {
	gbInstructionPacket[DXL_PKT_INST] = instruction;
 8004018:	3b7b      	subs	r3, #123
 800401a:	7113      	strb	r3, [r2, #4]
}

//##############################################################################
void dxl_set_txpacket_parameter(u8 index, u8 value) {
	gbInstructionPacket[DXL_PKT_PARA + index] = value;
 800401c:	231e      	movs	r3, #30
 800401e:	7153      	strb	r3, [r2, #5]
	// Starting address where to write to
	dxl_set_txpacket_parameter(0, DXL_GOAL_POSITION_L);
	// Length of data to be written (2 words = 4 bytes)
	dxl_set_txpacket_parameter(1, 4);
	// Loop over the active Dynamixel id's
	for( i=0; i<NUM_ACTUATOR; i++ )
 8004020:	2304      	movs	r3, #4
 8004022:	7193      	strb	r3, [r2, #6]
 8004024:	2100      	movs	r1, #0
 8004026:	f04f 0c00 	mov.w	ip, #0	; 0x0
 800402a:	f04f 0e00 	mov.w	lr, #0	; 0x0
 800402e:	4614      	mov	r4, r2
 8004030:	e024      	b.n	800407c <dxl_set_goal_speed+0x80>
 8004032:	f1ac 0303 	sub.w	r3, ip, #3	; 0x3
 8004036:	5c7a      	ldrb	r2, [r7, r1]
 8004038:	b2db      	uxtb	r3, r3
 800403a:	4423      	add	r3, r4
 800403c:	715a      	strb	r2, [r3, #5]
	gbInstructionPacket[DXL_PKT_INST] = instruction;
}

//##############################################################################
void dxl_set_txpacket_parameter(u8 index, u8 value) {
	gbInstructionPacket[DXL_PKT_PARA + index] = value;
 800403e:	f1ac 0302 	sub.w	r3, ip, #2	; 0x2
 8004042:	f816 200e 	ldrb.w	r2, [r6, lr]
 8004046:	b2db      	uxtb	r3, r3
 8004048:	4423      	add	r3, r4
 800404a:	715a      	strb	r2, [r3, #5]
	{
		// retrieve the id and value for each actuator and add to packet
		dxl_set_txpacket_parameter(2+5*i, ids[i]);
		dxl_set_txpacket_parameter(2+5*i+1, dxl_get_lowbyte(goal[i]));
		dxl_set_txpacket_parameter(2+5*i+2, dxl_get_highbyte(goal[i]));
		dxl_set_txpacket_parameter(2+5*i+3, dxl_get_lowbyte(speed[i]));
 800404c:	f836 300e 	ldrh.w	r3, [r6, lr]
 8004050:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
 8004054:	b2d2      	uxtb	r2, r2
 8004056:	4422      	add	r2, r4
 8004058:	0a1b      	lsrs	r3, r3, #8
 800405a:	7153      	strb	r3, [r2, #5]
 800405c:	f815 300e 	ldrb.w	r3, [r5, lr]
 8004060:	eb04 020c 	add.w	r2, r4, ip
 8004064:	7153      	strb	r3, [r2, #5]
 8004066:	f835 300e 	ldrh.w	r3, [r5, lr]
 800406a:	f10c 0201 	add.w	r2, ip, #1	; 0x1
 800406e:	b2d2      	uxtb	r2, r2
 8004070:	4422      	add	r2, r4
 8004072:	0a1b      	lsrs	r3, r3, #8
 8004074:	3101      	adds	r1, #1
	gbInstructionPacket[DXL_PKT_INST] = instruction;
}

//##############################################################################
void dxl_set_txpacket_parameter(u8 index, u8 value) {
	gbInstructionPacket[DXL_PKT_PARA + index] = value;
 8004076:	7153      	strb	r3, [r2, #5]
 8004078:	f10e 0e02 	add.w	lr, lr, #2	; 0x2
 800407c:	f10c 0305 	add.w	r3, ip, #5	; 0x5
	// Starting address where to write to
	dxl_set_txpacket_parameter(0, DXL_GOAL_POSITION_L);
	// Length of data to be written (2 words = 4 bytes)
	dxl_set_txpacket_parameter(1, 4);
	// Loop over the active Dynamixel id's
	for( i=0; i<NUM_ACTUATOR; i++ )
 8004080:	4281      	cmp	r1, r0
	gbInstructionPacket[DXL_PKT_INST] = instruction;
}

//##############################################################################
void dxl_set_txpacket_parameter(u8 index, u8 value) {
	gbInstructionPacket[DXL_PKT_PARA + index] = value;
 8004082:	fa5f fc83 	uxtb.w	ip, r3
	// Starting address where to write to
	dxl_set_txpacket_parameter(0, DXL_GOAL_POSITION_L);
	// Length of data to be written (2 words = 4 bytes)
	dxl_set_txpacket_parameter(1, 4);
	// Loop over the active Dynamixel id's
	for( i=0; i<NUM_ACTUATOR; i++ )
 8004086:	dbd4      	blt.n	8004032 <dxl_set_goal_speed+0x36>
	gbInstructionPacket[DXL_PKT_PARA + index] = value;
}

//##############################################################################
void dxl_set_txpacket_length(u8 length) {
	gbInstructionPacket[DXL_PKT_LEN] = length;
 8004088:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 800408c:	4a04      	ldr	r2, [pc, #16]	(80040a0 <dxl_set_goal_speed+0xa4>)
 800408e:	3304      	adds	r3, #4
 8004090:	70d3      	strb	r3, [r2, #3]

	// total length is as per formula above with L=4
	dxl_set_txpacket_length((4+1)*NUM_ACTUATOR + 4);

	// all done, send the packet
	dxl_txrx_packet();
 8004092:	f7ff ff83 	bl	8003f9c <dxl_txrx_packet>
	}

}
 8004096:	b001      	add	sp, #4
 8004098:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800409a:	46c0      	nop			(mov r8, r8)
 800409c:	200009d6 	.word	0x200009d6
 80040a0:	200008e4 	.word	0x200008e4

080040a4 <dxl_write_word>:
	return dxl_makeword(gbStatusPacket[DXL_PKT_PARA],
			gbStatusPacket[DXL_PKT_PARA + 1]);
}

//##############################################################################
int dxl_write_word(u8 id, u8 address, u16 value) {
 80040a4:	b500      	push	{lr}
 80040a6:	4694      	mov	ip, r2
	while (giBusUsing)
 80040a8:	4a0b      	ldr	r2, [pc, #44]	(80040d8 <dxl_write_word+0x34>)
	return dxl_makeword(gbStatusPacket[DXL_PKT_PARA],
			gbStatusPacket[DXL_PKT_PARA + 1]);
}

//##############################################################################
int dxl_write_word(u8 id, u8 address, u16 value) {
 80040aa:	b081      	sub	sp, #4
	while (giBusUsing)
 80040ac:	7813      	ldrb	r3, [r2, #0]
 80040ae:	2b00      	cmp	r3, #0
 80040b0:	d1fc      	bne.n	80040ac <dxl_write_word+0x8>
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 80040b2:	4a0a      	ldr	r2, [pc, #40]	(80040dc <dxl_write_word+0x38>)
	gbInstructionPacket[DXL_PKT_INST] = INST_WRITE_DATA;
 80040b4:	2303      	movs	r3, #3
 80040b6:	7113      	strb	r3, [r2, #4]
	gbInstructionPacket[DXL_PKT_PARA] = address;
	gbInstructionPacket[DXL_PKT_PARA + 1] = dxl_get_lowbyte(value);
	gbInstructionPacket[DXL_PKT_PARA + 2] = dxl_get_highbyte(value);
 80040b8:	ea4f 231c 	mov.w	r3, ip, lsr #8
 80040bc:	71d3      	strb	r3, [r2, #7]
	gbInstructionPacket[DXL_PKT_LEN] = 5;
 80040be:	2305      	movs	r3, #5
//##############################################################################
int dxl_write_word(u8 id, u8 address, u16 value) {
	while (giBusUsing)
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 80040c0:	7090      	strb	r0, [r2, #2]
	gbInstructionPacket[DXL_PKT_INST] = INST_WRITE_DATA;
	gbInstructionPacket[DXL_PKT_PARA] = address;
	gbInstructionPacket[DXL_PKT_PARA + 1] = dxl_get_lowbyte(value);
	gbInstructionPacket[DXL_PKT_PARA + 2] = dxl_get_highbyte(value);
	gbInstructionPacket[DXL_PKT_LEN] = 5;
 80040c2:	70d3      	strb	r3, [r2, #3]
	while (giBusUsing)
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
	gbInstructionPacket[DXL_PKT_INST] = INST_WRITE_DATA;
	gbInstructionPacket[DXL_PKT_PARA] = address;
 80040c4:	7151      	strb	r1, [r2, #5]
	gbInstructionPacket[DXL_PKT_PARA + 1] = dxl_get_lowbyte(value);
 80040c6:	f882 c006 	strb.w	ip, [r2, #6]
	gbInstructionPacket[DXL_PKT_PARA + 2] = dxl_get_highbyte(value);
	gbInstructionPacket[DXL_PKT_LEN] = 5;

	dxl_txrx_packet();
 80040ca:	f7ff ff67 	bl	8003f9c <dxl_txrx_packet>

	return gbCommStatus;
 80040ce:	4b04      	ldr	r3, [pc, #16]	(80040e0 <dxl_write_word+0x3c>)
 80040d0:	8818      	ldrh	r0, [r3, #0]
 80040d2:	b280      	uxth	r0, r0
}
 80040d4:	b001      	add	sp, #4
 80040d6:	bd00      	pop	{pc}
 80040d8:	200009d6 	.word	0x200009d6
 80040dc:	200008e4 	.word	0x200008e4
 80040e0:	20000000 	.word	0x20000000

080040e4 <dxl_read_word>:

	return gbCommStatus;
}

//##############################################################################
u16 dxl_read_word(u8 id, u8 address) {
 80040e4:	b500      	push	{lr}
	while (giBusUsing)
 80040e6:	4a0f      	ldr	r2, [pc, #60]	(8004124 <dxl_read_word+0x40>)

	return gbCommStatus;
}

//##############################################################################
u16 dxl_read_word(u8 id, u8 address) {
 80040e8:	b081      	sub	sp, #4
	while (giBusUsing)
 80040ea:	7813      	ldrb	r3, [r2, #0]
 80040ec:	2b00      	cmp	r3, #0
 80040ee:	d1fc      	bne.n	80040ea <dxl_read_word+0x6>
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 80040f0:	4a0d      	ldr	r2, [pc, #52]	(8004128 <dxl_read_word+0x44>)
	gbInstructionPacket[DXL_PKT_INST] = INST_READ_DATA;
 80040f2:	2302      	movs	r3, #2
 80040f4:	7113      	strb	r3, [r2, #4]
	gbInstructionPacket[DXL_PKT_PARA] = address;
	gbInstructionPacket[DXL_PKT_PARA + 1] = 2;
 80040f6:	7193      	strb	r3, [r2, #6]
	gbInstructionPacket[DXL_PKT_LEN] = 4;
 80040f8:	2304      	movs	r3, #4
 80040fa:	70d3      	strb	r3, [r2, #3]
//##############################################################################
u16 dxl_read_word(u8 id, u8 address) {
	while (giBusUsing)
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 80040fc:	7090      	strb	r0, [r2, #2]
	gbInstructionPacket[DXL_PKT_INST] = INST_READ_DATA;
	gbInstructionPacket[DXL_PKT_PARA] = address;
 80040fe:	7151      	strb	r1, [r2, #5]
	gbInstructionPacket[DXL_PKT_PARA + 1] = 2;
	gbInstructionPacket[DXL_PKT_LEN] = 4;

	dxl_txrx_packet();
 8004100:	f7ff ff4c 	bl	8003f9c <dxl_txrx_packet>

	if ((gbCommStatus & DXL_RXFAIL))
 8004104:	4b09      	ldr	r3, [pc, #36]	(800412c <dxl_read_word+0x48>)
 8004106:	881b      	ldrh	r3, [r3, #0]
 8004108:	f013 0f08 	tst.w	r3, #8	; 0x8
 800410c:	d001      	beq.n	8004112 <dxl_read_word+0x2e>
 800410e:	2000      	movs	r0, #0
 8004110:	e005      	b.n	800411e <dxl_read_word+0x3a>

//##############################################################################
u16 dxl_makeword(u8 lowbyte, u8 highbyte) {
	u16 word;

	word = highbyte;
 8004112:	4b07      	ldr	r3, [pc, #28]	(8004130 <dxl_read_word+0x4c>)
 8004114:	799a      	ldrb	r2, [r3, #6]
	word = word << 8;
	word = word + lowbyte;
 8004116:	795b      	ldrb	r3, [r3, #5]
 8004118:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 800411c:	b298      	uxth	r0, r3
	if ((gbCommStatus & DXL_RXFAIL))
		return 0;

	return dxl_makeword(gbStatusPacket[DXL_PKT_PARA],
			gbStatusPacket[DXL_PKT_PARA + 1]);
}
 800411e:	b001      	add	sp, #4
 8004120:	bd00      	pop	{pc}
 8004122:	46c0      	nop			(mov r8, r8)
 8004124:	200009d6 	.word	0x200009d6
 8004128:	200008e4 	.word	0x200008e4
 800412c:	20000000 	.word	0x20000000
 8004130:	20000984 	.word	0x20000984

08004134 <dxl_write_byte>:

	return gbStatusPacket[DXL_PKT_PARA];
}

//##############################################################################
int dxl_write_byte(u8 id, u8 address, u8 value) {
 8004134:	b500      	push	{lr}
 8004136:	4694      	mov	ip, r2
	while (giBusUsing)
 8004138:	4a0a      	ldr	r2, [pc, #40]	(8004164 <dxl_write_byte+0x30>)

	return gbStatusPacket[DXL_PKT_PARA];
}

//##############################################################################
int dxl_write_byte(u8 id, u8 address, u8 value) {
 800413a:	b081      	sub	sp, #4
	while (giBusUsing)
 800413c:	7813      	ldrb	r3, [r2, #0]
 800413e:	2b00      	cmp	r3, #0
 8004140:	d1fc      	bne.n	800413c <dxl_write_byte+0x8>
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 8004142:	4a09      	ldr	r2, [pc, #36]	(8004168 <dxl_write_byte+0x34>)
	gbInstructionPacket[DXL_PKT_INST] = INST_WRITE_DATA;
 8004144:	2303      	movs	r3, #3
 8004146:	7113      	strb	r3, [r2, #4]
	gbInstructionPacket[DXL_PKT_PARA] = address;
	gbInstructionPacket[DXL_PKT_PARA + 1] = value;
	gbInstructionPacket[DXL_PKT_LEN] = 4;
 8004148:	2304      	movs	r3, #4
//##############################################################################
int dxl_write_byte(u8 id, u8 address, u8 value) {
	while (giBusUsing)
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 800414a:	7090      	strb	r0, [r2, #2]
	gbInstructionPacket[DXL_PKT_INST] = INST_WRITE_DATA;
	gbInstructionPacket[DXL_PKT_PARA] = address;
	gbInstructionPacket[DXL_PKT_PARA + 1] = value;
	gbInstructionPacket[DXL_PKT_LEN] = 4;
 800414c:	70d3      	strb	r3, [r2, #3]
	while (giBusUsing)
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
	gbInstructionPacket[DXL_PKT_INST] = INST_WRITE_DATA;
	gbInstructionPacket[DXL_PKT_PARA] = address;
 800414e:	7151      	strb	r1, [r2, #5]
	gbInstructionPacket[DXL_PKT_PARA + 1] = value;
 8004150:	f882 c006 	strb.w	ip, [r2, #6]
	gbInstructionPacket[DXL_PKT_LEN] = 4;

	dxl_txrx_packet();
 8004154:	f7ff ff22 	bl	8003f9c <dxl_txrx_packet>

	return gbCommStatus;
 8004158:	4b04      	ldr	r3, [pc, #16]	(800416c <dxl_write_byte+0x38>)
 800415a:	8818      	ldrh	r0, [r3, #0]
 800415c:	b280      	uxth	r0, r0
}
 800415e:	b001      	add	sp, #4
 8004160:	bd00      	pop	{pc}
 8004162:	46c0      	nop			(mov r8, r8)
 8004164:	200009d6 	.word	0x200009d6
 8004168:	200008e4 	.word	0x200008e4
 800416c:	20000000 	.word	0x20000000

08004170 <dxl_capture>:
			gbStatusPacket[i] = 0;
	}
}

//##############################################################################
void dxl_capture(u8 id) {
 8004170:	b500      	push	{lr}
//    gbInstructionPacket[DXL_PKT_INST] = INST_CAP_REGION;
//    gbInstructionPacket[DXL_PKT_LEN] = 2;

//    dxl_txrx_packet();

	dxl_write_byte(id, 0, 0);
 8004172:	2100      	movs	r1, #0
			gbStatusPacket[i] = 0;
	}
}

//##############################################################################
void dxl_capture(u8 id) {
 8004174:	b081      	sub	sp, #4
//    gbInstructionPacket[DXL_PKT_INST] = INST_CAP_REGION;
//    gbInstructionPacket[DXL_PKT_LEN] = 2;

//    dxl_txrx_packet();

	dxl_write_byte(id, 0, 0);
 8004176:	2200      	movs	r2, #0
 8004178:	f7ff ffdc 	bl	8004134 <dxl_write_byte>
}
 800417c:	b001      	add	sp, #4
 800417e:	bd00      	pop	{pc}

08004180 <dxl_read_byte>:
		return 0;
	}
}

//##############################################################################
u8 dxl_read_byte(u8 id, u8 address) {
 8004180:	b500      	push	{lr}
	while (giBusUsing)
 8004182:	4a0d      	ldr	r2, [pc, #52]	(80041b8 <dxl_read_byte+0x38>)
		return 0;
	}
}

//##############################################################################
u8 dxl_read_byte(u8 id, u8 address) {
 8004184:	b081      	sub	sp, #4
	while (giBusUsing)
 8004186:	7813      	ldrb	r3, [r2, #0]
 8004188:	2b00      	cmp	r3, #0
 800418a:	d1fc      	bne.n	8004186 <dxl_read_byte+0x6>
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 800418c:	4a0b      	ldr	r2, [pc, #44]	(80041bc <dxl_read_byte+0x3c>)
	gbInstructionPacket[DXL_PKT_INST] = INST_READ_DATA;
 800418e:	2302      	movs	r3, #2
 8004190:	7113      	strb	r3, [r2, #4]
	gbInstructionPacket[DXL_PKT_PARA] = address;
	gbInstructionPacket[DXL_PKT_PARA + 1] = 1;
 8004192:	2301      	movs	r3, #1
 8004194:	7193      	strb	r3, [r2, #6]
	gbInstructionPacket[DXL_PKT_LEN] = 4;
 8004196:	2304      	movs	r3, #4
 8004198:	70d3      	strb	r3, [r2, #3]
//##############################################################################
u8 dxl_read_byte(u8 id, u8 address) {
	while (giBusUsing)
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 800419a:	7090      	strb	r0, [r2, #2]
	gbInstructionPacket[DXL_PKT_INST] = INST_READ_DATA;
	gbInstructionPacket[DXL_PKT_PARA] = address;
 800419c:	7151      	strb	r1, [r2, #5]
	gbInstructionPacket[DXL_PKT_PARA + 1] = 1;
	gbInstructionPacket[DXL_PKT_LEN] = 4;

	dxl_txrx_packet();
 800419e:	f7ff fefd 	bl	8003f9c <dxl_txrx_packet>

	if ((gbCommStatus & DXL_RXFAIL))
 80041a2:	4b07      	ldr	r3, [pc, #28]	(80041c0 <dxl_read_byte+0x40>)
 80041a4:	881b      	ldrh	r3, [r3, #0]
 80041a6:	f013 0f08 	tst.w	r3, #8	; 0x8
 80041aa:	d001      	beq.n	80041b0 <dxl_read_byte+0x30>
 80041ac:	2000      	movs	r0, #0
 80041ae:	e001      	b.n	80041b4 <dxl_read_byte+0x34>
		return 0;

	return gbStatusPacket[DXL_PKT_PARA];
 80041b0:	4b04      	ldr	r3, [pc, #16]	(80041c4 <dxl_read_byte+0x44>)
 80041b2:	7958      	ldrb	r0, [r3, #5]
}
 80041b4:	b001      	add	sp, #4
 80041b6:	bd00      	pop	{pc}
 80041b8:	200009d6 	.word	0x200009d6
 80041bc:	200008e4 	.word	0x200008e4
 80041c0:	20000000 	.word	0x20000000
 80041c4:	20000984 	.word	0x20000984

080041c8 <dxl_ping>:
	u16 temp = ((word & 0xFF00) >> 8);
	return (u8) temp;
}

//##############################################################################
int dxl_ping(u8 id) {
 80041c8:	b500      	push	{lr}
	while (giBusUsing)
 80041ca:	4a0e      	ldr	r2, [pc, #56]	(8004204 <dxl_ping+0x3c>)
	u16 temp = ((word & 0xFF00) >> 8);
	return (u8) temp;
}

//##############################################################################
int dxl_ping(u8 id) {
 80041cc:	b081      	sub	sp, #4
	while (giBusUsing)
 80041ce:	7813      	ldrb	r3, [r2, #0]
 80041d0:	2b00      	cmp	r3, #0
 80041d2:	d1fc      	bne.n	80041ce <dxl_ping+0x6>
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 80041d4:	4a0c      	ldr	r2, [pc, #48]	(8004208 <dxl_ping+0x40>)
	gbInstructionPacket[DXL_PKT_INST] = INST_PING;
 80041d6:	2301      	movs	r3, #1
 80041d8:	7113      	strb	r3, [r2, #4]
	gbInstructionPacket[DXL_PKT_LEN] = 2;
 80041da:	2302      	movs	r3, #2
 80041dc:	70d3      	strb	r3, [r2, #3]
//##############################################################################
int dxl_ping(u8 id) {
	while (giBusUsing)
		;

	gbInstructionPacket[DXL_PKT_ID] = id;
 80041de:	7090      	strb	r0, [r2, #2]
	gbInstructionPacket[DXL_PKT_INST] = INST_PING;
	gbInstructionPacket[DXL_PKT_LEN] = 2;

	dxl_txrx_packet();
 80041e0:	f7ff fedc 	bl	8003f9c <dxl_txrx_packet>


	if (gbCommStatus == DXL_RXSUCCESS)
 80041e4:	4a09      	ldr	r2, [pc, #36]	(800420c <dxl_ping+0x44>)
 80041e6:	8813      	ldrh	r3, [r2, #0]
 80041e8:	2b02      	cmp	r3, #2
 80041ea:	d102      	bne.n	80041f2 <dxl_ping+0x2a>
	{
		//printf("Sending ping to dxl %d success: %d\n", id, (int)gbStatusPacket[ERRBIT]);
		// return the error code
		return (int)gbStatusPacket[ERRBIT];
 80041ec:	4b08      	ldr	r3, [pc, #32]	(8004210 <dxl_ping+0x48>)
 80041ee:	7918      	ldrb	r0, [r3, #4]
 80041f0:	e006      	b.n	8004200 <dxl_ping+0x38>
	// check if servo exists (via timeout)
	} else if( gbCommStatus == DXL_RXTIMEOUT )
 80041f2:	8813      	ldrh	r3, [r2, #0]
 80041f4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80041f8:	bf0c      	ite	eq
 80041fa:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
 80041fe:	2000      	movne	r0, #0
		return -1;
	} else {
		//printf("Sending ping to dxl %d failed. comStatus: %d\n", id, gbCommStatus);
		return 0;
	}
}
 8004200:	b001      	add	sp, #4
 8004202:	bd00      	pop	{pc}
 8004204:	200009d6 	.word	0x200009d6
 8004208:	200008e4 	.word	0x200008e4
 800420c:	20000000 	.word	0x20000000
 8004210:	20000984 	.word	0x20000984

08004214 <dxl_terminate>:

	return 1;
}

//##############################################################################
void dxl_terminate(void) {
 8004214:	b500      	push	{lr}
 8004216:	b081      	sub	sp, #4
	dxl_hal_close();
 8004218:	f001 fe5c 	bl	8005ed4 <dxl_hal_close>
}
 800421c:	b001      	add	sp, #4
 800421e:	bd00      	pop	{pc}

08004220 <dxl_initialize>:

volatile u16 gbCommStatus = DXL_RXSUCCESS;
volatile u8 giBusUsing = 0;

//##############################################################################
u8 dxl_initialize(u32 baudrate) {
 8004220:	b500      	push	{lr}
 8004222:	b081      	sub	sp, #4
	if (dxl_hal_open(baudrate) == 0)
 8004224:	f001 fe7c 	bl	8005f20 <dxl_hal_open>
 8004228:	b138      	cbz	r0, 800423a <dxl_initialize+0x1a>
		return 0;

	gbCommStatus = DXL_RXSUCCESS;
 800422a:	4b05      	ldr	r3, [pc, #20]	(8004240 <dxl_initialize+0x20>)
 800422c:	f04f 0202 	mov.w	r2, #2	; 0x2
 8004230:	801a      	strh	r2, [r3, #0]
	giBusUsing = 0;
 8004232:	4b04      	ldr	r3, [pc, #16]	(8004244 <dxl_initialize+0x24>)
 8004234:	2200      	movs	r2, #0
 8004236:	701a      	strb	r2, [r3, #0]
 8004238:	2001      	movs	r0, #1

	return 1;
}
 800423a:	b001      	add	sp, #4
 800423c:	bd00      	pop	{pc}
 800423e:	46c0      	nop			(mov r8, r8)
 8004240:	20000000 	.word	0x20000000
 8004244:	200009d6 	.word	0x200009d6

08004248 <zgb_rx_data>:
}

//##############################################################################
u16 zgb_rx_data(void)
{
	gbRcvFlag = 0;
 8004248:	4b02      	ldr	r3, [pc, #8]	(8004254 <zgb_rx_data+0xc>)
 800424a:	2200      	movs	r2, #0
 800424c:	701a      	strb	r2, [r3, #0]
 800424e:	4b02      	ldr	r3, [pc, #8]	(8004258 <zgb_rx_data+0x10>)
 8004250:	8818      	ldrh	r0, [r3, #0]
	return gwRcvData;
}
 8004252:	4770      	bx	lr
 8004254:	200009ec 	.word	0x200009ec
 8004258:	200009ea 	.word	0x200009ea

0800425c <zgb_rx_data_right_V>:
    return gbRcvFlag;
}

//##############################################################################
u16 zgb_rx_data_right_V(void)
{
 800425c:	4b01      	ldr	r3, [pc, #4]	(8004264 <zgb_rx_data_right_V+0x8>)
 800425e:	7818      	ldrb	r0, [r3, #0]
    //gbRcvFlag = 0;
    return right_V;
}
 8004260:	4770      	bx	lr
 8004262:	46c0      	nop			(mov r8, r8)
 8004264:	200009ed 	.word	0x200009ed

08004268 <zgb_rx_data_right_H>:
//##############################################################################
u16 zgb_rx_data_right_H(void)
{
 8004268:	4b01      	ldr	r3, [pc, #4]	(8004270 <zgb_rx_data_right_H+0x8>)
 800426a:	7818      	ldrb	r0, [r3, #0]
    //gbRcvFlag = 0;
    return right_H;
}
 800426c:	4770      	bx	lr
 800426e:	46c0      	nop			(mov r8, r8)
 8004270:	200009ee 	.word	0x200009ee

08004274 <zgb_rx_data_left_V>:
//##############################################################################
u16 zgb_rx_data_left_V(void)
{
 8004274:	4b01      	ldr	r3, [pc, #4]	(800427c <zgb_rx_data_left_V+0x8>)
 8004276:	7818      	ldrb	r0, [r3, #0]
    //gbRcvFlag = 0;
    return left_V;
}
 8004278:	4770      	bx	lr
 800427a:	46c0      	nop			(mov r8, r8)
 800427c:	200009ef 	.word	0x200009ef

08004280 <zgb_rx_data_left_H>:
//##############################################################################
u16 zgb_rx_data_left_H(void)
{
 8004280:	4b01      	ldr	r3, [pc, #4]	(8004288 <zgb_rx_data_left_H+0x8>)
 8004282:	7818      	ldrb	r0, [r3, #0]
    //gbRcvFlag = 0;
    return left_H;
}
 8004284:	4770      	bx	lr
 8004286:	46c0      	nop			(mov r8, r8)
 8004288:	200009f0 	.word	0x200009f0

0800428c <zgb_rx_data_buttons>:
//##############################################################################
u8 zgb_rx_data_buttons(void)
{
 800428c:	4b01      	ldr	r3, [pc, #4]	(8004294 <zgb_rx_data_buttons+0x8>)
 800428e:	7818      	ldrb	r0, [r3, #0]
    //gbRcvFlag = 0;
    return buttons_;
}
 8004290:	4770      	bx	lr
 8004292:	46c0      	nop			(mov r8, r8)
 8004294:	200009f1 	.word	0x200009f1

08004298 <zgb_rx_data_extra>:
//##############################################################################
u8 zgb_rx_data_extra(void)
{
    gbRcvFlag = 0;
 8004298:	4b02      	ldr	r3, [pc, #8]	(80042a4 <zgb_rx_data_extra+0xc>)
 800429a:	2200      	movs	r2, #0
 800429c:	701a      	strb	r2, [r3, #0]
    return 0;

}
 800429e:	2000      	movs	r0, #0
 80042a0:	4770      	bx	lr
 80042a2:	46c0      	nop			(mov r8, r8)
 80042a4:	200009ec 	.word	0x200009ec

080042a8 <zgb_rx_data_right_V_>:
//##############################################################################
int zgb_rx_data_right_V_(void)
{
 80042a8:	4b01      	ldr	r3, [pc, #4]	(80042b0 <zgb_rx_data_right_V_+0x8>)
 80042aa:	7818      	ldrb	r0, [r3, #0]
 80042ac:	3880      	subs	r0, #128
    //gbRcvFlag = 0;
    return (right_V - 128);
}
 80042ae:	4770      	bx	lr
 80042b0:	200009ed 	.word	0x200009ed

080042b4 <zgb_rx_data_right_H_>:
//##############################################################################
int zgb_rx_data_right_H_(void)
{
 80042b4:	4b01      	ldr	r3, [pc, #4]	(80042bc <zgb_rx_data_right_H_+0x8>)
 80042b6:	7818      	ldrb	r0, [r3, #0]
 80042b8:	3880      	subs	r0, #128
    //gbRcvFlag = 0;
    return (right_H - 128);
}
 80042ba:	4770      	bx	lr
 80042bc:	200009ee 	.word	0x200009ee

080042c0 <zgb_rx_data_left_V_>:
//##############################################################################
int zgb_rx_data_left_V_(void)
{
 80042c0:	4b01      	ldr	r3, [pc, #4]	(80042c8 <zgb_rx_data_left_V_+0x8>)
 80042c2:	7818      	ldrb	r0, [r3, #0]
 80042c4:	3880      	subs	r0, #128
    //gbRcvFlag = 0;
    return (left_V - 128);
}
 80042c6:	4770      	bx	lr
 80042c8:	200009ef 	.word	0x200009ef

080042cc <zgb_rx_data_left_H_>:
//##############################################################################
int zgb_rx_data_left_H_(void)
{
 80042cc:	4b01      	ldr	r3, [pc, #4]	(80042d4 <zgb_rx_data_left_H_+0x8>)
 80042ce:	7818      	ldrb	r0, [r3, #0]
 80042d0:	3880      	subs	r0, #128
    //gbRcvFlag = 0;
    return (left_H- 128);
}
 80042d2:	4770      	bx	lr
 80042d4:	200009f0 	.word	0x200009f0

080042d8 <CheckZBNewArrive>:
//##############################################################################
byte CheckZBNewArrive(void) {
	if (gbZigRead != gbZigWrite)
 80042d8:	4b03      	ldr	r3, [pc, #12]	(80042e8 <CheckZBNewArrive+0x10>)
 80042da:	7818      	ldrb	r0, [r3, #0]
 80042dc:	4b03      	ldr	r3, [pc, #12]	(80042ec <CheckZBNewArrive+0x14>)
 80042de:	781b      	ldrb	r3, [r3, #0]
 80042e0:	1ac0      	subs	r0, r0, r3
 80042e2:	bf18      	it	ne
 80042e4:	2001      	movne	r0, #1
		return 1;
	else
		return 0;
}
 80042e6:	4770      	bx	lr
 80042e8:	200009d8 	.word	0x200009d8
 80042ec:	200009d9 	.word	0x200009d9

080042f0 <zgb_rx_check_arduino>:
	return gwRcvData;
}

//##############################################################################
u8 zgb_rx_check_arduino(void)
{
 80042f0:	b570      	push	{r4, r5, r6, lr}

    u8 RcvNum;
    u8 checksum;
    u8 i, j;

    if (gbRcvFlag==1){
 80042f2:	4b3e      	ldr	r3, [pc, #248]	(80043ec <zgb_rx_check_arduino+0xfc>)
 80042f4:	781b      	ldrb	r3, [r3, #0]
 80042f6:	2b01      	cmp	r3, #1
 80042f8:	d101      	bne.n	80042fe <zgb_rx_check_arduino+0xe>
 80042fa:	2001      	movs	r0, #1
 80042fc:	e075      	b.n	80043ea <zgb_rx_check_arduino+0xfa>
    }



    // Fill packet buffer
    if (gbRcvPacketNum<9)
 80042fe:	4c3c      	ldr	r4, [pc, #240]	(80043f0 <zgb_rx_check_arduino+0x100>)
 8004300:	7823      	ldrb	r3, [r4, #0]
 8004302:	2b08      	cmp	r3, #8
 8004304:	d809      	bhi.n	800431a <zgb_rx_check_arduino+0x2a>


    {


        RcvNum = zgb_hal_rx((u8*)&gbRcvPacketArduino[gbRcvPacketNum], (9-gbRcvPacketNum));
 8004306:	483b      	ldr	r0, [pc, #236]	(80043f4 <zgb_rx_check_arduino+0x104>)
 8004308:	f1c3 0109 	rsb	r1, r3, #9	; 0x9
 800430c:	18c0      	adds	r0, r0, r3
 800430e:	b2c9      	uxtb	r1, r1
 8004310:	f001 fcf8 	bl	8005d04 <zgb_hal_rx>
        if (RcvNum!=-1)
            gbRcvPacketNum += RcvNum;
 8004314:	7823      	ldrb	r3, [r4, #0]
 8004316:	18c0      	adds	r0, r0, r3
 8004318:	7020      	strb	r0, [r4, #0]
    }

    // Find header
    if (gbRcvPacketNum>=2)
 800431a:	4b35      	ldr	r3, [pc, #212]	(80043f0 <zgb_rx_check_arduino+0x100>)
 800431c:	f893 c000 	ldrb.w	ip, [r3]
 8004320:	f1bc 0f01 	cmp.w	ip, #1	; 0x1
 8004324:	d92c      	bls.n	8004380 <zgb_rx_check_arduino+0x90>
 8004326:	2200      	movs	r2, #0
    {

        for (i=0; i<gbRcvPacketNum; i++)
        {
            if (gbRcvPacketArduino[i]==0xFF)
 8004328:	4d32      	ldr	r5, [pc, #200]	(80043f4 <zgb_rx_check_arduino+0x104>)
            {
                if (i<=(gbRcvPacketNum-2))
 800432a:	f10c 34ff 	add.w	r4, ip, #4294967295	; 0xffffffff
 800432e:	e00a      	b.n	8004346 <zgb_rx_check_arduino+0x56>
    if (gbRcvPacketNum>=2)
    {

        for (i=0; i<gbRcvPacketNum; i++)
        {
            if (gbRcvPacketArduino[i]==0xFF)
 8004330:	5cab      	ldrb	r3, [r5, r2]
 8004332:	eb05 0102 	add.w	r1, r5, r2
 8004336:	2bff      	cmp	r3, #255
 8004338:	d104      	bne.n	8004344 <zgb_rx_check_arduino+0x54>
            {
                if (i<=(gbRcvPacketNum-2))
 800433a:	4294      	cmp	r4, r2
 800433c:	dd02      	ble.n	8004344 <zgb_rx_check_arduino+0x54>
                {
                    if (gbRcvPacketArduino[i+1]==0x55)
 800433e:	784b      	ldrb	r3, [r1, #1]
 8004340:	2b55      	cmp	r3, #85
 8004342:	d003      	beq.n	800434c <zgb_rx_check_arduino+0x5c>
                        break;
 8004344:	3201      	adds	r2, #1
 8004346:	b2d0      	uxtb	r0, r2

    // Find header
    if (gbRcvPacketNum>=2)
    {

        for (i=0; i<gbRcvPacketNum; i++)
 8004348:	4560      	cmp	r0, ip
 800434a:	d3f1      	bcc.n	8004330 <zgb_rx_check_arduino+0x40>
                        break;
                }
            }
        }

        if (i>0)
 800434c:	b1c0      	cbz	r0, 8004380 <zgb_rx_check_arduino+0x90>
        {
            if (i==gbRcvPacketNum)
 800434e:	4560      	cmp	r0, ip
 8004350:	d107      	bne.n	8004362 <zgb_rx_check_arduino+0x72>
            {
                // Cannot find header
                if (gbRcvPacketArduino[i-1]==0xFF)
 8004352:	4b28      	ldr	r3, [pc, #160]	(80043f4 <zgb_rx_check_arduino+0x104>)
 8004354:	181b      	adds	r3, r3, r0
 8004356:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 800435a:	2bff      	cmp	r3, #255
 800435c:	d101      	bne.n	8004362 <zgb_rx_check_arduino+0x72>

                    i--;
 800435e:	1e43      	subs	r3, r0, #1
 8004360:	b2d8      	uxtb	r0, r3
 8004362:	4601      	mov	r1, r0

            // Remove data before header
            for (j=i; j<gbRcvPacketNum; j++)
            {

                gbRcvPacketArduino[j-i] = gbRcvPacketArduino[j];
 8004364:	4c23      	ldr	r4, [pc, #140]	(80043f4 <zgb_rx_check_arduino+0x104>)
 8004366:	e005      	b.n	8004374 <zgb_rx_check_arduino+0x84>
 8004368:	5c62      	ldrb	r2, [r4, r1]
 800436a:	ebc0 0301 	rsb	r3, r0, r1
 800436e:	54e2      	strb	r2, [r4, r3]

                    i--;
            }

            // Remove data before header
            for (j=i; j<gbRcvPacketNum; j++)
 8004370:	1c4b      	adds	r3, r1, #1
 8004372:	b2d9      	uxtb	r1, r3
 8004374:	4561      	cmp	r1, ip
 8004376:	d3f7      	bcc.n	8004368 <zgb_rx_check_arduino+0x78>
            {

                gbRcvPacketArduino[j-i] = gbRcvPacketArduino[j];
            }
            gbRcvPacketNum -= i;
 8004378:	4b1d      	ldr	r3, [pc, #116]	(80043f0 <zgb_rx_check_arduino+0x100>)
 800437a:	ebc0 020c 	rsb	r2, r0, ip
 800437e:	701a      	strb	r2, [r3, #0]
        }
    }

    // Verify packet
    if (gbRcvPacketNum==9)
 8004380:	4b1b      	ldr	r3, [pc, #108]	(80043f0 <zgb_rx_check_arduino+0x100>)
 8004382:	781b      	ldrb	r3, [r3, #0]
 8004384:	2b09      	cmp	r3, #9
 8004386:	d12d      	bne.n	80043e4 <zgb_rx_check_arduino+0xf4>
    {

        if ( (gbRcvPacketArduino[0]==0xFF) && (gbRcvPacketArduino[1]==0x55) )
 8004388:	4e1a      	ldr	r6, [pc, #104]	(80043f4 <zgb_rx_check_arduino+0x104>)
 800438a:	7833      	ldrb	r3, [r6, #0]
 800438c:	2bff      	cmp	r3, #255
 800438e:	d124      	bne.n	80043da <zgb_rx_check_arduino+0xea>
 8004390:	7873      	ldrb	r3, [r6, #1]
 8004392:	2b55      	cmp	r3, #85
 8004394:	d121      	bne.n	80043da <zgb_rx_check_arduino+0xea>
                    gbRcvFlag = 1;
                }
            }*/


                  		left_V  =   gbRcvPacketArduino[2];
 8004396:	78b5      	ldrb	r5, [r6, #2]
 8004398:	4b17      	ldr	r3, [pc, #92]	(80043f8 <zgb_rx_check_arduino+0x108>)
        	            left_H  =   gbRcvPacketArduino[3];
 800439a:	78f4      	ldrb	r4, [r6, #3]
                    gbRcvFlag = 1;
                }
            }*/


                  		left_V  =   gbRcvPacketArduino[2];
 800439c:	701d      	strb	r5, [r3, #0]
        	            left_H  =   gbRcvPacketArduino[3];
 800439e:	4b17      	ldr	r3, [pc, #92]	(80043fc <zgb_rx_check_arduino+0x10c>)
        	            right_V =   gbRcvPacketArduino[4];
 80043a0:	f896 c004 	ldrb.w	ip, [r6, #4]
                }
            }*/


                  		left_V  =   gbRcvPacketArduino[2];
        	            left_H  =   gbRcvPacketArduino[3];
 80043a4:	701c      	strb	r4, [r3, #0]
        	            right_V =   gbRcvPacketArduino[4];
 80043a6:	4b16      	ldr	r3, [pc, #88]	(8004400 <zgb_rx_check_arduino+0x110>)
        	            right_H =   gbRcvPacketArduino[5];
 80043a8:	4a16      	ldr	r2, [pc, #88]	(8004404 <zgb_rx_check_arduino+0x114>)
            }*/


                  		left_V  =   gbRcvPacketArduino[2];
        	            left_H  =   gbRcvPacketArduino[3];
        	            right_V =   gbRcvPacketArduino[4];
 80043aa:	f883 c000 	strb.w	ip, [r3]
        	            right_H =   gbRcvPacketArduino[5];
 80043ae:	7973      	ldrb	r3, [r6, #5]
        	            buttons_=   gbRcvPacketArduino[6];
 80043b0:	79b0      	ldrb	r0, [r6, #6]


                  		left_V  =   gbRcvPacketArduino[2];
        	            left_H  =   gbRcvPacketArduino[3];
        	            right_V =   gbRcvPacketArduino[4];
        	            right_H =   gbRcvPacketArduino[5];
 80043b2:	7013      	strb	r3, [r2, #0]
        	            buttons_=   gbRcvPacketArduino[6];
 80043b4:	4a14      	ldr	r2, [pc, #80]	(8004408 <zgb_rx_check_arduino+0x118>)
	TxD_Dec_U8(extra);
	PrintString("\n");
#endif


            if (checksum == (255 - (right_V+right_H+left_V+left_H+buttons_)%256)){        	  //if (checksum == (255 - (gbRcvPacketArduino[2]+gbRcvPacketArduino[3]+gbRcvPacketArduino[4]+gbRcvPacketArduino[5]+gbRcvPacketArduino[6])%256)){
 80043b6:	4463      	add	r3, ip
 80043b8:	195b      	adds	r3, r3, r5
 80043ba:	191b      	adds	r3, r3, r4

                  		left_V  =   gbRcvPacketArduino[2];
        	            left_H  =   gbRcvPacketArduino[3];
        	            right_V =   gbRcvPacketArduino[4];
        	            right_H =   gbRcvPacketArduino[5];
        	            buttons_=   gbRcvPacketArduino[6];
 80043bc:	7010      	strb	r0, [r2, #0]
        	            extra   =   gbRcvPacketArduino[7];
 80043be:	79f1      	ldrb	r1, [r6, #7]
 80043c0:	4a12      	ldr	r2, [pc, #72]	(800440c <zgb_rx_check_arduino+0x11c>)
	TxD_Dec_U8(extra);
	PrintString("\n");
#endif


            if (checksum == (255 - (right_V+right_H+left_V+left_H+buttons_)%256)){        	  //if (checksum == (255 - (gbRcvPacketArduino[2]+gbRcvPacketArduino[3]+gbRcvPacketArduino[4]+gbRcvPacketArduino[5]+gbRcvPacketArduino[6])%256)){
 80043c2:	181b      	adds	r3, r3, r0
                  		left_V  =   gbRcvPacketArduino[2];
        	            left_H  =   gbRcvPacketArduino[3];
        	            right_V =   gbRcvPacketArduino[4];
        	            right_H =   gbRcvPacketArduino[5];
        	            buttons_=   gbRcvPacketArduino[6];
        	            extra   =   gbRcvPacketArduino[7];
 80043c4:	7011      	strb	r1, [r2, #0]
	TxD_Dec_U8(extra);
	PrintString("\n");
#endif


            if (checksum == (255 - (right_V+right_H+left_V+left_H+buttons_)%256)){        	  //if (checksum == (255 - (gbRcvPacketArduino[2]+gbRcvPacketArduino[3]+gbRcvPacketArduino[4]+gbRcvPacketArduino[5]+gbRcvPacketArduino[6])%256)){
 80043c6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80043ca:	7a32      	ldrb	r2, [r6, #8]
 80043cc:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80043d0:	429a      	cmp	r2, r3
 80043d2:	d102      	bne.n	80043da <zgb_rx_check_arduino+0xea>


				 gbRcvFlag = 1;
 80043d4:	4b05      	ldr	r3, [pc, #20]	(80043ec <zgb_rx_check_arduino+0xfc>)
 80043d6:	2201      	movs	r2, #1
 80043d8:	701a      	strb	r2, [r3, #0]
            }

        }
        gbRcvPacketArduino[0] = 0x00;
 80043da:	4a06      	ldr	r2, [pc, #24]	(80043f4 <zgb_rx_check_arduino+0x104>)
 80043dc:	2300      	movs	r3, #0
 80043de:	7013      	strb	r3, [r2, #0]
        gbRcvPacketNum = 0;
 80043e0:	4a03      	ldr	r2, [pc, #12]	(80043f0 <zgb_rx_check_arduino+0x100>)
 80043e2:	7013      	strb	r3, [r2, #0]
    }

    return gbRcvFlag;
 80043e4:	4b01      	ldr	r3, [pc, #4]	(80043ec <zgb_rx_check_arduino+0xfc>)
 80043e6:	781b      	ldrb	r3, [r3, #0]
 80043e8:	4618      	mov	r0, r3
}
 80043ea:	bd70      	pop	{r4, r5, r6, pc}
 80043ec:	200009ec 	.word	0x200009ec
 80043f0:	200009e9 	.word	0x200009e9
 80043f4:	200009e0 	.word	0x200009e0
 80043f8:	200009ef 	.word	0x200009ef
 80043fc:	200009f0 	.word	0x200009f0
 8004400:	200009ed 	.word	0x200009ed
 8004404:	200009ee 	.word	0x200009ee
 8004408:	200009f1 	.word	0x200009f1
 800440c:	200009f2 	.word	0x200009f2

08004410 <zgb_rx_check>:
	return 1;
}

//##############################################################################
u8 zgb_rx_check(void)
{
 8004410:	b530      	push	{r4, r5, lr}
	u8 RcvNum;
	u8 checksum;
	u8 i, j;

	if (gbRcvFlag==1)
 8004412:	4b39      	ldr	r3, [pc, #228]	(80044f8 <zgb_rx_check+0xe8>)
	return 1;
}

//##############################################################################
u8 zgb_rx_check(void)
{
 8004414:	b081      	sub	sp, #4
	u8 RcvNum;
	u8 checksum;
	u8 i, j;

	if (gbRcvFlag==1)
 8004416:	781b      	ldrb	r3, [r3, #0]
 8004418:	2b01      	cmp	r3, #1
 800441a:	d101      	bne.n	8004420 <zgb_rx_check+0x10>
 800441c:	2001      	movs	r0, #1
 800441e:	e068      	b.n	80044f2 <zgb_rx_check+0xe2>
	return 1;

	// Fill packet buffer
	if (gbRcvPacketNum<6)
 8004420:	4c36      	ldr	r4, [pc, #216]	(80044fc <zgb_rx_check+0xec>)
 8004422:	7823      	ldrb	r3, [r4, #0]
 8004424:	2b05      	cmp	r3, #5
 8004426:	d809      	bhi.n	800443c <zgb_rx_check+0x2c>
	{
		RcvNum = zgb_hal_rx((u8*)&gbRcvPacket[gbRcvPacketNum], (6-gbRcvPacketNum));
 8004428:	4835      	ldr	r0, [pc, #212]	(8004500 <zgb_rx_check+0xf0>)
 800442a:	f1c3 0106 	rsb	r1, r3, #6	; 0x6
 800442e:	18c0      	adds	r0, r0, r3
 8004430:	b2c9      	uxtb	r1, r1
 8004432:	f001 fc67 	bl	8005d04 <zgb_hal_rx>
		if (RcvNum!=-1)
		gbRcvPacketNum += RcvNum;
 8004436:	7823      	ldrb	r3, [r4, #0]
 8004438:	18c0      	adds	r0, r0, r3
 800443a:	7020      	strb	r0, [r4, #0]
	}

	// Find header
	if (gbRcvPacketNum>=2)
 800443c:	4b2f      	ldr	r3, [pc, #188]	(80044fc <zgb_rx_check+0xec>)
 800443e:	f893 c000 	ldrb.w	ip, [r3]
 8004442:	f1bc 0f01 	cmp.w	ip, #1	; 0x1
 8004446:	d92c      	bls.n	80044a2 <zgb_rx_check+0x92>
 8004448:	2200      	movs	r2, #0
	{
		for (i=0; i<gbRcvPacketNum; i++)
		{
			if (gbRcvPacket[i]==0xFF)
 800444a:	4d2d      	ldr	r5, [pc, #180]	(8004500 <zgb_rx_check+0xf0>)
			{
				if (i<=(gbRcvPacketNum-2))
 800444c:	f10c 34ff 	add.w	r4, ip, #4294967295	; 0xffffffff
 8004450:	e00a      	b.n	8004468 <zgb_rx_check+0x58>
	// Find header
	if (gbRcvPacketNum>=2)
	{
		for (i=0; i<gbRcvPacketNum; i++)
		{
			if (gbRcvPacket[i]==0xFF)
 8004452:	5cab      	ldrb	r3, [r5, r2]
 8004454:	eb05 0102 	add.w	r1, r5, r2
 8004458:	2bff      	cmp	r3, #255
 800445a:	d104      	bne.n	8004466 <zgb_rx_check+0x56>
			{
				if (i<=(gbRcvPacketNum-2))
 800445c:	4294      	cmp	r4, r2
 800445e:	dd02      	ble.n	8004466 <zgb_rx_check+0x56>
				{
					if (gbRcvPacket[i+1]==0x55)
 8004460:	784b      	ldrb	r3, [r1, #1]
 8004462:	2b55      	cmp	r3, #85
 8004464:	d003      	beq.n	800446e <zgb_rx_check+0x5e>
					break;
 8004466:	3201      	adds	r2, #1
 8004468:	b2d0      	uxtb	r0, r2
	}

	// Find header
	if (gbRcvPacketNum>=2)
	{
		for (i=0; i<gbRcvPacketNum; i++)
 800446a:	4560      	cmp	r0, ip
 800446c:	d3f1      	bcc.n	8004452 <zgb_rx_check+0x42>
					break;
				}
			}
		}

		if (i>0)
 800446e:	b1c0      	cbz	r0, 80044a2 <zgb_rx_check+0x92>
		{
			if (i==gbRcvPacketNum)
 8004470:	4560      	cmp	r0, ip
 8004472:	d107      	bne.n	8004484 <zgb_rx_check+0x74>
			{
				// Cannot find header
				if (gbRcvPacket[i-1]==0xFF)
 8004474:	4b22      	ldr	r3, [pc, #136]	(8004500 <zgb_rx_check+0xf0>)
 8004476:	181b      	adds	r3, r3, r0
 8004478:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 800447c:	2bff      	cmp	r3, #255
 800447e:	d101      	bne.n	8004484 <zgb_rx_check+0x74>
				i--;
 8004480:	1e43      	subs	r3, r0, #1
 8004482:	b2d8      	uxtb	r0, r3
 8004484:	4601      	mov	r1, r0
			}

			// Remove data before header
			for (j=i; j<gbRcvPacketNum; j++)
			{
				gbRcvPacket[j-i] = gbRcvPacket[j];
 8004486:	4c1e      	ldr	r4, [pc, #120]	(8004500 <zgb_rx_check+0xf0>)
 8004488:	e005      	b.n	8004496 <zgb_rx_check+0x86>
 800448a:	5c62      	ldrb	r2, [r4, r1]
 800448c:	ebc0 0301 	rsb	r3, r0, r1
 8004490:	54e2      	strb	r2, [r4, r3]
				if (gbRcvPacket[i-1]==0xFF)
				i--;
			}

			// Remove data before header
			for (j=i; j<gbRcvPacketNum; j++)
 8004492:	1c4b      	adds	r3, r1, #1
 8004494:	b2d9      	uxtb	r1, r3
 8004496:	4561      	cmp	r1, ip
 8004498:	d3f7      	bcc.n	800448a <zgb_rx_check+0x7a>
			{
				gbRcvPacket[j-i] = gbRcvPacket[j];
			}
			gbRcvPacketNum -= i;
 800449a:	4b18      	ldr	r3, [pc, #96]	(80044fc <zgb_rx_check+0xec>)
 800449c:	ebc0 020c 	rsb	r2, r0, ip
 80044a0:	701a      	strb	r2, [r3, #0]
		}
	}

	// Verify packet
	if (gbRcvPacketNum==6)
 80044a2:	4b16      	ldr	r3, [pc, #88]	(80044fc <zgb_rx_check+0xec>)
 80044a4:	781b      	ldrb	r3, [r3, #0]
 80044a6:	2b06      	cmp	r3, #6
 80044a8:	d120      	bne.n	80044ec <zgb_rx_check+0xdc>
	{
		if ( (gbRcvPacket[0]==0xFF) && (gbRcvPacket[1]==0x55) )
 80044aa:	4a15      	ldr	r2, [pc, #84]	(8004500 <zgb_rx_check+0xf0>)
 80044ac:	7813      	ldrb	r3, [r2, #0]
 80044ae:	2bff      	cmp	r3, #255
 80044b0:	d117      	bne.n	80044e2 <zgb_rx_check+0xd2>
 80044b2:	7853      	ldrb	r3, [r2, #1]
 80044b4:	2b55      	cmp	r3, #85
 80044b6:	d114      	bne.n	80044e2 <zgb_rx_check+0xd2>
		{
			checksum = ~gbRcvPacket[3];
			if (gbRcvPacket[2]==checksum)
 80044b8:	78d3      	ldrb	r3, [r2, #3]
 80044ba:	7890      	ldrb	r0, [r2, #2]
 80044bc:	ea6f 0303 	mvn.w	r3, r3
 80044c0:	b2db      	uxtb	r3, r3
 80044c2:	4298      	cmp	r0, r3
 80044c4:	d10d      	bne.n	80044e2 <zgb_rx_check+0xd2>
			{
				checksum = ~gbRcvPacket[5];
				if (gbRcvPacket[4]==checksum)
 80044c6:	7953      	ldrb	r3, [r2, #5]
 80044c8:	7911      	ldrb	r1, [r2, #4]
 80044ca:	ea6f 0303 	mvn.w	r3, r3
 80044ce:	b2db      	uxtb	r3, r3
 80044d0:	4299      	cmp	r1, r3
 80044d2:	d106      	bne.n	80044e2 <zgb_rx_check+0xd2>
				{
					gwRcvData = (u16) ((gbRcvPacket[4]<<8)&0xFF00);
					gwRcvData += gbRcvPacket[2];
 80044d4:	4b0b      	ldr	r3, [pc, #44]	(8004504 <zgb_rx_check+0xf4>)
 80044d6:	eb00 2201 	add.w	r2, r0, r1, lsl #8
 80044da:	801a      	strh	r2, [r3, #0]
					gbRcvFlag = 1;
 80044dc:	4b06      	ldr	r3, [pc, #24]	(80044f8 <zgb_rx_check+0xe8>)
 80044de:	2201      	movs	r2, #1
 80044e0:	701a      	strb	r2, [r3, #0]
				}
			}
		}
		gbRcvPacket[0] = 0x00;
 80044e2:	4a07      	ldr	r2, [pc, #28]	(8004500 <zgb_rx_check+0xf0>)
 80044e4:	2300      	movs	r3, #0
 80044e6:	7013      	strb	r3, [r2, #0]
		gbRcvPacketNum = 0;
 80044e8:	4a04      	ldr	r2, [pc, #16]	(80044fc <zgb_rx_check+0xec>)
 80044ea:	7013      	strb	r3, [r2, #0]
	}

	return gbRcvFlag;
 80044ec:	4b02      	ldr	r3, [pc, #8]	(80044f8 <zgb_rx_check+0xe8>)
 80044ee:	781b      	ldrb	r3, [r3, #0]
 80044f0:	4618      	mov	r0, r3
}
 80044f2:	b001      	add	sp, #4
 80044f4:	bd30      	pop	{r4, r5, pc}
 80044f6:	46c0      	nop			(mov r8, r8)
 80044f8:	200009ec 	.word	0x200009ec
 80044fc:	200009e9 	.word	0x200009e9
 8004500:	200009da 	.word	0x200009da
 8004504:	200009ea 	.word	0x200009ea

08004508 <zgb_tx_data>:
	zgb_hal_close();
}

//##############################################################################
u8 zgb_tx_data(u16 word)
{
 8004508:	b500      	push	{lr}
	u8 SndPacket[6];
	u8 lowbyte = (u8) (word&0xFF);
 800450a:	b2c2      	uxtb	r2, r0
	zgb_hal_close();
}

//##############################################################################
u8 zgb_tx_data(u16 word)
{
 800450c:	b083      	sub	sp, #12
	u8 SndPacket[6];
	u8 lowbyte = (u8) (word&0xFF);
	u8 highbyte = (u8) ((word>>8)&0xFF);
 800450e:	0a00      	lsrs	r0, r0, #8

	SndPacket[0] = 0xFF;
	SndPacket[1] = 0x55;
	SndPacket[2] = lowbyte;
	SndPacket[3] = ~lowbyte;
	SndPacket[4] = highbyte;
 8004510:	f88d 0006 	strb.w	r0, [sp, #6]
{
	u8 SndPacket[6];
	u8 lowbyte = (u8) (word&0xFF);
	u8 highbyte = (u8) ((word>>8)&0xFF);

	SndPacket[0] = 0xFF;
 8004514:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	SndPacket[1] = 0x55;
	SndPacket[2] = lowbyte;
	SndPacket[3] = ~lowbyte;
	SndPacket[4] = highbyte;
	SndPacket[5] = ~highbyte;
 8004518:	ea6f 0000 	mvn.w	r0, r0
{
	u8 SndPacket[6];
	u8 lowbyte = (u8) (word&0xFF);
	u8 highbyte = (u8) ((word>>8)&0xFF);

	SndPacket[0] = 0xFF;
 800451c:	f88d 3002 	strb.w	r3, [sp, #2]
	SndPacket[1] = 0x55;
	SndPacket[2] = lowbyte;
 8004520:	f88d 2004 	strb.w	r2, [sp, #4]
	u8 SndPacket[6];
	u8 lowbyte = (u8) (word&0xFF);
	u8 highbyte = (u8) ((word>>8)&0xFF);

	SndPacket[0] = 0xFF;
	SndPacket[1] = 0x55;
 8004524:	2355      	movs	r3, #85
	SndPacket[2] = lowbyte;
	SndPacket[3] = ~lowbyte;
 8004526:	ea6f 0202 	mvn.w	r2, r2
	SndPacket[4] = highbyte;
	SndPacket[5] = ~highbyte;
 800452a:	f88d 0007 	strb.w	r0, [sp, #7]

	if (zgb_hal_tx(SndPacket, 6)!=6)
 800452e:	2106      	movs	r1, #6
 8004530:	f10d 0002 	add.w	r0, sp, #2	; 0x2
	u8 SndPacket[6];
	u8 lowbyte = (u8) (word&0xFF);
	u8 highbyte = (u8) ((word>>8)&0xFF);

	SndPacket[0] = 0xFF;
	SndPacket[1] = 0x55;
 8004534:	f88d 3003 	strb.w	r3, [sp, #3]
	SndPacket[2] = lowbyte;
	SndPacket[3] = ~lowbyte;
 8004538:	f88d 2005 	strb.w	r2, [sp, #5]
	SndPacket[4] = highbyte;
	SndPacket[5] = ~highbyte;

	if (zgb_hal_tx(SndPacket, 6)!=6)
 800453c:	f001 fdd0 	bl	80060e0 <zgb_hal_tx>
 8004540:	2806      	cmp	r0, #6
 8004542:	bf14      	ite	ne
 8004544:	2000      	movne	r0, #0
 8004546:	2001      	moveq	r0, #1
	return 0;

	return 1;
}
 8004548:	b003      	add	sp, #12
 800454a:	bd00      	pop	{pc}

0800454c <zgb_terminate>:
	return 1;
}

//##############################################################################
void zgb_terminate(void)
{
 800454c:	b500      	push	{lr}
 800454e:	b081      	sub	sp, #4
	zgb_hal_close();
 8004550:	f001 fcca 	bl	8005ee8 <zgb_hal_close>
}
 8004554:	b001      	add	sp, #4
 8004556:	bd00      	pop	{pc}

08004558 <zgb_initialize>:
u8 extra;


//##############################################################################
u8 zgb_initialize(u32 baudrate)
{
 8004558:	b500      	push	{lr}
 800455a:	b081      	sub	sp, #4
	if (zgb_hal_open(baudrate)==0)
 800455c:	f001 fd10 	bl	8005f80 <zgb_hal_open>
 8004560:	b148      	cbz	r0, 8004576 <zgb_initialize+0x1e>
	return 0;

	gbRcvFlag = 0;
 8004562:	4b06      	ldr	r3, [pc, #24]	(800457c <zgb_initialize+0x24>)
 8004564:	2200      	movs	r2, #0
 8004566:	701a      	strb	r2, [r3, #0]
	gwRcvData = 0;
 8004568:	4b05      	ldr	r3, [pc, #20]	(8004580 <zgb_initialize+0x28>)
 800456a:	f04f 0100 	mov.w	r1, #0	; 0x0
 800456e:	8019      	strh	r1, [r3, #0]
	gbRcvPacketNum = 0;
 8004570:	4b04      	ldr	r3, [pc, #16]	(8004584 <zgb_initialize+0x2c>)
 8004572:	2001      	movs	r0, #1
 8004574:	701a      	strb	r2, [r3, #0]
	return 1;
}
 8004576:	b001      	add	sp, #4
 8004578:	bd00      	pop	{pc}
 800457a:	46c0      	nop			(mov r8, r8)
 800457c:	200009ec 	.word	0x200009ec
 8004580:	200009ea 	.word	0x200009ea
 8004584:	200009e9 	.word	0x200009e9

08004588 <checkMotionFinished>:
	
	// return the page of the next motion in sequence
	return (int) CurrentMotion.NextPage;	
}

int checkMotionFinished() {
 8004588:	4b03      	ldr	r3, [pc, #12]	(8004598 <checkMotionFinished+0x10>)
 800458a:	7818      	ldrb	r0, [r3, #0]
 800458c:	f1d0 0001 	rsbs	r0, r0, #1	; 0x1
 8004590:	bf38      	it	cc
 8004592:	2000      	movcc	r0, #0
	return motion_state == MOTION_STOPPED;
}
 8004594:	4770      	bx	lr
 8004596:	46c0      	nop			(mov r8, r8)
 8004598:	200009f4 	.word	0x200009f4

0800459c <setNewMotionCommand>:
		executeMotion(NextPage);
	}
}

void setNewMotionCommand(int motionPageId) {
	bioloid_command = COMMAND_MOTIONPAGE;
 800459c:	4b04      	ldr	r3, [pc, #16]	(80045b0 <setNewMotionCommand+0x14>)
 800459e:	2215      	movs	r2, #21
 80045a0:	701a      	strb	r2, [r3, #0]
	next_motion_page = motionPageId;
 80045a2:	4b04      	ldr	r3, [pc, #16]	(80045b4 <setNewMotionCommand+0x18>)
 80045a4:	b2c0      	uxtb	r0, r0
 80045a6:	7018      	strb	r0, [r3, #0]
	new_command = 1;
 80045a8:	4b03      	ldr	r3, [pc, #12]	(80045b8 <setNewMotionCommand+0x1c>)
 80045aa:	2201      	movs	r2, #1
 80045ac:	701a      	strb	r2, [r3, #0]
}
 80045ae:	4770      	bx	lr
 80045b0:	20000f74 	.word	0x20000f74
 80045b4:	20000f7a 	.word	0x20000f7a
 80045b8:	20000f76 	.word	0x20000f76

080045bc <getCurrentMotionStartTime>:

/* Get the timestamp (as given by millis()) for when the current motion page started.
 * If no motion page is currently executing, return time stamp of when last executed motion page started executing.
 * If no motion has been executed yet, return 0. */
u32 getCurrentMotionStartTime() {
 80045bc:	4b01      	ldr	r3, [pc, #4]	(80045c4 <getCurrentMotionStartTime+0x8>)
 80045be:	6818      	ldr	r0, [r3, #0]
	return current_motion_start_time;
}
 80045c0:	4770      	bx	lr
 80045c2:	46c0      	nop			(mov r8, r8)
 80045c4:	20000a0c 	.word	0x20000a0c

080045c8 <printCurrentMotionPage>:

// for debugging
void printCurrentMotionPage() {
 80045c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	PrintString("motion.c: CurrentMotion:\n");
	PrintString(" RepeatTime=%d \n Steps=%d \n SpeedRate10=%d \n InertialForce=%d \n NextPage=%d \n ExitPage=%d \n", CurrentMotion.RepeatTime, CurrentMotion.Steps, CurrentMotion.SpeedRate10, CurrentMotion.InertialForce, CurrentMotion.NextPage, CurrentMotion.ExitPage);
 80045ca:	4c24      	ldr	r4, [pc, #144]	(800465c <printCurrentMotionPage+0x94>)
u32 getCurrentMotionStartTime() {
	return current_motion_start_time;
}

// for debugging
void printCurrentMotionPage() {
 80045cc:	b085      	sub	sp, #20
	PrintString("motion.c: CurrentMotion:\n");
 80045ce:	4824      	ldr	r0, [pc, #144]	(8004660 <printCurrentMotionPage+0x98>)
 80045d0:	f7ff fa3c 	bl	8003a4c <PrintString>
	PrintString(" RepeatTime=%d \n Steps=%d \n SpeedRate10=%d \n InertialForce=%d \n NextPage=%d \n ExitPage=%d \n", CurrentMotion.RepeatTime, CurrentMotion.Steps, CurrentMotion.SpeedRate10, CurrentMotion.InertialForce, CurrentMotion.NextPage, CurrentMotion.ExitPage);
 80045d4:	7da0      	ldrb	r0, [r4, #22]
 80045d6:	7d21      	ldrb	r1, [r4, #20]
 80045d8:	7de2      	ldrb	r2, [r4, #23]
 80045da:	7d63      	ldrb	r3, [r4, #21]
 80045dc:	9000      	str	r0, [sp, #0]
 80045de:	7ca0      	ldrb	r0, [r4, #18]
 80045e0:	4626      	mov	r6, r4
 80045e2:	9001      	str	r0, [sp, #4]
 80045e4:	7ce0      	ldrb	r0, [r4, #19]
 80045e6:	2500      	movs	r5, #0
 80045e8:	9002      	str	r0, [sp, #8]
 80045ea:	481e      	ldr	r0, [pc, #120]	(8004664 <printCurrentMotionPage+0x9c>)
 80045ec:	f7ff fa2e 	bl	8003a4c <PrintString>
 80045f0:	e01f      	b.n	8004632 <printCurrentMotionPage+0x6a>
	for (int s=0; s<CurrentMotion.Steps; s++)
	{
		PrintString(" Steps:\n");
 80045f2:	481d      	ldr	r0, [pc, #116]	(8004668 <printCurrentMotionPage+0xa0>)
 80045f4:	f7ff fa2a 	bl	8003a4c <PrintString>
		PrintString("   step %i: play=%d pause=%d\n  ", s, CurrentMotion.PlayTime[s], CurrentMotion.PauseTime[s]);
 80045f8:	f8b6 2122 	ldrh.w	r2, [r6, #290]
 80045fc:	f8b6 3114 	ldrh.w	r3, [r6, #276]
 8004600:	481a      	ldr	r0, [pc, #104]	(800466c <printCurrentMotionPage+0xa4>)
 8004602:	4629      	mov	r1, r5
 8004604:	f7ff fa22 	bl	8003a4c <PrintString>
 8004608:	4a14      	ldr	r2, [pc, #80]	(800465c <printCurrentMotionPage+0x94>)
 800460a:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
 800460e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8004612:	f103 0718 	add.w	r7, r3, #24	; 0x18
 8004616:	2400      	movs	r4, #0
		for (int i=0; i<NUM_AX12_SERVOS; i++)
		{
			PrintString("%d ", CurrentMotion.StepValues[s][i]);
 8004618:	f837 1b02 	ldrh.w	r1, [r7], #2
 800461c:	4814      	ldr	r0, [pc, #80]	(8004670 <printCurrentMotionPage+0xa8>)
	PrintString(" RepeatTime=%d \n Steps=%d \n SpeedRate10=%d \n InertialForce=%d \n NextPage=%d \n ExitPage=%d \n", CurrentMotion.RepeatTime, CurrentMotion.Steps, CurrentMotion.SpeedRate10, CurrentMotion.InertialForce, CurrentMotion.NextPage, CurrentMotion.ExitPage);
	for (int s=0; s<CurrentMotion.Steps; s++)
	{
		PrintString(" Steps:\n");
		PrintString("   step %i: play=%d pause=%d\n  ", s, CurrentMotion.PlayTime[s], CurrentMotion.PauseTime[s]);
		for (int i=0; i<NUM_AX12_SERVOS; i++)
 800461e:	3401      	adds	r4, #1
		{
			PrintString("%d ", CurrentMotion.StepValues[s][i]);
 8004620:	f7ff fa14 	bl	8003a4c <PrintString>
	PrintString(" RepeatTime=%d \n Steps=%d \n SpeedRate10=%d \n InertialForce=%d \n NextPage=%d \n ExitPage=%d \n", CurrentMotion.RepeatTime, CurrentMotion.Steps, CurrentMotion.SpeedRate10, CurrentMotion.InertialForce, CurrentMotion.NextPage, CurrentMotion.ExitPage);
	for (int s=0; s<CurrentMotion.Steps; s++)
	{
		PrintString(" Steps:\n");
		PrintString("   step %i: play=%d pause=%d\n  ", s, CurrentMotion.PlayTime[s], CurrentMotion.PauseTime[s]);
		for (int i=0; i<NUM_AX12_SERVOS; i++)
 8004624:	2c12      	cmp	r4, #18
 8004626:	d1f7      	bne.n	8004618 <printCurrentMotionPage+0x50>
		{
			PrintString("%d ", CurrentMotion.StepValues[s][i]);
		}
		PrintString("\n");
 8004628:	4812      	ldr	r0, [pc, #72]	(8004674 <printCurrentMotionPage+0xac>)
 800462a:	f7ff fa0f 	bl	8003a4c <PrintString>

// for debugging
void printCurrentMotionPage() {
	PrintString("motion.c: CurrentMotion:\n");
	PrintString(" RepeatTime=%d \n Steps=%d \n SpeedRate10=%d \n InertialForce=%d \n NextPage=%d \n ExitPage=%d \n", CurrentMotion.RepeatTime, CurrentMotion.Steps, CurrentMotion.SpeedRate10, CurrentMotion.InertialForce, CurrentMotion.NextPage, CurrentMotion.ExitPage);
	for (int s=0; s<CurrentMotion.Steps; s++)
 800462e:	3501      	adds	r5, #1
 8004630:	3602      	adds	r6, #2
 8004632:	4a0a      	ldr	r2, [pc, #40]	(800465c <printCurrentMotionPage+0x94>)
 8004634:	7dd3      	ldrb	r3, [r2, #23]
 8004636:	429d      	cmp	r5, r3
 8004638:	dbdb      	blt.n	80045f2 <printCurrentMotionPage+0x2a>
		{
			PrintString("%d ", CurrentMotion.StepValues[s][i]);
		}
		PrintString("\n");
	}
	PrintString("Joint flex:\n ");
 800463a:	480f      	ldr	r0, [pc, #60]	(8004678 <printCurrentMotionPage+0xb0>)
 800463c:	f7ff fa06 	bl	8003a4c <PrintString>
	for (int i=0; i<NUM_AX12_SERVOS; i++)
	{
		PrintString("%d ", CurrentMotion.JointFlex[i]);
 8004640:	4d06      	ldr	r5, [pc, #24]	(800465c <printCurrentMotionPage+0x94>)
		{
			PrintString("%d ", CurrentMotion.StepValues[s][i]);
		}
		PrintString("\n");
	}
	PrintString("Joint flex:\n ");
 8004642:	2400      	movs	r4, #0
	for (int i=0; i<NUM_AX12_SERVOS; i++)
	{
		PrintString("%d ", CurrentMotion.JointFlex[i]);
 8004644:	5d29      	ldrb	r1, [r5, r4]
 8004646:	480a      	ldr	r0, [pc, #40]	(8004670 <printCurrentMotionPage+0xa8>)
			PrintString("%d ", CurrentMotion.StepValues[s][i]);
		}
		PrintString("\n");
	}
	PrintString("Joint flex:\n ");
	for (int i=0; i<NUM_AX12_SERVOS; i++)
 8004648:	3401      	adds	r4, #1
	{
		PrintString("%d ", CurrentMotion.JointFlex[i]);
 800464a:	f7ff f9ff 	bl	8003a4c <PrintString>
			PrintString("%d ", CurrentMotion.StepValues[s][i]);
		}
		PrintString("\n");
	}
	PrintString("Joint flex:\n ");
	for (int i=0; i<NUM_AX12_SERVOS; i++)
 800464e:	2c12      	cmp	r4, #18
 8004650:	d1f8      	bne.n	8004644 <printCurrentMotionPage+0x7c>
	{
		PrintString("%d ", CurrentMotion.JointFlex[i]);
	}
	PrintString("\n");
 8004652:	4808      	ldr	r0, [pc, #32]	(8004674 <printCurrentMotionPage+0xac>)
 8004654:	f7ff f9fa 	bl	8003a4c <PrintString>
}
 8004658:	b005      	add	sp, #20
 800465a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800465c:	20000e24 	.word	0x20000e24
 8004660:	080080e6 	.word	0x080080e6
 8004664:	08008100 	.word	0x08008100
 8004668:	0800815c 	.word	0x0800815c
 800466c:	08008165 	.word	0x08008165
 8004670:	08008185 	.word	0x08008185
 8004674:	08007cba 	.word	0x08007cba
 8004678:	08008189 	.word	0x08008189

0800467c <checkMotionStepFinished>:
}

// Function to check for any remaining servo movement
// Returns:  (int)	number of servos still moving
int checkMotionStepFinished()
{
 800467c:	b500      	push	{lr}
 800467e:	b081      	sub	sp, #4

	// use the same logic as when walking, only go on expected time.
	//TEST:
	//printf("checkMotionStepFinished %d %d %d\n", step_start_time,  CurrentMotion.PlayTime[current_step-1], millis() );
	if (getMillis() < step_start_time + CurrentMotion.PlayTime[current_step-1]) {
 8004680:	f000 ffda 	bl	8005638 <getMillis>
 8004684:	4b07      	ldr	r3, [pc, #28]	(80046a4 <checkMotionStepFinished+0x28>)
 8004686:	781a      	ldrb	r2, [r3, #0]
 8004688:	4b07      	ldr	r3, [pc, #28]	(80046a8 <checkMotionStepFinished+0x2c>)
 800468a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800468e:	4a07      	ldr	r2, [pc, #28]	(80046ac <checkMotionStepFinished+0x30>)
 8004690:	f8b3 3120 	ldrh.w	r3, [r3, #288]
 8004694:	6812      	ldr	r2, [r2, #0]
 8004696:	189b      	adds	r3, r3, r2
 8004698:	4298      	cmp	r0, r3
 800469a:	bf2c      	ite	cs
 800469c:	2000      	movcs	r0, #0
 800469e:	2001      	movcc	r0, #1
//		}
//	}
//	return 0;


}
 80046a0:	b001      	add	sp, #4
 80046a2:	bd00      	pop	{pc}
 80046a4:	20000f7b 	.word	0x20000f7b
 80046a8:	20000e24 	.word	0x20000e24
 80046ac:	20000a00 	.word	0x20000a00

080046b0 <executeMotionStep>:
{
	//uint16 goalPose[NUM_AX12_SERVOS];
	unsigned long step_start_time;

	// Make sure we never access random memory by accident and damage the robot
	if ( Step > 0 && Step <= CurrentMotion.Steps )
 80046b0:	2800      	cmp	r0, #0

// This function initiates the execution of a motion step in the given motion page
// Step - number of the step to be initiated
// Returns (long) start time of the step
unsigned long executeMotionStep(int Step)
{
 80046b2:	b570      	push	{r4, r5, r6, lr}
 80046b4:	4604      	mov	r4, r0
	//uint16 goalPose[NUM_AX12_SERVOS];
	unsigned long step_start_time;

	// Make sure we never access random memory by accident and damage the robot
	if ( Step > 0 && Step <= CurrentMotion.Steps )
 80046b6:	dd13      	ble.n	80046e0 <executeMotionStep+0x30>
 80046b8:	4d0b      	ldr	r5, [pc, #44]	(80046e8 <executeMotionStep+0x38>)
 80046ba:	7deb      	ldrb	r3, [r5, #23]
 80046bc:	4298      	cmp	r0, r3
 80046be:	dc0f      	bgt.n	80046e0 <executeMotionStep+0x30>
		// create the servo values array 
		// actually no need to copy, just send in the CurrentMotion.StepValues[Step-1] array directly
		//for (int j=0; j<NUM_AX12_SERVOS; j++)
		//	{ goalPose[j] = CurrentMotion.StepValues[Step-1][j]; }
		// take the time
		step_start_time = getMillis();
 80046c0:	f000 ffba 	bl	8005638 <getMillis>
		// execute the pose without waiting for completion
		moveToGoalPose(CurrentMotion.PlayTime[Step-1], CurrentMotion.StepValues[Step-1], DONT_WAIT_FOR_POSE_FINISH);
 80046c4:	eb04 01c4 	add.w	r1, r4, r4, lsl #3
 80046c8:	eb05 0344 	add.w	r3, r5, r4, lsl #1
 80046cc:	eb05 0181 	add.w	r1, r5, r1, lsl #2
		// create the servo values array 
		// actually no need to copy, just send in the CurrentMotion.StepValues[Step-1] array directly
		//for (int j=0; j<NUM_AX12_SERVOS; j++)
		//	{ goalPose[j] = CurrentMotion.StepValues[Step-1][j]; }
		// take the time
		step_start_time = getMillis();
 80046d0:	4606      	mov	r6, r0
		// execute the pose without waiting for completion
		moveToGoalPose(CurrentMotion.PlayTime[Step-1], CurrentMotion.StepValues[Step-1], DONT_WAIT_FOR_POSE_FINISH);
 80046d2:	390c      	subs	r1, #12
 80046d4:	f8b3 0120 	ldrh.w	r0, [r3, #288]
 80046d8:	2200      	movs	r2, #0
 80046da:	f000 fcb3 	bl	8005044 <moveToGoalPose>
 80046de:	e000      	b.n	80046e2 <executeMotionStep+0x32>
		// return the start time to keep track of step timing
		return step_start_time;
 80046e0:	2600      	movs	r6, #0
	} else {
		// do nothing and return 0
		return 0;
	}
}
 80046e2:	4630      	mov	r0, r6
 80046e4:	bd70      	pop	{r4, r5, r6, pc}
 80046e6:	46c0      	nop			(mov r8, r8)
 80046e8:	20000e24 	.word	0x20000e24

080046ec <setMotionPageJointFlexibility>:

// This function initializes the joint flexibility values for the current motion page
// Returns (int)  0  - all ok
//				 -1  - communication error
int setMotionPageJointFlexibility()
{
 80046ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	int commStatus;

	// now we can process the joint flexibility values
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
		// update is only required if different from last set of values
		if ( last_joint_flex[i] != CurrentMotion.JointFlex[i] )
 80046ee:	4f15      	ldr	r7, [pc, #84]	(8004744 <setMotionPageJointFlexibility+0x58>)

// This function initializes the joint flexibility values for the current motion page
// Returns (int)  0  - all ok
//				 -1  - communication error
int setMotionPageJointFlexibility()
{
 80046f0:	b081      	sub	sp, #4
 80046f2:	2400      	movs	r4, #0
	int commStatus;

	// now we can process the joint flexibility values
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
		// update is only required if different from last set of values
		if ( last_joint_flex[i] != CurrentMotion.JointFlex[i] )
 80046f4:	4914      	ldr	r1, [pc, #80]	(8004748 <setMotionPageJointFlexibility+0x5c>)
 80046f6:	5d3b      	ldrb	r3, [r7, r4]
 80046f8:	5d0a      	ldrb	r2, [r1, r4]
 80046fa:	4293      	cmp	r3, r2
 80046fc:	d018      	beq.n	8004730 <setMotionPageJointFlexibility+0x44>
		{
			// translation is bit shift operation (see AX-12 manual)
			complianceSlope = 1<<CurrentMotion.JointFlex[i]; 
 80046fe:	2101      	movs	r1, #1
 8004700:	fa11 f302 	lsls.w	r3, r1, r2
			commStatus = dxl_write_byte(AX12_IDS[i], DXL_CCW_COMPLIANCE_SLOPE, complianceSlope);
 8004704:	4a11      	ldr	r2, [pc, #68]	(800474c <setMotionPageJointFlexibility+0x60>)
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
		// update is only required if different from last set of values
		if ( last_joint_flex[i] != CurrentMotion.JointFlex[i] )
		{
			// translation is bit shift operation (see AX-12 manual)
			complianceSlope = 1<<CurrentMotion.JointFlex[i]; 
 8004706:	b2de      	uxtb	r6, r3
			commStatus = dxl_write_byte(AX12_IDS[i], DXL_CCW_COMPLIANCE_SLOPE, complianceSlope);
 8004708:	5d15      	ldrb	r5, [r2, r4]
 800470a:	211d      	movs	r1, #29
 800470c:	4628      	mov	r0, r5
 800470e:	4632      	mov	r2, r6
 8004710:	f7ff fd10 	bl	8004134 <dxl_write_byte>
			if(commStatus != DXL_RXSUCCESS) {
 8004714:	2802      	cmp	r0, #2
 8004716:	d006      	beq.n	8004726 <setMotionPageJointFlexibility+0x3a>
				// there has been an error, print and break
				PrintString("\nsetMotionPageJointFlexibility CCW ID%i - ", AX12_IDS[i]);
 8004718:	480d      	ldr	r0, [pc, #52]	(8004750 <setMotionPageJointFlexibility+0x64>)
 800471a:	4629      	mov	r1, r5
 800471c:	f7ff f996 	bl	8003a4c <PrintString>
 8004720:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004724:	e00b      	b.n	800473e <setMotionPageJointFlexibility+0x52>
				return -1;
			}
			dxl_write_byte(AX12_IDS[i], DXL_CW_COMPLIANCE_SLOPE, complianceSlope);
 8004726:	4628      	mov	r0, r5
 8004728:	211c      	movs	r1, #28
 800472a:	4632      	mov	r2, r6
 800472c:	f7ff fd02 	bl	8004134 <dxl_write_byte>
				dxl_printCommStatus(commStatus);
				return -1;
			}
		}
		// update values for next iteration
		last_joint_flex[i] = CurrentMotion.JointFlex[i];
 8004730:	4905      	ldr	r1, [pc, #20]	(8004748 <setMotionPageJointFlexibility+0x5c>)
 8004732:	5d0b      	ldrb	r3, [r1, r4]
 8004734:	553b      	strb	r3, [r7, r4]
 8004736:	3401      	adds	r4, #1
{
	uint8 complianceSlope;
	int commStatus;

	// now we can process the joint flexibility values
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
 8004738:	2c12      	cmp	r4, #18
 800473a:	d1db      	bne.n	80046f4 <setMotionPageJointFlexibility+0x8>
 800473c:	2000      	movs	r0, #0
		}
		// update values for next iteration
		last_joint_flex[i] = CurrentMotion.JointFlex[i];
	}
	return 0;
}
 800473e:	b001      	add	sp, #4
 8004740:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004742:	46c0      	nop			(mov r8, r8)
 8004744:	20000a10 	.word	0x20000a10
 8004748:	20000e24 	.word	0x20000e24
 800474c:	08007c3e 	.word	0x08007c3e
 8004750:	08008197 	.word	0x08008197

08004754 <unpackMotion2>:
}

// This function unpacks a motion page as stored by RoboPlus Motion
// StartPage - number of the motion page to be unpacked
// DONT DO PRINTF IN THIS FUNCTION! IT WILL TAKE TOO LONG AND MAY BREAK WALKING OR OTHER MOTIONS.
void unpackMotion2(int StartPage) {
 8004754:	b5f0      	push	{r4, r5, r6, r7, lr}
	int i;
	const motion_page * motion = &motion_pointer_pages[StartPage-1];
 8004756:	0243      	lsls	r3, r0, #9
}

// This function unpacks a motion page as stored by RoboPlus Motion
// StartPage - number of the motion page to be unpacked
// DONT DO PRINTF IN THIS FUNCTION! IT WILL TAKE TOO LONG AND MAY BREAK WALKING OR OTHER MOTIONS.
void unpackMotion2(int StartPage) {
 8004758:	b089      	sub	sp, #36
	int i;
	const motion_page * motion = &motion_pointer_pages[StartPage-1];
 800475a:	f103 6c00 	add.w	ip, r3, #134217728	; 0x8000000
}

// This function unpacks a motion page as stored by RoboPlus Motion
// StartPage - number of the motion page to be unpacked
// DONT DO PRINTF IN THIS FUNCTION! IT WILL TAKE TOO LONG AND MAY BREAK WALKING OR OTHER MOTIONS.
void unpackMotion2(int StartPage) {
 800475e:	9006      	str	r0, [sp, #24]
	int i;
	const motion_page * motion = &motion_pointer_pages[StartPage-1];
 8004760:	f50c 2c86 	add.w	ip, ip, #274432	; 0x43000
	//printf("Unpacking motion %i: %s\n", StartPage, motion->name);

	CurrentMotion.RepeatTime = motion->repetitions;
 8004764:	f89c 300f 	ldrb.w	r3, [ip, #15]
 8004768:	4a3c      	ldr	r2, [pc, #240]	(800485c <unpackMotion2+0x108>)
 800476a:	7513      	strb	r3, [r2, #20]
	CurrentMotion.Steps = motion->n_steps;
 800476c:	f89c 3014 	ldrb.w	r3, [ip, #20]
 8004770:	9307      	str	r3, [sp, #28]
 8004772:	75d3      	strb	r3, [r2, #23]
	CurrentMotion.SpeedRate10 = 10 * 32 / motion->speed_rate; // not actually used just for comparision with old code
 8004774:	f89c 1016 	ldrb.w	r1, [ip, #22]
 8004778:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800477c:	fb93 f3f1 	sdiv	r3, r3, r1
 8004780:	7553      	strb	r3, [r2, #21]
	//printf("speedrate in mem is: %d, calculated speedrate10 is: %d\n", motion->speed_rate, CurrentMotion.SpeedRate10);
	CurrentMotion.InertialForce = motion->ctrl_inertial_force;
 8004782:	f89c 3018 	ldrb.w	r3, [ip, #24]
	CurrentMotion.NextPage = motion->next_page;
	CurrentMotion.ExitPage = motion->exit_page;
 8004786:	2100      	movs	r1, #0

	CurrentMotion.RepeatTime = motion->repetitions;
	CurrentMotion.Steps = motion->n_steps;
	CurrentMotion.SpeedRate10 = 10 * 32 / motion->speed_rate; // not actually used just for comparision with old code
	//printf("speedrate in mem is: %d, calculated speedrate10 is: %d\n", motion->speed_rate, CurrentMotion.SpeedRate10);
	CurrentMotion.InertialForce = motion->ctrl_inertial_force;
 8004788:	7593      	strb	r3, [r2, #22]
	CurrentMotion.NextPage = motion->next_page;
 800478a:	f89c 3019 	ldrb.w	r3, [ip, #25]
 800478e:	7493      	strb	r3, [r2, #18]
	CurrentMotion.ExitPage = motion->exit_page;
 8004790:	f89c 301a 	ldrb.w	r3, [ip, #26]
 8004794:	74d3      	strb	r3, [r2, #19]

	// servo compliance slope / joint softness
	for (i=0; i<NUM_AX12_SERVOS; i++)
	{
		 CurrentMotion.JointFlex[i] = motion->joint_softness[i+1] & 0x0f; // actually both cw and ccw is sttored in 4 bits each, here we use the same value for both
 8004796:	eb0c 0301 	add.w	r3, ip, r1
 800479a:	f893 3021 	ldrb.w	r3, [r3, #33]
 800479e:	f003 030f 	and.w	r3, r3, #15	; 0xf
 80047a2:	5453      	strb	r3, [r2, r1]
 80047a4:	3101      	adds	r1, #1
	CurrentMotion.InertialForce = motion->ctrl_inertial_force;
	CurrentMotion.NextPage = motion->next_page;
	CurrentMotion.ExitPage = motion->exit_page;

	// servo compliance slope / joint softness
	for (i=0; i<NUM_AX12_SERVOS; i++)
 80047a6:	2912      	cmp	r1, #18
 80047a8:	d1f5      	bne.n	8004796 <unpackMotion2+0x42>
 80047aa:	4667      	mov	r7, ip
 80047ac:	482b      	ldr	r0, [pc, #172]	(800485c <unpackMotion2+0x108>)
 80047ae:	2400      	movs	r4, #0
 80047b0:	e043      	b.n	800483a <unpackMotion2+0xe6>
 80047b2:	9d03      	ldr	r5, [sp, #12]

	// step servo positions and step pause/execution time
	for (int step = 0; step < CurrentMotion.Steps; step++)
	{
		for (i = 0; i < NUM_AX12_SERVOS; i++) {
			CurrentMotion.StepValues[step][i] = motion->steps[step].joint_pos[i+1];
 80047b4:	1c6e      	adds	r6, r5, #1
 80047b6:	884b      	ldrh	r3, [r1, #2]
 80047b8:	9603      	str	r6, [sp, #12]

			if ( CurrentMotion.StepValues[step][i] > 1023 )
 80047ba:	f240 36ff 	movw	r6, #1023	; 0x3ff
 80047be:	42b3      	cmp	r3, r6

	// step servo positions and step pause/execution time
	for (int step = 0; step < CurrentMotion.Steps; step++)
	{
		for (i = 0; i < NUM_AX12_SERVOS; i++) {
			CurrentMotion.StepValues[step][i] = motion->steps[step].joint_pos[i+1];
 80047c0:	8013      	strh	r3, [r2, #0]

			if ( CurrentMotion.StepValues[step][i] > 1023 )
 80047c2:	d91c      	bls.n	80047fe <unpackMotion2+0xaa>
			{
				// obviously have unpacked rubbish, stop right here
				PrintString("\nUnpack Motion Page %i, Step %i - rubbish data. STOP.", StartPage, step+1);
 80047c4:	1c62      	adds	r2, r4, #1
 80047c6:	9906      	ldr	r1, [sp, #24]
 80047c8:	4825      	ldr	r0, [pc, #148]	(8004860 <unpackMotion2+0x10c>)
 80047ca:	f7ff f93f 	bl	8003a4c <PrintString>
				PrintString("\nServo ID%i, Step Value = %i, Min = %i, Max = %i \n", AX12_IDS[i], CurrentMotion.StepValues[step][i], SERVO_MIN_VALUES[i],SERVO_MAX_VALUES[i] );
 80047ce:	4b25      	ldr	r3, [pc, #148]	(8004864 <unpackMotion2+0x110>)
 80047d0:	4a22      	ldr	r2, [pc, #136]	(800485c <unpackMotion2+0x108>)
 80047d2:	5d59      	ldrb	r1, [r3, r5]
 80047d4:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 80047d8:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 80047dc:	4822      	ldr	r0, [pc, #136]	(8004868 <unpackMotion2+0x114>)
 80047de:	330c      	adds	r3, #12
 80047e0:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 80047e4:	f830 0015 	ldrh.w	r0, [r0, r5, lsl #1]
 80047e8:	4b20      	ldr	r3, [pc, #128]	(800486c <unpackMotion2+0x118>)
 80047ea:	9000      	str	r0, [sp, #0]
 80047ec:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
 80047f0:	481f      	ldr	r0, [pc, #124]	(8004870 <unpackMotion2+0x11c>)
 80047f2:	f7ff f92b 	bl	8003a4c <PrintString>
				exit(-1);
 80047f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80047fa:	f003 e942 	blx	8007a80 <exit>
	}

	// step servo positions and step pause/execution time
	for (int step = 0; step < CurrentMotion.Steps; step++)
	{
		for (i = 0; i < NUM_AX12_SERVOS; i++) {
 80047fe:	9b03      	ldr	r3, [sp, #12]
			if ( CurrentMotion.StepValues[step][i] > 1023 )
			{
				// obviously have unpacked rubbish, stop right here
				PrintString("\nUnpack Motion Page %i, Step %i - rubbish data. STOP.", StartPage, step+1);
				PrintString("\nServo ID%i, Step Value = %i, Min = %i, Max = %i \n", AX12_IDS[i], CurrentMotion.StepValues[step][i], SERVO_MIN_VALUES[i],SERVO_MAX_VALUES[i] );
				exit(-1);
 8004800:	3102      	adds	r1, #2
 8004802:	3202      	adds	r2, #2
	}

	// step servo positions and step pause/execution time
	for (int step = 0; step < CurrentMotion.Steps; step++)
	{
		for (i = 0; i < NUM_AX12_SERVOS; i++) {
 8004804:	2b12      	cmp	r3, #18
 8004806:	d1d4      	bne.n	80047b2 <unpackMotion2+0x5e>
				PrintString("\nServo ID%i, Step Value = %i, Min = %i, Max = %i \n", AX12_IDS[i], CurrentMotion.StepValues[step][i], SERVO_MIN_VALUES[i],SERVO_MAX_VALUES[i] );
				exit(-1);
			}
		}

		CurrentMotion.PauseTime[step] = motion->steps[step].pause * 8; //ms
 8004808:	f897 307e 	ldrb.w	r3, [r7, #126]
	{
		 CurrentMotion.JointFlex[i] = motion->joint_softness[i+1] & 0x0f; // actually both cw and ccw is sttored in 4 bits each, here we use the same value for both
	}

	// step servo positions and step pause/execution time
	for (int step = 0; step < CurrentMotion.Steps; step++)
 800480c:	3401      	adds	r4, #1
				PrintString("\nServo ID%i, Step Value = %i, Min = %i, Max = %i \n", AX12_IDS[i], CurrentMotion.StepValues[step][i], SERVO_MIN_VALUES[i],SERVO_MAX_VALUES[i] );
				exit(-1);
			}
		}

		CurrentMotion.PauseTime[step] = motion->steps[step].pause * 8; //ms
 800480e:	00db      	lsls	r3, r3, #3
 8004810:	f8a0 3114 	strh.w	r3, [r0, #276]
		CurrentMotion.PlayTime[step] = motion->steps[step].time * 8; //ms
 8004814:	f897 107f 	ldrb.w	r1, [r7, #127]
	{
		 CurrentMotion.JointFlex[i] = motion->joint_softness[i+1] & 0x0f; // actually both cw and ccw is sttored in 4 bits each, here we use the same value for both
	}

	// step servo positions and step pause/execution time
	for (int step = 0; step < CurrentMotion.Steps; step++)
 8004818:	3740      	adds	r7, #64
				exit(-1);
			}
		}

		CurrentMotion.PauseTime[step] = motion->steps[step].pause * 8; //ms
		CurrentMotion.PlayTime[step] = motion->steps[step].time * 8; //ms
 800481a:	00c9      	lsls	r1, r1, #3
 800481c:	f8a0 1122 	strh.w	r1, [r0, #290]

		// apply speed rate
		CurrentMotion.PauseTime[step] = (CurrentMotion.PauseTime[step] * motion->speed_rate) / 32; //ms
 8004820:	f89c 2016 	ldrb.w	r2, [ip, #22]
 8004824:	fb02 f303 	mul.w	r3, r2, r3
		CurrentMotion.PlayTime[step] = (CurrentMotion.PlayTime[step] * motion->speed_rate) / 32; //ms
 8004828:	fb02 f201 	mul.w	r2, r2, r1

		CurrentMotion.PauseTime[step] = motion->steps[step].pause * 8; //ms
		CurrentMotion.PlayTime[step] = motion->steps[step].time * 8; //ms

		// apply speed rate
		CurrentMotion.PauseTime[step] = (CurrentMotion.PauseTime[step] * motion->speed_rate) / 32; //ms
 800482c:	115b      	asrs	r3, r3, #5
		CurrentMotion.PlayTime[step] = (CurrentMotion.PlayTime[step] * motion->speed_rate) / 32; //ms
 800482e:	1152      	asrs	r2, r2, #5

		CurrentMotion.PauseTime[step] = motion->steps[step].pause * 8; //ms
		CurrentMotion.PlayTime[step] = motion->steps[step].time * 8; //ms

		// apply speed rate
		CurrentMotion.PauseTime[step] = (CurrentMotion.PauseTime[step] * motion->speed_rate) / 32; //ms
 8004830:	f8a0 3114 	strh.w	r3, [r0, #276]
		CurrentMotion.PlayTime[step] = (CurrentMotion.PlayTime[step] * motion->speed_rate) / 32; //ms
 8004834:	f8a0 2122 	strh.w	r2, [r0, #290]
	{
		 CurrentMotion.JointFlex[i] = motion->joint_softness[i+1] & 0x0f; // actually both cw and ccw is sttored in 4 bits each, here we use the same value for both
	}

	// step servo positions and step pause/execution time
	for (int step = 0; step < CurrentMotion.Steps; step++)
 8004838:	3002      	adds	r0, #2
 800483a:	9e07      	ldr	r6, [sp, #28]
 800483c:	42b4      	cmp	r4, r6
 800483e:	da0b      	bge.n	8004858 <unpackMotion2+0x104>
 8004840:	1c63      	adds	r3, r4, #1
 8004842:	4a06      	ldr	r2, [pc, #24]	(800485c <unpackMotion2+0x108>)
 8004844:	eb0c 1183 	add.w	r1, ip, r3, lsl #6
 8004848:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 800484c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8004850:	f103 0218 	add.w	r2, r3, #24	; 0x18
 8004854:	2500      	movs	r5, #0
 8004856:	e7ad      	b.n	80047b4 <unpackMotion2+0x60>
		CurrentMotion.PauseTime[step] = (CurrentMotion.PauseTime[step] * motion->speed_rate) / 32; //ms
		CurrentMotion.PlayTime[step] = (CurrentMotion.PlayTime[step] * motion->speed_rate) / 32; //ms
	}

	// printCurrentMotionPage();
}
 8004858:	b009      	add	sp, #36
 800485a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800485c:	20000e24 	.word	0x20000e24
 8004860:	080081c2 	.word	0x080081c2
 8004864:	08007c3e 	.word	0x08007c3e
 8004868:	08007bd6 	.word	0x08007bd6
 800486c:	08007bfa 	.word	0x08007bfa
 8004870:	080081f8 	.word	0x080081f8

08004874 <executeMotion>:
// It waits for the motion to finish to return control, so it's no good 
// for a command loop
// StartPage - number of the first motion page in the motion
// Returns (int) StartPage of next motion in sequence (0 - no further motions)
int executeMotion(int StartPage)
{
 8004874:	b5f0      	push	{r4, r5, r6, r7, lr}
	// temporary array of timings to keep track of step timing
	unsigned long step_times[MAX_MOTION_STEPS];
	unsigned long pre_step_time, total_time;

	// set the currently executed motion page global variable
	current_motion_page = StartPage;
 8004876:	4b28      	ldr	r3, [pc, #160]	(8004918 <executeMotion+0xa4>)
 8004878:	b2c2      	uxtb	r2, r0
// It waits for the motion to finish to return control, so it's no good 
// for a command loop
// StartPage - number of the first motion page in the motion
// Returns (int) StartPage of next motion in sequence (0 - no further motions)
int executeMotion(int StartPage)
{
 800487a:	b08b      	sub	sp, #44
	// temporary array of timings to keep track of step timing
	unsigned long step_times[MAX_MOTION_STEPS];
	unsigned long pre_step_time, total_time;

	// set the currently executed motion page global variable
	current_motion_page = StartPage;
 800487c:	701a      	strb	r2, [r3, #0]
	
	// first step is to unpack the motion
	unpackMotion(StartPage);
 800487e:	f7ff ff69 	bl	8004754 <unpackMotion2>
	
	// now we can process the joint flexibility values
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
		// translation is bit shift operation (see AX-12 manual)
		complianceSlope = 1<<CurrentMotion.JointFlex[i]; 
		dxl_write_byte(AX12_IDS[i], DXL_CCW_COMPLIANCE_SLOPE, complianceSlope);
 8004882:	4f26      	ldr	r7, [pc, #152]	(800491c <executeMotion+0xa8>)

	// set the currently executed motion page global variable
	current_motion_page = StartPage;
	
	// first step is to unpack the motion
	unpackMotion(StartPage);
 8004884:	2600      	movs	r6, #0
	
	// now we can process the joint flexibility values
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
		// translation is bit shift operation (see AX-12 manual)
		complianceSlope = 1<<CurrentMotion.JointFlex[i]; 
 8004886:	4826      	ldr	r0, [pc, #152]	(8004920 <executeMotion+0xac>)
 8004888:	2101      	movs	r1, #1
 800488a:	5d84      	ldrb	r4, [r0, r6]
		dxl_write_byte(AX12_IDS[i], DXL_CCW_COMPLIANCE_SLOPE, complianceSlope);
 800488c:	5dbd      	ldrb	r5, [r7, r6]
	unpackMotion(StartPage);
	
	// now we can process the joint flexibility values
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
		// translation is bit shift operation (see AX-12 manual)
		complianceSlope = 1<<CurrentMotion.JointFlex[i]; 
 800488e:	fa11 f404 	lsls.w	r4, r1, r4
 8004892:	b2e4      	uxtb	r4, r4
		dxl_write_byte(AX12_IDS[i], DXL_CCW_COMPLIANCE_SLOPE, complianceSlope);
 8004894:	211d      	movs	r1, #29
 8004896:	4622      	mov	r2, r4
 8004898:	4628      	mov	r0, r5
 800489a:	f7ff fc4b 	bl	8004134 <dxl_write_byte>
		dxl_write_byte(AX12_IDS[i], DXL_CW_COMPLIANCE_SLOPE, complianceSlope);
 800489e:	3601      	adds	r6, #1
 80048a0:	211c      	movs	r1, #28
 80048a2:	4628      	mov	r0, r5
 80048a4:	4622      	mov	r2, r4
 80048a6:	f7ff fc45 	bl	8004134 <dxl_write_byte>
	
	// first step is to unpack the motion
	unpackMotion(StartPage);
	
	// now we can process the joint flexibility values
	for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
 80048aa:	2e12      	cmp	r6, #18
 80048ac:	d1eb      	bne.n	8004886 <executeMotion+0x12>
		dxl_write_byte(AX12_IDS[i], DXL_CCW_COMPLIANCE_SLOPE, complianceSlope);
		dxl_write_byte(AX12_IDS[i], DXL_CW_COMPLIANCE_SLOPE, complianceSlope);

	}
	
	total_time = getMillis();
 80048ae:	f000 fec3 	bl	8005638 <getMillis>
 80048b2:	2601      	movs	r6, #1
	
	// in case the motion repeats we need a loop
	for (int r=1; r<=CurrentMotion.RepeatTime; r++)
 80048b4:	4f1a      	ldr	r7, [pc, #104]	(8004920 <executeMotion+0xac>)
 80048b6:	e022      	b.n	80048fe <executeMotion+0x8a>
		// loop over the steps and execute poses
		for (int s=0; s<CurrentMotion.Steps; s++)
		{
			// create the servo values array 
			for (int j=0; j<NUM_AX12_SERVOS; j++)
				{ goalPose[j] = CurrentMotion.StepValues[s][j]; }
 80048b8:	f833 1b02 	ldrh.w	r1, [r3], #2
 80048bc:	a801      	add	r0, sp, #4
 80048be:	5281      	strh	r1, [r0, r2]
 80048c0:	3202      	adds	r2, #2
	{
		// loop over the steps and execute poses
		for (int s=0; s<CurrentMotion.Steps; s++)
		{
			// create the servo values array 
			for (int j=0; j<NUM_AX12_SERVOS; j++)
 80048c2:	2a24      	cmp	r2, #36
 80048c4:	d1f8      	bne.n	80048b8 <executeMotion+0x44>
				{ goalPose[j] = CurrentMotion.StepValues[s][j]; }
			// take the time
			pre_step_time = getMillis();
 80048c6:	f000 feb7 	bl	8005638 <getMillis>
			// execute each pose 
			moveToGoalPose(CurrentMotion.PlayTime[s], goalPose, WAIT_FOR_POSE_FINISH);
 80048ca:	a901      	add	r1, sp, #4
 80048cc:	2201      	movs	r2, #1
 80048ce:	f8b5 0122 	ldrh.w	r0, [r5, #290]
 80048d2:	f000 fbb7 	bl	8005044 <moveToGoalPose>
			// store the time
			step_times[s] = getMillis() - pre_step_time;
 80048d6:	f000 feaf 	bl	8005638 <getMillis>
			
			// now pause if required
			if(CurrentMotion.PauseTime[s] > 0) 
 80048da:	f8b5 0114 	ldrh.w	r0, [r5, #276]
 80048de:	b108      	cbz	r0, 80048e4 <executeMotion+0x70>
				{ mDelay(CurrentMotion.PauseTime[s]); }
 80048e0:	f000 fe52 	bl	8005588 <mDelay>
	
	// in case the motion repeats we need a loop
	for (int r=1; r<=CurrentMotion.RepeatTime; r++)
	{
		// loop over the steps and execute poses
		for (int s=0; s<CurrentMotion.Steps; s++)
 80048e4:	3401      	adds	r4, #1
 80048e6:	3502      	adds	r5, #2
 80048e8:	7dfb      	ldrb	r3, [r7, #23]
 80048ea:	429c      	cmp	r4, r3
 80048ec:	da06      	bge.n	80048fc <executeMotion+0x88>
 80048ee:	eb04 03c4 	add.w	r3, r4, r4, lsl #3
 80048f2:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80048f6:	3318      	adds	r3, #24
 80048f8:	2200      	movs	r2, #0
 80048fa:	e7dd      	b.n	80048b8 <executeMotion+0x44>
	}
	
	total_time = getMillis();
	
	// in case the motion repeats we need a loop
	for (int r=1; r<=CurrentMotion.RepeatTime; r++)
 80048fc:	3601      	adds	r6, #1
 80048fe:	7d3b      	ldrb	r3, [r7, #20]
 8004900:	4c07      	ldr	r4, [pc, #28]	(8004920 <executeMotion+0xac>)
 8004902:	429e      	cmp	r6, r3
 8004904:	dc02      	bgt.n	800490c <executeMotion+0x98>
 8004906:	4625      	mov	r5, r4
 8004908:	2400      	movs	r4, #0
 800490a:	e7ed      	b.n	80048e8 <executeMotion+0x74>
			if(CurrentMotion.PauseTime[s] > 0) 
				{ mDelay(CurrentMotion.PauseTime[s]); }
		}
	}
	
	total_time = getMillis() - total_time;
 800490c:	f000 fe94 	bl	8005638 <getMillis>
 8004910:	7ca0      	ldrb	r0, [r4, #18]
	// TEST: for (int s=0; s<CurrentMotion.Steps; s++) { printf(" %lu,", step_times[s]); }
	// TEST: printf(" Total: %lu", total_time);
	
	// return the page of the next motion in sequence
	return (int) CurrentMotion.NextPage;	
}
 8004912:	b00b      	add	sp, #44
 8004914:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004916:	46c0      	nop			(mov r8, r8)
 8004918:	20000f79 	.word	0x20000f79
 800491c:	08007c3e 	.word	0x08007c3e
 8004920:	20000e24 	.word	0x20000e24

08004924 <executeMotionExitPage>:
}

// This function executes the exit page motion for the  
// current motion page
 void executeMotionExitPage()
{
 8004924:	b500      	push	{lr}
	int	NextPage;
	
	// find the exit page
	NextPage = CurrentMotion.ExitPage;
 8004926:	4b04      	ldr	r3, [pc, #16]	(8004938 <executeMotionExitPage+0x14>)
}

// This function executes the exit page motion for the  
// current motion page
 void executeMotionExitPage()
{
 8004928:	b081      	sub	sp, #4
	int	NextPage;
	
	// find the exit page
	NextPage = CurrentMotion.ExitPage;
 800492a:	7cd8      	ldrb	r0, [r3, #19]
	// execute the exit page if it exists
	if (NextPage != 0)
 800492c:	b108      	cbz	r0, 8004932 <executeMotionExitPage+0xe>
	{
		executeMotion(NextPage);
 800492e:	f7ff ffa1 	bl	8004874 <executeMotion>
	}
}
 8004932:	b001      	add	sp, #4
 8004934:	bd00      	pop	{pc}
 8004936:	46c0      	nop			(mov r8, r8)
 8004938:	20000e24 	.word	0x20000e24

0800493c <motionPageInit>:


// Initialize the motion pages by constructing a table of pointers to each page
// Motion pages are stored in Flash (PROGMEM) - see motion.h
void motionPageInit()
{
 800493c:	b500      	push	{lr}
	// first we need to check file matches the configuration defined
	for (int i=0; i<MAX_AX12_SERVOS; i++)
	{
		if (AX12_ENABLED[i] != AX12Servos[i])
 800493e:	f8df c02c 	ldr.w	ip, [pc, #44]	; 800496c <motionPageInit+0x30>
 8004942:	480b      	ldr	r0, [pc, #44]	(8004970 <motionPageInit+0x34>)


// Initialize the motion pages by constructing a table of pointers to each page
// Motion pages are stored in Flash (PROGMEM) - see motion.h
void motionPageInit()
{
 8004944:	b081      	sub	sp, #4
 8004946:	2100      	movs	r1, #0
	// first we need to check file matches the configuration defined
	for (int i=0; i<MAX_AX12_SERVOS; i++)
	{
		if (AX12_ENABLED[i] != AX12Servos[i])
 8004948:	f81c 2001 	ldrb.w	r2, [ip, r1]
 800494c:	5c43      	ldrb	r3, [r0, r1]
 800494e:	429a      	cmp	r2, r3
 8004950:	d006      	beq.n	8004960 <motionPageInit+0x24>
		{
			// configuration does not match
			PrintString("\nConfiguration of enabled AX-12 servos does not match motion.h. ABORT!\n");
 8004952:	4808      	ldr	r0, [pc, #32]	(8004974 <motionPageInit+0x38>)
 8004954:	f7ff f87a 	bl	8003a4c <PrintString>
			exit(-1);
 8004958:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800495c:	f003 e890 	blx	8007a80 <exit>
// Initialize the motion pages by constructing a table of pointers to each page
// Motion pages are stored in Flash (PROGMEM) - see motion.h
void motionPageInit()
{
	// first we need to check file matches the configuration defined
	for (int i=0; i<MAX_AX12_SERVOS; i++)
 8004960:	3101      	adds	r1, #1
 8004962:	291a      	cmp	r1, #26
 8004964:	d1f0      	bne.n	8004948 <motionPageInit+0xc>
//	motion_pointer[224] = (void*) &MotionPage224;
//	motion_pointer[225] = (void*) &MotionPage225;
//	motion_pointer[226] = (void*) &MotionPage226;
//	motion_pointer[227] = (void*) &MotionPage227;
#endif // use_old_motions_code
}
 8004966:	b001      	add	sp, #4
 8004968:	bd00      	pop	{pc}
 800496a:	46c0      	nop			(mov r8, r8)
 800496c:	08007bbc 	.word	0x08007bbc
 8004970:	08007c24 	.word	0x08007c24
 8004974:	0800822b 	.word	0x0800822b

08004978 <executeMotionSequence>:
// pages defined in motion.h
// It implements a finite state machine to know what it is doing and what to do next
// Code is meant to be reentrant so it can easily be converted to a task with a RTOS
// Returns:		motion_state
uint8 executeMotionSequence()
{
 8004978:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	// TEST: if ( motion_state != MOTION_STOPPED ) printf("\nMotion State = %i, Walk State = %i, Current Step = %i", motion_state, walk_getWalkState(), current_step);
	
	// check the states in order of likelihood of occurrence
	// the most likely state is that a motion step is still being executed or paused
	if ( motion_state == STEP_IN_MOTION )
 800497a:	4cd1      	ldr	r4, [pc, #836]	(8004cc0 <executeMotionSequence+0x348>)
// pages defined in motion.h
// It implements a finite state machine to know what it is doing and what to do next
// Code is meant to be reentrant so it can easily be converted to a task with a RTOS
// Returns:		motion_state
uint8 executeMotionSequence()
{
 800497c:	b083      	sub	sp, #12
	
	// TEST: if ( motion_state != MOTION_STOPPED ) printf("\nMotion State = %i, Walk State = %i, Current Step = %i", motion_state, walk_getWalkState(), current_step);
	
	// check the states in order of likelihood of occurrence
	// the most likely state is that a motion step is still being executed or paused
	if ( motion_state == STEP_IN_MOTION )
 800497e:	7823      	ldrb	r3, [r4, #0]
 8004980:	2b01      	cmp	r3, #1
 8004982:	d10f      	bne.n	80049a4 <executeMotionSequence+0x2c>
	{
		// if walking we can't wait for motion to finish, go by step time instead
//		if( walk_getWalkState() != 0 ) {
			if ( (getMillis()-step_start_time) >= CurrentMotion.PlayTime[current_step-1] ) {
 8004984:	f000 fe58 	bl	8005638 <getMillis>
 8004988:	4bce      	ldr	r3, [pc, #824]	(8004cc4 <executeMotionSequence+0x34c>)
 800498a:	681b      	ldr	r3, [r3, #0]
 800498c:	1ac0      	subs	r0, r0, r3
 800498e:	4bce      	ldr	r3, [pc, #824]	(8004cc8 <executeMotionSequence+0x350>)
 8004990:	781a      	ldrb	r2, [r3, #0]
 8004992:	4bce      	ldr	r3, [pc, #824]	(8004ccc <executeMotionSequence+0x354>)
 8004994:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8004998:	f8b3 3120 	ldrh.w	r3, [r3, #288]
 800499c:	4298      	cmp	r0, r3
 800499e:	d314      	bcc.n	80049ca <executeMotionSequence+0x52>
				// step time is up, update state
				motion_state = STEP_FINISHED;
 80049a0:	2303      	movs	r3, #3
 80049a2:	e010      	b.n	80049c6 <executeMotionSequence+0x4e>
//			} else {
//				// step isn't finished yet, return
//				return motion_state;
//			}
//		}
	} else if( motion_state == STEP_IN_PAUSE ) {
 80049a4:	2b02      	cmp	r3, #2
 80049a6:	d112      	bne.n	80049ce <executeMotionSequence+0x56>
		// check if we still need to wait for pause time to expire
		if ( (getMillis()-pause_start_time) >= CurrentMotion.PauseTime[current_step-1] )
 80049a8:	f000 fe46 	bl	8005638 <getMillis>
 80049ac:	4bc8      	ldr	r3, [pc, #800]	(8004cd0 <executeMotionSequence+0x358>)
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	1ac0      	subs	r0, r0, r3
 80049b2:	4bc5      	ldr	r3, [pc, #788]	(8004cc8 <executeMotionSequence+0x350>)
 80049b4:	781a      	ldrb	r2, [r3, #0]
 80049b6:	4bc5      	ldr	r3, [pc, #788]	(8004ccc <executeMotionSequence+0x354>)
 80049b8:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80049bc:	f8b3 3112 	ldrh.w	r3, [r3, #274]
 80049c0:	4298      	cmp	r0, r3
 80049c2:	d302      	bcc.n	80049ca <executeMotionSequence+0x52>
		{
			// pause is finished, update state
			motion_state = PAUSE_FINISHED;
 80049c4:	2304      	movs	r3, #4
 80049c6:	7023      	strb	r3, [r4, #0]
 80049c8:	e001      	b.n	80049ce <executeMotionSequence+0x56>
		} else {
			// pause isn't finished yet, return
			return motion_state;
 80049ca:	7820      	ldrb	r0, [r4, #0]
 80049cc:	e176      	b.n	8004cbc <executeMotionSequence+0x344>
	}
	
	// Next we check for any movement related alarms - at this point the only way the
	// motion state can be STEP_FINISHED is because it was changed above
	// Given this takes 11ms, that's too long for walking (may have to revisit)
	if ( motion_state == STEP_FINISHED && walk_getWalkState() == 0 )
 80049ce:	4bbc      	ldr	r3, [pc, #752]	(8004cc0 <executeMotionSequence+0x348>)
 80049d0:	781b      	ldrb	r3, [r3, #0]
 80049d2:	2b03      	cmp	r3, #3
 80049d4:	d11e      	bne.n	8004a14 <executeMotionSequence+0x9c>
 80049d6:	f000 fba5 	bl	8005124 <walk_getWalkState>
 80049da:	b9d8      	cbnz	r0, 8004a14 <executeMotionSequence+0x9c>
	{
		// check that executing the last step didn't cause any alarms (takes 5ms)
		for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
			// ping the servo and unpack error code (if any)
			error_status = dxl_ping(AX12_IDS[i]);
 80049dc:	4fbd      	ldr	r7, [pc, #756]	(8004cd4 <executeMotionSequence+0x35c>)
	}
	
	// Next we check for any movement related alarms - at this point the only way the
	// motion state can be STEP_FINISHED is because it was changed above
	// Given this takes 11ms, that's too long for walking (may have to revisit)
	if ( motion_state == STEP_FINISHED && walk_getWalkState() == 0 )
 80049de:	2400      	movs	r4, #0
	{
		// check that executing the last step didn't cause any alarms (takes 5ms)
		for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
			// ping the servo and unpack error code (if any)
			error_status = dxl_ping(AX12_IDS[i]);
 80049e0:	5d3e      	ldrb	r6, [r7, r4]
 80049e2:	4630      	mov	r0, r6
 80049e4:	f7ff fbf0 	bl	80041c8 <dxl_ping>
 80049e8:	4605      	mov	r5, r0
			if(error_status != 0) {
 80049ea:	b170      	cbz	r0, 8004a0a <executeMotionSequence+0x92>
				// there has been an error, disable torque
				comm_status = dxl_write_byte(BROADCAST_ID, DXL_TORQUE_ENABLE, 0);
 80049ec:	2118      	movs	r1, #24
 80049ee:	2200      	movs	r2, #0
 80049f0:	20fe      	movs	r0, #254
 80049f2:	f7ff fb9f 	bl	8004134 <dxl_write_byte>
				PrintString("\nexecuteMotionSequence Alarm ID%i - Error Code %i\n", AX12_IDS[i], error_status);
 80049f6:	462a      	mov	r2, r5
 80049f8:	48b7      	ldr	r0, [pc, #732]	(8004cd8 <executeMotionSequence+0x360>)
 80049fa:	4631      	mov	r1, r6
 80049fc:	f7ff f826 	bl	8003a4c <PrintString>
				motion_state = MOTION_ALARM;
 8004a00:	4baf      	ldr	r3, [pc, #700]	(8004cc0 <executeMotionSequence+0x348>)
 8004a02:	2206      	movs	r2, #6
 8004a04:	701a      	strb	r2, [r3, #0]
 8004a06:	2006      	movs	r0, #6
 8004a08:	e158      	b.n	8004cbc <executeMotionSequence+0x344>
				return motion_state;
 8004a0a:	3401      	adds	r4, #1
	// motion state can be STEP_FINISHED is because it was changed above
	// Given this takes 11ms, that's too long for walking (may have to revisit)
	if ( motion_state == STEP_FINISHED && walk_getWalkState() == 0 )
	{
		// check that executing the last step didn't cause any alarms (takes 5ms)
		for (uint8 i=0; i<NUM_AX12_SERVOS; i++) {
 8004a0c:	2c12      	cmp	r4, #18
 8004a0e:	d1e7      	bne.n	80049e0 <executeMotionSequence+0x68>
				motion_state = MOTION_ALARM;
				return motion_state;
			}
		}	
		// no alarm has occurred, read back current pose (takes 6ms)
		readCurrentPose();
 8004a10:	f000 fac4 	bl	8004f9c <readCurrentPose>
	}
	
	// We also need to check if we received a RESET command after alarm shutdown
	if ( motion_state == MOTION_ALARM && bioloid_command == COMMAND_RESET )
 8004a14:	4caa      	ldr	r4, [pc, #680]	(8004cc0 <executeMotionSequence+0x348>)
 8004a16:	7823      	ldrb	r3, [r4, #0]
 8004a18:	2b06      	cmp	r3, #6
 8004a1a:	d110      	bne.n	8004a3e <executeMotionSequence+0xc6>
 8004a1c:	4baf      	ldr	r3, [pc, #700]	(8004cdc <executeMotionSequence+0x364>)
 8004a1e:	781b      	ldrb	r3, [r3, #0]
 8004a20:	2b18      	cmp	r3, #24
 8004a22:	d10c      	bne.n	8004a3e <executeMotionSequence+0xc6>
	{
		// Reset the Dynamixel actuators - reset torque limit and re-enable torque
		comm_status = dxl_write_word(BROADCAST_ID, DXL_TORQUE_LIMIT_L, 0x3FF);
 8004a24:	2122      	movs	r1, #34
 8004a26:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8004a2a:	20fe      	movs	r0, #254
 8004a2c:	f7ff fb3a 	bl	80040a4 <dxl_write_word>
		comm_status = dxl_write_byte(BROADCAST_ID, DXL_TORQUE_ENABLE, 1);
 8004a30:	20fe      	movs	r0, #254
 8004a32:	2118      	movs	r1, #24
 8004a34:	2201      	movs	r2, #1
 8004a36:	f7ff fb7d 	bl	8004134 <dxl_write_byte>
		motion_state = MOTION_STOPPED;
 8004a3a:	2300      	movs	r3, #0
 8004a3c:	7023      	strb	r3, [r4, #0]
	//				6. Switch to NextPage
	//				7. Respond to a new non-walk command 
	//				8. Nothing to do - wait for new command
	
	// first we deal with state changes at the end of a motion page
	if ( current_step == CurrentMotion.Steps && (motion_state == STEP_FINISHED || motion_state == PAUSE_FINISHED) )
 8004a3e:	4ba2      	ldr	r3, [pc, #648]	(8004cc8 <executeMotionSequence+0x350>)
 8004a40:	4ea2      	ldr	r6, [pc, #648]	(8004ccc <executeMotionSequence+0x354>)
 8004a42:	7819      	ldrb	r1, [r3, #0]
 8004a44:	7df4      	ldrb	r4, [r6, #23]
 8004a46:	42a1      	cmp	r1, r4
 8004a48:	f040 808e 	bne.w	8004b68 <executeMotionSequence+0x1f0>
 8004a4c:	4f9c      	ldr	r7, [pc, #624]	(8004cc0 <executeMotionSequence+0x348>)
 8004a4e:	783b      	ldrb	r3, [r7, #0]
 8004a50:	3b03      	subs	r3, #3
 8004a52:	b2db      	uxtb	r3, r3
 8004a54:	2b01      	cmp	r3, #1
 8004a56:	f200 8087 	bhi.w	8004b68 <executeMotionSequence+0x1f0>
	{
		PrintString("Motion step finished: nextPage %d\n", CurrentMotion.NextPage);
 8004a5a:	7cb1      	ldrb	r1, [r6, #18]
 8004a5c:	48a0      	ldr	r0, [pc, #640]	(8004ce0 <executeMotionSequence+0x368>)
 8004a5e:	f7fe fff5 	bl	8003a4c <PrintString>
		// check if we just finished an exit page
		if ( exit_flag == 1 )
 8004a62:	f8df c280 	ldr.w	ip, [pc, #640]	; 8004ce4 <executeMotionSequence+0x36c>
 8004a66:	f89c 3000 	ldrb.w	r3, [ip]
 8004a6a:	2b01      	cmp	r3, #1
 8004a6c:	d10c      	bne.n	8004a88 <executeMotionSequence+0x110>
		{
			if ( CurrentMotion.ExitPage != 0 ) {
 8004a6e:	7cf1      	ldrb	r1, [r6, #19]
 8004a70:	b131      	cbz	r1, 8004a80 <executeMotionSequence+0x108>
				// go to next exit page, then check again.
				PrintString("Going to exit page (from exit page): %d\n", CurrentMotion.ExitPage);
 8004a72:	489d      	ldr	r0, [pc, #628]	(8004ce8 <executeMotionSequence+0x370>)
 8004a74:	f7fe ffea 	bl	8003a4c <PrintString>
				current_motion_page = CurrentMotion.ExitPage;
 8004a78:	7cf2      	ldrb	r2, [r6, #19]
 8004a7a:	4b9c      	ldr	r3, [pc, #624]	(8004cec <executeMotionSequence+0x374>)
 8004a7c:	701a      	strb	r2, [r3, #0]
 8004a7e:	e054      	b.n	8004b2a <executeMotionSequence+0x1b2>
			} else {
				// yes, reset flag and change motion state and then return to not complicate things
				exit_flag = 0;
 8004a80:	f88c 1000 	strb.w	r1, [ip]
				motion_state = MOTION_STOPPED;
 8004a84:	7039      	strb	r1, [r7, #0]
 8004a86:	e005      	b.n	8004a94 <executeMotionSequence+0x11c>
				return motion_state;
			}
		}
		
		// we have finished the current page - determine the next motion page
		else if ( bioloid_command == COMMAND_STOP )
 8004a88:	4b94      	ldr	r3, [pc, #592]	(8004cdc <executeMotionSequence+0x364>)
 8004a8a:	781b      	ldrb	r3, [r3, #0]
 8004a8c:	b953      	cbnz	r3, 8004aa4 <executeMotionSequence+0x12c>
		{
		// Option 1 - switch to exit page
			if ( CurrentMotion.ExitPage == 0 ) {
 8004a8e:	7cf2      	ldrb	r2, [r6, #19]
 8004a90:	b912      	cbnz	r2, 8004a98 <executeMotionSequence+0x120>
				// no exit page, stop
				motion_state = MOTION_STOPPED;
 8004a92:	703a      	strb	r2, [r7, #0]
 8004a94:	2000      	movs	r0, #0
 8004a96:	e111      	b.n	8004cbc <executeMotionSequence+0x344>
				return motion_state;
			} else {
				// need to execute an Exit Page before stopping		
				//printf("Going to exit page: %d\n", CurrentMotion.ExitPage);
				current_motion_page = CurrentMotion.ExitPage;
 8004a98:	4b94      	ldr	r3, [pc, #592]	(8004cec <executeMotionSequence+0x374>)
 8004a9a:	701a      	strb	r2, [r3, #0]
				exit_flag = 1;		// flag that we need to stop after the exit page
 8004a9c:	2301      	movs	r3, #1
 8004a9e:	f88c 3000 	strb.w	r3, [ip]
 8004aa2:	e042      	b.n	8004b2a <executeMotionSequence+0x1b2>
			}
		} 
		// Option 2 - respond to change in walk command (seamless transitions only)
		else if ( new_command == TRUE ) 
 8004aa4:	4c92      	ldr	r4, [pc, #584]	(8004cf0 <executeMotionSequence+0x378>)
 8004aa6:	7823      	ldrb	r3, [r4, #0]
 8004aa8:	2b01      	cmp	r3, #1
 8004aaa:	461d      	mov	r5, r3
 8004aac:	d113      	bne.n	8004ad6 <executeMotionSequence+0x15e>
		{
			if ( walk_shift() == 1 ) {
 8004aae:	f8cd c004 	str.w	ip, [sp, #4]
 8004ab2:	f000 fb3d 	bl	8005130 <walk_shift>
 8004ab6:	2801      	cmp	r0, #1
 8004ab8:	f8dd c004 	ldr.w	ip, [sp, #4]
 8004abc:	d101      	bne.n	8004ac2 <executeMotionSequence+0x14a>
				// walkShift already updates the current motion page
				new_command = FALSE;
 8004abe:	2300      	movs	r3, #0
 8004ac0:	e02b      	b.n	8004b1a <executeMotionSequence+0x1a2>
			} else {
				// to transition to new command we first need to execute the exit page
				if ( CurrentMotion.ExitPage == 0 ) {
 8004ac2:	7cf3      	ldrb	r3, [r6, #19]
 8004ac4:	4c89      	ldr	r4, [pc, #548]	(8004cec <executeMotionSequence+0x374>)
 8004ac6:	b913      	cbnz	r3, 8004ace <executeMotionSequence+0x156>
					// no exit page
					current_motion_page = 0;
 8004ac8:	7023      	strb	r3, [r4, #0]
					motion_state = MOTION_STOPPED;
 8004aca:	703b      	strb	r3, [r7, #0]
 8004acc:	e7e2      	b.n	8004a94 <executeMotionSequence+0x11c>
					return motion_state;
				} else {
					// need to execute an Exit Page before new command		
					current_motion_page = CurrentMotion.ExitPage;
 8004ace:	7023      	strb	r3, [r4, #0]
					exit_flag = 1;		// flag that we need to stop after the exit page
 8004ad0:	f88c 5000 	strb.w	r5, [ip]
 8004ad4:	e029      	b.n	8004b2a <executeMotionSequence+0x1b2>
				}				
			}	
		} 
		// Option 5 - repeat the current motion page
		else if ( CurrentMotion.RepeatTime > repeat_counter )
 8004ad6:	4c87      	ldr	r4, [pc, #540]	(8004cf4 <executeMotionSequence+0x37c>)
 8004ad8:	7d33      	ldrb	r3, [r6, #20]
 8004ada:	7821      	ldrb	r1, [r4, #0]
 8004adc:	428b      	cmp	r3, r1
 8004ade:	d913      	bls.n	8004b08 <executeMotionSequence+0x190>
		{
			PrintString("Repeating motion page (%d'th time): %d\n", repeat_counter+1, current_motion_page);
 8004ae0:	4b82      	ldr	r3, [pc, #520]	(8004cec <executeMotionSequence+0x374>)
 8004ae2:	3101      	adds	r1, #1
 8004ae4:	781a      	ldrb	r2, [r3, #0]
 8004ae6:	4884      	ldr	r0, [pc, #528]	(8004cf8 <executeMotionSequence+0x380>)
 8004ae8:	f7fe ffb0 	bl	8003a4c <PrintString>
			// Update step, repeat counter and motion status
			current_step = 1;
 8004aec:	4b76      	ldr	r3, [pc, #472]	(8004cc8 <executeMotionSequence+0x350>)
 8004aee:	2201      	movs	r2, #1
 8004af0:	701a      	strb	r2, [r3, #0]
			repeat_counter++;
 8004af2:	7823      	ldrb	r3, [r4, #0]
			motion_state = STEP_IN_MOTION;
 8004af4:	703a      	strb	r2, [r7, #0]
		else if ( CurrentMotion.RepeatTime > repeat_counter )
		{
			PrintString("Repeating motion page (%d'th time): %d\n", repeat_counter+1, current_motion_page);
			// Update step, repeat counter and motion status
			current_step = 1;
			repeat_counter++;
 8004af6:	3301      	adds	r3, #1
 8004af8:	7023      	strb	r3, [r4, #0]
			motion_state = STEP_IN_MOTION;
			// can go straight to executing step 1 since we have executed this page before
			step_start_time = executeMotionStep(current_step);
 8004afa:	2001      	movs	r0, #1
 8004afc:	f7ff fdd8 	bl	80046b0 <executeMotionStep>
 8004b00:	4b70      	ldr	r3, [pc, #448]	(8004cc4 <executeMotionSequence+0x34c>)
 8004b02:	6018      	str	r0, [r3, #0]
			return motion_state;
 8004b04:	7838      	ldrb	r0, [r7, #0]
 8004b06:	e0d9      	b.n	8004cbc <executeMotionSequence+0x344>
		} 
		// Option 6 - switch to NextPage motion page
		else if ( CurrentMotion.NextPage > 0 && CurrentMotion.NextPage <= NUM_MOTION_PAGES )
 8004b08:	7cb5      	ldrb	r5, [r6, #18]
 8004b0a:	4c78      	ldr	r4, [pc, #480]	(8004cec <executeMotionSequence+0x374>)
 8004b0c:	b13d      	cbz	r5, 8004b1e <executeMotionSequence+0x1a6>
		{
			PrintString("Switching to next motion page: %d -> %d\n", current_motion_page, CurrentMotion.NextPage);
 8004b0e:	7821      	ldrb	r1, [r4, #0]
 8004b10:	487a      	ldr	r0, [pc, #488]	(8004cfc <executeMotionSequence+0x384>)
 8004b12:	462a      	mov	r2, r5
 8004b14:	f7fe ff9a 	bl	8003a4c <PrintString>
			current_motion_page = CurrentMotion.NextPage;
 8004b18:	7cb3      	ldrb	r3, [r6, #18]
 8004b1a:	7023      	strb	r3, [r4, #0]
 8004b1c:	e005      	b.n	8004b2a <executeMotionSequence+0x1b2>
		}
		// Nothing else to do - stop motion
		else
		{
			PrintString("Finished motion page: %d\n", current_motion_page);
 8004b1e:	7821      	ldrb	r1, [r4, #0]
 8004b20:	4877      	ldr	r0, [pc, #476]	(8004d00 <executeMotionSequence+0x388>)
 8004b22:	f7fe ff93 	bl	8003a4c <PrintString>
			motion_state = MOTION_STOPPED;
 8004b26:	703d      	strb	r5, [r7, #0]
 8004b28:	e7b4      	b.n	8004a94 <executeMotionSequence+0x11c>
			return motion_state;
		}

		// in Options 1,2,6 above we had a change of motion page - start execution
		unpackMotion(current_motion_page);
 8004b2a:	4b70      	ldr	r3, [pc, #448]	(8004cec <executeMotionSequence+0x374>)
 8004b2c:	4c64      	ldr	r4, [pc, #400]	(8004cc0 <executeMotionSequence+0x348>)
 8004b2e:	7818      	ldrb	r0, [r3, #0]
 8004b30:	f7ff fe10 	bl	8004754 <unpackMotion2>
		if ( setMotionPageJointFlexibility() == 0 ) {
 8004b34:	f7ff fdda 	bl	80046ec <setMotionPageJointFlexibility>
 8004b38:	b958      	cbnz	r0, 8004b52 <executeMotionSequence+0x1da>
			// joint flex values set ok, execute motion
			current_step = 1;
 8004b3a:	4b63      	ldr	r3, [pc, #396]	(8004cc8 <executeMotionSequence+0x350>)
 8004b3c:	2201      	movs	r2, #1
 8004b3e:	701a      	strb	r2, [r3, #0]
			repeat_counter = 1;
 8004b40:	4b6c      	ldr	r3, [pc, #432]	(8004cf4 <executeMotionSequence+0x37c>)
			motion_state = STEP_IN_MOTION;
 8004b42:	7022      	strb	r2, [r4, #0]
		// in Options 1,2,6 above we had a change of motion page - start execution
		unpackMotion(current_motion_page);
		if ( setMotionPageJointFlexibility() == 0 ) {
			// joint flex values set ok, execute motion
			current_step = 1;
			repeat_counter = 1;
 8004b44:	701a      	strb	r2, [r3, #0]
			motion_state = STEP_IN_MOTION;
			step_start_time = executeMotionStep(current_step);
 8004b46:	2001      	movs	r0, #1
 8004b48:	f7ff fdb2 	bl	80046b0 <executeMotionStep>
 8004b4c:	4b5d      	ldr	r3, [pc, #372]	(8004cc4 <executeMotionSequence+0x34c>)
 8004b4e:	6018      	str	r0, [r3, #0]
 8004b50:	e006      	b.n	8004b60 <executeMotionSequence+0x1e8>
		} else {
			// this shouldn't really happen, but we need to cater to the eventuality
			dxl_write_byte(BROADCAST_ID, DXL_TORQUE_ENABLE, 0);
 8004b52:	20fe      	movs	r0, #254
 8004b54:	2118      	movs	r1, #24
 8004b56:	2200      	movs	r2, #0
 8004b58:	f7ff faec 	bl	8004134 <dxl_write_byte>
			motion_state = MOTION_ALARM;
 8004b5c:	2306      	movs	r3, #6
 8004b5e:	7023      	strb	r3, [r4, #0]
		}
		current_motion_start_time = getMillis();
 8004b60:	f000 fd6a 	bl	8005638 <getMillis>
 8004b64:	4b67      	ldr	r3, [pc, #412]	(8004d04 <executeMotionSequence+0x38c>)
 8004b66:	e029      	b.n	8004bbc <executeMotionSequence+0x244>
		// either way we are finished here - return
		return motion_state;
	}	
	
	// now we can deal with state changes during page execution
	if ( motion_state == STEP_FINISHED )
 8004b68:	4d55      	ldr	r5, [pc, #340]	(8004cc0 <executeMotionSequence+0x348>)
 8004b6a:	782b      	ldrb	r3, [r5, #0]
 8004b6c:	2b03      	cmp	r3, #3
 8004b6e:	d113      	bne.n	8004b98 <executeMotionSequence+0x220>
	{
		// Option 3 - start pause after step
		if ( CurrentMotion.PauseTime[current_step-1] > 0 && bioloid_command != COMMAND_STOP )
 8004b70:	4b56      	ldr	r3, [pc, #344]	(8004ccc <executeMotionSequence+0x354>)
 8004b72:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 8004b76:	f8b3 3112 	ldrh.w	r3, [r3, #274]
 8004b7a:	b153      	cbz	r3, 8004b92 <executeMotionSequence+0x21a>
 8004b7c:	4b57      	ldr	r3, [pc, #348]	(8004cdc <executeMotionSequence+0x364>)
 8004b7e:	781b      	ldrb	r3, [r3, #0]
 8004b80:	b13b      	cbz	r3, 8004b92 <executeMotionSequence+0x21a>
		{
			// set the timer for the pause
			pause_start_time = getMillis();
 8004b82:	f000 fd59 	bl	8005638 <getMillis>
 8004b86:	4b52      	ldr	r3, [pc, #328]	(8004cd0 <executeMotionSequence+0x358>)
 8004b88:	6018      	str	r0, [r3, #0]
			motion_state = STEP_IN_PAUSE;
 8004b8a:	2302      	movs	r3, #2
 8004b8c:	702b      	strb	r3, [r5, #0]
 8004b8e:	2002      	movs	r0, #2
 8004b90:	e094      	b.n	8004cbc <executeMotionSequence+0x344>
			return motion_state;
		} else {
			// no pause required, go straight to executing next step
			motion_state = PAUSE_FINISHED;
 8004b92:	4b4b      	ldr	r3, [pc, #300]	(8004cc0 <executeMotionSequence+0x348>)
 8004b94:	2204      	movs	r2, #4
 8004b96:	701a      	strb	r2, [r3, #0]
		}
	}	
	
	if ( motion_state == PAUSE_FINISHED )
 8004b98:	f8df c124 	ldr.w	ip, [pc, #292]	; 8004cc0 <executeMotionSequence+0x348>
 8004b9c:	f89c 0000 	ldrb.w	r0, [ip]
 8004ba0:	2804      	cmp	r0, #4
 8004ba2:	d112      	bne.n	8004bca <executeMotionSequence+0x252>
	{
		// Option 4 - execute next step in this motion page
		if ( current_step < CurrentMotion.Steps )
 8004ba4:	42a1      	cmp	r1, r4
 8004ba6:	d20b      	bcs.n	8004bc0 <executeMotionSequence+0x248>
		{
			// Update step and motion status
			current_step++;
 8004ba8:	1c48      	adds	r0, r1, #1
 8004baa:	4b47      	ldr	r3, [pc, #284]	(8004cc8 <executeMotionSequence+0x350>)
 8004bac:	b2c0      	uxtb	r0, r0
 8004bae:	7018      	strb	r0, [r3, #0]
			motion_state = STEP_IN_MOTION;
 8004bb0:	2301      	movs	r3, #1
 8004bb2:	f88c 3000 	strb.w	r3, [ip]
			step_start_time = executeMotionStep(current_step);
 8004bb6:	f7ff fd7b 	bl	80046b0 <executeMotionStep>
 8004bba:	4b42      	ldr	r3, [pc, #264]	(8004cc4 <executeMotionSequence+0x34c>)
 8004bbc:	6018      	str	r0, [r3, #0]
 8004bbe:	e07b      	b.n	8004cb8 <executeMotionSequence+0x340>
		}
		// should never end up here
		else 
		{
			// reset to default
			motion_state = MOTION_STOPPED;
 8004bc0:	2200      	movs	r2, #0
 8004bc2:	f88c 2000 	strb.w	r2, [ip]
			current_motion_page = 0;
 8004bc6:	4b49      	ldr	r3, [pc, #292]	(8004cec <executeMotionSequence+0x374>)
 8004bc8:	e075      	b.n	8004cb6 <executeMotionSequence+0x33e>
		}
		return motion_state;
	}
	
	// Option 7 - Respond to new command - set associated motion page
	if ( motion_state == MOTION_STOPPED && new_command == TRUE )
 8004bca:	2800      	cmp	r0, #0
 8004bcc:	d176      	bne.n	8004cbc <executeMotionSequence+0x344>
 8004bce:	4b48      	ldr	r3, [pc, #288]	(8004cf0 <executeMotionSequence+0x378>)
 8004bd0:	781b      	ldrb	r3, [r3, #0]
 8004bd2:	2b01      	cmp	r3, #1
 8004bd4:	d172      	bne.n	8004cbc <executeMotionSequence+0x344>
	{
		// special case for walk commands we need to get walk ready if we weren't walking before
		if( (last_bioloid_command == COMMAND_STOP || last_bioloid_command > COMMAND_WALK_READY) &&
 8004bd6:	4a4c      	ldr	r2, [pc, #304]	(8004d08 <executeMotionSequence+0x390>)
 8004bd8:	7813      	ldrb	r3, [r2, #0]
 8004bda:	b113      	cbz	r3, 8004be2 <executeMotionSequence+0x26a>
 8004bdc:	7813      	ldrb	r3, [r2, #0]
 8004bde:	2b11      	cmp	r3, #17
 8004be0:	d908      	bls.n	8004bf4 <executeMotionSequence+0x27c>
 8004be2:	4a3e      	ldr	r2, [pc, #248]	(8004cdc <executeMotionSequence+0x364>)
 8004be4:	7813      	ldrb	r3, [r2, #0]
 8004be6:	b12b      	cbz	r3, 8004bf4 <executeMotionSequence+0x27c>
 8004be8:	7813      	ldrb	r3, [r2, #0]
 8004bea:	2b10      	cmp	r3, #16
 8004bec:	d802      	bhi.n	8004bf4 <executeMotionSequence+0x27c>
		    ( bioloid_command >= COMMAND_WALK_FORWARD && bioloid_command < COMMAND_WALK_READY ) ) {
				// this is the only time we wait for a motion to finish before returning to the command loop!
				walk_init();
 8004bee:	f000 fb6d 	bl	80052cc <walk_init>
 8004bf2:	e024      	b.n	8004c3e <executeMotionSequence+0x2c6>
		} 
		// special case of shifting between walk commands - non-seamless transitions
		else if ( walk_getWalkState() > 0 && (bioloid_command >= COMMAND_WALK_FORWARD && bioloid_command < COMMAND_WALK_READY) )
 8004bf4:	f000 fa96 	bl	8005124 <walk_getWalkState>
 8004bf8:	2800      	cmp	r0, #0
 8004bfa:	dd20      	ble.n	8004c3e <executeMotionSequence+0x2c6>
 8004bfc:	4837      	ldr	r0, [pc, #220]	(8004cdc <executeMotionSequence+0x364>)
 8004bfe:	7803      	ldrb	r3, [r0, #0]
 8004c00:	b1eb      	cbz	r3, 8004c3e <executeMotionSequence+0x2c6>
 8004c02:	7803      	ldrb	r3, [r0, #0]
 8004c04:	2b10      	cmp	r3, #16
 8004c06:	d81a      	bhi.n	8004c3e <executeMotionSequence+0x2c6>
		{
				// calculate the page number relative to start of previous command
				left_right_step = current_motion_page - COMMAND_WALK_READY_MP;
 8004c08:	4b38      	ldr	r3, [pc, #224]	(8004cec <executeMotionSequence+0x374>)
				temp1 = left_right_step / 12U;
				left_right_step -= temp1 * 12;
 8004c0a:	4a40      	ldr	r2, [pc, #256]	(8004d0c <executeMotionSequence+0x394>)
		} 
		// special case of shifting between walk commands - non-seamless transitions
		else if ( walk_getWalkState() > 0 && (bioloid_command >= COMMAND_WALK_FORWARD && bioloid_command < COMMAND_WALK_READY) )
		{
				// calculate the page number relative to start of previous command
				left_right_step = current_motion_page - COMMAND_WALK_READY_MP;
 8004c0c:	7819      	ldrb	r1, [r3, #0]
 8004c0e:	391f      	subs	r1, #31
				temp1 = left_right_step / 12U;
				left_right_step -= temp1 * 12;
 8004c10:	fba1 2302 	umull	r2, r3, r1, r2
 8004c14:	08db      	lsrs	r3, r3, #3
 8004c16:	b2db      	uxtb	r3, r3
 8004c18:	ebc3 7203 	rsb	r2, r3, r3, lsl #28
 8004c1c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
				// check if we finished on left or right step
				if ( left_right_step == 10 ) {
 8004c20:	eb01 0183 	add.w	r1, r1, r3, lsl #2
				} else {
					// left step is next
					left_right_step = 0;
				}
				// can calculate next motion page as in WALK EXECUTE 
				next_motion_page = (bioloid_command-1)*12 + COMMAND_WALK_READY_MP + left_right_step + 1;
 8004c24:	7803      	ldrb	r3, [r0, #0]
				// calculate the page number relative to start of previous command
				left_right_step = current_motion_page - COMMAND_WALK_READY_MP;
				temp1 = left_right_step / 12U;
				left_right_step -= temp1 * 12;
				// check if we finished on left or right step
				if ( left_right_step == 10 ) {
 8004c26:	290a      	cmp	r1, #10
 8004c28:	bf0c      	ite	eq
 8004c2a:	2102      	moveq	r1, #2
 8004c2c:	2100      	movne	r1, #0
				} else {
					// left step is next
					left_right_step = 0;
				}
				// can calculate next motion page as in WALK EXECUTE 
				next_motion_page = (bioloid_command-1)*12 + COMMAND_WALK_READY_MP + left_right_step + 1;
 8004c2e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004c32:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8004c36:	3114      	adds	r1, #20
 8004c38:	4b35      	ldr	r3, [pc, #212]	(8004d10 <executeMotionSequence+0x398>)
 8004c3a:	b2c9      	uxtb	r1, r1
 8004c3c:	7019      	strb	r1, [r3, #0]
		}
		
		if ( bioloid_command != COMMAND_STOP )
 8004c3e:	4e27      	ldr	r6, [pc, #156]	(8004cdc <executeMotionSequence+0x364>)
 8004c40:	4c2a      	ldr	r4, [pc, #168]	(8004cec <executeMotionSequence+0x374>)
 8004c42:	7833      	ldrb	r3, [r6, #0]
 8004c44:	4d32      	ldr	r5, [pc, #200]	(8004d10 <executeMotionSequence+0x398>)
 8004c46:	461a      	mov	r2, r3
 8004c48:	2b00      	cmp	r3, #0
 8004c4a:	d02f      	beq.n	8004cac <executeMotionSequence+0x334>
		{
			// unpack the new motion page and start the motion
			unpackMotion(next_motion_page);
 8004c4c:	7828      	ldrb	r0, [r5, #0]
 8004c4e:	f7ff fd81 	bl	8004754 <unpackMotion2>
			current_motion_page = next_motion_page;
 8004c52:	782b      	ldrb	r3, [r5, #0]
 8004c54:	7023      	strb	r3, [r4, #0]
			current_motion_start_time = getMillis();
 8004c56:	f000 fcef 	bl	8005638 <getMillis>
 8004c5a:	4b2a      	ldr	r3, [pc, #168]	(8004d04 <executeMotionSequence+0x38c>)
 8004c5c:	6018      	str	r0, [r3, #0]
			next_motion_page = 0;
 8004c5e:	2300      	movs	r3, #0
 8004c60:	702b      	strb	r3, [r5, #0]
			// also need to set walk state if it's a walk command
			if ( bioloid_command >= COMMAND_WALK_FORWARD && bioloid_command < COMMAND_WALK_READY ) {
 8004c62:	7833      	ldrb	r3, [r6, #0]
 8004c64:	b123      	cbz	r3, 8004c70 <executeMotionSequence+0x2f8>
 8004c66:	7833      	ldrb	r3, [r6, #0]
 8004c68:	2b10      	cmp	r3, #16
				walk_setWalkState(bioloid_command);
 8004c6a:	bf98      	it	ls
 8004c6c:	7830      	ldrbls	r0, [r6, #0]
			unpackMotion(next_motion_page);
			current_motion_page = next_motion_page;
			current_motion_start_time = getMillis();
			next_motion_page = 0;
			// also need to set walk state if it's a walk command
			if ( bioloid_command >= COMMAND_WALK_FORWARD && bioloid_command < COMMAND_WALK_READY ) {
 8004c6e:	d900      	bls.n	8004c72 <executeMotionSequence+0x2fa>
				walk_setWalkState(bioloid_command);
			} else {
				// not a walk command, reset walk state
				walk_setWalkState(0);
 8004c70:	2000      	movs	r0, #0
 8004c72:	f000 fa51 	bl	8005118 <walk_setWalkState>
			}
			
			if ( setMotionPageJointFlexibility() == 0 ) {
 8004c76:	f7ff fd39 	bl	80046ec <setMotionPageJointFlexibility>
 8004c7a:	4c11      	ldr	r4, [pc, #68]	(8004cc0 <executeMotionSequence+0x348>)
 8004c7c:	4605      	mov	r5, r0
 8004c7e:	4e1c      	ldr	r6, [pc, #112]	(8004cf0 <executeMotionSequence+0x378>)
 8004c80:	b960      	cbnz	r0, 8004c9c <executeMotionSequence+0x324>
				// joint flex values set ok, execute motion
				current_step = 1;
 8004c82:	4b11      	ldr	r3, [pc, #68]	(8004cc8 <executeMotionSequence+0x350>)
 8004c84:	2201      	movs	r2, #1
 8004c86:	701a      	strb	r2, [r3, #0]
				repeat_counter = 1;
 8004c88:	4b1a      	ldr	r3, [pc, #104]	(8004cf4 <executeMotionSequence+0x37c>)
				motion_state = STEP_IN_MOTION;
 8004c8a:	7022      	strb	r2, [r4, #0]
			}
			
			if ( setMotionPageJointFlexibility() == 0 ) {
				// joint flex values set ok, execute motion
				current_step = 1;
				repeat_counter = 1;
 8004c8c:	701a      	strb	r2, [r3, #0]
				motion_state = STEP_IN_MOTION;
				step_start_time = executeMotionStep(current_step);
 8004c8e:	2001      	movs	r0, #1
 8004c90:	f7ff fd0e 	bl	80046b0 <executeMotionStep>
 8004c94:	4b0b      	ldr	r3, [pc, #44]	(8004cc4 <executeMotionSequence+0x34c>)
				new_command = FALSE;
 8004c96:	7035      	strb	r5, [r6, #0]
			if ( setMotionPageJointFlexibility() == 0 ) {
				// joint flex values set ok, execute motion
				current_step = 1;
				repeat_counter = 1;
				motion_state = STEP_IN_MOTION;
				step_start_time = executeMotionStep(current_step);
 8004c98:	6018      	str	r0, [r3, #0]
 8004c9a:	e00d      	b.n	8004cb8 <executeMotionSequence+0x340>
				new_command = FALSE;
			} else {
				// something went wrong when setting compliance slope
				current_motion_page = 0;
 8004c9c:	4a13      	ldr	r2, [pc, #76]	(8004cec <executeMotionSequence+0x374>)
 8004c9e:	2300      	movs	r3, #0
 8004ca0:	7013      	strb	r3, [r2, #0]
				next_motion_page = 0;
 8004ca2:	4a1b      	ldr	r2, [pc, #108]	(8004d10 <executeMotionSequence+0x398>)
				new_command = FALSE;
				motion_state = MOTION_STOPPED;
 8004ca4:	7023      	strb	r3, [r4, #0]
				step_start_time = executeMotionStep(current_step);
				new_command = FALSE;
			} else {
				// something went wrong when setting compliance slope
				current_motion_page = 0;
				next_motion_page = 0;
 8004ca6:	7013      	strb	r3, [r2, #0]
				new_command = FALSE;
 8004ca8:	7033      	strb	r3, [r6, #0]
 8004caa:	e005      	b.n	8004cb8 <executeMotionSequence+0x340>
				motion_state = MOTION_STOPPED;
			}
		} else {
			// execute STOP command
			current_motion_page = 0;
 8004cac:	7023      	strb	r3, [r4, #0]
			next_motion_page = 0;
 8004cae:	702b      	strb	r3, [r5, #0]
			new_command = FALSE;
 8004cb0:	4b0f      	ldr	r3, [pc, #60]	(8004cf0 <executeMotionSequence+0x378>)
 8004cb2:	701a      	strb	r2, [r3, #0]
			motion_state = MOTION_STOPPED;
 8004cb4:	4b02      	ldr	r3, [pc, #8]	(8004cc0 <executeMotionSequence+0x348>)
 8004cb6:	701a      	strb	r2, [r3, #0]
	// Option 8 - Nothing to do - keep waiting for new command
	else {
		return motion_state;
	}

	return motion_state;
 8004cb8:	4b01      	ldr	r3, [pc, #4]	(8004cc0 <executeMotionSequence+0x348>)
 8004cba:	7818      	ldrb	r0, [r3, #0]
}
 8004cbc:	b003      	add	sp, #12
 8004cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004cc0:	200009f4 	.word	0x200009f4
 8004cc4:	20000a00 	.word	0x20000a00
 8004cc8:	20000f7b 	.word	0x20000f7b
 8004ccc:	20000e24 	.word	0x20000e24
 8004cd0:	200009f8 	.word	0x200009f8
 8004cd4:	08007c3e 	.word	0x08007c3e
 8004cd8:	08008273 	.word	0x08008273
 8004cdc:	20000f74 	.word	0x20000f74
 8004ce0:	080082a6 	.word	0x080082a6
 8004ce4:	200009fd 	.word	0x200009fd
 8004ce8:	080082c9 	.word	0x080082c9
 8004cec:	20000f79 	.word	0x20000f79
 8004cf0:	20000f76 	.word	0x20000f76
 8004cf4:	200009fc 	.word	0x200009fc
 8004cf8:	080082f2 	.word	0x080082f2
 8004cfc:	0800831a 	.word	0x0800831a
 8004d00:	08008343 	.word	0x08008343
 8004d04:	20000a0c 	.word	0x20000a0c
 8004d08:	20000f75 	.word	0x20000f75
 8004d0c:	aaaaaaab 	.word	0xaaaaaaab
 8004d10:	20000f7a 	.word	0x20000f7a

08004d14 <calculate_speed>:
	u32 travel = abs(goal_position - current_position);

	// now we can calculate the desired moving speed
	// for 59pm the factor is 847.46 which we round to 848
	// we need to use a temporary 32bit integer to prevent overflow
	u16 goal_speed = (uint16) (700 * travel / time );
 8004d14:	1a40      	subs	r0, r0, r1
 8004d16:	2800      	cmp	r0, #0
 8004d18:	bfb8      	it	lt
 8004d1a:	4240      	neglt	r0, r0
 8004d1c:	f44f 732f 	mov.w	r3, #700	; 0x2bc
 8004d20:	fb03 f300 	mul.w	r3, r3, r0
 8004d24:	fbb3 f3f2 	udiv	r3, r3, r2
 8004d28:	b298      	uxth	r0, r3
	// if the desired speed exceeds the maximum, we need to adjust
	if (goal_speed > 1023) goal_speed = 1023;
 8004d2a:	f240 33ff 	movw	r3, #1023	; 0x3ff
 8004d2e:	4298      	cmp	r0, r3
 8004d30:	bf88      	it	hi
 8004d32:	4618      	movhi	r0, r3
 8004d34:	d802      	bhi.n	8004d3c <calculate_speed+0x28>
	// we also use a minimum speed of 26 (5% of 530 the max value for 59RPM)
	if (goal_speed < 26) goal_speed = 26;
 8004d36:	2819      	cmp	r0, #25
 8004d38:	bf98      	it	ls
 8004d3a:	201a      	movls	r0, #26

	return goal_speed;
}
 8004d3c:	4770      	bx	lr
 8004d3e:	46c0      	nop			(mov r8, r8)

08004d40 <applyOffsetsBounds>:

void applyOffsetsBounds(uint16 goal_pose_adjusted[NUM_AX12_SERVOS]) {
 8004d40:	b530      	push	{r4, r5, lr}
	int16  temp_goal;
	int i;
	for (i=0; i<NUM_AX12_SERVOS; i++)
	{
		// process the joint offset values bearing in mind the different variable types
		temp_goal = (int16) goal_pose[i] + offsets[i];
 8004d42:	4d0b      	ldr	r5, [pc, #44]	(8004d70 <applyOffsetsBounds+0x30>)
 8004d44:	4c0b      	ldr	r4, [pc, #44]	(8004d74 <applyOffsetsBounds+0x34>)
	if (goal_speed < 26) goal_speed = 26;

	return goal_speed;
}

void applyOffsetsBounds(uint16 goal_pose_adjusted[NUM_AX12_SERVOS]) {
 8004d46:	2100      	movs	r1, #0
		// process the joint offset values bearing in mind the different variable types
		temp_goal = (int16) goal_pose[i] + offsets[i];
		if ( temp_goal < 0 ) {
			goal_pose_adjusted[i] = 0;		// can't go below 0
		}
		else if ( temp_goal > 1023 ) {
 8004d48:	f240 3cff 	movw	ip, #1023	; 0x3ff
	int16  temp_goal;
	int i;
	for (i=0; i<NUM_AX12_SERVOS; i++)
	{
		// process the joint offset values bearing in mind the different variable types
		temp_goal = (int16) goal_pose[i] + offsets[i];
 8004d4c:	5a62      	ldrh	r2, [r4, r1]
 8004d4e:	5a6b      	ldrh	r3, [r5, r1]
 8004d50:	189b      	adds	r3, r3, r2
 8004d52:	b29b      	uxth	r3, r3
		if ( temp_goal < 0 ) {
 8004d54:	b21a      	sxth	r2, r3
 8004d56:	2a00      	cmp	r2, #0
			goal_pose_adjusted[i] = 0;		// can't go below 0
 8004d58:	bfb8      	it	lt
 8004d5a:	2300      	movlt	r3, #0
	int i;
	for (i=0; i<NUM_AX12_SERVOS; i++)
	{
		// process the joint offset values bearing in mind the different variable types
		temp_goal = (int16) goal_pose[i] + offsets[i];
		if ( temp_goal < 0 ) {
 8004d5c:	db03      	blt.n	8004d66 <applyOffsetsBounds+0x26>
			goal_pose_adjusted[i] = 0;		// can't go below 0
		}
		else if ( temp_goal > 1023 ) {
 8004d5e:	4562      	cmp	r2, ip
			goal_pose_adjusted[i] = 1023;	// or above 1023
 8004d60:	bfc8      	it	gt
 8004d62:	f240 33ff 	movwgt	r3, #1023	; 0x3ff
		}
		else {
			goal_pose_adjusted[i] = (uint16) temp_goal;
 8004d66:	5243      	strh	r3, [r0, r1]
 8004d68:	3102      	adds	r1, #2
}

void applyOffsetsBounds(uint16 goal_pose_adjusted[NUM_AX12_SERVOS]) {
	int16  temp_goal;
	int i;
	for (i=0; i<NUM_AX12_SERVOS; i++)
 8004d6a:	2924      	cmp	r1, #36
 8004d6c:	d1ee      	bne.n	8004d4c <applyOffsetsBounds+0xc>
		}
		else {
			goal_pose_adjusted[i] = (uint16) temp_goal;
		}
	}
}
 8004d6e:	bd30      	pop	{r4, r5, pc}
 8004d70:	20001130 	.word	0x20001130
 8004d74:	20001056 	.word	0x20001056

08004d78 <resetJointOffsets>:
	moveToGoalPose(InitialPlayTime, InitialValues, WAIT_FOR_POSE_FINISH);
}

void resetJointOffsets(void) {
	for (int i = 0; i < NUM_AX12_SERVOS; i++) {
		offsets[i] = 0;
 8004d78:	4a04      	ldr	r2, [pc, #16]	(8004d8c <resetJointOffsets+0x14>)
{
	// assume default pose defined 
	moveToGoalPose(InitialPlayTime, InitialValues, WAIT_FOR_POSE_FINISH);
}

void resetJointOffsets(void) {
 8004d7a:	2300      	movs	r3, #0
	for (int i = 0; i < NUM_AX12_SERVOS; i++) {
		offsets[i] = 0;
 8004d7c:	f04f 0100 	mov.w	r1, #0	; 0x0
 8004d80:	52d1      	strh	r1, [r2, r3]
 8004d82:	3302      	adds	r3, #2
	// assume default pose defined 
	moveToGoalPose(InitialPlayTime, InitialValues, WAIT_FOR_POSE_FINISH);
}

void resetJointOffsets(void) {
	for (int i = 0; i < NUM_AX12_SERVOS; i++) {
 8004d84:	2b24      	cmp	r3, #36
 8004d86:	d1f9      	bne.n	8004d7c <resetJointOffsets+0x4>
		offsets[i] = 0;
	}
}
 8004d88:	4770      	bx	lr
 8004d8a:	46c0      	nop			(mov r8, r8)
 8004d8c:	20001130 	.word	0x20001130

08004d90 <get_offset_adjustment_time>:
	offsets[id-1] = offset;
	offsets_speeds[id-1] = speed;
	//printf("setting offset of %d to %d\n", id, offset);
}

u32 get_offset_adjustment_time(int id) {
 8004d90:	4b02      	ldr	r3, [pc, #8]	(8004d9c <get_offset_adjustment_time+0xc>)
 8004d92:	3801      	subs	r0, #1
 8004d94:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
	return offset_timings[id-1];
}
 8004d98:	4770      	bx	lr
 8004d9a:	46c0      	nop			(mov r8, r8)
 8004d9c:	200010e8 	.word	0x200010e8

08004da0 <get_offset>:

s16 get_offset(int id) {
 8004da0:	4b02      	ldr	r3, [pc, #8]	(8004dac <get_offset+0xc>)
 8004da2:	3801      	subs	r0, #1
 8004da4:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
	return offsets[id-1];
}
 8004da8:	4770      	bx	lr
 8004daa:	46c0      	nop			(mov r8, r8)
 8004dac:	20001130 	.word	0x20001130

08004db0 <set_pose_mode>:


void set_pose_mode(POSE_MODE mode) {
	pose_mode = mode;
 8004db0:	4b01      	ldr	r3, [pc, #4]	(8004db8 <set_pose_mode+0x8>)
 8004db2:	7018      	strb	r0, [r3, #0]
}
 8004db4:	4770      	bx	lr
 8004db6:	46c0      	nop			(mov r8, r8)
 8004db8:	20001054 	.word	0x20001054

08004dbc <getCurrentGoalPose>:


uint16 * getCurrentGoalPose(){
	return goal_pose;
}
 8004dbc:	4800      	ldr	r0, [pc, #0]	(8004dc0 <getCurrentGoalPose+0x4>)
 8004dbe:	4770      	bx	lr
 8004dc0:	20001056 	.word	0x20001056

08004dc4 <apply_new_pose_and_offsets>:

// Checks the offsets array for new values, and sync writes the changes to the servos.
// This function will calculate the speeds of the servos automatically when a change has occured, based on the curent goal pose time setting.
void apply_new_pose_and_offsets()
{
 8004dc4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004dc6:	b09d      	sub	sp, #116
	int num_changed = 0;
	u8 ids_changed[NUM_AX12_SERVOS];
	u16 goal_pose_changed[NUM_AX12_SERVOS];
	u16 goal_speeds_changed[NUM_AX12_SERVOS];

	const u32 now = micros();
 8004dc8:	f000 fce4 	bl	8005794 <micros>
			else if ( adjusted > 1023 ) {
				adjusted = 1023;	// or above 1023
			}

			// calculate speeds
			u16 speed = calculate_speed(adjusted, current_pose[i], goal_time);
 8004dcc:	4b46      	ldr	r3, [pc, #280]	(8004ee8 <apply_new_pose_and_offsets+0x124>)
 8004dce:	2600      	movs	r6, #0
 8004dd0:	681b      	ldr	r3, [r3, #0]
	int num_changed = 0;
	u8 ids_changed[NUM_AX12_SERVOS];
	u16 goal_pose_changed[NUM_AX12_SERVOS];
	u16 goal_speeds_changed[NUM_AX12_SERVOS];

	const u32 now = micros();
 8004dd2:	9001      	str	r0, [sp, #4]
			else if ( adjusted > 1023 ) {
				adjusted = 1023;	// or above 1023
			}

			// calculate speeds
			u16 speed = calculate_speed(adjusted, current_pose[i], goal_time);
 8004dd4:	9300      	str	r3, [sp, #0]
 8004dd6:	2701      	movs	r7, #1
 8004dd8:	9603      	str	r6, [sp, #12]
 8004dda:	2500      	movs	r5, #0

		bool offset_adjustment_has_just_completed = 0;

		// check if offset adjustment is completed.

		if (offset_timings[i] != 0) {
 8004ddc:	4943      	ldr	r1, [pc, #268]	(8004eec <apply_new_pose_and_offsets+0x128>)
 8004dde:	9b03      	ldr	r3, [sp, #12]
			else if ( adjusted > 1023 ) {
				adjusted = 1023;	// or above 1023
			}

			// calculate speeds
			u16 speed = calculate_speed(adjusted, current_pose[i], goal_time);
 8004de0:	1e78      	subs	r0, r7, #1

		bool offset_adjustment_has_just_completed = 0;

		// check if offset adjustment is completed.

		if (offset_timings[i] != 0) {
 8004de2:	eb01 0203 	add.w	r2, r1, r3
 8004de6:	58cb      	ldr	r3, [r1, r3]
			else if ( adjusted > 1023 ) {
				adjusted = 1023;	// or above 1023
			}

			// calculate speeds
			u16 speed = calculate_speed(adjusted, current_pose[i], goal_time);
 8004de8:	9002      	str	r0, [sp, #8]

		bool offset_adjustment_has_just_completed = 0;

		// check if offset adjustment is completed.

		if (offset_timings[i] != 0) {
 8004dea:	b90b      	cbnz	r3, 8004df0 <apply_new_pose_and_offsets+0x2c>
 8004dec:	2200      	movs	r2, #0
 8004dee:	e005      	b.n	8004dfc <apply_new_pose_and_offsets+0x38>
			if (now < offset_timings[i]) {
 8004df0:	9c01      	ldr	r4, [sp, #4]
 8004df2:	429c      	cmp	r4, r3
 8004df4:	d365      	bcc.n	8004ec2 <apply_new_pose_and_offsets+0xfe>
				continue; // dont do anything with this servo as it is currently adjusting offset.
			} else {
				offset_timings[i] = 0;
 8004df6:	2300      	movs	r3, #0
 8004df8:	6013      	str	r3, [r2, #0]
 8004dfa:	2201      	movs	r2, #1
				offset_adjustment_has_just_completed = 1;
			}
		}

		if (offsets[i] != offsets_shadow[i]) {
 8004dfc:	483c      	ldr	r0, [pc, #240]	(8004ef0 <apply_new_pose_and_offsets+0x12c>)
 8004dfe:	4b3d      	ldr	r3, [pc, #244]	(8004ef4 <apply_new_pose_and_offsets+0x130>)
 8004e00:	5b41      	ldrh	r1, [r0, r5]
 8004e02:	f833 e005 	ldrh.w	lr, [r3, r5]
 8004e06:	fa0f fc81 	sxth.w	ip, r1
 8004e0a:	458e      	cmp	lr, r1
 8004e0c:	d02c      	beq.n	8004e68 <apply_new_pose_and_offsets+0xa4>
			s16 old_offset = offsets_shadow[i];
			offsets_shadow[i] = offsets[i];
 8004e0e:	5359      	strh	r1, [r3, r5]

			int speed = offsets_speeds[i];
 8004e10:	4b39      	ldr	r3, [pc, #228]	(8004ef8 <apply_new_pose_and_offsets+0x134>)

			u32 est_time = (uint16) ( ((uint32) 848 * 1000 * abs(offsets[i])) / speed );
			//printf("est_time %d\n", est_time);
			offset_timings[i] = now + est_time;
 8004e12:	ea8c 72ec 	eor.w	r2, ip, ip, asr #31
 8004e16:	eba2 72ec 	sub.w	r2, r2, ip, asr #31

		if (offsets[i] != offsets_shadow[i]) {
			s16 old_offset = offsets_shadow[i];
			offsets_shadow[i] = offsets[i];

			int speed = offsets_speeds[i];
 8004e1a:	5f58      	ldrsh	r0, [r3, r5]

			u32 est_time = (uint16) ( ((uint32) 848 * 1000 * abs(offsets[i])) / speed );
			//printf("est_time %d\n", est_time);
			offset_timings[i] = now + est_time;
 8004e1c:	4b37      	ldr	r3, [pc, #220]	(8004efc <apply_new_pose_and_offsets+0x138>)
 8004e1e:	9c01      	ldr	r4, [sp, #4]
 8004e20:	fb03 f302 	mul.w	r3, r3, r2
 8004e24:	fbb3 f3f0 	udiv	r3, r3, r0
 8004e28:	b29b      	uxth	r3, r3
 8004e2a:	4423      	add	r3, r4
 8004e2c:	4a2f      	ldr	r2, [pc, #188]	(8004eec <apply_new_pose_and_offsets+0x128>)
 8004e2e:	9c03      	ldr	r4, [sp, #12]
 8004e30:	5113      	str	r3, [r2, r4]

			// apply offsets + bounds
			s16 goal_tmp = current_pose[i] - old_offset + offsets[i];
 8004e32:	4b33      	ldr	r3, [pc, #204]	(8004f00 <apply_new_pose_and_offsets+0x13c>)
 8004e34:	9c02      	ldr	r4, [sp, #8]
 8004e36:	f833 2014 	ldrh.w	r2, [r3, r4, lsl #1]
 8004e3a:	ebce 0301 	rsb	r3, lr, r1
 8004e3e:	189b      	adds	r3, r3, r2
			else if (goal_tmp > 1023)
				goal_tmp = 1023;

			//printf("current pose + offset: %d\n", goal_tmp);

			goal_speeds_changed[num_changed] = speed; // full speed ahead!
 8004e40:	aa1c      	add	r2, sp, #112
 8004e42:	eb02 0146 	add.w	r1, r2, r6, lsl #1
			u32 est_time = (uint16) ( ((uint32) 848 * 1000 * abs(offsets[i])) / speed );
			//printf("est_time %d\n", est_time);
			offset_timings[i] = now + est_time;

			// apply offsets + bounds
			s16 goal_tmp = current_pose[i] - old_offset + offsets[i];
 8004e46:	b21b      	sxth	r3, r3
				goal_tmp = 1023;

			//printf("current pose + offset: %d\n", goal_tmp);

			goal_speeds_changed[num_changed] = speed; // full speed ahead!
			goal_pose_changed[num_changed] = goal_tmp;
 8004e48:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8004e4c:	4293      	cmp	r3, r2
 8004e4e:	bfa8      	it	ge
 8004e50:	4613      	movge	r3, r2
 8004e52:	2b00      	cmp	r3, #0
 8004e54:	bfb8      	it	lt
 8004e56:	2300      	movlt	r3, #0
			ids_changed[num_changed] = i+1;
 8004e58:	ac1c      	add	r4, sp, #112
				goal_tmp = 1023;

			//printf("current pose + offset: %d\n", goal_tmp);

			goal_speeds_changed[num_changed] = speed; // full speed ahead!
			goal_pose_changed[num_changed] = goal_tmp;
 8004e5a:	f821 3c36 	strh.w	r3, [r1, #-54]
			else if (goal_tmp > 1023)
				goal_tmp = 1023;

			//printf("current pose + offset: %d\n", goal_tmp);

			goal_speeds_changed[num_changed] = speed; // full speed ahead!
 8004e5e:	f821 0c5a 	strh.w	r0, [r1, #-90]
			goal_pose_changed[num_changed] = goal_tmp;
			ids_changed[num_changed] = i+1;
 8004e62:	eb04 0306 	add.w	r3, r4, r6
 8004e66:	e029      	b.n	8004ebc <apply_new_pose_and_offsets+0xf8>
			num_changed++;
		} else if (goal_pose[i] != goal_pose_shadow[i] || offset_adjustment_has_just_completed) {
 8004e68:	4826      	ldr	r0, [pc, #152]	(8004f04 <apply_new_pose_and_offsets+0x140>)
 8004e6a:	5b44      	ldrh	r4, [r0, r5]
 8004e6c:	4826      	ldr	r0, [pc, #152]	(8004f08 <apply_new_pose_and_offsets+0x144>)
 8004e6e:	5b43      	ldrh	r3, [r0, r5]
 8004e70:	42a3      	cmp	r3, r4
 8004e72:	bf0c      	ite	eq
 8004e74:	4613      	moveq	r3, r2
 8004e76:	f042 0301 	orrne.w	r3, r2, #1	; 0x1
 8004e7a:	b313      	cbz	r3, 8004ec2 <apply_new_pose_and_offsets+0xfe>
			goal_pose_shadow[i] = goal_pose[i];
 8004e7c:	5344      	strh	r4, [r0, r5]

			// apply offsets and bounds
			s16 adjusted = (int16) goal_pose[i] + offsets[i];
 8004e7e:	1864      	adds	r4, r4, r1
			else if ( adjusted > 1023 ) {
				adjusted = 1023;	// or above 1023
			}

			// calculate speeds
			u16 speed = calculate_speed(adjusted, current_pose[i], goal_time);
 8004e80:	f240 33ff 	movw	r3, #1023	; 0x3ff
			num_changed++;
		} else if (goal_pose[i] != goal_pose_shadow[i] || offset_adjustment_has_just_completed) {
			goal_pose_shadow[i] = goal_pose[i];

			// apply offsets and bounds
			s16 adjusted = (int16) goal_pose[i] + offsets[i];
 8004e84:	b224      	sxth	r4, r4
			else if ( adjusted > 1023 ) {
				adjusted = 1023;	// or above 1023
			}

			// calculate speeds
			u16 speed = calculate_speed(adjusted, current_pose[i], goal_time);
 8004e86:	429c      	cmp	r4, r3
 8004e88:	bfa8      	it	ge
 8004e8a:	461c      	movge	r4, r3
 8004e8c:	9a02      	ldr	r2, [sp, #8]
 8004e8e:	4b1c      	ldr	r3, [pc, #112]	(8004f00 <apply_new_pose_and_offsets+0x13c>)
 8004e90:	2c00      	cmp	r4, #0
 8004e92:	bfb8      	it	lt
 8004e94:	2400      	movlt	r4, #0
 8004e96:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 8004e9a:	b2a4      	uxth	r4, r4
 8004e9c:	b289      	uxth	r1, r1
 8004e9e:	4620      	mov	r0, r4
 8004ea0:	9a00      	ldr	r2, [sp, #0]
 8004ea2:	f7ff ff37 	bl	8004d14 <calculate_speed>

			goal_pose_adjusted[i] = adjusted;
 8004ea6:	4b19      	ldr	r3, [pc, #100]	(8004f0c <apply_new_pose_and_offsets+0x148>)
			goal_pose_changed[num_changed] = adjusted;
 8004ea8:	a91c      	add	r1, sp, #112
			}

			// calculate speeds
			u16 speed = calculate_speed(adjusted, current_pose[i], goal_time);

			goal_pose_adjusted[i] = adjusted;
 8004eaa:	535c      	strh	r4, [r3, r5]
			goal_pose_changed[num_changed] = adjusted;
 8004eac:	eb01 0346 	add.w	r3, r1, r6, lsl #1
 8004eb0:	f823 4c36 	strh.w	r4, [r3, #-54]
			goal_speeds_changed[num_changed] = speed;
 8004eb4:	f823 0c5a 	strh.w	r0, [r3, #-90]
			ids_changed[num_changed] = i+1;
 8004eb8:	eb01 0306 	add.w	r3, r1, r6
 8004ebc:	f803 7c12 	strb.w	r7, [r3, #-18]
			num_changed++;
 8004ec0:	3601      	adds	r6, #1
 8004ec2:	9a03      	ldr	r2, [sp, #12]
 8004ec4:	3701      	adds	r7, #1
 8004ec6:	3204      	adds	r2, #4
 8004ec8:	3502      	adds	r5, #2
	u16 goal_speeds_changed[NUM_AX12_SERVOS];

	const u32 now = micros();

	// check for offset changes, if not offset change, check for goal pose changes
	for (int i = 0; i < NUM_AX12_SERVOS; i++) {
 8004eca:	2f13      	cmp	r7, #19

			goal_pose_adjusted[i] = adjusted;
			goal_pose_changed[num_changed] = adjusted;
			goal_speeds_changed[num_changed] = speed;
			ids_changed[num_changed] = i+1;
			num_changed++;
 8004ecc:	9203      	str	r2, [sp, #12]
	u16 goal_speeds_changed[NUM_AX12_SERVOS];

	const u32 now = micros();

	// check for offset changes, if not offset change, check for goal pose changes
	for (int i = 0; i < NUM_AX12_SERVOS; i++) {
 8004ece:	d185      	bne.n	8004ddc <apply_new_pose_and_offsets+0x18>
			ids_changed[num_changed] = i+1;
			num_changed++;
		}
	}

	if (num_changed > 0) {
 8004ed0:	b146      	cbz	r6, 8004ee4 <apply_new_pose_and_offsets+0x120>
		//printf("apply_new_pose_and_offsets: applying new positions to %d servos\n", num_changed);
		/* Apply only the changed servo settings. */
		dxl_set_goal_speed(num_changed, ids_changed, goal_pose_changed, goal_speeds_changed);
 8004ed2:	4630      	mov	r0, r6
 8004ed4:	f10d 015e 	add.w	r1, sp, #94	; 0x5e
 8004ed8:	f10d 023a 	add.w	r2, sp, #58	; 0x3a
 8004edc:	f10d 0316 	add.w	r3, sp, #22	; 0x16
 8004ee0:	f7ff f88c 	bl	8003ffc <dxl_set_goal_speed>

	}
}
 8004ee4:	b01d      	add	sp, #116
 8004ee6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004ee8:	2000119c 	.word	0x2000119c
 8004eec:	200010e8 	.word	0x200010e8
 8004ef0:	20001130 	.word	0x20001130
 8004ef4:	20001154 	.word	0x20001154
 8004ef8:	20001178 	.word	0x20001178
 8004efc:	000cf080 	.word	0x000cf080
 8004f00:	20000fa0 	.word	0x20000fa0
 8004f04:	20001056 	.word	0x20001056
 8004f08:	2000107a 	.word	0x2000107a
 8004f0c:	200010c2 	.word	0x200010c2

08004f10 <setJointOffsetSpeedById>:
	//printf("setting offset of %d to %d\n", id, offset);
}

void setJointOffsetSpeedById(u8 id, s16 offset, u16 speed)
{
	if (id == 0 || id > NUM_AX12_SERVOS) {
 8004f10:	1e43      	subs	r3, r0, #1
 8004f12:	b2db      	uxtb	r3, r3
 8004f14:	2b11      	cmp	r3, #17
	setJointOffsetSpeedById(id, offset, 1023);
	//printf("setting offset of %d to %d\n", id, offset);
}

void setJointOffsetSpeedById(u8 id, s16 offset, u16 speed)
{
 8004f16:	b570      	push	{r4, r5, r6, lr}
 8004f18:	4604      	mov	r4, r0
 8004f1a:	460d      	mov	r5, r1
 8004f1c:	4616      	mov	r6, r2
	if (id == 0 || id > NUM_AX12_SERVOS) {
 8004f1e:	d902      	bls.n	8004f26 <setJointOffsetSpeedById+0x16>
		PrintString("setJointOffsetById: invalid servo id, did you perhaps send the index?\n");
 8004f20:	4807      	ldr	r0, [pc, #28]	(8004f40 <setJointOffsetSpeedById+0x30>)
 8004f22:	f7fe fd93 	bl	8003a4c <PrintString>
	}
	if (offset_timings[id-1] != 0)
 8004f26:	4b07      	ldr	r3, [pc, #28]	(8004f44 <setJointOffsetSpeedById+0x34>)
 8004f28:	1e60      	subs	r0, r4, #1
 8004f2a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8004f2e:	b92b      	cbnz	r3, 8004f3c <setJointOffsetSpeedById+0x2c>
		return;
	offsets[id-1] = offset;
 8004f30:	4b05      	ldr	r3, [pc, #20]	(8004f48 <setJointOffsetSpeedById+0x38>)
 8004f32:	f823 5010 	strh.w	r5, [r3, r0, lsl #1]
	offsets_speeds[id-1] = speed;
 8004f36:	4b05      	ldr	r3, [pc, #20]	(8004f4c <setJointOffsetSpeedById+0x3c>)
 8004f38:	f823 6010 	strh.w	r6, [r3, r0, lsl #1]
	//printf("setting offset of %d to %d\n", id, offset);
}
 8004f3c:	bd70      	pop	{r4, r5, r6, pc}
 8004f3e:	46c0      	nop			(mov r8, r8)
 8004f40:	0800835d 	.word	0x0800835d
 8004f44:	200010e8 	.word	0x200010e8
 8004f48:	20001130 	.word	0x20001130
 8004f4c:	20001178 	.word	0x20001178

08004f50 <setJointOffsetById>:
		offsets[i] = 0;
	}
}

void setJointOffsetById(u8 id, s16 offset)
{
 8004f50:	b500      	push	{lr}
	setJointOffsetSpeedById(id, offset, 1023);
 8004f52:	f240 32ff 	movw	r2, #1023	; 0x3ff
		offsets[i] = 0;
	}
}

void setJointOffsetById(u8 id, s16 offset)
{
 8004f56:	b081      	sub	sp, #4
	setJointOffsetSpeedById(id, offset, 1023);
 8004f58:	f7ff ffda 	bl	8004f10 <setJointOffsetSpeedById>
	//printf("setting offset of %d to %d\n", id, offset);
}
 8004f5c:	b001      	add	sp, #4
 8004f5e:	bd00      	pop	{pc}

08004f60 <waitForPoseFinish>:
	}
}

// Function to wait out any existing servo movement
void waitForPoseFinish()
{
 8004f60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004f62:	b087      	sub	sp, #28
 8004f64:	2600      	movs	r6, #0
		moving_flag = 0;
		
		for (i=0; i<NUM_AX12_SERVOS; i++) {
			// keep reading the moving state of servos 
			if( first_loop == 0 || still_moving[i] == 1) {
				still_moving[i] = dxl_read_byte( AX12_IDS[i], DXL_MOVING );
 8004f66:	f10d 0706 	add.w	r7, sp, #6	; 0x6
	}
}

// Function to wait out any existing servo movement
void waitForPoseFinish()
{
 8004f6a:	2500      	movs	r5, #0
 8004f6c:	2400      	movs	r4, #0
		// reset the flag
		moving_flag = 0;
		
		for (i=0; i<NUM_AX12_SERVOS; i++) {
			// keep reading the moving state of servos 
			if( first_loop == 0 || still_moving[i] == 1) {
 8004f6e:	b116      	cbz	r6, 8004f76 <waitForPoseFinish+0x16>
 8004f70:	5d3b      	ldrb	r3, [r7, r4]
 8004f72:	2b01      	cmp	r3, #1
 8004f74:	d107      	bne.n	8004f86 <waitForPoseFinish+0x26>
				still_moving[i] = dxl_read_byte( AX12_IDS[i], DXL_MOVING );
 8004f76:	4b08      	ldr	r3, [pc, #32]	(8004f98 <waitForPoseFinish+0x38>)
 8004f78:	212e      	movs	r1, #46
 8004f7a:	5d18      	ldrb	r0, [r3, r4]
 8004f7c:	f7ff f900 	bl	8004180 <dxl_read_byte>
 8004f80:	5538      	strb	r0, [r7, r4]
				moving_flag += still_moving[i];
 8004f82:	4428      	add	r0, r5
 8004f84:	b2c5      	uxtb	r5, r0
	do 
	{
		// reset the flag
		moving_flag = 0;
		
		for (i=0; i<NUM_AX12_SERVOS; i++) {
 8004f86:	3401      	adds	r4, #1
 8004f88:	2c12      	cmp	r4, #18
 8004f8a:	d1f0      	bne.n	8004f6e <waitForPoseFinish+0xe>
 8004f8c:	2601      	movs	r6, #1
				still_moving[i] = dxl_read_byte( AX12_IDS[i], DXL_MOVING );
				moving_flag += still_moving[i];
			}		
		}
		first_loop = 1;
	} while (moving_flag > 0);
 8004f8e:	2d00      	cmp	r5, #0
 8004f90:	d1eb      	bne.n	8004f6a <waitForPoseFinish+0xa>
}
 8004f92:	b007      	add	sp, #28
 8004f94:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004f96:	46c0      	nop			(mov r8, r8)
 8004f98:	08007c3e 	.word	0x08007c3e

08004f9c <readCurrentPose>:

// read in current servo positions to determine current pose
// takes between 260us and 456us per servo (mainly 260us or 300us)
// all up takes 5-6ms
void readCurrentPose()
{
 8004f9c:	b570      	push	{r4, r5, r6, lr}
	int i;
	// loop over all possible actuators
	for(i=0; i<NUM_AX12_SERVOS; i++) {
		current_pose[i] = dxl_read_word( AX12_IDS[i], DXL_PRESENT_POSITION_L );
 8004f9e:	4e06      	ldr	r6, [pc, #24]	(8004fb8 <readCurrentPose+0x1c>)
 8004fa0:	4d06      	ldr	r5, [pc, #24]	(8004fbc <readCurrentPose+0x20>)

// read in current servo positions to determine current pose
// takes between 260us and 456us per servo (mainly 260us or 300us)
// all up takes 5-6ms
void readCurrentPose()
{
 8004fa2:	2400      	movs	r4, #0
	int i;
	// loop over all possible actuators
	for(i=0; i<NUM_AX12_SERVOS; i++) {
		current_pose[i] = dxl_read_word( AX12_IDS[i], DXL_PRESENT_POSITION_L );
 8004fa4:	5d30      	ldrb	r0, [r6, r4]
 8004fa6:	2124      	movs	r1, #36
 8004fa8:	f7ff f89c 	bl	80040e4 <dxl_read_word>
 8004fac:	f825 0014 	strh.w	r0, [r5, r4, lsl #1]
// all up takes 5-6ms
void readCurrentPose()
{
	int i;
	// loop over all possible actuators
	for(i=0; i<NUM_AX12_SERVOS; i++) {
 8004fb0:	3401      	adds	r4, #1
 8004fb2:	2c12      	cmp	r4, #18
 8004fb4:	d1f6      	bne.n	8004fa4 <readCurrentPose+0x8>
		current_pose[i] = dxl_read_word( AX12_IDS[i], DXL_PRESENT_POSITION_L );
	}
}
 8004fb6:	bd70      	pop	{r4, r5, r6, pc}
 8004fb8:	08007c3e 	.word	0x08007c3e
 8004fbc:	20000fa0 	.word	0x20000fa0

08004fc0 <calculatePoseServoSpeeds>:
// The AX-12 manual states this as the 'no load speed' at 12V
// The Moving Speed control table entry states that 0x3FF = 114rpm
// and according to Robotis this means 0x212 = 59rpm and anything greater 0x212 is also 59rpm

void calculatePoseServoSpeeds(uint16 time, uint16 goal_pose[NUM_AX12_SERVOS], uint16 goal_speed[NUM_AX12_SERVOS])
{
 8004fc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004fc2:	b085      	sub	sp, #20
 8004fc4:	9003      	str	r0, [sp, #12]
 8004fc6:	9102      	str	r1, [sp, #8]
 8004fc8:	9201      	str	r2, [sp, #4]
    int i;
	uint16 travel;
	uint32 factor;

	// read the current pose only if we are not walking (no time)
	if( walk_getWalkState() == 0 ) {
 8004fca:	f000 f8ab 	bl	8005124 <walk_getWalkState>
 8004fce:	b908      	cbnz	r0, 8004fd4 <calculatePoseServoSpeeds+0x14>
		readCurrentPose();		// takes 6ms we do this in a global loop
 8004fd0:	f7ff ffe4 	bl	8004f9c <readCurrentPose>
		//printf("\nDXL%i Current, Goal, Travel, Speed:", i+1);
		


		// find the amount of travel for each servo
		if( goal_pose[i] > current_pose[i]) {
 8004fd4:	4f1a      	ldr	r7, [pc, #104]	(8005040 <calculatePoseServoSpeeds+0x80>)
	uint16 travel;
	uint32 factor;

	// read the current pose only if we are not walking (no time)
	if( walk_getWalkState() == 0 ) {
		readCurrentPose();		// takes 6ms we do this in a global loop
 8004fd6:	2400      	movs	r4, #0
 8004fd8:	2500      	movs	r5, #0
		//printf("\nDXL%i Current, Goal, Travel, Speed:", i+1);
		


		// find the amount of travel for each servo
		if( goal_pose[i] > current_pose[i]) {
 8004fda:	9b02      	ldr	r3, [sp, #8]
 8004fdc:	5b5a      	ldrh	r2, [r3, r5]
 8004fde:	f837 3014 	ldrh.w	r3, [r7, r4, lsl #1]
 8004fe2:	b21b      	sxth	r3, r3
 8004fe4:	429a      	cmp	r2, r3
			travel = goal_pose[i] - current_pose[i];
 8004fe6:	bfcb      	itete	gt
 8004fe8:	f837 3014 	ldrhgt.w	r3, [r7, r4, lsl #1]
		} else {
			travel = current_pose[i] - goal_pose[i];
 8004fec:	f837 3014 	ldrhle.w	r3, [r7, r4, lsl #1]
		


		// find the amount of travel for each servo
		if( goal_pose[i] > current_pose[i]) {
			travel = goal_pose[i] - current_pose[i];
 8004ff0:	ebc3 0302 	rsbgt	r3, r3, r2
		} else {
			travel = current_pose[i] - goal_pose[i];
 8004ff4:	1a9b      	suble	r3, r3, r2
		}
		
		goal_speed[i] = (uint16) ( factor / time );
 8004ff6:	9a03      	ldr	r2, [sp, #12]

		// find the amount of travel for each servo
		if( goal_pose[i] > current_pose[i]) {
			travel = goal_pose[i] - current_pose[i];
		} else {
			travel = current_pose[i] - goal_pose[i];
 8004ff8:	b29e      	uxth	r6, r3
		}
		
		goal_speed[i] = (uint16) ( factor / time );
 8004ffa:	fbb1 f3f2 	udiv	r3, r1, r2
 8004ffe:	9a01      	ldr	r2, [sp, #4]
 8005000:	5353      	strh	r3, [r2, r5]

		// if we are walking we simply set the current pose as the goal pose to save time
		if( walk_getWalkState() != 0 ) {
 8005002:	f000 f88f 	bl	8005124 <walk_getWalkState>
 8005006:	b118      	cbz	r0, 8005010 <calculatePoseServoSpeeds+0x50>
			current_pose[i] = goal_pose[i];
 8005008:	9a02      	ldr	r2, [sp, #8]
 800500a:	5b53      	ldrh	r3, [r2, r5]
 800500c:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]
	
		// now we can calculate the desired moving speed
		// for 59pm the factor is 847.46 which we round to 848
		// we need to use a temporary 32bit integer to prevent overflow
//		factor = (uint32) 848 * travel;
		factor = (uint32) 700 * travel;
 8005010:	f44f 732f 	mov.w	r3, #700	; 0x2bc
 8005014:	fb03 f106 	mul.w	r1, r3, r6
		goal_speed[i] = (uint16) ( factor / time );
 8005018:	9a03      	ldr	r2, [sp, #12]
	
	// TEST:
	//printf("\nCalculate Pose Speeds. Time = %i \n", time);
	
	// determine travel for each servo 
	for (i=0; i<NUM_AX12_SERVOS; i++)
 800501a:	3401      	adds	r4, #1
		// now we can calculate the desired moving speed
		// for 59pm the factor is 847.46 which we round to 848
		// we need to use a temporary 32bit integer to prevent overflow
//		factor = (uint32) 848 * travel;
		factor = (uint32) 700 * travel;
		goal_speed[i] = (uint16) ( factor / time );
 800501c:	fbb1 f3f2 	udiv	r3, r1, r2
 8005020:	b29b      	uxth	r3, r3
 8005022:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8005026:	4293      	cmp	r3, r2
 8005028:	bf28      	it	cs
 800502a:	4613      	movcs	r3, r2
		// if the desired speed exceeds the maximum, we need to adjust
		if (goal_speed[i] > 1023) goal_speed[i] = 1023;
		// we also use a minimum speed of 26 (5% of 530 the max value for 59RPM)
		if (goal_speed[i] < 26) goal_speed[i] = 26;
 800502c:	9a01      	ldr	r2, [sp, #4]
 800502e:	2b19      	cmp	r3, #25
 8005030:	bf98      	it	ls
 8005032:	231a      	movls	r3, #26
 8005034:	5353      	strh	r3, [r2, r5]
	
	// TEST:
	//printf("\nCalculate Pose Speeds. Time = %i \n", time);
	
	// determine travel for each servo 
	for (i=0; i<NUM_AX12_SERVOS; i++)
 8005036:	3502      	adds	r5, #2
 8005038:	2c12      	cmp	r4, #18
 800503a:	d1ce      	bne.n	8004fda <calculatePoseServoSpeeds+0x1a>
		
		// TEST:
		//printf(" %u, %u, %u, %u", current_pose[i], goal_pose[i], travel, goal_speed[i]);
	}
	
}
 800503c:	b005      	add	sp, #20
 800503e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005040:	20000fa0 	.word	0x20000fa0

08005044 <moveToGoalPose>:
//					  flag = 1 wait for motion to finish and check alarms
// Returns	(int)	  -1  - communication error
//					   0  - all ok
//					   1  - alarm
int moveToGoalPose(uint16 time, const uint16 goal[], uint8 wait_flag)
{
 8005044:	b5f0      	push	{r4, r5, r6, r7, lr}
	//printf("setting goal pose, mode=%d\n", pose_mode);

	if (pose_mode == POSE_MODE_DIRECT || wait_flag) {
 8005046:	4b27      	ldr	r3, [pc, #156]	(80050e4 <moveToGoalPose+0xa0>)
//					  flag = 1 wait for motion to finish and check alarms
// Returns	(int)	  -1  - communication error
//					   0  - all ok
//					   1  - alarm
int moveToGoalPose(uint16 time, const uint16 goal[], uint8 wait_flag)
{
 8005048:	4614      	mov	r4, r2
	//printf("setting goal pose, mode=%d\n", pose_mode);

	if (pose_mode == POSE_MODE_DIRECT || wait_flag) {
 800504a:	781a      	ldrb	r2, [r3, #0]
 800504c:	1e23      	subs	r3, r4, #0
 800504e:	bf18      	it	ne
 8005050:	2301      	movne	r3, #1
 8005052:	2a00      	cmp	r2, #0
 8005054:	bf08      	it	eq
 8005056:	f043 0301 	orreq.w	r3, r3, #1	; 0x1
//					  flag = 1 wait for motion to finish and check alarms
// Returns	(int)	  -1  - communication error
//					   0  - all ok
//					   1  - alarm
int moveToGoalPose(uint16 time, const uint16 goal[], uint8 wait_flag)
{
 800505a:	b081      	sub	sp, #4
 800505c:	4605      	mov	r5, r0
	//printf("setting goal pose, mode=%d\n", pose_mode);

	if (pose_mode == POSE_MODE_DIRECT || wait_flag) {
 800505e:	2b00      	cmp	r3, #0
 8005060:	d033      	beq.n	80050ca <moveToGoalPose+0x86>
		int i;
		int commStatus, errorStatus;

		for (i=0; i<NUM_AX12_SERVOS; i++) {
			goal_pose[i] = goal[i];
 8005062:	4821      	ldr	r0, [pc, #132]	(80050e8 <moveToGoalPose+0xa4>)
			goal_pose_adjusted[i] = goal[i];
 8005064:	4a21      	ldr	r2, [pc, #132]	(80050ec <moveToGoalPose+0xa8>)
//					   1  - alarm
int moveToGoalPose(uint16 time, const uint16 goal[], uint8 wait_flag)
{
	//printf("setting goal pose, mode=%d\n", pose_mode);

	if (pose_mode == POSE_MODE_DIRECT || wait_flag) {
 8005066:	2300      	movs	r3, #0
		int i;
		int commStatus, errorStatus;

		for (i=0; i<NUM_AX12_SERVOS; i++) {
			goal_pose[i] = goal[i];
 8005068:	5ace      	ldrh	r6, [r1, r3]
 800506a:	52c6      	strh	r6, [r0, r3]
			goal_pose_adjusted[i] = goal[i];
 800506c:	5ace      	ldrh	r6, [r1, r3]
 800506e:	52d6      	strh	r6, [r2, r3]
 8005070:	3302      	adds	r3, #2

	if (pose_mode == POSE_MODE_DIRECT || wait_flag) {
		int i;
		int commStatus, errorStatus;

		for (i=0; i<NUM_AX12_SERVOS; i++) {
 8005072:	2b24      	cmp	r3, #36
 8005074:	d1f8      	bne.n	8005068 <moveToGoalPose+0x24>
			goal_pose[i] = goal[i];
			goal_pose_adjusted[i] = goal[i];
		}


		applyOffsetsBounds(goal_pose_adjusted);
 8005076:	481d      	ldr	r0, [pc, #116]	(80050ec <moveToGoalPose+0xa8>)
 8005078:	f7ff fe62 	bl	8004d40 <applyOffsetsBounds>

		//printf("calculate speeds\n");

		// do the setup and calculate speeds
		calculatePoseServoSpeeds(time, goal_pose_adjusted, goal_speed);
 800507c:	4628      	mov	r0, r5
 800507e:	491b      	ldr	r1, [pc, #108]	(80050ec <moveToGoalPose+0xa8>)
 8005080:	4a1b      	ldr	r2, [pc, #108]	(80050f0 <moveToGoalPose+0xac>)
 8005082:	f7ff ff9d 	bl	8004fc0 <calculatePoseServoSpeeds>

		//printf("setting goal pose done\n");

		// write out the goal positions via sync write
		dxl_set_goal_speed(NUM_AX12_SERVOS, AX12_IDS, goal_pose_adjusted, goal_speed);
 8005086:	2012      	movs	r0, #18
 8005088:	491a      	ldr	r1, [pc, #104]	(80050f4 <moveToGoalPose+0xb0>)
 800508a:	4a18      	ldr	r2, [pc, #96]	(80050ec <moveToGoalPose+0xa8>)
 800508c:	4b18      	ldr	r3, [pc, #96]	(80050f0 <moveToGoalPose+0xac>)
 800508e:	f7fe ffb5 	bl	8003ffc <dxl_set_goal_speed>
		// check for communication error or timeout

		//printf("set speeds sent\n");

		// only wait for pose to finish if requested to do so
		if( wait_flag == 1 )
 8005092:	2c01      	cmp	r4, #1
 8005094:	d122      	bne.n	80050dc <moveToGoalPose+0x98>
		{
			//printf("waiting for finish...");
			// wait for the movement to finish
			waitForPoseFinish();
 8005096:	f7ff ff63 	bl	8004f60 <waitForPoseFinish>
			//printf(" done!\n");

			// check that we didn't cause any alarms
			for (i=0; i<NUM_AX12_SERVOS; i++) {
				// ping the servo and unpack error code (if any)
				errorStatus = dxl_ping(AX12_IDS[i]);
 800509a:	4f16      	ldr	r7, [pc, #88]	(80050f4 <moveToGoalPose+0xb0>)
		// only wait for pose to finish if requested to do so
		if( wait_flag == 1 )
		{
			//printf("waiting for finish...");
			// wait for the movement to finish
			waitForPoseFinish();
 800509c:	2400      	movs	r4, #0
			//printf(" done!\n");

			// check that we didn't cause any alarms
			for (i=0; i<NUM_AX12_SERVOS; i++) {
				// ping the servo and unpack error code (if any)
				errorStatus = dxl_ping(AX12_IDS[i]);
 800509e:	5d3e      	ldrb	r6, [r7, r4]
 80050a0:	4630      	mov	r0, r6
 80050a2:	f7ff f891 	bl	80041c8 <dxl_ping>
 80050a6:	4605      	mov	r5, r0
				if(errorStatus != 0) {
 80050a8:	b158      	cbz	r0, 80050c2 <moveToGoalPose+0x7e>
					// there has been an error, disable torque
					dxl_write_byte(BROADCAST_ID, DXL_TORQUE_ENABLE, 0);
 80050aa:	2118      	movs	r1, #24
 80050ac:	2200      	movs	r2, #0
 80050ae:	20fe      	movs	r0, #254
 80050b0:	f7ff f840 	bl	8004134 <dxl_write_byte>
					PrintString("\nmoveToGoalPose Alarm ID%i - Error Code %i\n", AX12_IDS[i], errorStatus);
 80050b4:	4810      	ldr	r0, [pc, #64]	(80050f8 <moveToGoalPose+0xb4>)
 80050b6:	4631      	mov	r1, r6
 80050b8:	462a      	mov	r2, r5
 80050ba:	f7fe fcc7 	bl	8003a4c <PrintString>
 80050be:	2001      	movs	r0, #1
 80050c0:	e00d      	b.n	80050de <moveToGoalPose+0x9a>
			waitForPoseFinish();

			//printf(" done!\n");

			// check that we didn't cause any alarms
			for (i=0; i<NUM_AX12_SERVOS; i++) {
 80050c2:	3401      	adds	r4, #1
 80050c4:	2c12      	cmp	r4, #18
 80050c6:	d1ea      	bne.n	800509e <moveToGoalPose+0x5a>
 80050c8:	e008      	b.n	80050dc <moveToGoalPose+0x98>
		}

		return 0;
	} else { // pose_mode == POSE_MODE_SYNC
		for (int i=0; i<NUM_AX12_SERVOS; i++) {
			goal_pose[i] = goal[i];
 80050ca:	4a07      	ldr	r2, [pc, #28]	(80050e8 <moveToGoalPose+0xa4>)
			waitForPoseFinish();

			//printf(" done!\n");

			// check that we didn't cause any alarms
			for (i=0; i<NUM_AX12_SERVOS; i++) {
 80050cc:	2300      	movs	r3, #0
		}

		return 0;
	} else { // pose_mode == POSE_MODE_SYNC
		for (int i=0; i<NUM_AX12_SERVOS; i++) {
			goal_pose[i] = goal[i];
 80050ce:	5ac8      	ldrh	r0, [r1, r3]
 80050d0:	52d0      	strh	r0, [r2, r3]
 80050d2:	3302      	adds	r3, #2
			//readCurrentPose();
		}

		return 0;
	} else { // pose_mode == POSE_MODE_SYNC
		for (int i=0; i<NUM_AX12_SERVOS; i++) {
 80050d4:	2b24      	cmp	r3, #36
 80050d6:	d1fa      	bne.n	80050ce <moveToGoalPose+0x8a>
			goal_pose[i] = goal[i];
		}

		goal_time = time;
 80050d8:	4b08      	ldr	r3, [pc, #32]	(80050fc <moveToGoalPose+0xb8>)
 80050da:	601d      	str	r5, [r3, #0]

		return 0;
 80050dc:	2000      	movs	r0, #0
	}
}
 80050de:	b001      	add	sp, #4
 80050e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80050e2:	46c0      	nop			(mov r8, r8)
 80050e4:	20001054 	.word	0x20001054
 80050e8:	20001056 	.word	0x20001056
 80050ec:	200010c2 	.word	0x200010c2
 80050f0:	2000109e 	.word	0x2000109e
 80050f4:	08007c3e 	.word	0x08007c3e
 80050f8:	080083a4 	.word	0x080083a4
 80050fc:	2000119c 	.word	0x2000119c

08005100 <moveToDefaultPose>:

// move robot to default pose
void moveToDefaultPose()
{
 8005100:	b500      	push	{lr}
	// assume default pose defined 
	moveToGoalPose(InitialPlayTime, InitialValues, WAIT_FOR_POSE_FINISH);
 8005102:	4904      	ldr	r1, [pc, #16]	(8005114 <moveToDefaultPose+0x14>)
	}
}

// move robot to default pose
void moveToDefaultPose()
{
 8005104:	b081      	sub	sp, #4
	// assume default pose defined 
	moveToGoalPose(InitialPlayTime, InitialValues, WAIT_FOR_POSE_FINISH);
 8005106:	2201      	movs	r2, #1
 8005108:	f44f 70c8 	mov.w	r0, #400	; 0x190
 800510c:	f7ff ff9a 	bl	8005044 <moveToGoalPose>
}
 8005110:	b001      	add	sp, #4
 8005112:	bd00      	pop	{pc}
 8005114:	08007c50 	.word	0x08007c50

08005118 <walk_setWalkState>:

// function to update the walk state
void walk_setWalkState(int command)
{
	// the walk state simply corresponds to the command
	walk_state = command;
 8005118:	4b01      	ldr	r3, [pc, #4]	(8005120 <walk_setWalkState+0x8>)
 800511a:	7018      	strb	r0, [r3, #0]
}
 800511c:	4770      	bx	lr
 800511e:	46c0      	nop			(mov r8, r8)
 8005120:	200011a0 	.word	0x200011a0

08005124 <walk_getWalkState>:

// function to retrieve the walk state
// Returns (int) walk state
int walk_getWalkState()
{
 8005124:	4b01      	ldr	r3, [pc, #4]	(800512c <walk_getWalkState+0x8>)
 8005126:	7818      	ldrb	r0, [r3, #0]
	// return current walk state
	return walk_state;
}
 8005128:	4770      	bx	lr
 800512a:	46c0      	nop			(mov r8, r8)
 800512c:	200011a0 	.word	0x200011a0

08005130 <walk_shift>:
// Returns:	(int)	shift flag 0 - nothing happened
//							   1 - new motion page set
int walk_shift()
{
	// first check that the current command is a walk command
	if ( bioloid_command < COMMAND_WALK_FORWARD || bioloid_command > COMMAND_WALK_BWD_TURN_RIGHT )
 8005130:	4a4e      	ldr	r2, [pc, #312]	(800526c <walk_shift+0x13c>)
 8005132:	7813      	ldrb	r3, [r2, #0]
 8005134:	2b00      	cmp	r3, #0
 8005136:	f000 8096 	beq.w	8005266 <walk_shift+0x136>
 800513a:	7813      	ldrb	r3, [r2, #0]
 800513c:	2b10      	cmp	r3, #16
 800513e:	f200 8092 	bhi.w	8005266 <walk_shift+0x136>
		// nothing to do here, return
		return 0;
	}

	// next we deal with the special cases - walk forward related first
	if ( walk_state == 1 && bioloid_command == COMMAND_WALK_FWD_LEFT_SIDE )
 8005142:	f8df c12c 	ldr.w	ip, [pc, #300]	; 8005270 <walk_shift+0x140>
 8005146:	f89c 3000 	ldrb.w	r3, [ip]
 800514a:	2b01      	cmp	r3, #1
 800514c:	d123      	bne.n	8005196 <walk_shift+0x66>
 800514e:	7813      	ldrb	r3, [r2, #0]
 8005150:	2b07      	cmp	r3, #7
 8005152:	4619      	mov	r1, r3
 8005154:	d10d      	bne.n	8005172 <walk_shift+0x42>
	{
		// Transition WFWD -> WFLS
		if ( current_motion_page == 35 || current_motion_page == 39 )
 8005156:	4847      	ldr	r0, [pc, #284]	(8005274 <walk_shift+0x144>)
 8005158:	7802      	ldrb	r2, [r0, #0]
 800515a:	2a27      	cmp	r2, #39
 800515c:	bf14      	ite	ne
 800515e:	2300      	movne	r3, #0
 8005160:	2301      	moveq	r3, #1
 8005162:	2a23      	cmp	r2, #35
 8005164:	bf08      	it	eq
 8005166:	f043 0301 	orreq.w	r3, r3, #1	; 0x1
 800516a:	2b00      	cmp	r3, #0
 800516c:	d17b      	bne.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 108;
 800516e:	236c      	movs	r3, #108
 8005170:	e054      	b.n	800521c <walk_shift+0xec>
			walk_state = 7;
			return 1;
		}
	} else if ( walk_state == 1 && bioloid_command == COMMAND_WALK_FWD_RIGHT_SIDE )
 8005172:	7813      	ldrb	r3, [r2, #0]
 8005174:	2b08      	cmp	r3, #8
 8005176:	4619      	mov	r1, r3
 8005178:	d175      	bne.n	8005266 <walk_shift+0x136>
	{
		// Transition WFWD -> WFRS
		if ( current_motion_page == 33 || current_motion_page == 37 )
 800517a:	483e      	ldr	r0, [pc, #248]	(8005274 <walk_shift+0x144>)
 800517c:	7802      	ldrb	r2, [r0, #0]
 800517e:	2a25      	cmp	r2, #37
 8005180:	bf14      	ite	ne
 8005182:	2300      	movne	r3, #0
 8005184:	2301      	moveq	r3, #1
 8005186:	2a21      	cmp	r2, #33
 8005188:	bf08      	it	eq
 800518a:	f043 0301 	orreq.w	r3, r3, #1	; 0x1
 800518e:	2b00      	cmp	r3, #0
 8005190:	d169      	bne.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 122;
 8005192:	237a      	movs	r3, #122
 8005194:	e042      	b.n	800521c <walk_shift+0xec>
			walk_state = 8;
			return 1;
		}
	} else if ( walk_state == 7 && (bioloid_command == COMMAND_WALK_FWD_RIGHT_SIDE || bioloid_command == COMMAND_WALK_FORWARD) )
 8005196:	2b07      	cmp	r3, #7
 8005198:	d10b      	bne.n	80051b2 <walk_shift+0x82>
 800519a:	7813      	ldrb	r3, [r2, #0]
 800519c:	2b08      	cmp	r3, #8
 800519e:	d002      	beq.n	80051a6 <walk_shift+0x76>
 80051a0:	7813      	ldrb	r3, [r2, #0]
 80051a2:	2b01      	cmp	r3, #1
 80051a4:	d15f      	bne.n	8005266 <walk_shift+0x136>
	{
		// Transition WFLS -> WFRS or WFWD
		if ( current_motion_page == 111 )
 80051a6:	4a33      	ldr	r2, [pc, #204]	(8005274 <walk_shift+0x144>)
 80051a8:	7813      	ldrb	r3, [r2, #0]
 80051aa:	2b6f      	cmp	r3, #111
 80051ac:	d05b      	beq.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 36;
 80051ae:	2324      	movs	r3, #36
 80051b0:	e00c      	b.n	80051cc <walk_shift+0x9c>
			walk_state = 1;
			return 1;
		}
	} else if ( walk_state == 8 && (bioloid_command == COMMAND_WALK_FWD_LEFT_SIDE || bioloid_command == COMMAND_WALK_FORWARD) )
 80051b2:	2b08      	cmp	r3, #8
 80051b4:	d10d      	bne.n	80051d2 <walk_shift+0xa2>
 80051b6:	7813      	ldrb	r3, [r2, #0]
 80051b8:	2b07      	cmp	r3, #7
 80051ba:	d002      	beq.n	80051c2 <walk_shift+0x92>
 80051bc:	7813      	ldrb	r3, [r2, #0]
 80051be:	2b01      	cmp	r3, #1
 80051c0:	d151      	bne.n	8005266 <walk_shift+0x136>
	{
		// Transition WFRS -> WFLS or WFWD
		if ( current_motion_page == 121 )
 80051c2:	4a2c      	ldr	r2, [pc, #176]	(8005274 <walk_shift+0x144>)
 80051c4:	7813      	ldrb	r3, [r2, #0]
 80051c6:	2b79      	cmp	r3, #121
 80051c8:	d04d      	beq.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 38;
 80051ca:	2326      	movs	r3, #38
 80051cc:	7013      	strb	r3, [r2, #0]
			walk_state = 1;
 80051ce:	2201      	movs	r2, #1
 80051d0:	e045      	b.n	800525e <walk_shift+0x12e>
			return 1;
		}
	}

	// now the walk backward related special cases
	if ( walk_state == 2 && bioloid_command == COMMAND_WALK_BWD_LEFT_SIDE )
 80051d2:	2b02      	cmp	r3, #2
 80051d4:	d126      	bne.n	8005224 <walk_shift+0xf4>
 80051d6:	7813      	ldrb	r3, [r2, #0]
 80051d8:	2b09      	cmp	r3, #9
 80051da:	4619      	mov	r1, r3
 80051dc:	d10d      	bne.n	80051fa <walk_shift+0xca>
	{
		// Transition WBWD -> WBLS
		if ( current_motion_page == 45 || current_motion_page == 49 )
 80051de:	4825      	ldr	r0, [pc, #148]	(8005274 <walk_shift+0x144>)
 80051e0:	7802      	ldrb	r2, [r0, #0]
 80051e2:	2a31      	cmp	r2, #49
 80051e4:	bf14      	ite	ne
 80051e6:	2300      	movne	r3, #0
 80051e8:	2301      	moveq	r3, #1
 80051ea:	2a2d      	cmp	r2, #45
 80051ec:	bf08      	it	eq
 80051ee:	f043 0301 	orreq.w	r3, r3, #1	; 0x1
 80051f2:	2b00      	cmp	r3, #0
 80051f4:	d137      	bne.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 134;
 80051f6:	3b7a      	subs	r3, #122
 80051f8:	e010      	b.n	800521c <walk_shift+0xec>
			walk_state = 9;
			return 1;
		}
	} else if ( walk_state == 2 && bioloid_command == COMMAND_WALK_BWD_RIGHT_SIDE )
 80051fa:	7813      	ldrb	r3, [r2, #0]
 80051fc:	2b0a      	cmp	r3, #10
 80051fe:	4619      	mov	r1, r3
 8005200:	d131      	bne.n	8005266 <walk_shift+0x136>
	{
		// Transition WBWD -> WBRS
		if ( current_motion_page == 47 || current_motion_page == 51 )
 8005202:	481c      	ldr	r0, [pc, #112]	(8005274 <walk_shift+0x144>)
 8005204:	7802      	ldrb	r2, [r0, #0]
 8005206:	2a33      	cmp	r2, #51
 8005208:	bf14      	ite	ne
 800520a:	2300      	movne	r3, #0
 800520c:	2301      	moveq	r3, #1
 800520e:	2a2f      	cmp	r2, #47
 8005210:	bf08      	it	eq
 8005212:	f043 0301 	orreq.w	r3, r3, #1	; 0x1
 8005216:	2b00      	cmp	r3, #0
 8005218:	d125      	bne.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 144;
 800521a:	3b70      	subs	r3, #112
 800521c:	7003      	strb	r3, [r0, #0]
			walk_state = 10;
 800521e:	f88c 1000 	strb.w	r1, [ip]
 8005222:	e01e      	b.n	8005262 <walk_shift+0x132>
			return 1;
		}
	} else if ( walk_state == 9 && (bioloid_command == COMMAND_WALK_BWD_RIGHT_SIDE || bioloid_command == COMMAND_WALK_BACKWARD) )
 8005224:	2b09      	cmp	r3, #9
 8005226:	d10b      	bne.n	8005240 <walk_shift+0x110>
 8005228:	7813      	ldrb	r3, [r2, #0]
 800522a:	2b0a      	cmp	r3, #10
 800522c:	d002      	beq.n	8005234 <walk_shift+0x104>
 800522e:	7813      	ldrb	r3, [r2, #0]
 8005230:	2b02      	cmp	r3, #2
 8005232:	d118      	bne.n	8005266 <walk_shift+0x136>
	{
		// Transition WBLS -> WBRS or WBWD
		if ( current_motion_page == 133 )
 8005234:	4a0f      	ldr	r2, [pc, #60]	(8005274 <walk_shift+0x144>)
 8005236:	7813      	ldrb	r3, [r2, #0]
 8005238:	2b85      	cmp	r3, #133
 800523a:	d014      	beq.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 50;
 800523c:	2332      	movs	r3, #50
 800523e:	e00c      	b.n	800525a <walk_shift+0x12a>
			walk_state = 2;
			return 1;
		}
	} else if ( walk_state == 10 && (bioloid_command == COMMAND_WALK_BWD_LEFT_SIDE || bioloid_command == COMMAND_WALK_BACKWARD) )
 8005240:	2b0a      	cmp	r3, #10
 8005242:	d110      	bne.n	8005266 <walk_shift+0x136>
 8005244:	7813      	ldrb	r3, [r2, #0]
 8005246:	2b09      	cmp	r3, #9
 8005248:	d002      	beq.n	8005250 <walk_shift+0x120>
 800524a:	7813      	ldrb	r3, [r2, #0]
 800524c:	2b02      	cmp	r3, #2
 800524e:	d10a      	bne.n	8005266 <walk_shift+0x136>
	{
		// Transition WBRS -> WBLS or WBWD
		if ( current_motion_page == 147 )
 8005250:	4a08      	ldr	r2, [pc, #32]	(8005274 <walk_shift+0x144>)
 8005252:	7813      	ldrb	r3, [r2, #0]
 8005254:	2b93      	cmp	r3, #147
 8005256:	d006      	beq.n	8005266 <walk_shift+0x136>
		{
			// nothing to do yet, return
			return 0;
		} else {
			// last step is finished, switch motion page
			current_motion_page = 48;
 8005258:	2330      	movs	r3, #48
 800525a:	7013      	strb	r3, [r2, #0]
			walk_state = 2;
 800525c:	2202      	movs	r2, #2
 800525e:	4b04      	ldr	r3, [pc, #16]	(8005270 <walk_shift+0x140>)
 8005260:	701a      	strb	r2, [r3, #0]
 8005262:	2001      	movs	r0, #1
 8005264:	e000      	b.n	8005268 <walk_shift+0x138>
			return 1;
 8005266:	2000      	movs	r0, #0
		}
	}

	// in all other cases nothing happened
	return 0;
}
 8005268:	4770      	bx	lr
 800526a:	46c0      	nop			(mov r8, r8)
 800526c:	20000f74 	.word	0x20000f74
 8005270:	200011a0 	.word	0x200011a0
 8005274:	20000f79 	.word	0x20000f79

08005278 <walk_avoidObstacle>:
//								2 - currently avoiding obstacle
//							   -1 - finished avoiding
int walk_avoidObstacle(int obstacle_flag)
{
	// first check if we are currently in obstacle avoidance mode
	if ( obstacle_flag == 1 || obstacle_flag == 2 )
 8005278:	1e43      	subs	r3, r0, #1
 800527a:	2b01      	cmp	r3, #1
 800527c:	d80e      	bhi.n	800529c <walk_avoidObstacle+0x24>
	{
#ifdef ACCEL_AND_ULTRASONIC
		if ( adc_dms_distance > SAFE_DISTANCE && adc_ultrasonic_distance > SAFE_DISTANCE )
#else
		if ( adc_dms_distance > SAFE_DISTANCE )
 800527e:	4b10      	ldr	r3, [pc, #64]	(80052c0 <walk_avoidObstacle+0x48>)
 8005280:	881b      	ldrh	r3, [r3, #0]
 8005282:	2b32      	cmp	r3, #50
 8005284:	d801      	bhi.n	800528a <walk_avoidObstacle+0x12>
 8005286:	2002      	movs	r0, #2
 8005288:	e018      	b.n	80052bc <walk_avoidObstacle+0x44>
#endif
		{
			// have cleared the obstacle, return to walking forward
			last_bioloid_command = bioloid_command;
 800528a:	490e      	ldr	r1, [pc, #56]	(80052c4 <walk_avoidObstacle+0x4c>)
 800528c:	4a0e      	ldr	r2, [pc, #56]	(80052c8 <walk_avoidObstacle+0x50>)
 800528e:	780b      	ldrb	r3, [r1, #0]
			bioloid_command = COMMAND_WALK_FORWARD;
 8005290:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
#else
		if ( adc_dms_distance > SAFE_DISTANCE )
#endif
		{
			// have cleared the obstacle, return to walking forward
			last_bioloid_command = bioloid_command;
 8005294:	7013      	strb	r3, [r2, #0]
			bioloid_command = COMMAND_WALK_FORWARD;
 8005296:	2301      	movs	r3, #1
 8005298:	700b      	strb	r3, [r1, #0]
 800529a:	e00f      	b.n	80052bc <walk_avoidObstacle+0x44>
			return 2;
		}
	}

	// next check for a new obstacle
	if ( obstacle_flag == 0 || obstacle_flag == -1 )
 800529c:	1c43      	adds	r3, r0, #1
 800529e:	2b01      	cmp	r3, #1
 80052a0:	d80b      	bhi.n	80052ba <walk_avoidObstacle+0x42>
	{
#ifdef ACCEL_AND_ULTRASONIC
		if ( adc_dms_distance < MINIMUM_DISTANCE || adc_ultrasonic_distance < MINIMUM_DISTANCE )
#else
		if ( adc_dms_distance < MINIMUM_DISTANCE )
 80052a2:	4b07      	ldr	r3, [pc, #28]	(80052c0 <walk_avoidObstacle+0x48>)
 80052a4:	881b      	ldrh	r3, [r3, #0]
 80052a6:	2b13      	cmp	r3, #19
 80052a8:	d807      	bhi.n	80052ba <walk_avoidObstacle+0x42>
#endif
		{
			// have found an obstacle, start turning left
			last_bioloid_command = bioloid_command;
 80052aa:	4906      	ldr	r1, [pc, #24]	(80052c4 <walk_avoidObstacle+0x4c>)
 80052ac:	4a06      	ldr	r2, [pc, #24]	(80052c8 <walk_avoidObstacle+0x50>)
 80052ae:	780b      	ldrb	r3, [r1, #0]
			bioloid_command = COMMAND_WALK_TURN_LEFT;
 80052b0:	2001      	movs	r0, #1
#else
		if ( adc_dms_distance < MINIMUM_DISTANCE )
#endif
		{
			// have found an obstacle, start turning left
			last_bioloid_command = bioloid_command;
 80052b2:	7013      	strb	r3, [r2, #0]
			bioloid_command = COMMAND_WALK_TURN_LEFT;
 80052b4:	2303      	movs	r3, #3
 80052b6:	700b      	strb	r3, [r1, #0]
 80052b8:	e000      	b.n	80052bc <walk_avoidObstacle+0x44>
			return 1;
 80052ba:	2000      	movs	r0, #0
			return 0;
		}
	}
	// not needed, but avoids compiler warning :)
	return 0;
}
 80052bc:	4770      	bx	lr
 80052be:	46c0      	nop			(mov r8, r8)
 80052c0:	20000f72 	.word	0x20000f72
 80052c4:	20000f74 	.word	0x20000f74
 80052c8:	20000f75 	.word	0x20000f75

080052cc <walk_init>:
static uint8 walk_state = 0;

// initialize for walking - assume walk ready pose
// Note: it is called from motion.c's executeMotion() when a new walk command is issued (from previously not walking)
void walk_init()
{
 80052cc:	b500      	push	{lr}
	PrintString("walk_init\n");
 80052ce:	480b      	ldr	r0, [pc, #44]	(80052fc <walk_init+0x30>)
static uint8 walk_state = 0;

// initialize for walking - assume walk ready pose
// Note: it is called from motion.c's executeMotion() when a new walk command is issued (from previously not walking)
void walk_init()
{
 80052d0:	b081      	sub	sp, #4
	PrintString("walk_init\n");
 80052d2:	f7fe fbbb 	bl	8003a4c <PrintString>
	int commStatus = 0;

	// reset walk state and command
	walk_state = 0;
 80052d6:	4b0a      	ldr	r3, [pc, #40]	(8005300 <walk_init+0x34>)
 80052d8:	2200      	movs	r2, #0
 80052da:	701a      	strb	r2, [r3, #0]
	walk_command = 0;
 80052dc:	4b09      	ldr	r3, [pc, #36]	(8005304 <walk_init+0x38>)

	// and get ready for walking!
	current_motion_page = COMMAND_WALK_READY_MP;
	executeMotion(current_motion_page);
 80052de:	201f      	movs	r0, #31
	PrintString("walk_init\n");
	int commStatus = 0;

	// reset walk state and command
	walk_state = 0;
	walk_command = 0;
 80052e0:	701a      	strb	r2, [r3, #0]

	// and get ready for walking!
	current_motion_page = COMMAND_WALK_READY_MP;
 80052e2:	4b09      	ldr	r3, [pc, #36]	(8005308 <walk_init+0x3c>)
 80052e4:	221f      	movs	r2, #31
 80052e6:	701a      	strb	r2, [r3, #0]
	executeMotion(current_motion_page);
 80052e8:	f7ff fac4 	bl	8004874 <executeMotion>

	// experimental - increase punch for walking
	dxl_write_word(BROADCAST_ID, DXL_PUNCH_L, 100);
 80052ec:	20fe      	movs	r0, #254
 80052ee:	2130      	movs	r1, #48
 80052f0:	2264      	movs	r2, #100
 80052f2:	f7fe fed7 	bl	80040a4 <dxl_write_word>
}
 80052f6:	b001      	add	sp, #4
 80052f8:	bd00      	pop	{pc}
 80052fa:	46c0      	nop			(mov r8, r8)
 80052fc:	080083d0 	.word	0x080083d0
 8005300:	200011a0 	.word	0x200011a0
 8005304:	200011a1 	.word	0x200011a1
 8005308:	20000f79 	.word	0x20000f79

0800530c <SetEPort>:
PORT_SIG_MOT6P, PIN_SIG_MOT6P }, { PORT_SIG_MOT6M,
PIN_SIG_MOT6M } };



void SetEPort(EPortD_t pin, u8 state) {
 800530c:	b500      	push	{lr}
 800530e:	4b09      	ldr	r3, [pc, #36]	(8005334 <SetEPort+0x28>)
 8005310:	b081      	sub	sp, #4
 8005312:	00c2      	lsls	r2, r0, #3
	if (state)
 8005314:	b131      	cbz	r1, 8005324 <SetEPort+0x18>
		GPIO_SetBits(EasyEPort[pin].port, EasyEPort[pin].pin);
 8005316:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
 800531a:	189b      	adds	r3, r3, r2
 800531c:	8899      	ldrh	r1, [r3, #4]
 800531e:	f001 fc45 	bl	8006bac <GPIO_SetBits>
 8005322:	e005      	b.n	8005330 <SetEPort+0x24>
	else
		GPIO_ResetBits(EasyEPort[pin].port, EasyEPort[pin].pin);
 8005324:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
 8005328:	189b      	adds	r3, r3, r2
 800532a:	8899      	ldrh	r1, [r3, #4]
 800532c:	f001 fc40 	bl	8006bb0 <GPIO_ResetBits>
}
 8005330:	b001      	add	sp, #4
 8005332:	bd00      	pop	{pc}
 8005334:	20000004 	.word	0x20000004

08005338 <ReadAnalog>:

#define ANALOG_RIGHT_BIT_SHIFT          0
//##############################################################################
u16 ReadAnalog(EPortA_t port) {
 8005338:	b510      	push	{r4, lr}
	if ((port == EPORT1A) || (port == EPORT4A)) {
 800533a:	f1d0 0401 	rsbs	r4, r0, #1	; 0x1
 800533e:	bf38      	it	cc
 8005340:	2400      	movcc	r4, #0
 8005342:	2803      	cmp	r0, #3
 8005344:	bf14      	ite	ne
 8005346:	4623      	movne	r3, r4
 8005348:	f044 0301 	orreq.w	r3, r4, #1	; 0x1
 800534c:	b123      	cbz	r3, 8005358 <ReadAnalog+0x20>
		// Select EPORT1A and EPORT4A via multiplexer
		GPIO_ResetBits(PORT_ADC_SELECT0, PIN_ADC_SELECT0);
 800534e:	4833      	ldr	r0, [pc, #204]	(800541c <ReadAnalog+0xe4>)
 8005350:	2102      	movs	r1, #2
 8005352:	f001 fc2d 	bl	8006bb0 <GPIO_ResetBits>
 8005356:	e00d      	b.n	8005374 <ReadAnalog+0x3c>
			ADC_SoftwareStartConvCmd(ADC2, ENABLE);
			uDelay(5);
			return (u16) (ADC_GetConversionValue(ADC2))
					>> ANALOG_RIGHT_BIT_SHIFT;
		}
	} else if ((port == EPORT2A) || (port == EPORT5A)) {
 8005358:	2801      	cmp	r0, #1
 800535a:	bf14      	ite	ne
 800535c:	2400      	movne	r4, #0
 800535e:	2401      	moveq	r4, #1
 8005360:	2804      	cmp	r0, #4
 8005362:	bf14      	ite	ne
 8005364:	4623      	movne	r3, r4
 8005366:	f044 0301 	orreq.w	r3, r4, #1	; 0x1
 800536a:	b143      	cbz	r3, 800537e <ReadAnalog+0x46>
		// Select EPORT2A and EPORT5A via multiplexer
		GPIO_SetBits(PORT_ADC_SELECT0, PIN_ADC_SELECT0);
 800536c:	482b      	ldr	r0, [pc, #172]	(800541c <ReadAnalog+0xe4>)
 800536e:	2102      	movs	r1, #2
 8005370:	f001 fc1c 	bl	8006bac <GPIO_SetBits>
		GPIO_ResetBits(PORT_ADC_SELECT1, PIN_ADC_SELECT1);
 8005374:	4829      	ldr	r0, [pc, #164]	(800541c <ReadAnalog+0xe4>)
 8005376:	2104      	movs	r1, #4
 8005378:	f001 fc1a 	bl	8006bb0 <GPIO_ResetBits>
 800537c:	e011      	b.n	80053a2 <ReadAnalog+0x6a>
			ADC_SoftwareStartConvCmd(ADC2, ENABLE);
			uDelay(5);
			return (u16) (ADC_GetConversionValue(ADC2))
					>> ANALOG_RIGHT_BIT_SHIFT;
		}
	} else if ((port == EPORT3A) || (port == EPORT6A)) {
 800537e:	2802      	cmp	r0, #2
 8005380:	bf14      	ite	ne
 8005382:	2400      	movne	r4, #0
 8005384:	2401      	moveq	r4, #1
 8005386:	2805      	cmp	r0, #5
 8005388:	bf14      	ite	ne
 800538a:	4623      	movne	r3, r4
 800538c:	f044 0301 	orreq.w	r3, r4, #1	; 0x1
 8005390:	b303      	cbz	r3, 80053d4 <ReadAnalog+0x9c>
		// Select EPORT3A and EPORT6A via multiplexer
		GPIO_ResetBits(PORT_ADC_SELECT0, PIN_ADC_SELECT0);
 8005392:	4822      	ldr	r0, [pc, #136]	(800541c <ReadAnalog+0xe4>)
 8005394:	2102      	movs	r1, #2
 8005396:	f001 fc0b 	bl	8006bb0 <GPIO_ResetBits>
		GPIO_SetBits(PORT_ADC_SELECT1, PIN_ADC_SELECT1);
 800539a:	4820      	ldr	r0, [pc, #128]	(800541c <ReadAnalog+0xe4>)
 800539c:	2104      	movs	r1, #4
 800539e:	f001 fc05 	bl	8006bac <GPIO_SetBits>

		uDelay(5);
 80053a2:	2005      	movs	r0, #5
 80053a4:	f000 f8d0 	bl	8005548 <uDelay>

		if (port == EPORT3A) {
 80053a8:	b144      	cbz	r4, 80053bc <ReadAnalog+0x84>
			// Start ADC1 Software Conversion
			ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 80053aa:	481d      	ldr	r0, [pc, #116]	(8005420 <ReadAnalog+0xe8>)
 80053ac:	2101      	movs	r1, #1
 80053ae:	f000 ff95 	bl	80062dc <ADC_SoftwareStartConvCmd>
			uDelay(5);
 80053b2:	2005      	movs	r0, #5
 80053b4:	f000 f8c8 	bl	8005548 <uDelay>
			return (u16) (ADC_GetConversionValue(ADC1))
 80053b8:	4819      	ldr	r0, [pc, #100]	(8005420 <ReadAnalog+0xe8>)
 80053ba:	e007      	b.n	80053cc <ReadAnalog+0x94>
					>> ANALOG_RIGHT_BIT_SHIFT;
		} else {
			// Start ADC2 Software Conversion
			ADC_SoftwareStartConvCmd(ADC2, ENABLE);
 80053bc:	4819      	ldr	r0, [pc, #100]	(8005424 <ReadAnalog+0xec>)
 80053be:	2101      	movs	r1, #1
 80053c0:	f000 ff8c 	bl	80062dc <ADC_SoftwareStartConvCmd>
			uDelay(5);
 80053c4:	2005      	movs	r0, #5
 80053c6:	f000 f8bf 	bl	8005548 <uDelay>
			return (u16) (ADC_GetConversionValue(ADC2))
 80053ca:	4816      	ldr	r0, [pc, #88]	(8005424 <ReadAnalog+0xec>)
 80053cc:	f000 fffe 	bl	80063cc <ADC_GetConversionValue>
 80053d0:	4604      	mov	r4, r0
 80053d2:	e021      	b.n	8005418 <ReadAnalog+0xe0>
					>> ANALOG_RIGHT_BIT_SHIFT;
		}
	} else if (port == VBUS) {
 80053d4:	2806      	cmp	r0, #6
 80053d6:	bf18      	it	ne
 80053d8:	f44f 4400 	movne.w	r4, #32768	; 0x8000
 80053dc:	d11c      	bne.n	8005418 <ReadAnalog+0xe0>
		u16 temp;

		// Set ADC1 to read SIG_VDD/VBUS on Channel 13
		ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 1,
 80053de:	2201      	movs	r2, #1
 80053e0:	2307      	movs	r3, #7
 80053e2:	210d      	movs	r1, #13
 80053e4:	480e      	ldr	r0, [pc, #56]	(8005420 <ReadAnalog+0xe8>)
 80053e6:	f000 ff9b 	bl	8006320 <ADC_RegularChannelConfig>
		ADC_SampleTime_239Cycles5);
		uDelay(5);
 80053ea:	2005      	movs	r0, #5
 80053ec:	f000 f8ac 	bl	8005548 <uDelay>
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 80053f0:	2101      	movs	r1, #1
 80053f2:	480b      	ldr	r0, [pc, #44]	(8005420 <ReadAnalog+0xe8>)
 80053f4:	f000 ff72 	bl	80062dc <ADC_SoftwareStartConvCmd>
		uDelay(5);
 80053f8:	2005      	movs	r0, #5
 80053fa:	f000 f8a5 	bl	8005548 <uDelay>
		temp = (ADC_GetConversionValue(ADC1)) >> ANALOG_RIGHT_BIT_SHIFT;
 80053fe:	4808      	ldr	r0, [pc, #32]	(8005420 <ReadAnalog+0xe8>)
 8005400:	f000 ffe4 	bl	80063cc <ADC_GetConversionValue>

		// Set ADC1 to read SIG_ADC0 (ADC1 multiplexer output) on Channel 10
		ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1,
 8005404:	210a      	movs	r1, #10
		ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 1,
		ADC_SampleTime_239Cycles5);
		uDelay(5);
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
		uDelay(5);
		temp = (ADC_GetConversionValue(ADC1)) >> ANALOG_RIGHT_BIT_SHIFT;
 8005406:	4604      	mov	r4, r0

		// Set ADC1 to read SIG_ADC0 (ADC1 multiplexer output) on Channel 10
		ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1,
 8005408:	2201      	movs	r2, #1
 800540a:	4805      	ldr	r0, [pc, #20]	(8005420 <ReadAnalog+0xe8>)
 800540c:	2307      	movs	r3, #7
 800540e:	f000 ff87 	bl	8006320 <ADC_RegularChannelConfig>
		ADC_SampleTime_239Cycles5);
		uDelay(5);
 8005412:	2005      	movs	r0, #5
 8005414:	f000 f898 	bl	8005548 <uDelay>

		return temp;
	}
	return 0x8000;
}
 8005418:	4620      	mov	r0, r4
 800541a:	bd10      	pop	{r4, pc}
 800541c:	40011000 	.word	0x40011000
 8005420:	40012400 	.word	0x40012400
 8005424:	40012800 	.word	0x40012800

08005428 <Battery_Monitor_Alarm>:

	return temp;
}

//##############################################################################
void Battery_Monitor_Alarm(void) {
 8005428:	b500      	push	{lr}
	u16 volt = ReadAnalog(VBUS) >> 4;
 800542a:	2006      	movs	r0, #6

	return temp;
}

//##############################################################################
void Battery_Monitor_Alarm(void) {
 800542c:	b081      	sub	sp, #4
	u16 volt = ReadAnalog(VBUS) >> 4;
 800542e:	f7ff ff83 	bl	8005338 <ReadAnalog>
	//Printu32d(volt);
	//PrintString("e-1 [Volts]\n");
#endif

	// ALARM!!!
	if (volt < VBUS_LOW_LIMIT) {
 8005432:	0900      	lsrs	r0, r0, #4
 8005434:	b280      	uxth	r0, r0
 8005436:	2872      	cmp	r0, #114
 8005438:	d815      	bhi.n	8005466 <Battery_Monitor_Alarm+0x3e>
		Buzzed(500, 100);
 800543a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800543e:	2164      	movs	r1, #100
 8005440:	f000 f85c 	bl	80054fc <Buzzed>
		Buzzed(500, 5000);
 8005444:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8005448:	f241 3188 	movw	r1, #5000	; 0x1388
 800544c:	f000 f856 	bl	80054fc <Buzzed>
		Buzzed(500, 100);
 8005450:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8005454:	2164      	movs	r1, #100
 8005456:	f000 f851 	bl	80054fc <Buzzed>
		Buzzed(500, 5000);
 800545a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800545e:	f241 3188 	movw	r1, #5000	; 0x1388
 8005462:	f000 f84b 	bl	80054fc <Buzzed>
		PrintString("Battery Voltage Critical");
		PrintString("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
#endif
	}
	return;
}
 8005466:	b001      	add	sp, #4
 8005468:	bd00      	pop	{pc}
 800546a:	46c0      	nop			(mov r8, r8)

0800546c <ReadIR>:
	}
	return 0x8000;
}

//##############################################################################
u16 ReadIR(EPortA_t port) {
 800546c:	b570      	push	{r4, r5, r6, lr}
	u16 temp;

	SetEPort((port * 2), 1);
 800546e:	0044      	lsls	r4, r0, #1
 8005470:	b2e6      	uxtb	r6, r4
	SetEPort((port * 2) + 1, 0);
 8005472:	3401      	adds	r4, #1
	}
	return 0x8000;
}

//##############################################################################
u16 ReadIR(EPortA_t port) {
 8005474:	4605      	mov	r5, r0
	u16 temp;

	SetEPort((port * 2), 1);
 8005476:	2101      	movs	r1, #1
 8005478:	4630      	mov	r0, r6
	SetEPort((port * 2) + 1, 0);
 800547a:	b2e4      	uxtb	r4, r4

//##############################################################################
u16 ReadIR(EPortA_t port) {
	u16 temp;

	SetEPort((port * 2), 1);
 800547c:	f7ff ff46 	bl	800530c <SetEPort>
	SetEPort((port * 2) + 1, 0);
 8005480:	2100      	movs	r1, #0
 8005482:	4620      	mov	r0, r4
 8005484:	f7ff ff42 	bl	800530c <SetEPort>

	uDelay(25);
 8005488:	2019      	movs	r0, #25
 800548a:	f000 f85d 	bl	8005548 <uDelay>
	temp = ReadAnalog(port);
 800548e:	4628      	mov	r0, r5
 8005490:	f7ff ff52 	bl	8005338 <ReadAnalog>

	SetEPort((port * 2), 0);
 8005494:	2100      	movs	r1, #0

	SetEPort((port * 2), 1);
	SetEPort((port * 2) + 1, 0);

	uDelay(25);
	temp = ReadAnalog(port);
 8005496:	4605      	mov	r5, r0

	SetEPort((port * 2), 0);
 8005498:	4630      	mov	r0, r6
 800549a:	f7ff ff37 	bl	800530c <SetEPort>
	SetEPort((port * 2) + 1, 0);
 800549e:	4620      	mov	r0, r4
 80054a0:	2100      	movs	r1, #0
 80054a2:	f7ff ff33 	bl	800530c <SetEPort>

	return temp;
}
 80054a6:	4628      	mov	r0, r5
 80054a8:	bd70      	pop	{r4, r5, r6, pc}
 80054aa:	46c0      	nop			(mov r8, r8)

080054ac <ReadButton>:
EasyPort_t EasyButton[6] = { { PORT_SW_UP, PIN_SW_UP }, { PORT_SW_DOWN,
PIN_SW_DOWN }, { PORT_SW_LEFT, PIN_SW_LEFT }, {
PORT_SW_RIGHT, PIN_SW_RIGHT }, { PORT_SW_START,
PIN_SW_START }, { PORT_MIC, PIN_MIC } };
//##############################################################################
u8 ReadButton(Button_t button) {
 80054ac:	b500      	push	{lr}
	if (GPIO_ReadInputDataBit(EasyButton[button].port, EasyButton[button].pin)	!= SET)
 80054ae:	4b07      	ldr	r3, [pc, #28]	(80054cc <ReadButton+0x20>)
EasyPort_t EasyButton[6] = { { PORT_SW_UP, PIN_SW_UP }, { PORT_SW_DOWN,
PIN_SW_DOWN }, { PORT_SW_LEFT, PIN_SW_LEFT }, {
PORT_SW_RIGHT, PIN_SW_RIGHT }, { PORT_SW_START,
PIN_SW_START }, { PORT_MIC, PIN_MIC } };
//##############################################################################
u8 ReadButton(Button_t button) {
 80054b0:	b081      	sub	sp, #4
	if (GPIO_ReadInputDataBit(EasyButton[button].port, EasyButton[button].pin)	!= SET)
 80054b2:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
 80054b6:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 80054ba:	8899      	ldrh	r1, [r3, #4]
 80054bc:	4610      	mov	r0, r2
 80054be:	f001 fb61 	bl	8006b84 <GPIO_ReadInputDataBit>
 80054c2:	3801      	subs	r0, #1
 80054c4:	bf18      	it	ne
 80054c6:	2001      	movne	r0, #1
		return 1;
	return 0;
}
 80054c8:	b001      	add	sp, #4
 80054ca:	bd00      	pop	{pc}
 80054cc:	20000064 	.word	0x20000064

080054d0 <SetLED>:
PIN_LED_MANAGE }, { PORT_LED_PROGRAM, PIN_LED_PROGRAM }, { PORT_LED_PLAY,
PIN_LED_PLAY }, { PORT_LED_TXD, PIN_LED_TXD }, { PORT_LED_RXD,
PIN_LED_RXD }, { PORT_LED_AUX, PIN_LED_AUX } };

//##############################################################################
void SetLED(LED_t led, u8 state) {
 80054d0:	b500      	push	{lr}
 80054d2:	4b09      	ldr	r3, [pc, #36]	(80054f8 <SetLED+0x28>)
 80054d4:	b081      	sub	sp, #4
 80054d6:	00c2      	lsls	r2, r0, #3
	if (state)
 80054d8:	b131      	cbz	r1, 80054e8 <SetLED+0x18>
		GPIO_ResetBits(EasyLED[led].port, EasyLED[led].pin);
 80054da:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
 80054de:	189b      	adds	r3, r3, r2
 80054e0:	8899      	ldrh	r1, [r3, #4]
 80054e2:	f001 fb65 	bl	8006bb0 <GPIO_ResetBits>
 80054e6:	e005      	b.n	80054f4 <SetLED+0x24>
	else
		GPIO_SetBits(EasyLED[led].port, EasyLED[led].pin);
 80054e8:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
 80054ec:	189b      	adds	r3, r3, r2
 80054ee:	8899      	ldrh	r1, [r3, #4]
 80054f0:	f001 fb5c 	bl	8006bac <GPIO_SetBits>
}
 80054f4:	b001      	add	sp, #4
 80054f6:	bd00      	pop	{pc}
 80054f8:	20000094 	.word	0x20000094

080054fc <Buzzed>:
#include "system_init.h"
#include "system_func.h"


//##############################################################################
void Buzzed(u32 mlength, u32 tone) {
 80054fc:	b530      	push	{r4, r5, lr}
 80054fe:	b081      	sub	sp, #4
 8005500:	460c      	mov	r4, r1
	//   using uDelay(), 50% duty cycle, cents relative to A_5

//#define FREQTOTONE(f)    (5000000/f)    // (1/(2*1e-6*f))

	start_countdown_buzzer(mlength);
	while (glBuzzerCounter > 0) {
 8005502:	4d0b      	ldr	r5, [pc, #44]	(8005530 <Buzzed+0x34>)
	// tone = 1/(2*1e-6*f) = 1/(2*1e-6*440*2^(cents_relative/1200))
	//   using uDelay(), 50% duty cycle, cents relative to A_5

//#define FREQTOTONE(f)    (5000000/f)    // (1/(2*1e-6*f))

	start_countdown_buzzer(mlength);
 8005504:	f000 f84c 	bl	80055a0 <start_countdown_buzzer>
 8005508:	e00d      	b.n	8005526 <Buzzed+0x2a>
	while (glBuzzerCounter > 0) {
		GPIO_ResetBits(PORT_BUZZER, PIN_BUZZER);
 800550a:	2140      	movs	r1, #64
 800550c:	4809      	ldr	r0, [pc, #36]	(8005534 <Buzzed+0x38>)
 800550e:	f001 fb4f 	bl	8006bb0 <GPIO_ResetBits>
		uDelay(tone);
 8005512:	4620      	mov	r0, r4
 8005514:	f000 f818 	bl	8005548 <uDelay>
		GPIO_SetBits(PORT_BUZZER, PIN_BUZZER);
 8005518:	4806      	ldr	r0, [pc, #24]	(8005534 <Buzzed+0x38>)
 800551a:	2140      	movs	r1, #64
 800551c:	f001 fb46 	bl	8006bac <GPIO_SetBits>
		uDelay(tone);
 8005520:	4620      	mov	r0, r4
 8005522:	f000 f811 	bl	8005548 <uDelay>
	//   using uDelay(), 50% duty cycle, cents relative to A_5

//#define FREQTOTONE(f)    (5000000/f)    // (1/(2*1e-6*f))

	start_countdown_buzzer(mlength);
	while (glBuzzerCounter > 0) {
 8005526:	682b      	ldr	r3, [r5, #0]
 8005528:	2b00      	cmp	r3, #0
 800552a:	d1ee      	bne.n	800550a <Buzzed+0xe>
		GPIO_ResetBits(PORT_BUZZER, PIN_BUZZER);
		uDelay(tone);
		GPIO_SetBits(PORT_BUZZER, PIN_BUZZER);
		uDelay(tone);
	}
}
 800552c:	b001      	add	sp, #4
 800552e:	bd30      	pop	{r4, r5, pc}
 8005530:	200011b8 	.word	0x200011b8
 8005534:	40010800 	.word	0x40010800

08005538 <PlayNote>:

//##############################################################################
void PlayNote(u32 mlength, buzzed_note_t note, u8 octave) {
 8005538:	b500      	push	{lr}
	Buzzed(mlength, (u32) (note >> octave));
 800553a:	4111      	asrs	r1, r2
		uDelay(tone);
	}
}

//##############################################################################
void PlayNote(u32 mlength, buzzed_note_t note, u8 octave) {
 800553c:	b081      	sub	sp, #4
	Buzzed(mlength, (u32) (note >> octave));
 800553e:	f7ff ffdd 	bl	80054fc <Buzzed>
}
 8005542:	b001      	add	sp, #4
 8005544:	bd00      	pop	{pc}
 8005546:	46c0      	nop			(mov r8, r8)

08005548 <uDelay>:
	uDelay(nTime * 1000);
}

//##############################################################################
void uDelay(u32 nTime) {
	if (glDelayCounter == 0)
 8005548:	4b0c      	ldr	r3, [pc, #48]	(800557c <uDelay+0x34>)
 800554a:	681b      	ldr	r3, [r3, #0]
 800554c:	b923      	cbnz	r3, 8005558 <uDelay+0x10>
		gbCounterCount++;
 800554e:	4a0c      	ldr	r2, [pc, #48]	(8005580 <uDelay+0x38>)
 8005550:	7813      	ldrb	r3, [r2, #0]
 8005552:	3301      	adds	r3, #1
 8005554:	b2db      	uxtb	r3, r3
 8005556:	7013      	strb	r3, [r2, #0]
	if (nTime>=100)
	glDelayCounter = (nTime/100);
	else
	glDelayCounter = 1;
#elif defined USING_SYSTICK_10US
	if (nTime >= 10)
 8005558:	2809      	cmp	r0, #9
 800555a:	4908      	ldr	r1, [pc, #32]	(800557c <uDelay+0x34>)
 800555c:	d904      	bls.n	8005568 <uDelay+0x20>
		glDelayCounter = (nTime / 10);
 800555e:	4a09      	ldr	r2, [pc, #36]	(8005584 <uDelay+0x3c>)
 8005560:	fba0 2302 	umull	r2, r3, r0, r2
 8005564:	08db      	lsrs	r3, r3, #3
 8005566:	e000      	b.n	800556a <uDelay+0x22>
	else
		glDelayCounter = 1;
 8005568:	2301      	movs	r3, #1
 800556a:	600b      	str	r3, [r1, #0]
#elif defined USING_SYSTICK_1US
	glDelayCounter = (nTime);
#endif

	if (gbCounterCount == 1) {
 800556c:	4b04      	ldr	r3, [pc, #16]	(8005580 <uDelay+0x38>)
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}

	while (glDelayCounter != 0)
 800556e:	4a03      	ldr	r2, [pc, #12]	(800557c <uDelay+0x34>)
		glDelayCounter = 1;
#elif defined USING_SYSTICK_1US
	glDelayCounter = (nTime);
#endif

	if (gbCounterCount == 1) {
 8005570:	781b      	ldrb	r3, [r3, #0]
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}

	while (glDelayCounter != 0)
 8005572:	6813      	ldr	r3, [r2, #0]
 8005574:	2b00      	cmp	r3, #0
 8005576:	d1fc      	bne.n	8005572 <uDelay+0x2a>
		;
}
 8005578:	4770      	bx	lr
 800557a:	46c0      	nop			(mov r8, r8)
 800557c:	200011a8 	.word	0x200011a8
 8005580:	200011bc 	.word	0x200011bc
 8005584:	cccccccd 	.word	0xcccccccd

08005588 <mDelay>:
void BreakToBootLoader(void);
#endif


//##############################################################################
void mDelay(u32 nTime) {
 8005588:	b500      	push	{lr}
	uDelay(nTime * 1000);
 800558a:	ebc0 1340 	rsb	r3, r0, r0, lsl #5
 800558e:	eb00 0083 	add.w	r0, r0, r3, lsl #2
void BreakToBootLoader(void);
#endif


//##############################################################################
void mDelay(u32 nTime) {
 8005592:	b081      	sub	sp, #4
	uDelay(nTime * 1000);
 8005594:	00c0      	lsls	r0, r0, #3
 8005596:	f7ff ffd7 	bl	8005548 <uDelay>
}
 800559a:	b001      	add	sp, #4
 800559c:	bd00      	pop	{pc}
 800559e:	46c0      	nop			(mov r8, r8)

080055a0 <start_countdown_buzzer>:
	SetLED(AUX, 1);
}

//##############################################################################
void start_countdown_buzzer(u32 nTime) {
	if (glBuzzerCounter == 0)
 80055a0:	4b07      	ldr	r3, [pc, #28]	(80055c0 <start_countdown_buzzer+0x20>)
 80055a2:	681b      	ldr	r3, [r3, #0]
 80055a4:	b923      	cbnz	r3, 80055b0 <start_countdown_buzzer+0x10>
		gbCounterCount++;
 80055a6:	4a07      	ldr	r2, [pc, #28]	(80055c4 <start_countdown_buzzer+0x24>)
 80055a8:	7813      	ldrb	r3, [r2, #0]
 80055aa:	3301      	adds	r3, #1
 80055ac:	b2db      	uxtb	r3, r3
 80055ae:	7013      	strb	r3, [r2, #0]
#ifdef USING_SYSTICK_1000US
	glCountdownCounter = (StartTime*1);
#elif USING_SYSTICK_100US
	glBuzzerCounter = (nTime*10);
#elif defined USING_SYSTICK_10US
	glBuzzerCounter = (nTime * 100);
 80055b0:	2364      	movs	r3, #100
 80055b2:	fb03 f300 	mul.w	r3, r3, r0
 80055b6:	4a02      	ldr	r2, [pc, #8]	(80055c0 <start_countdown_buzzer+0x20>)
 80055b8:	6013      	str	r3, [r2, #0]
#elif defined USING_SYSTICK_1US
	glBuzzerCounter = (nTime*1000);
#endif

	if (gbCounterCount == 1) {
 80055ba:	4b02      	ldr	r3, [pc, #8]	(80055c4 <start_countdown_buzzer+0x24>)
 80055bc:	781b      	ldrb	r3, [r3, #0]
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}
}
 80055be:	4770      	bx	lr
 80055c0:	200011b8 	.word	0x200011b8
 80055c4:	200011bc 	.word	0x200011bc

080055c8 <start_timeout_dxl>:

//##############################################################################
void start_timeout_dxl(u32 nTime) {
	if (glDxlTimeoutCounter == 0)
 80055c8:	4b0a      	ldr	r3, [pc, #40]	(80055f4 <start_timeout_dxl+0x2c>)
 80055ca:	681b      	ldr	r3, [r3, #0]
 80055cc:	b923      	cbnz	r3, 80055d8 <start_timeout_dxl+0x10>
		gbCounterCount++;
 80055ce:	4a0a      	ldr	r2, [pc, #40]	(80055f8 <start_timeout_dxl+0x30>)
 80055d0:	7813      	ldrb	r3, [r2, #0]
 80055d2:	3301      	adds	r3, #1
 80055d4:	b2db      	uxtb	r3, r3
 80055d6:	7013      	strb	r3, [r2, #0]
	if (nTime>=100)
	glDxlTimeoutCounter = (nTime/100);
	else
	glDxlTimeoutCounter = 1;
#elif defined USING_SYSTICK_10US
	if (nTime >= 10)
 80055d8:	2809      	cmp	r0, #9
 80055da:	4906      	ldr	r1, [pc, #24]	(80055f4 <start_timeout_dxl+0x2c>)
 80055dc:	d904      	bls.n	80055e8 <start_timeout_dxl+0x20>
		glDxlTimeoutCounter = (nTime / 10);
 80055de:	4a07      	ldr	r2, [pc, #28]	(80055fc <start_timeout_dxl+0x34>)
 80055e0:	fba0 2302 	umull	r2, r3, r0, r2
 80055e4:	08db      	lsrs	r3, r3, #3
 80055e6:	e000      	b.n	80055ea <start_timeout_dxl+0x22>
	else
		glDxlTimeoutCounter = 1;
 80055e8:	2301      	movs	r3, #1
 80055ea:	600b      	str	r3, [r1, #0]
#elif defined USING_SYSTICK_1US
	glDxlTimeoutCounter = (nTime);
#endif

	if (gbCounterCount == 1) {
 80055ec:	4b02      	ldr	r3, [pc, #8]	(80055f8 <start_timeout_dxl+0x30>)
 80055ee:	781b      	ldrb	r3, [r3, #0]
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}
}
 80055f0:	4770      	bx	lr
 80055f2:	46c0      	nop			(mov r8, r8)
 80055f4:	200011b0 	.word	0x200011b0
 80055f8:	200011bc 	.word	0x200011bc
 80055fc:	cccccccd 	.word	0xcccccccd

08005600 <start_timeout_pcu>:

//##############################################################################
void start_timeout_pcu(u32 nTime) {
	if (glPcuTimeoutCounter == 0)
 8005600:	4b0a      	ldr	r3, [pc, #40]	(800562c <start_timeout_pcu+0x2c>)
 8005602:	681b      	ldr	r3, [r3, #0]
 8005604:	b923      	cbnz	r3, 8005610 <start_timeout_pcu+0x10>
		gbCounterCount++;
 8005606:	4a0a      	ldr	r2, [pc, #40]	(8005630 <start_timeout_pcu+0x30>)
 8005608:	7813      	ldrb	r3, [r2, #0]
 800560a:	3301      	adds	r3, #1
 800560c:	b2db      	uxtb	r3, r3
 800560e:	7013      	strb	r3, [r2, #0]
	if (nTime>=100)
	glPcuTimeoutCounter = (nTime/100);
	else
	glPcuTimeoutCounter = 1;
#elif defined USING_SYSTICK_10US
	if (nTime >= 10)
 8005610:	2809      	cmp	r0, #9
 8005612:	4906      	ldr	r1, [pc, #24]	(800562c <start_timeout_pcu+0x2c>)
 8005614:	d904      	bls.n	8005620 <start_timeout_pcu+0x20>
		glPcuTimeoutCounter = (nTime / 10);
 8005616:	4a07      	ldr	r2, [pc, #28]	(8005634 <start_timeout_pcu+0x34>)
 8005618:	fba0 2302 	umull	r2, r3, r0, r2
 800561c:	08db      	lsrs	r3, r3, #3
 800561e:	e000      	b.n	8005622 <start_timeout_pcu+0x22>
	else
		glPcuTimeoutCounter = 1;
 8005620:	2301      	movs	r3, #1
 8005622:	600b      	str	r3, [r1, #0]
#elif defined USING_SYSTICK_1US
	glPcuTimeoutCounter = (nTime);
#endif

	if (gbCounterCount == 1) {
 8005624:	4b02      	ldr	r3, [pc, #8]	(8005630 <start_timeout_pcu+0x30>)
 8005626:	781b      	ldrb	r3, [r3, #0]
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}
}
 8005628:	4770      	bx	lr
 800562a:	46c0      	nop			(mov r8, r8)
 800562c:	200011b4 	.word	0x200011b4
 8005630:	200011bc 	.word	0x200011bc
 8005634:	cccccccd 	.word	0xcccccccd

08005638 <getMillis>:

//##############################################################################
u32 getMillis(){
	/**msMillis = (Millis * (u32)(0.001)); //convert us to ms
	return msMillis;*/
	return (Millis/100) ;
 8005638:	4b03      	ldr	r3, [pc, #12]	(8005648 <getMillis+0x10>)
 800563a:	4904      	ldr	r1, [pc, #16]	(800564c <getMillis+0x14>)
 800563c:	681a      	ldr	r2, [r3, #0]
 800563e:	fba2 2301 	umull	r2, r3, r2, r1
 8005642:	0958      	lsrs	r0, r3, #5
}
 8005644:	4770      	bx	lr
 8005646:	46c0      	nop			(mov r8, r8)
 8005648:	200011c0 	.word	0x200011c0
 800564c:	51eb851f 	.word	0x51eb851f

08005650 <__ISR_SYSTICK>:
//##############################################################################

void __ISR_SYSTICK(void)
{
	// tick at 1 ms.
	msSystickCounter++;
 8005650:	4a02      	ldr	r2, [pc, #8]	(800565c <__ISR_SYSTICK+0xc>)
 8005652:	6813      	ldr	r3, [r2, #0]
 8005654:	3301      	adds	r3, #1
 8005656:	6013      	str	r3, [r2, #0]
}
 8005658:	4770      	bx	lr
 800565a:	46c0      	nop			(mov r8, r8)
 800565c:	200011a4 	.word	0x200011a4

08005660 <ISR_Delay_Base>:


void ISR_Delay_Base(void) {

	Millis++;
 8005660:	4b37      	ldr	r3, [pc, #220]	(8005740 <ISR_Delay_Base+0xe0>)
	// tick at 1 ms.
	msSystickCounter++;
}


void ISR_Delay_Base(void) {
 8005662:	b510      	push	{r4, lr}

	Millis++;
 8005664:	681a      	ldr	r2, [r3, #0]
 8005666:	3201      	adds	r2, #1
 8005668:	601a      	str	r2, [r3, #0]

	// User accessible delay counter
	if (glDelayCounter > 1)
 800566a:	4a36      	ldr	r2, [pc, #216]	(8005744 <ISR_Delay_Base+0xe4>)
 800566c:	6813      	ldr	r3, [r2, #0]
 800566e:	2b01      	cmp	r3, #1
 8005670:	d903      	bls.n	800567a <ISR_Delay_Base+0x1a>
		glDelayCounter--;
 8005672:	6813      	ldr	r3, [r2, #0]
 8005674:	3b01      	subs	r3, #1
 8005676:	6013      	str	r3, [r2, #0]
 8005678:	e009      	b.n	800568e <ISR_Delay_Base+0x2e>
	else if (glDelayCounter > 0) {
 800567a:	6813      	ldr	r3, [r2, #0]
 800567c:	b13b      	cbz	r3, 800568e <ISR_Delay_Base+0x2e>
		glDelayCounter--;
 800567e:	6813      	ldr	r3, [r2, #0]
 8005680:	3b01      	subs	r3, #1
 8005682:	6013      	str	r3, [r2, #0]
		gbCounterCount--;
 8005684:	4a30      	ldr	r2, [pc, #192]	(8005748 <ISR_Delay_Base+0xe8>)
 8005686:	7813      	ldrb	r3, [r2, #0]
 8005688:	3b01      	subs	r3, #1
 800568a:	b2db      	uxtb	r3, r3
 800568c:	7013      	strb	r3, [r2, #0]
	}

	// User accessible timeout/countdown counter
	if (glCountdownCounter > 1) {
 800568e:	4c2f      	ldr	r4, [pc, #188]	(800574c <ISR_Delay_Base+0xec>)
 8005690:	6823      	ldr	r3, [r4, #0]
 8005692:	2b01      	cmp	r3, #1
 8005694:	d90e      	bls.n	80056b4 <ISR_Delay_Base+0x54>
		glCountdownCounter--;
 8005696:	6823      	ldr	r3, [r4, #0]
 8005698:	3b01      	subs	r3, #1
 800569a:	6023      	str	r3, [r4, #0]
#ifdef USING_SYSTICK_1000US
		if ( (glCountdownCounter&0x00000300) )
#elif USING_SYSTICK_100US
		if ( (glCountdownCounter&0x00000200) )
#elif defined USING_SYSTICK_10US
		if ((glCountdownCounter & 0x00001000))
 800569c:	6823      	ldr	r3, [r4, #0]
 800569e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80056a2:	d002      	beq.n	80056aa <ISR_Delay_Base+0x4a>
#elif defined USING_SYSTICK_1US
			if ( (glCountdownCounter&0x00010000) )
#endif
			SetLED(AUX, 1);
 80056a4:	2006      	movs	r0, #6
 80056a6:	2101      	movs	r1, #1
 80056a8:	e001      	b.n	80056ae <ISR_Delay_Base+0x4e>
		else
			SetLED(AUX, 0);
 80056aa:	2006      	movs	r0, #6
 80056ac:	2100      	movs	r1, #0
 80056ae:	f7ff ff0f 	bl	80054d0 <SetLED>
 80056b2:	e00d      	b.n	80056d0 <ISR_Delay_Base+0x70>
	} else if (glCountdownCounter > 0) {
 80056b4:	6823      	ldr	r3, [r4, #0]
 80056b6:	b15b      	cbz	r3, 80056d0 <ISR_Delay_Base+0x70>
		SetLED(AUX, 0);
 80056b8:	2006      	movs	r0, #6
 80056ba:	2100      	movs	r1, #0
 80056bc:	f7ff ff08 	bl	80054d0 <SetLED>
		glCountdownCounter--;
 80056c0:	6823      	ldr	r3, [r4, #0]
		gbCounterCount--;
 80056c2:	4a21      	ldr	r2, [pc, #132]	(8005748 <ISR_Delay_Base+0xe8>)
			SetLED(AUX, 1);
		else
			SetLED(AUX, 0);
	} else if (glCountdownCounter > 0) {
		SetLED(AUX, 0);
		glCountdownCounter--;
 80056c4:	3b01      	subs	r3, #1
 80056c6:	6023      	str	r3, [r4, #0]
		gbCounterCount--;
 80056c8:	7813      	ldrb	r3, [r2, #0]
 80056ca:	3b01      	subs	r3, #1
 80056cc:	b2db      	uxtb	r3, r3
 80056ce:	7013      	strb	r3, [r2, #0]
	}

	// Buzzer countdown counter
	if (glBuzzerCounter > 1)
 80056d0:	4a1f      	ldr	r2, [pc, #124]	(8005750 <ISR_Delay_Base+0xf0>)
 80056d2:	6813      	ldr	r3, [r2, #0]
 80056d4:	2b01      	cmp	r3, #1
 80056d6:	d903      	bls.n	80056e0 <ISR_Delay_Base+0x80>
		glBuzzerCounter--;
 80056d8:	6813      	ldr	r3, [r2, #0]
 80056da:	3b01      	subs	r3, #1
 80056dc:	6013      	str	r3, [r2, #0]
 80056de:	e009      	b.n	80056f4 <ISR_Delay_Base+0x94>
	else if (glBuzzerCounter > 0) {
 80056e0:	6813      	ldr	r3, [r2, #0]
 80056e2:	b13b      	cbz	r3, 80056f4 <ISR_Delay_Base+0x94>
		glBuzzerCounter--;
 80056e4:	6813      	ldr	r3, [r2, #0]
 80056e6:	3b01      	subs	r3, #1
 80056e8:	6013      	str	r3, [r2, #0]
		gbCounterCount--;
 80056ea:	4a17      	ldr	r2, [pc, #92]	(8005748 <ISR_Delay_Base+0xe8>)
 80056ec:	7813      	ldrb	r3, [r2, #0]
 80056ee:	3b01      	subs	r3, #1
 80056f0:	b2db      	uxtb	r3, r3
 80056f2:	7013      	strb	r3, [r2, #0]
	}

	// Dynamixel timeout counter
	if (glDxlTimeoutCounter > 1)
 80056f4:	4a17      	ldr	r2, [pc, #92]	(8005754 <ISR_Delay_Base+0xf4>)
 80056f6:	6813      	ldr	r3, [r2, #0]
 80056f8:	2b01      	cmp	r3, #1
 80056fa:	d903      	bls.n	8005704 <ISR_Delay_Base+0xa4>
		glDxlTimeoutCounter--;
 80056fc:	6813      	ldr	r3, [r2, #0]
 80056fe:	3b01      	subs	r3, #1
 8005700:	6013      	str	r3, [r2, #0]
 8005702:	e009      	b.n	8005718 <ISR_Delay_Base+0xb8>
	else if (glDxlTimeoutCounter > 0) {
 8005704:	6813      	ldr	r3, [r2, #0]
 8005706:	b13b      	cbz	r3, 8005718 <ISR_Delay_Base+0xb8>
		glDxlTimeoutCounter--;
 8005708:	6813      	ldr	r3, [r2, #0]
 800570a:	3b01      	subs	r3, #1
 800570c:	6013      	str	r3, [r2, #0]
		gbCounterCount--;
 800570e:	4a0e      	ldr	r2, [pc, #56]	(8005748 <ISR_Delay_Base+0xe8>)
 8005710:	7813      	ldrb	r3, [r2, #0]
 8005712:	3b01      	subs	r3, #1
 8005714:	b2db      	uxtb	r3, r3
 8005716:	7013      	strb	r3, [r2, #0]
	}

	// PC UART timeout counter
	if (glPcuTimeoutCounter > 1)
 8005718:	4a0f      	ldr	r2, [pc, #60]	(8005758 <ISR_Delay_Base+0xf8>)
 800571a:	6813      	ldr	r3, [r2, #0]
 800571c:	2b01      	cmp	r3, #1
 800571e:	d903      	bls.n	8005728 <ISR_Delay_Base+0xc8>
		glPcuTimeoutCounter--;
 8005720:	6813      	ldr	r3, [r2, #0]
 8005722:	3b01      	subs	r3, #1
 8005724:	6013      	str	r3, [r2, #0]
 8005726:	e009      	b.n	800573c <ISR_Delay_Base+0xdc>
	else if (glPcuTimeoutCounter > 0) {
 8005728:	6813      	ldr	r3, [r2, #0]
 800572a:	b13b      	cbz	r3, 800573c <ISR_Delay_Base+0xdc>
		glPcuTimeoutCounter--;
 800572c:	6813      	ldr	r3, [r2, #0]
 800572e:	3b01      	subs	r3, #1
 8005730:	6013      	str	r3, [r2, #0]
		gbCounterCount--;
 8005732:	4a05      	ldr	r2, [pc, #20]	(8005748 <ISR_Delay_Base+0xe8>)
 8005734:	7813      	ldrb	r3, [r2, #0]
 8005736:	3b01      	subs	r3, #1
 8005738:	b2db      	uxtb	r3, r3
 800573a:	7013      	strb	r3, [r2, #0]
		// Disable SysTick Counter
		SysTick_CounterCmd(SysTick_Counter_Disable);
		// Clear SysTick Counter
		SysTick_CounterCmd(SysTick_Counter_Clear);
	}*/
}
 800573c:	bd10      	pop	{r4, pc}
 800573e:	46c0      	nop			(mov r8, r8)
 8005740:	200011c0 	.word	0x200011c0
 8005744:	200011a8 	.word	0x200011a8
 8005748:	200011bc 	.word	0x200011bc
 800574c:	200011ac 	.word	0x200011ac
 8005750:	200011b8 	.word	0x200011b8
 8005754:	200011b0 	.word	0x200011b0
 8005758:	200011b4 	.word	0x200011b4

0800575c <StartCountdown>:
	while (glDelayCounter != 0)
		;
}

//##############################################################################
void StartCountdown(u32 StartTime) {
 800575c:	b500      	push	{lr}
	if (glCountdownCounter == 0)
 800575e:	4b0b      	ldr	r3, [pc, #44]	(800578c <StartCountdown+0x30>)
	while (glDelayCounter != 0)
		;
}

//##############################################################################
void StartCountdown(u32 StartTime) {
 8005760:	b081      	sub	sp, #4
	if (glCountdownCounter == 0)
 8005762:	681b      	ldr	r3, [r3, #0]
 8005764:	b923      	cbnz	r3, 8005770 <StartCountdown+0x14>
		gbCounterCount++;
 8005766:	4a0a      	ldr	r2, [pc, #40]	(8005790 <StartCountdown+0x34>)
 8005768:	7813      	ldrb	r3, [r2, #0]
 800576a:	3301      	adds	r3, #1
 800576c:	b2db      	uxtb	r3, r3
 800576e:	7013      	strb	r3, [r2, #0]
#ifdef USING_SYSTICK_1000US
	glCountdownCounter = (StartTime*1);
#elif USING_SYSTICK_100US
	glCountdownCounter = (StartTime*10);
#elif defined USING_SYSTICK_10US
	glCountdownCounter = (StartTime * 100);
 8005770:	2364      	movs	r3, #100
 8005772:	fb03 f300 	mul.w	r3, r3, r0
 8005776:	4a05      	ldr	r2, [pc, #20]	(800578c <StartCountdown+0x30>)
	if (gbCounterCount == 1) {
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}

	SetLED(AUX, 1);
 8005778:	2006      	movs	r0, #6
#ifdef USING_SYSTICK_1000US
	glCountdownCounter = (StartTime*1);
#elif USING_SYSTICK_100US
	glCountdownCounter = (StartTime*10);
#elif defined USING_SYSTICK_10US
	glCountdownCounter = (StartTime * 100);
 800577a:	6013      	str	r3, [r2, #0]
#elif defined USING_SYSTICK_1US
	glCountdownCounter = (StartTime*1000);
#endif

	if (gbCounterCount == 1) {
 800577c:	4b04      	ldr	r3, [pc, #16]	(8005790 <StartCountdown+0x34>)
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}

	SetLED(AUX, 1);
 800577e:	2101      	movs	r1, #1
	glCountdownCounter = (StartTime * 100);
#elif defined USING_SYSTICK_1US
	glCountdownCounter = (StartTime*1000);
#endif

	if (gbCounterCount == 1) {
 8005780:	781b      	ldrb	r3, [r3, #0]
		// Enable the SysTick Counter
		//SysTick_CounterCmd(SysTick_Counter_Enable);
	}

	SetLED(AUX, 1);
 8005782:	f7ff fea5 	bl	80054d0 <SetLED>
}
 8005786:	b001      	add	sp, #4
 8005788:	bd00      	pop	{pc}
 800578a:	46c0      	nop			(mov r8, r8)
 800578c:	200011ac 	.word	0x200011ac
 8005790:	200011bc 	.word	0x200011bc

08005794 <micros>:
	return msMillis;*/
	return (Millis/100) ;
}
//}

u32 micros() {
 8005794:	b530      	push	{r4, r5, lr}
	u32 ms = msSystickCounter;
 8005796:	4c0e      	ldr	r4, [pc, #56]	(80057d0 <micros+0x3c>)
	return msMillis;*/
	return (Millis/100) ;
}
//}

u32 micros() {
 8005798:	b081      	sub	sp, #4
	u32 ms = msSystickCounter;
 800579a:	6825      	ldr	r5, [r4, #0]
	u32 us = SysTick_GetCounter(); // is counting DOWN from 9000 = 1 ms !
 800579c:	f001 ff16 	bl	80075cc <SysTick_GetCounter>
	// if systick interrupt between readings, return value will be up to 1000 us wrong.
	// so read ms again to check that. (interrupt again is impossible as next interrupt will be in about 1000 us)
	u32 ms2 = msSystickCounter;
 80057a0:	6824      	ldr	r4, [r4, #0]
	if (ms != ms2) {
 80057a2:	42a5      	cmp	r5, r4
 80057a4:	d005      	beq.n	80057b2 <micros+0x1e>
		return ms2 * 1000;
 80057a6:	ebc4 1344 	rsb	r3, r4, r4, lsl #5
 80057aa:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80057ae:	00d8      	lsls	r0, r3, #3
 80057b0:	e00c      	b.n	80057cc <micros+0x38>
	} else {
		return ms * 1000 + (9000 - us)/9; // TODO will overflow at 2^32 us ~= 71 minutes! [could separate us and ms in a struct]
 80057b2:	f5c0 520c 	rsb	r2, r0, #8960	; 0x2300
 80057b6:	4907      	ldr	r1, [pc, #28]	(80057d4 <micros+0x40>)
 80057b8:	3228      	adds	r2, #40
 80057ba:	fba2 2301 	umull	r2, r3, r2, r1
 80057be:	ebc5 1145 	rsb	r1, r5, r5, lsl #5
 80057c2:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 80057c6:	00c9      	lsls	r1, r1, #3
 80057c8:	eb01 0053 	add.w	r0, r1, r3, lsr #1
	}
}
 80057cc:	b001      	add	sp, #4
 80057ce:	bd30      	pop	{r4, r5, pc}
 80057d0:	200011a4 	.word	0x200011a4
 80057d4:	38e38e39 	.word	0x38e38e39

080057d8 <USART_Configuration>:
	// Reset Active Counter count
	gbCounterCount = 0;
}
//##############################################################################
//void USART_Configuration(){
void USART_Configuration(){
 80057d8:	b500      	push	{lr}
	u16 error = 0;

#ifdef USING_PC_UART
	mDelay(100);
 80057da:	2064      	movs	r0, #100
	// Reset Active Counter count
	gbCounterCount = 0;
}
//##############################################################################
//void USART_Configuration(){
void USART_Configuration(){
 80057dc:	b081      	sub	sp, #4
	u16 error = 0;

#ifdef USING_PC_UART
	mDelay(100);
 80057de:	f7ff fed3 	bl	8005588 <mDelay>
	if (!pcu_initialize(Baudrate_PCU))
 80057e2:	4b0a      	ldr	r3, [pc, #40]	(800580c <USART_Configuration+0x34>)
 80057e4:	6818      	ldr	r0, [r3, #0]
 80057e6:	f7fe fa1d 	bl	8003c24 <pcu_initialize>
		error |= (1 << 0);
#endif
#ifdef USING_ZIGBEE
	mDelay(100);
 80057ea:	2064      	movs	r0, #100
 80057ec:	f7ff fecc 	bl	8005588 <mDelay>
	if (!zgb_initialize(Baudrate_ZIG))
 80057f0:	4b07      	ldr	r3, [pc, #28]	(8005810 <USART_Configuration+0x38>)
 80057f2:	6818      	ldr	r0, [r3, #0]
 80057f4:	f7fe feb0 	bl	8004558 <zgb_initialize>
	error|=(1<<1);
#endif
#ifdef USING_DYNAMIXEL
	mDelay(100);
 80057f8:	2064      	movs	r0, #100
 80057fa:	f7ff fec5 	bl	8005588 <mDelay>
	if (!dxl_initialize(Baudrate_DXL))
 80057fe:	4b05      	ldr	r3, [pc, #20]	(8005814 <USART_Configuration+0x3c>)
 8005800:	6818      	ldr	r0, [r3, #0]
 8005802:	f7fe fd0d 	bl	8004220 <dxl_initialize>
		error |= (1 << 2);
#endif
}
 8005806:	b001      	add	sp, #4
 8005808:	bd00      	pop	{pc}
 800580a:	46c0      	nop			(mov r8, r8)
 800580c:	200000d4 	.word	0x200000d4
 8005810:	200000d0 	.word	0x200000d0
 8005814:	200000cc 	.word	0x200000cc

08005818 <SysTick_Configuration>:
		// Start ADC2 Software Conversion
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
		ADC_SoftwareStartConvCmd(ADC2, ENABLE);
}
//##############################################################################
void SysTick_Configuration(void) {
 8005818:	b500      	push	{lr}
#elif USING_SYSTICK_100US
	// SysTick end of count event each 100us with input clock equal to 9MHz (HCLK/8, default)
	SysTick_SetReload(900);
#elif defined USING_SYSTICK_10US
	// SysTick end of count event each 10us with input clock equal to 9MHz (HCLK/8, default)
	SysTick_SetReload(90);
 800581a:	205a      	movs	r0, #90
		// Start ADC2 Software Conversion
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
		ADC_SoftwareStartConvCmd(ADC2, ENABLE);
}
//##############################################################################
void SysTick_Configuration(void) {
 800581c:	b081      	sub	sp, #4
#elif USING_SYSTICK_100US
	// SysTick end of count event each 100us with input clock equal to 9MHz (HCLK/8, default)
	SysTick_SetReload(900);
#elif defined USING_SYSTICK_10US
	// SysTick end of count event each 10us with input clock equal to 9MHz (HCLK/8, default)
	SysTick_SetReload(90);
 800581e:	f001 feab 	bl	8007578 <SysTick_SetReload>
#elif defined USING_SYSTICK_1US
	// SysTick end of count event each 1us with input clock equal to 9MHz (HCLK/8, default)
	SysTick_SetReload(9);
#endif
	// Enable SysTick interrupt
	SysTick_ITConfig(ENABLE);
 8005822:	2001      	movs	r0, #1
 8005824:	f001 fec4 	bl	80075b0 <SysTick_ITConfig>

	// Enable the SysTick Counter
    SysTick_CounterCmd(SysTick_Counter_Enable);
 8005828:	2001      	movs	r0, #1
 800582a:	f001 feab 	bl	8007584 <SysTick_CounterCmd>

	// Reset Active Counter count
	gbCounterCount = 0;
 800582e:	4b02      	ldr	r3, [pc, #8]	(8005838 <SysTick_Configuration+0x20>)
 8005830:	2200      	movs	r2, #0
 8005832:	701a      	strb	r2, [r3, #0]
}
 8005834:	b001      	add	sp, #4
 8005836:	bd00      	pop	{pc}
 8005838:	200011bc 	.word	0x200011bc

0800583c <ADC_Configuration>:

		GPIO_PinRemapConfig( GPIO_Remap_USART1, ENABLE);
		GPIO_PinRemapConfig( GPIO_Remap_SWJ_Disable, ENABLE);
}
//##############################################################################
void ADC_Configuration(void) {
 800583c:	b570      	push	{r4, r5, r6, lr}
 800583e:	b086      	sub	sp, #24
	ADC_InitTypeDef ADC_InitStructure;

		ADC_StructInit(&ADC_InitStructure);
 8005840:	ad01      	add	r5, sp, #4
 8005842:	4628      	mov	r0, r5
 8005844:	f000 fd08 	bl	8006258 <ADC_StructInit>

		// ADC1 configuration
		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
 8005848:	2400      	movs	r4, #0
		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
		ADC_InitStructure.ADC_NbrOfChannel = 2;
 800584a:	2302      	movs	r3, #2

		// ADC1 configuration
		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 800584c:	f44f 2660 	mov.w	r6, #917504	; 0xe0000
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
		ADC_InitStructure.ADC_NbrOfChannel = 2;

		ADC_Init(ADC1, &ADC_InitStructure);
 8005850:	4832      	ldr	r0, [pc, #200]	(800591c <ADC_Configuration+0xe0>)
 8005852:	4629      	mov	r1, r5
		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
		ADC_InitStructure.ADC_NbrOfChannel = 2;
 8005854:	f88d 3014 	strb.w	r3, [sp, #20]
	ADC_InitTypeDef ADC_InitStructure;

		ADC_StructInit(&ADC_InitStructure);

		// ADC1 configuration
		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
 8005858:	9401      	str	r4, [sp, #4]
		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
 800585a:	f88d 4008 	strb.w	r4, [sp, #8]
		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 800585e:	f88d 4009 	strb.w	r4, [sp, #9]
		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 8005862:	9603      	str	r6, [sp, #12]
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8005864:	9404      	str	r4, [sp, #16]
		ADC_InitStructure.ADC_NbrOfChannel = 2;

		ADC_Init(ADC1, &ADC_InitStructure);
 8005866:	f000 fcd3 	bl	8006210 <ADC_Init>
		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
		ADC_InitStructure.ADC_NbrOfChannel = 1;
 800586a:	2301      	movs	r3, #1

		ADC_Init(ADC2, &ADC_InitStructure);
 800586c:	482c      	ldr	r0, [pc, #176]	(8005920 <ADC_Configuration+0xe4>)
 800586e:	4629      	mov	r1, r5
		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
		ADC_InitStructure.ADC_NbrOfChannel = 1;
 8005870:	f88d 3014 	strb.w	r3, [sp, #20]
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
		ADC_InitStructure.ADC_NbrOfChannel = 2;

		ADC_Init(ADC1, &ADC_InitStructure);

		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
 8005874:	9401      	str	r4, [sp, #4]
		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
 8005876:	f88d 4008 	strb.w	r4, [sp, #8]
		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 800587a:	f88d 4009 	strb.w	r4, [sp, #9]
		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 800587e:	9603      	str	r6, [sp, #12]
		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8005880:	9404      	str	r4, [sp, #16]
		ADC_InitStructure.ADC_NbrOfChannel = 1;

		ADC_Init(ADC2, &ADC_InitStructure);
 8005882:	f000 fcc5 	bl	8006210 <ADC_Init>

		// ADC1 regular channels configuration
		// Set ADC1 to read SIG_ADC0 (ADC1 multiplexer output) on Channel 10
		ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1,
 8005886:	4825      	ldr	r0, [pc, #148]	(800591c <ADC_Configuration+0xe0>)
 8005888:	210a      	movs	r1, #10
 800588a:	2201      	movs	r2, #1
 800588c:	2307      	movs	r3, #7
 800588e:	f000 fd47 	bl	8006320 <ADC_RegularChannelConfig>
	//    ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 1 , ADC_SampleTime_239Cycles5);    // SIG_VDD/VBUS
		//ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);

		// ADC2 regular channels configuration
		// Set ADC2 to read SIG_ADC1 (ADC2 multiplexer output) on Channel 5
		ADC_RegularChannelConfig(ADC2, ADC_Channel_5, 1, ADC_SampleTime_239Cycles5); // SIG_ADC1
 8005892:	2201      	movs	r2, #1
 8005894:	2307      	movs	r3, #7
 8005896:	4822      	ldr	r0, [pc, #136]	(8005920 <ADC_Configuration+0xe4>)
 8005898:	2105      	movs	r1, #5
 800589a:	f000 fd41 	bl	8006320 <ADC_RegularChannelConfig>

		// Enable ADC1 DMA
		//ADC_DMACmd(ADC1, ENABLE);

		// Enable ADC1,2
		ADC_Cmd(ADC1, ENABLE);
 800589e:	481f      	ldr	r0, [pc, #124]	(800591c <ADC_Configuration+0xe0>)
 80058a0:	2101      	movs	r1, #1
 80058a2:	f000 fce3 	bl	800626c <ADC_Cmd>
		ADC_Cmd(ADC2, ENABLE);
 80058a6:	481e      	ldr	r0, [pc, #120]	(8005920 <ADC_Configuration+0xe4>)
 80058a8:	2101      	movs	r1, #1
 80058aa:	f000 fcdf 	bl	800626c <ADC_Cmd>

		// Enable ADC1,2 reset calibration register
		// Check the end of ADC1,2 reset calibration register
		ADC_ResetCalibration(ADC1);
 80058ae:	481b      	ldr	r0, [pc, #108]	(800591c <ADC_Configuration+0xe0>)
 80058b0:	f000 fcfc 	bl	80062ac <ADC_ResetCalibration>
		while (ADC_GetResetCalibrationStatus(ADC1))
 80058b4:	4819      	ldr	r0, [pc, #100]	(800591c <ADC_Configuration+0xe0>)
 80058b6:	f000 fcff 	bl	80062b8 <ADC_GetResetCalibrationStatus>
 80058ba:	2800      	cmp	r0, #0
 80058bc:	d1fa      	bne.n	80058b4 <ADC_Configuration+0x78>
			;

		ADC_ResetCalibration(ADC2);
 80058be:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 80058c2:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
 80058c6:	f000 fcf1 	bl	80062ac <ADC_ResetCalibration>
		while (ADC_GetResetCalibrationStatus(ADC2))
 80058ca:	4815      	ldr	r0, [pc, #84]	(8005920 <ADC_Configuration+0xe4>)
 80058cc:	f000 fcf4 	bl	80062b8 <ADC_GetResetCalibrationStatus>
 80058d0:	2800      	cmp	r0, #0
 80058d2:	d1fa      	bne.n	80058ca <ADC_Configuration+0x8e>
			;

		// Start ADC1,2 calibration
		// Check the end of ADC1,2 calibration
		ADC_StartCalibration(ADC1);
 80058d4:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 80058d8:	f500 3092 	add.w	r0, r0, #74752	; 0x12400
 80058dc:	f000 fcf2 	bl	80062c4 <ADC_StartCalibration>
		while (ADC_GetCalibrationStatus(ADC1))
 80058e0:	480e      	ldr	r0, [pc, #56]	(800591c <ADC_Configuration+0xe0>)
 80058e2:	f000 fcf5 	bl	80062d0 <ADC_GetCalibrationStatus>
 80058e6:	2800      	cmp	r0, #0
 80058e8:	d1fa      	bne.n	80058e0 <ADC_Configuration+0xa4>
			;

		ADC_StartCalibration(ADC2);
 80058ea:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 80058ee:	f500 3094 	add.w	r0, r0, #75776	; 0x12800
 80058f2:	f000 fce7 	bl	80062c4 <ADC_StartCalibration>
		while (ADC_GetCalibrationStatus(ADC2))
 80058f6:	480a      	ldr	r0, [pc, #40]	(8005920 <ADC_Configuration+0xe4>)
 80058f8:	f000 fcea 	bl	80062d0 <ADC_GetCalibrationStatus>
 80058fc:	2800      	cmp	r0, #0
 80058fe:	d1fa      	bne.n	80058f6 <ADC_Configuration+0xba>
			;

		// Start ADC2 Software Conversion
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 8005900:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8005904:	2101      	movs	r1, #1
 8005906:	f500 3092 	add.w	r0, r0, #74752	; 0x12400
 800590a:	f000 fce7 	bl	80062dc <ADC_SoftwareStartConvCmd>
		ADC_SoftwareStartConvCmd(ADC2, ENABLE);
 800590e:	4804      	ldr	r0, [pc, #16]	(8005920 <ADC_Configuration+0xe4>)
 8005910:	2101      	movs	r1, #1
 8005912:	f000 fce3 	bl	80062dc <ADC_SoftwareStartConvCmd>
}
 8005916:	b006      	add	sp, #24
 8005918:	bd70      	pop	{r4, r5, r6, pc}
 800591a:	46c0      	nop			(mov r8, r8)
 800591c:	40012400 	.word	0x40012400
 8005920:	40012800 	.word	0x40012800

08005924 <GPIO_Configuration>:
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}

//##############################################################################
void GPIO_Configuration(void) {
 8005924:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005926:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
		GPIO_StructInit(&GPIO_InitStructure);
 8005928:	ac01      	add	r4, sp, #4
		// PORTA CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT1P | PIN_SIG_MOT1M | PIN_SIG_MOT2P
				| PIN_SIG_MOT2M | PIN_SIG_MOT5P | PIN_SIG_MOT5M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 800592a:	4d71      	ldr	r5, [pc, #452]	(8005af0 <GPIO_Configuration+0x1cc>)
}

//##############################################################################
void GPIO_Configuration(void) {
	GPIO_InitTypeDef GPIO_InitStructure;
		GPIO_StructInit(&GPIO_InitStructure);
 800592c:	4620      	mov	r0, r4

		// PORTA CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT1P | PIN_SIG_MOT1M | PIN_SIG_MOT2P
				| PIN_SIG_MOT2M | PIN_SIG_MOT5P | PIN_SIG_MOT5M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800592e:	2603      	movs	r6, #3
}

//##############################################################################
void GPIO_Configuration(void) {
	GPIO_InitTypeDef GPIO_InitStructure;
		GPIO_StructInit(&GPIO_InitStructure);
 8005930:	f001 f920 	bl	8006b74 <GPIO_StructInit>

		// PORTA CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT1P | PIN_SIG_MOT1M | PIN_SIG_MOT2P
				| PIN_SIG_MOT2M | PIN_SIG_MOT5P | PIN_SIG_MOT5M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005934:	2710      	movs	r7, #16
void GPIO_Configuration(void) {
	GPIO_InitTypeDef GPIO_InitStructure;
		GPIO_StructInit(&GPIO_InitStructure);

		// PORTA CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT1P | PIN_SIG_MOT1M | PIN_SIG_MOT2P
 8005936:	f640 130f 	movw	r3, #2319	; 0x90f
				| PIN_SIG_MOT2M | PIN_SIG_MOT5P | PIN_SIG_MOT5M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 800593a:	4628      	mov	r0, r5
 800593c:	4621      	mov	r1, r4
void GPIO_Configuration(void) {
	GPIO_InitTypeDef GPIO_InitStructure;
		GPIO_StructInit(&GPIO_InitStructure);

		// PORTA CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT1P | PIN_SIG_MOT1M | PIN_SIG_MOT2P
 800593e:	f8ad 3004 	strh.w	r3, [sp, #4]
				| PIN_SIG_MOT2M | PIN_SIG_MOT5P | PIN_SIG_MOT5M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005942:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005946:	f88d 7007 	strb.w	r7, [sp, #7]
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 800594a:	f001 f8bf 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_BUZZER | PIN_ZIGBEE_RESET;
 800594e:	f44f 5382 	mov.w	r3, #4160	; 0x1040
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 8005952:	4628      	mov	r0, r5
 8005954:	4621      	mov	r1, r4
				| PIN_SIG_MOT2M | PIN_SIG_MOT5P | PIN_SIG_MOT5M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOA, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_BUZZER | PIN_ZIGBEE_RESET;
 8005956:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800595a:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 800595e:	f88d 7007 	strb.w	r7, [sp, #7]
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 8005962:	f001 f8b3 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_ADC1;
 8005966:	f04f 0320 	mov.w	r3, #32	; 0x20
 800596a:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 800596e:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOA, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ADC1;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 8005970:	f04f 0300 	mov.w	r3, #0	; 0x0
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 8005974:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOA, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ADC1;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 8005976:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 800597a:	f001 f8a7 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_SW_RIGHT | PIN_SW_LEFT;
 800597e:	f24c 0300 	movw	r3, #49152	; 0xc000
 8005982:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 8005986:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Pin = PIN_ADC1;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
		GPIO_Init(GPIOA, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_RIGHT | PIN_SW_LEFT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005988:	f04f 0348 	mov.w	r3, #72	; 0x48
		// PORTB CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_LED_AUX | PIN_LED_MANAGE | PIN_LED_PROGRAM
				| PIN_LED_PLAY;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 800598c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
		GPIO_Init(GPIOA, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_RIGHT | PIN_SW_LEFT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 8005990:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Pin = PIN_ADC1;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
		GPIO_Init(GPIOA, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_RIGHT | PIN_SW_LEFT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005992:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOA, &GPIO_InitStructure);
 8005996:	f001 f899 	bl	8006acc <GPIO_Init>

		// PORTB CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_LED_AUX | PIN_LED_MANAGE | PIN_LED_PROGRAM
 800599a:	f24f 0300 	movw	r3, #61440	; 0xf000
				| PIN_LED_PLAY;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 800599e:	4628      	mov	r0, r5
 80059a0:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Pin = PIN_SW_RIGHT | PIN_SW_LEFT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOA, &GPIO_InitStructure);

		// PORTB CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_LED_AUX | PIN_LED_MANAGE | PIN_LED_PROGRAM
 80059a2:	f8ad 3004 	strh.w	r3, [sp, #4]
				| PIN_LED_PLAY;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80059a6:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80059aa:	f88d 7007 	strb.w	r7, [sp, #7]
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059ae:	f001 f88d 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_ENABLE_TXD | PIN_ENABLE_RXD;
 80059b2:	f04f 0330 	mov.w	r3, #48	; 0x30
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059b6:	4628      	mov	r0, r5
 80059b8:	4621      	mov	r1, r4
				| PIN_LED_PLAY;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ENABLE_TXD | PIN_ENABLE_RXD;
 80059ba:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80059be:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80059c2:	f88d 7007 	strb.w	r7, [sp, #7]
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059c6:	f001 f881 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_DXL_RXD | PIN_PC_RXD;
 80059ca:	f44f 6308 	mov.w	r3, #2176	; 0x880
 80059ce:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059d2:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_DXL_RXD | PIN_PC_RXD;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 80059d4:	f04f 0304 	mov.w	r3, #4	; 0x4
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059d8:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_DXL_RXD | PIN_PC_RXD;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 80059da:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059de:	f001 f875 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_DXL_TXD | PIN_PC_TXD;
 80059e2:	f44f 6388 	mov.w	r3, #1088	; 0x440
 80059e6:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059ea:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_DXL_TXD | PIN_PC_TXD;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 80059ec:	f04f 0318 	mov.w	r3, #24	; 0x18
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059f0:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_DXL_TXD | PIN_PC_TXD;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 80059f2:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_InitStructure.GPIO_Pin = PIN_DXL_RXD | PIN_PC_RXD;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_DXL_TXD | PIN_PC_TXD;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80059f6:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 80059fa:	f001 f867 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_SW_START;
 80059fe:	f04f 0308 	mov.w	r3, #8	; 0x8
 8005a02:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 8005a06:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_START;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005a08:	f04f 0348 	mov.w	r3, #72	; 0x48
		// PORTC CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT3P | PIN_SIG_MOT3M | PIN_SIG_MOT4P
				| PIN_SIG_MOT4M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a0c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_START;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 8005a10:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_START;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005a12:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 8005a16:	f001 f859 	bl	8006acc <GPIO_Init>

		// PORTC CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT3P | PIN_SIG_MOT3M | PIN_SIG_MOT4P
 8005a1a:	f44f 7370 	mov.w	r3, #960	; 0x3c0
				| PIN_SIG_MOT4M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a1e:	4628      	mov	r0, r5
 8005a20:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Pin = PIN_SW_START;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOB, &GPIO_InitStructure);

		// PORTC CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_SIG_MOT3P | PIN_SIG_MOT3M | PIN_SIG_MOT4P
 8005a22:	f8ad 3004 	strh.w	r3, [sp, #4]
				| PIN_SIG_MOT4M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005a26:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005a2a:	f88d 7007 	strb.w	r7, [sp, #7]
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a2e:	f001 f84d 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_ADC_SELECT0 | PIN_ADC_SELECT1;
 8005a32:	f04f 0306 	mov.w	r3, #6	; 0x6
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a36:	4628      	mov	r0, r5
 8005a38:	4621      	mov	r1, r4
				| PIN_SIG_MOT4M;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ADC_SELECT0 | PIN_ADC_SELECT1;
 8005a3a:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005a3e:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005a42:	f88d 7007 	strb.w	r7, [sp, #7]
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a46:	f001 f841 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_LED_POWER | PIN_LED_TXD | PIN_LED_RXD;
 8005a4a:	f24e 0300 	movw	r3, #57344	; 0xe000
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a4e:	4628      	mov	r0, r5
 8005a50:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Pin = PIN_ADC_SELECT0 | PIN_ADC_SELECT1;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_LED_POWER | PIN_LED_TXD | PIN_LED_RXD;
 8005a52:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005a56:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8005a5a:	f88d 7007 	strb.w	r7, [sp, #7]
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a5e:	f001 f835 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_ZIGBEE_TXD;
 8005a62:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005a66:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a6a:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ZIGBEE_TXD;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 8005a6c:	f04f 0318 	mov.w	r3, #24	; 0x18
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a70:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ZIGBEE_TXD;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 8005a72:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ZIGBEE_TXD;
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005a76:	f88d 6006 	strb.w	r6, [sp, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a7a:	f001 f827 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_ADC0 | PIN_VDD_VOLT;
 8005a7e:	f04f 0309 	mov.w	r3, #9	; 0x9
 8005a82:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a86:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ADC0 | PIN_VDD_VOLT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 8005a88:	f04f 0300 	mov.w	r3, #0	; 0x0
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a8c:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_ADC0 | PIN_VDD_VOLT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 8005a8e:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a92:	f001 f81b 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_MIC;
 8005a96:	f04f 0310 	mov.w	r3, #16	; 0x10
 8005a9a:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005a9e:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Pin = PIN_ADC0 | PIN_VDD_VOLT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_MIC;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005aa0:	f04f 0348 	mov.w	r3, #72	; 0x48
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005aa4:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Pin = PIN_ADC0 | PIN_VDD_VOLT;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_MIC;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005aa6:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005aaa:	f001 f80f 	bl	8006acc <GPIO_Init>

		GPIO_InitStructure.GPIO_Pin = PIN_SW_UP | PIN_SW_DOWN;
 8005aae:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8005ab2:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005ab6:	4628      	mov	r0, r5
		GPIO_InitStructure.GPIO_Pin = PIN_MIC;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_UP | PIN_SW_DOWN;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005ab8:	f04f 0348 	mov.w	r3, #72	; 0x48
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005abc:	4621      	mov	r1, r4
		GPIO_InitStructure.GPIO_Pin = PIN_MIC;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		GPIO_InitStructure.GPIO_Pin = PIN_SW_UP | PIN_SW_DOWN;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8005abe:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOC, &GPIO_InitStructure);
 8005ac2:	f001 f803 	bl	8006acc <GPIO_Init>

		// PORTD CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_ZIGBEE_RXD;
 8005ac6:	f04f 0304 	mov.w	r3, #4	; 0x4
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		GPIO_Init(GPIOD, &GPIO_InitStructure);
 8005aca:	4621      	mov	r1, r4
 8005acc:	4809      	ldr	r0, [pc, #36]	(8005af4 <GPIO_Configuration+0x1d0>)
		GPIO_InitStructure.GPIO_Pin = PIN_SW_UP | PIN_SW_DOWN;
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
		GPIO_Init(GPIOC, &GPIO_InitStructure);

		// PORTD CONFIG
		GPIO_InitStructure.GPIO_Pin = PIN_ZIGBEE_RXD;
 8005ace:	f8ad 3004 	strh.w	r3, [sp, #4]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8005ad2:	f88d 3007 	strb.w	r3, [sp, #7]
		GPIO_Init(GPIOD, &GPIO_InitStructure);
 8005ad6:	f000 fff9 	bl	8006acc <GPIO_Init>

		GPIO_PinRemapConfig( GPIO_Remap_USART1, ENABLE);
 8005ada:	2004      	movs	r0, #4
 8005adc:	2101      	movs	r1, #1
 8005ade:	f001 f88f 	bl	8006c00 <GPIO_PinRemapConfig>
		GPIO_PinRemapConfig( GPIO_Remap_SWJ_Disable, ENABLE);
 8005ae2:	4805      	ldr	r0, [pc, #20]	(8005af8 <GPIO_Configuration+0x1d4>)
 8005ae4:	2101      	movs	r1, #1
 8005ae6:	f001 f88b 	bl	8006c00 <GPIO_PinRemapConfig>
}
 8005aea:	b003      	add	sp, #12
 8005aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005aee:	46c0      	nop			(mov r8, r8)
 8005af0:	40010800 	.word	0x40010800
 8005af4:	40011400 	.word	0x40011400
 8005af8:	00300400 	.word	0x00300400

08005afc <NVIC_Configuration>:

	PWR_BackupAccessCmd(ENABLE);
}

//##############################################################################
void NVIC_Configuration(void) {
 8005afc:	b570      	push	{r4, r5, r6, lr}
#ifdef  VECT_TAB_RAM
	// Set the Vector Table base location at 0x20000000
	NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
#else  // VECT_TAB_FLASH
	// Set the Vector Table base location at 0x08003000
	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x3000);
 8005afe:	f44f 5140 	mov.w	r1, #12288	; 0x3000

	PWR_BackupAccessCmd(ENABLE);
}

//##############################################################################
void NVIC_Configuration(void) {
 8005b02:	b082      	sub	sp, #8
#ifdef  VECT_TAB_RAM
	// Set the Vector Table base location at 0x20000000
	NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
#else  // VECT_TAB_FLASH
	// Set the Vector Table base location at 0x08003000
	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x3000);
 8005b04:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8005b08:	f001 f9f4 	bl	8006ef4 <NVIC_SetVectorTable>
	// Enable the USART1 Interrupt (Dynamixel)
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8005b0c:	ad01      	add	r5, sp, #4
	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x3000);
#endif

	// Configure the NVIC Preemption Priority Bits
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
 8005b0e:	f44f 60c0 	mov.w	r0, #1536	; 0x600
 8005b12:	f001 f951 	bl	8006db8 <NVIC_PriorityGroupConfig>

	// Enable the USART1 Interrupt (Dynamixel)
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 8005b16:	2401      	movs	r4, #1
	// Configure the NVIC Preemption Priority Bits
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

	// Enable the USART1 Interrupt (Dynamixel)
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;
 8005b18:	2325      	movs	r3, #37
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8005b1a:	2600      	movs	r6, #0
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8005b1c:	4628      	mov	r0, r5
	// Configure the NVIC Preemption Priority Bits
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

	// Enable the USART1 Interrupt (Dynamixel)
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQChannel;
 8005b1e:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8005b22:	f88d 6005 	strb.w	r6, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 8005b26:	f88d 4006 	strb.w	r4, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8005b2a:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8005b2e:	f001 f94d 	bl	8006dcc <NVIC_Init>

	// Enable the USART3 Interrupt (Serial/PC_UART)
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQChannel;
 8005b32:	2327      	movs	r3, #39
 8005b34:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8005b38:	4628      	mov	r0, r5
	NVIC_Init(&NVIC_InitStructure);

	// Enable the USART3 Interrupt (Serial/PC_UART)
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQChannel;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
 8005b3a:	2303      	movs	r3, #3
 8005b3c:	f88d 3006 	strb.w	r3, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	// Enable the USART3 Interrupt (Serial/PC_UART)
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQChannel;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8005b40:	f88d 6005 	strb.w	r6, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8005b44:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8005b48:	f001 f940 	bl	8006dcc <NVIC_Init>

	// Enable the UART5 Interrupt (Zigbee)
	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQChannel;
 8005b4c:	2335      	movs	r3, #53
 8005b4e:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8005b52:	4628      	mov	r0, r5
	NVIC_Init(&NVIC_InitStructure);

	// Enable the UART5 Interrupt (Zigbee)
	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQChannel;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
 8005b54:	2302      	movs	r3, #2
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	// Enable the UART5 Interrupt (Zigbee)
	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQChannel;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8005b56:	f88d 6005 	strb.w	r6, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
 8005b5a:	f88d 3006 	strb.w	r3, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8005b5e:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8005b62:	f001 f933 	bl	8006dcc <NVIC_Init>
}
 8005b66:	b002      	add	sp, #8
 8005b68:	bd70      	pop	{r4, r5, r6, pc}
 8005b6a:	46c0      	nop			(mov r8, r8)

08005b6c <RCC_Configuration>:
	// USART Configuration
	USART_Configuration();
}

//##############################################################################
void RCC_Configuration(void) {
 8005b6c:	b500      	push	{lr}
 8005b6e:	b081      	sub	sp, #4
	ErrorStatus HSEStartUpStatus;
	// RCC system reset(for debug purpose)
	RCC_DeInit();
 8005b70:	f001 fb22 	bl	80071b8 <RCC_DeInit>

	// Enable HSE
	RCC_HSEConfig(RCC_HSE_ON);
 8005b74:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8005b78:	f001 fb3e 	bl	80071f8 <RCC_HSEConfig>

	// Wait till HSE is ready
	HSEStartUpStatus = RCC_WaitForHSEStartUp();
 8005b7c:	f001 fb56 	bl	800722c <RCC_WaitForHSEStartUp>

	if (HSEStartUpStatus == SUCCESS) {
 8005b80:	2801      	cmp	r0, #1
 8005b82:	d124      	bne.n	8005bce <RCC_Configuration+0x62>
		// Enable Prefetch Buffer
		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 8005b84:	2010      	movs	r0, #16
 8005b86:	f000 fd25 	bl	80065d4 <FLASH_PrefetchBufferCmd>

		// Flash 2 wait state
		FLASH_SetLatency(FLASH_Latency_2);
 8005b8a:	2002      	movs	r0, #2
 8005b8c:	f000 fd0a 	bl	80065a4 <FLASH_SetLatency>

		// HCLK = SYSCLK
		RCC_HCLKConfig(RCC_SYSCLK_Div1);
 8005b90:	2000      	movs	r0, #0
 8005b92:	f001 fb95 	bl	80072c0 <RCC_HCLKConfig>

		// PCLK2 = HCLK
		RCC_PCLK2Config(RCC_HCLK_Div1);
 8005b96:	2000      	movs	r0, #0
 8005b98:	f001 fba6 	bl	80072e8 <RCC_PCLK2Config>

		// PCLK1 = HCLK/2
		RCC_PCLK1Config(RCC_HCLK_Div2);
 8005b9c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8005ba0:	f001 fb98 	bl	80072d4 <RCC_PCLK1Config>

		// PLLCLK = 8MHz * 9 = 72 MHz
		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
 8005ba4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8005ba8:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000
 8005bac:	f001 fb66 	bl	800727c <RCC_PLLConfig>

		// Enable PLL
		RCC_PLLCmd(ENABLE);
 8005bb0:	2001      	movs	r0, #1
 8005bb2:	f001 fb6d 	bl	8007290 <RCC_PLLCmd>

		// Wait till PLL is ready
		while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
 8005bb6:	2039      	movs	r0, #57
 8005bb8:	f001 fc96 	bl	80074e8 <RCC_GetFlagStatus>
 8005bbc:	2800      	cmp	r0, #0
 8005bbe:	d0fa      	beq.n	8005bb6 <RCC_Configuration+0x4a>
		}

		// Select PLL as system clock source
		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 8005bc0:	2002      	movs	r0, #2
 8005bc2:	f001 fb6b 	bl	800729c <RCC_SYSCLKConfig>

		// Wait till PLL is used as system clock source
		while (RCC_GetSYSCLKSource() != 0x08) {
 8005bc6:	f001 fb73 	bl	80072b0 <RCC_GetSYSCLKSource>
 8005bca:	2808      	cmp	r0, #8
 8005bcc:	d1fb      	bne.n	8005bc6 <RCC_Configuration+0x5a>
	}

	// Enable peripheral clocks

	// Enable GPIOB and GPIOC clocks
	RCC_APB2PeriphClockCmd(
 8005bce:	2101      	movs	r1, #1
 8005bd0:	f240 601c 	movw	r0, #1564	; 0x61c
 8005bd4:	f001 fc3e 	bl	8007454 <RCC_APB2PeriphClockCmd>
			RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC
					| RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);

	// Enable USART1 Clock (Dynamixel)
#ifdef USING_DYNAMIXEL
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 8005bd8:	2101      	movs	r1, #1
 8005bda:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8005bde:	f001 fc39 	bl	8007454 <RCC_APB2PeriphClockCmd>
#endif
#ifdef USING_PC_UART
	// Enable USART3 Clock (PC_UART)
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
 8005be2:	2101      	movs	r1, #1
 8005be4:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8005be8:	f001 fc42 	bl	8007470 <RCC_APB1PeriphClockCmd>
#endif
#ifdef USING_ZIGBEE
	// Enable UART5 Clock (Zigbee)
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
 8005bec:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005bf0:	2101      	movs	r1, #1
 8005bf2:	f001 fc3d 	bl	8007470 <RCC_APB1PeriphClockCmd>
#endif

	PWR_BackupAccessCmd(ENABLE);
 8005bf6:	2001      	movs	r0, #1
 8005bf8:	f001 fa6e 	bl	80070d8 <PWR_BackupAccessCmd>
}
 8005bfc:	b001      	add	sp, #4
 8005bfe:	bd00      	pop	{pc}

08005c00 <SysInit>:
#include "serial.h"
#include "dynamixel.h"
#include "zigbee.h"

//##############################################################################
void SysInit(){
 8005c00:	b500      	push	{lr}
	// Clear the WatchDog Early Wakeup interrupt flag
//    WWDG_ClearFlag();
	ReBootToBootLoader = 0;
 8005c02:	4b09      	ldr	r3, [pc, #36]	(8005c28 <SysInit+0x28>)
 8005c04:	2200      	movs	r2, #0
#include "serial.h"
#include "dynamixel.h"
#include "zigbee.h"

//##############################################################################
void SysInit(){
 8005c06:	b081      	sub	sp, #4
	// Clear the WatchDog Early Wakeup interrupt flag
//    WWDG_ClearFlag();
	ReBootToBootLoader = 0;
 8005c08:	701a      	strb	r2, [r3, #0]

	// System Clocks Configuration
	RCC_Configuration();
 8005c0a:	f7ff ffaf 	bl	8005b6c <RCC_Configuration>

	// NVIC configuration
	NVIC_Configuration();
 8005c0e:	f7ff ff75 	bl	8005afc <NVIC_Configuration>

	// GPIO configuration
	GPIO_Configuration();
 8005c12:	f7ff fe87 	bl	8005924 <GPIO_Configuration>

	// System clock count configuration
	SysTick_Configuration();
 8005c16:	f7ff fdff 	bl	8005818 <SysTick_Configuration>

	// Analog to Digital Converter Configuration
	ADC_Configuration();
 8005c1a:	f7ff fe0f 	bl	800583c <ADC_Configuration>

	// USART Configuration
	USART_Configuration();
 8005c1e:	f7ff fddb 	bl	80057d8 <USART_Configuration>
}
 8005c22:	b001      	add	sp, #4
 8005c24:	bd00      	pop	{pc}
 8005c26:	46c0      	nop			(mov r8, r8)
 8005c28:	200011c8 	.word	0x200011c8

08005c2c <pcu_hal_timeout>:
	}

	//##############################################################################
	u8 pcu_hal_timeout(void)
	{
	    if (glPcuTimeoutCounter==0)
 8005c2c:	4b03      	ldr	r3, [pc, #12]	(8005c3c <pcu_hal_timeout+0x10>)
 8005c2e:	6818      	ldr	r0, [r3, #0]
 8005c30:	f1d0 0001 	rsbs	r0, r0, #1	; 0x1
 8005c34:	bf38      	it	cc
 8005c36:	2000      	movcc	r0, #0
	        return 1;
	    else
	        return 0;
	}
 8005c38:	4770      	bx	lr
 8005c3a:	46c0      	nop			(mov r8, r8)
 8005c3c:	200011b4 	.word	0x200011b4

08005c40 <pcu_get_queue>:
	}

	//##############################################################################
	u8 pcu_get_queue(void)
	{
	    if (gbPcuWrite==gbPcuRead)
 8005c40:	4b0b      	ldr	r3, [pc, #44]	(8005c70 <pcu_get_queue+0x30>)
 8005c42:	490c      	ldr	r1, [pc, #48]	(8005c74 <pcu_get_queue+0x34>)
 8005c44:	881a      	ldrh	r2, [r3, #0]
 8005c46:	880b      	ldrh	r3, [r1, #0]
 8005c48:	4293      	cmp	r3, r2
 8005c4a:	d101      	bne.n	8005c50 <pcu_get_queue+0x10>
 8005c4c:	20ff      	movs	r0, #255
 8005c4e:	e00e      	b.n	8005c6e <pcu_get_queue+0x2e>
	        return 0xFF;

	    u8 data = gbpPcuBuffer[gbPcuRead++];
 8005c50:	880b      	ldrh	r3, [r1, #0]
 8005c52:	4a09      	ldr	r2, [pc, #36]	(8005c78 <pcu_get_queue+0x38>)
 8005c54:	b29b      	uxth	r3, r3
 8005c56:	5cd2      	ldrb	r2, [r2, r3]
 8005c58:	3301      	adds	r3, #1
 8005c5a:	b29b      	uxth	r3, r3
 8005c5c:	800b      	strh	r3, [r1, #0]
 8005c5e:	4610      	mov	r0, r2

	    if (gbPcuRead>(PC_UART_BUFFER_LENGTH-1))
 8005c60:	880a      	ldrh	r2, [r1, #0]
 8005c62:	f240 33fe 	movw	r3, #1022	; 0x3fe
 8005c66:	429a      	cmp	r2, r3
	        gbPcuRead = 0;
 8005c68:	bf84      	itt	hi
 8005c6a:	2300      	movhi	r3, #0
 8005c6c:	800b      	strhhi	r3, [r1, #0]

	    return data;
	}
 8005c6e:	4770      	bx	lr
 8005c70:	200015d2 	.word	0x200015d2
 8005c74:	200015d4 	.word	0x200015d4
 8005c78:	200011d0 	.word	0x200011d0

08005c7c <pcu_peek_queue>:

	//##############################################################################
	u8 pcu_peek_queue(void)
	{
	    if (gbPcuWrite==gbPcuRead)
 8005c7c:	4b06      	ldr	r3, [pc, #24]	(8005c98 <pcu_peek_queue+0x1c>)
 8005c7e:	4907      	ldr	r1, [pc, #28]	(8005c9c <pcu_peek_queue+0x20>)
 8005c80:	881a      	ldrh	r2, [r3, #0]
 8005c82:	880b      	ldrh	r3, [r1, #0]
 8005c84:	4293      	cmp	r3, r2
 8005c86:	d101      	bne.n	8005c8c <pcu_peek_queue+0x10>
 8005c88:	20ff      	movs	r0, #255
 8005c8a:	e004      	b.n	8005c96 <pcu_peek_queue+0x1a>
	        return 0xFF;

	    u8 data = gbpPcuBuffer[gbPcuRead];
 8005c8c:	880b      	ldrh	r3, [r1, #0]
 8005c8e:	4a04      	ldr	r2, [pc, #16]	(8005ca0 <pcu_peek_queue+0x24>)
 8005c90:	b29b      	uxth	r3, r3
 8005c92:	5cd3      	ldrb	r3, [r2, r3]
 8005c94:	4618      	mov	r0, r3

	    return data;
	}
 8005c96:	4770      	bx	lr
 8005c98:	200015d2 	.word	0x200015d2
 8005c9c:	200015d4 	.word	0x200015d4
 8005ca0:	200011d0 	.word	0x200011d0

08005ca4 <pcu_clear_queue>:
	}

	//##############################################################################
	void pcu_clear_queue(void)
	{
	    gbPcuWrite = 0;
 8005ca4:	4b03      	ldr	r3, [pc, #12]	(8005cb4 <pcu_clear_queue+0x10>)
 8005ca6:	f04f 0200 	mov.w	r2, #0	; 0x0
 8005caa:	801a      	strh	r2, [r3, #0]
	    gbPcuRead = 0;
 8005cac:	4b02      	ldr	r3, [pc, #8]	(8005cb8 <pcu_clear_queue+0x14>)
 8005cae:	801a      	strh	r2, [r3, #0]
	}
 8005cb0:	4770      	bx	lr
 8005cb2:	46c0      	nop			(mov r8, r8)
 8005cb4:	200015d2 	.word	0x200015d2
 8005cb8:	200015d4 	.word	0x200015d4

08005cbc <pcu_get_qstate>:

	//##############################################################################
	u8 pcu_get_qstate(void)
	{
	    if (gbPcuWrite==gbPcuRead)
 8005cbc:	490f      	ldr	r1, [pc, #60]	(8005cfc <pcu_get_qstate+0x40>)
 8005cbe:	4810      	ldr	r0, [pc, #64]	(8005d00 <pcu_get_qstate+0x44>)
 8005cc0:	880a      	ldrh	r2, [r1, #0]
 8005cc2:	8803      	ldrh	r3, [r0, #0]
 8005cc4:	4293      	cmp	r3, r2
 8005cc6:	d105      	bne.n	8005cd4 <pcu_get_qstate+0x18>
	}

	//##############################################################################
	void pcu_clear_queue(void)
	{
	    gbPcuWrite = 0;
 8005cc8:	f04f 0300 	mov.w	r3, #0	; 0x0
 8005ccc:	800b      	strh	r3, [r1, #0]
	    gbPcuRead = 0;
 8005cce:	8003      	strh	r3, [r0, #0]
 8005cd0:	2000      	movs	r0, #0
 8005cd2:	e011      	b.n	8005cf8 <pcu_get_qstate+0x3c>
	    if (gbPcuWrite==gbPcuRead)
	    {
	        pcu_clear_queue();
	        return 0;
	    }
	    else if (gbPcuRead<gbPcuWrite)
 8005cd4:	8802      	ldrh	r2, [r0, #0]
 8005cd6:	880b      	ldrh	r3, [r1, #0]
 8005cd8:	4293      	cmp	r3, r2
 8005cda:	d906      	bls.n	8005cea <pcu_get_qstate+0x2e>
	        return (u8) (gbPcuWrite-gbPcuRead);
 8005cdc:	880a      	ldrh	r2, [r1, #0]
 8005cde:	8803      	ldrh	r3, [r0, #0]
 8005ce0:	b292      	uxth	r2, r2
 8005ce2:	b29b      	uxth	r3, r3
 8005ce4:	1ad2      	subs	r2, r2, r3
 8005ce6:	b2d0      	uxtb	r0, r2
 8005ce8:	e006      	b.n	8005cf8 <pcu_get_qstate+0x3c>
	    else
	        return (u8) (PC_UART_BUFFER_LENGTH-(gbPcuRead-gbPcuWrite));
 8005cea:	880b      	ldrh	r3, [r1, #0]
 8005cec:	8802      	ldrh	r2, [r0, #0]
 8005cee:	b29b      	uxth	r3, r3
 8005cf0:	b292      	uxth	r2, r2
 8005cf2:	3b01      	subs	r3, #1
 8005cf4:	1a9b      	subs	r3, r3, r2
 8005cf6:	b2d8      	uxtb	r0, r3
	}
 8005cf8:	4770      	bx	lr
 8005cfa:	46c0      	nop			(mov r8, r8)
 8005cfc:	200015d2 	.word	0x200015d2
 8005d00:	200015d4 	.word	0x200015d4

08005d04 <zgb_hal_rx>:
	return numPacket;
}

//##############################################################################
u8 zgb_hal_rx(u8 *pPacket, u8 numPacket)
{
 8005d04:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005d06:	f04f 0c00 	mov.w	ip, #0	; 0x0
 8005d0a:	460c      	mov	r4, r1
 8005d0c:	b083      	sub	sp, #12
 8005d0e:	4605      	mov	r5, r0
	u8 i;
	for (i=0; i<numPacket; i++)
	{
		if (gbZigRead!=gbZigWrite)
 8005d10:	490e      	ldr	r1, [pc, #56]	(8005d4c <zgb_hal_rx+0x48>)
		{
			pPacket[i] = gbpZigBuffer[gbZigRead++];
 8005d12:	4f0f      	ldr	r7, [pc, #60]	(8005d50 <zgb_hal_rx+0x4c>)
			if (gbZigRead>(ZIGBEE_BUFFER_LENGTH-1))
			gbZigRead = 0;
 8005d14:	2600      	movs	r6, #0
 8005d16:	e011      	b.n	8005d3c <zgb_hal_rx+0x38>
u8 zgb_hal_rx(u8 *pPacket, u8 numPacket)
{
	u8 i;
	for (i=0; i<numPacket; i++)
	{
		if (gbZigRead!=gbZigWrite)
 8005d18:	4b0e      	ldr	r3, [pc, #56]	(8005d54 <zgb_hal_rx+0x50>)
 8005d1a:	780a      	ldrb	r2, [r1, #0]
 8005d1c:	781b      	ldrb	r3, [r3, #0]
 8005d1e:	429a      	cmp	r2, r3
 8005d20:	d011      	beq.n	8005d46 <zgb_hal_rx+0x42>
		{
			pPacket[i] = gbpZigBuffer[gbZigRead++];
 8005d22:	780b      	ldrb	r3, [r1, #0]
 8005d24:	5cfa      	ldrb	r2, [r7, r3]
 8005d26:	3301      	adds	r3, #1
 8005d28:	b2db      	uxtb	r3, r3
 8005d2a:	f805 200c 	strb.w	r2, [r5, ip]
 8005d2e:	700b      	strb	r3, [r1, #0]
			if (gbZigRead>(ZIGBEE_BUFFER_LENGTH-1))
 8005d30:	780b      	ldrb	r3, [r1, #0]
			gbZigRead = 0;
 8005d32:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
	for (i=0; i<numPacket; i++)
	{
		if (gbZigRead!=gbZigWrite)
		{
			pPacket[i] = gbpZigBuffer[gbZigRead++];
			if (gbZigRead>(ZIGBEE_BUFFER_LENGTH-1))
 8005d36:	2b3f      	cmp	r3, #63
			gbZigRead = 0;
 8005d38:	bf88      	it	hi
 8005d3a:	700e      	strbhi	r6, [r1, #0]
 8005d3c:	fa5f f08c 	uxtb.w	r0, ip

//##############################################################################
u8 zgb_hal_rx(u8 *pPacket, u8 numPacket)
{
	u8 i;
	for (i=0; i<numPacket; i++)
 8005d40:	42a0      	cmp	r0, r4
 8005d42:	d3e9      	bcc.n	8005d18 <zgb_hal_rx+0x14>
 8005d44:	4620      	mov	r0, r4
		else
		return i;
	}

	return numPacket;
}
 8005d46:	b003      	add	sp, #12
 8005d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005d4a:	46c0      	nop			(mov r8, r8)
 8005d4c:	200011cf 	.word	0x200011cf
 8005d50:	200015d6 	.word	0x200015d6
 8005d54:	200011ce 	.word	0x200011ce

08005d58 <dxl_hal_clear>:
//##############################################################################
void dxl_hal_clear(void) {
	// Clear communication buffer
	u16 i;
	for (i = 0; i < DXL_BUFFER_LENGTH; i++)
		gbpDxlBuffer[i] = 0;
 8005d58:	4807      	ldr	r0, [pc, #28]	(8005d78 <dxl_hal_clear+0x20>)
	// Disable USART1 (dynamixel)
	USART_Cmd(USART1, DISABLE);
}

//##############################################################################
void dxl_hal_clear(void) {
 8005d5a:	2300      	movs	r3, #0
	// Clear communication buffer
	u16 i;
	for (i = 0; i < DXL_BUFFER_LENGTH; i++)
		gbpDxlBuffer[i] = 0;
 8005d5c:	2100      	movs	r1, #0

//##############################################################################
void dxl_hal_clear(void) {
	// Clear communication buffer
	u16 i;
	for (i = 0; i < DXL_BUFFER_LENGTH; i++)
 8005d5e:	f240 32ff 	movw	r2, #1023	; 0x3ff
		gbpDxlBuffer[i] = 0;
 8005d62:	54c1      	strb	r1, [r0, r3]
 8005d64:	3301      	adds	r3, #1

//##############################################################################
void dxl_hal_clear(void) {
	// Clear communication buffer
	u16 i;
	for (i = 0; i < DXL_BUFFER_LENGTH; i++)
 8005d66:	4293      	cmp	r3, r2
 8005d68:	d1fb      	bne.n	8005d62 <dxl_hal_clear+0xa>
		gbpDxlBuffer[i] = 0;
	gbDxlRead = 0;
 8005d6a:	4b04      	ldr	r3, [pc, #16]	(8005d7c <dxl_hal_clear+0x24>)
 8005d6c:	f04f 0200 	mov.w	r2, #0	; 0x0
 8005d70:	801a      	strh	r2, [r3, #0]
	gbDxlWrite = 0;
 8005d72:	4b03      	ldr	r3, [pc, #12]	(8005d80 <dxl_hal_clear+0x28>)
 8005d74:	801a      	strh	r2, [r3, #0]
}
 8005d76:	4770      	bx	lr
 8005d78:	20001617 	.word	0x20001617
 8005d7c:	200011cc 	.word	0x200011cc
 8005d80:	200011ca 	.word	0x200011ca

08005d84 <dxl_hal_rx>:

	return numPacket;
}

//##############################################################################
u8 dxl_hal_rx(u8 *pPacket, u8 numPacket) {
 8005d84:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005d86:	f04f 0c00 	mov.w	ip, #0	; 0x0
 8005d8a:	460c      	mov	r4, r1
 8005d8c:	b083      	sub	sp, #12
 8005d8e:	4605      	mov	r5, r0
	u8 i;
	for (i = 0; i < numPacket; i++) {
		if (gbDxlRead != gbDxlWrite) {
 8005d90:	4910      	ldr	r1, [pc, #64]	(8005dd4 <dxl_hal_rx+0x50>)
			pPacket[i] = gbpDxlBuffer[gbDxlRead++];
 8005d92:	4f11      	ldr	r7, [pc, #68]	(8005dd8 <dxl_hal_rx+0x54>)
			if (gbDxlRead > (DXL_BUFFER_LENGTH - 1))
 8005d94:	f240 36fe 	movw	r6, #1022	; 0x3fe
 8005d98:	e014      	b.n	8005dc4 <dxl_hal_rx+0x40>

//##############################################################################
u8 dxl_hal_rx(u8 *pPacket, u8 numPacket) {
	u8 i;
	for (i = 0; i < numPacket; i++) {
		if (gbDxlRead != gbDxlWrite) {
 8005d9a:	4b10      	ldr	r3, [pc, #64]	(8005ddc <dxl_hal_rx+0x58>)
 8005d9c:	880a      	ldrh	r2, [r1, #0]
 8005d9e:	881b      	ldrh	r3, [r3, #0]
 8005da0:	4293      	cmp	r3, r2
 8005da2:	d014      	beq.n	8005dce <dxl_hal_rx+0x4a>
			pPacket[i] = gbpDxlBuffer[gbDxlRead++];
 8005da4:	880b      	ldrh	r3, [r1, #0]
 8005da6:	b29b      	uxth	r3, r3
 8005da8:	5cfa      	ldrb	r2, [r7, r3]
 8005daa:	3301      	adds	r3, #1
 8005dac:	b29b      	uxth	r3, r3
 8005dae:	f805 200c 	strb.w	r2, [r5, ip]
 8005db2:	800b      	strh	r3, [r1, #0]
			if (gbDxlRead > (DXL_BUFFER_LENGTH - 1))
 8005db4:	880b      	ldrh	r3, [r1, #0]
				gbDxlRead = 0;
 8005db6:	f10c 0c01 	add.w	ip, ip, #1	; 0x1
u8 dxl_hal_rx(u8 *pPacket, u8 numPacket) {
	u8 i;
	for (i = 0; i < numPacket; i++) {
		if (gbDxlRead != gbDxlWrite) {
			pPacket[i] = gbpDxlBuffer[gbDxlRead++];
			if (gbDxlRead > (DXL_BUFFER_LENGTH - 1))
 8005dba:	b29b      	uxth	r3, r3
 8005dbc:	42b3      	cmp	r3, r6
				gbDxlRead = 0;
 8005dbe:	bf84      	itt	hi
 8005dc0:	2300      	movhi	r3, #0
 8005dc2:	800b      	strhhi	r3, [r1, #0]
 8005dc4:	fa5f f08c 	uxtb.w	r0, ip
}

//##############################################################################
u8 dxl_hal_rx(u8 *pPacket, u8 numPacket) {
	u8 i;
	for (i = 0; i < numPacket; i++) {
 8005dc8:	42a0      	cmp	r0, r4
 8005dca:	d3e6      	bcc.n	8005d9a <dxl_hal_rx+0x16>
 8005dcc:	4620      	mov	r0, r4
		} else
			return i;
	}

	return numPacket;
}
 8005dce:	b003      	add	sp, #12
 8005dd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005dd2:	46c0      	nop			(mov r8, r8)
 8005dd4:	200011cc 	.word	0x200011cc
 8005dd8:	20001617 	.word	0x20001617
 8005ddc:	200011ca 	.word	0x200011ca

08005de0 <dxl_hal_timeout>:
	start_timeout_dxl(NumRcvByte * 30);
}

//##############################################################################
u8 dxl_hal_timeout(void) {
	if (glDxlTimeoutCounter == 0)
 8005de0:	4b03      	ldr	r3, [pc, #12]	(8005df0 <dxl_hal_timeout+0x10>)
 8005de2:	6818      	ldr	r0, [r3, #0]
 8005de4:	f1d0 0001 	rsbs	r0, r0, #1	; 0x1
 8005de8:	bf38      	it	cc
 8005dea:	2000      	movcc	r0, #0
		return 1;
	else
		return 0;
}
 8005dec:	4770      	bx	lr
 8005dee:	46c0      	nop			(mov r8, r8)
 8005df0:	200011b0 	.word	0x200011b0

08005df4 <RxD_DXL_Interrupt>:

//##############################################################################
void RxD_DXL_Interrupt(void) {
 8005df4:	b500      	push	{lr}
	u8 temp;
	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
 8005df6:	4819      	ldr	r0, [pc, #100]	(8005e5c <RxD_DXL_Interrupt+0x68>)
	else
		return 0;
}

//##############################################################################
void RxD_DXL_Interrupt(void) {
 8005df8:	b081      	sub	sp, #4
	u8 temp;
	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
 8005dfa:	f240 5125 	movw	r1, #1317	; 0x525
 8005dfe:	f001 fd17 	bl	8007830 <USART_GetITStatus>
 8005e02:	2800      	cmp	r0, #0
 8005e04:	d028      	beq.n	8005e58 <RxD_DXL_Interrupt+0x64>
		temp = USART_ReceiveData(USART1);
 8005e06:	4815      	ldr	r0, [pc, #84]	(8005e5c <RxD_DXL_Interrupt+0x68>)
 8005e08:	f001 fca4 	bl	8007754 <USART_ReceiveData>
	} else
		return;

	if (gbDxlWrite < (DXL_BUFFER_LENGTH - 1)) {
 8005e0c:	4914      	ldr	r1, [pc, #80]	(8005e60 <RxD_DXL_Interrupt+0x6c>)
 8005e0e:	f240 33fd 	movw	r3, #1021	; 0x3fd
 8005e12:	880a      	ldrh	r2, [r1, #0]

//##############################################################################
void RxD_DXL_Interrupt(void) {
	u8 temp;
	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
		temp = USART_ReceiveData(USART1);
 8005e14:	b2c0      	uxtb	r0, r0
	} else
		return;

	if (gbDxlWrite < (DXL_BUFFER_LENGTH - 1)) {
 8005e16:	429a      	cmp	r2, r3
 8005e18:	4a12      	ldr	r2, [pc, #72]	(8005e64 <RxD_DXL_Interrupt+0x70>)
 8005e1a:	d805      	bhi.n	8005e28 <RxD_DXL_Interrupt+0x34>
		gbpDxlBuffer[gbDxlWrite++] = temp;
 8005e1c:	880b      	ldrh	r3, [r1, #0]
 8005e1e:	b29b      	uxth	r3, r3
 8005e20:	54d0      	strb	r0, [r2, r3]
 8005e22:	3301      	adds	r3, #1
 8005e24:	b29b      	uxth	r3, r3
 8005e26:	e004      	b.n	8005e32 <RxD_DXL_Interrupt+0x3e>
	} else {
		gbpDxlBuffer[gbDxlWrite] = temp;
 8005e28:	880b      	ldrh	r3, [r1, #0]
 8005e2a:	b29b      	uxth	r3, r3
 8005e2c:	54d0      	strb	r0, [r2, r3]
		gbDxlWrite = 0;
 8005e2e:	f04f 0300 	mov.w	r3, #0	; 0x0
 8005e32:	800b      	strh	r3, [r1, #0]
	}

	if (gbDxlRead == gbDxlWrite)
 8005e34:	4a0a      	ldr	r2, [pc, #40]	(8005e60 <RxD_DXL_Interrupt+0x6c>)
 8005e36:	490c      	ldr	r1, [pc, #48]	(8005e68 <RxD_DXL_Interrupt+0x74>)
 8005e38:	880b      	ldrh	r3, [r1, #0]
 8005e3a:	8812      	ldrh	r2, [r2, #0]
 8005e3c:	429a      	cmp	r2, r3
 8005e3e:	d103      	bne.n	8005e48 <RxD_DXL_Interrupt+0x54>
		gbDxlRead++;
 8005e40:	880b      	ldrh	r3, [r1, #0]
 8005e42:	3301      	adds	r3, #1
 8005e44:	b29b      	uxth	r3, r3
 8005e46:	800b      	strh	r3, [r1, #0]
	if (gbDxlRead > (DXL_BUFFER_LENGTH - 1))
 8005e48:	4907      	ldr	r1, [pc, #28]	(8005e68 <RxD_DXL_Interrupt+0x74>)
 8005e4a:	f240 33fe 	movw	r3, #1022	; 0x3fe
 8005e4e:	880a      	ldrh	r2, [r1, #0]
 8005e50:	429a      	cmp	r2, r3
		gbDxlRead = 0;
 8005e52:	bf84      	itt	hi
 8005e54:	2300      	movhi	r3, #0
 8005e56:	800b      	strhhi	r3, [r1, #0]
}
 8005e58:	b001      	add	sp, #4
 8005e5a:	bd00      	pop	{pc}
 8005e5c:	40013800 	.word	0x40013800
 8005e60:	200011ca 	.word	0x200011ca
 8005e64:	20001617 	.word	0x20001617
 8005e68:	200011cc 	.word	0x200011cc

08005e6c <dxl_hal_set_timeout>:

	return numPacket;
}

//##############################################################################
void dxl_hal_set_timeout(u8 NumRcvByte) {
 8005e6c:	b500      	push	{lr}
	start_timeout_dxl(NumRcvByte * 30);
 8005e6e:	ebc0 1000 	rsb	r0, r0, r0, lsl #4

	return numPacket;
}

//##############################################################################
void dxl_hal_set_timeout(u8 NumRcvByte) {
 8005e72:	b081      	sub	sp, #4
	start_timeout_dxl(NumRcvByte * 30);
 8005e74:	0040      	lsls	r0, r0, #1
 8005e76:	f7ff fba7 	bl	80055c8 <start_timeout_dxl>
}
 8005e7a:	b001      	add	sp, #4
 8005e7c:	bd00      	pop	{pc}
 8005e7e:	46c0      	nop			(mov r8, r8)

08005e80 <dxl_hal_tx>:
	gbDxlRead = 0;
	gbDxlWrite = 0;
}

//##############################################################################
u8 dxl_hal_tx(u8 *pPacket, u8 numPacket) {
 8005e80:	b570      	push	{r4, r5, r6, lr}
 8005e82:	4606      	mov	r6, r0
 8005e84:	460d      	mov	r5, r1
 8005e86:	2400      	movs	r4, #0
 8005e88:	e01a      	b.n	8005ec0 <dxl_hal_tx+0x40>
	u8 i;
	for (i = 0; i < numPacket; i++) {
		// RX Disable
		GPIO_ResetBits(PORT_ENABLE_RXD, PIN_ENABLE_RXD);
 8005e8a:	4810      	ldr	r0, [pc, #64]	(8005ecc <dxl_hal_tx+0x4c>)
 8005e8c:	2120      	movs	r1, #32
 8005e8e:	f000 fe8f 	bl	8006bb0 <GPIO_ResetBits>
		// TX Enable
		GPIO_SetBits(PORT_ENABLE_TXD, PIN_ENABLE_TXD);
 8005e92:	480e      	ldr	r0, [pc, #56]	(8005ecc <dxl_hal_tx+0x4c>)
 8005e94:	2110      	movs	r1, #16
 8005e96:	f000 fe89 	bl	8006bac <GPIO_SetBits>

		USART_SendData(USART1, pPacket[i]);
 8005e9a:	5d31      	ldrb	r1, [r6, r4]
 8005e9c:	480c      	ldr	r0, [pc, #48]	(8005ed0 <dxl_hal_tx+0x50>)
 8005e9e:	f001 fc55 	bl	800774c <USART_SendData>
		while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
 8005ea2:	480b      	ldr	r0, [pc, #44]	(8005ed0 <dxl_hal_tx+0x50>)
 8005ea4:	2140      	movs	r1, #64
 8005ea6:	f001 fcb7 	bl	8007818 <USART_GetFlagStatus>
 8005eaa:	2800      	cmp	r0, #0
 8005eac:	d0f9      	beq.n	8005ea2 <dxl_hal_tx+0x22>
			;

		// TX Disable
		GPIO_ResetBits(PORT_ENABLE_TXD, PIN_ENABLE_TXD);
 8005eae:	4807      	ldr	r0, [pc, #28]	(8005ecc <dxl_hal_tx+0x4c>)
 8005eb0:	2110      	movs	r1, #16
 8005eb2:	f000 fe7d 	bl	8006bb0 <GPIO_ResetBits>
		// RX Enable
		GPIO_SetBits(PORT_ENABLE_RXD, PIN_ENABLE_RXD);
 8005eb6:	4805      	ldr	r0, [pc, #20]	(8005ecc <dxl_hal_tx+0x4c>)
 8005eb8:	2120      	movs	r1, #32
 8005eba:	f000 fe77 	bl	8006bac <GPIO_SetBits>
 8005ebe:	3401      	adds	r4, #1
}

//##############################################################################
u8 dxl_hal_tx(u8 *pPacket, u8 numPacket) {
	u8 i;
	for (i = 0; i < numPacket; i++) {
 8005ec0:	b2e3      	uxtb	r3, r4
 8005ec2:	42ab      	cmp	r3, r5
 8005ec4:	d3e1      	bcc.n	8005e8a <dxl_hal_tx+0xa>
		// RX Enable
		GPIO_SetBits(PORT_ENABLE_RXD, PIN_ENABLE_RXD);
	}

	return numPacket;
}
 8005ec6:	4628      	mov	r0, r5
 8005ec8:	bd70      	pop	{r4, r5, r6, pc}
 8005eca:	46c0      	nop			(mov r8, r8)
 8005ecc:	40010c00 	.word	0x40010c00
 8005ed0:	40013800 	.word	0x40013800

08005ed4 <dxl_hal_close>:

	return 1;
}

//##############################################################################
void dxl_hal_close(void) {
 8005ed4:	b500      	push	{lr}
	// Disable USART1 (dynamixel)
	USART_Cmd(USART1, DISABLE);
 8005ed6:	4803      	ldr	r0, [pc, #12]	(8005ee4 <dxl_hal_close+0x10>)

	return 1;
}

//##############################################################################
void dxl_hal_close(void) {
 8005ed8:	b081      	sub	sp, #4
	// Disable USART1 (dynamixel)
	USART_Cmd(USART1, DISABLE);
 8005eda:	2100      	movs	r1, #0
 8005edc:	f001 fbbc 	bl	8007658 <USART_Cmd>
}
 8005ee0:	b001      	add	sp, #4
 8005ee2:	bd00      	pop	{pc}
 8005ee4:	40013800 	.word	0x40013800

08005ee8 <zgb_hal_close>:
	return 1;
}

//##############################################################################
void zgb_hal_close(void)
{
 8005ee8:	b500      	push	{lr}
	// Disable UART5 (ZigBee)
	USART_Cmd(UART5, DISABLE);
 8005eea:	2100      	movs	r1, #0
	return 1;
}

//##############################################################################
void zgb_hal_close(void)
{
 8005eec:	b081      	sub	sp, #4
	// Disable UART5 (ZigBee)
	USART_Cmd(UART5, DISABLE);
 8005eee:	4805      	ldr	r0, [pc, #20]	(8005f04 <zgb_hal_close+0x1c>)
 8005ef0:	f001 fbb2 	bl	8007658 <USART_Cmd>
	// Activate Reset mode of ZIG-110 module
//    GPIO_SetBits(PORT_ZIGBEE_RESET, PIN_ZIGBEE_RESET);    // original
	GPIO_ResetBits(PORT_ZIGBEE_RESET, PIN_ZIGBEE_RESET);// correct?
 8005ef4:	4804      	ldr	r0, [pc, #16]	(8005f08 <zgb_hal_close+0x20>)
 8005ef6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8005efa:	f000 fe59 	bl	8006bb0 <GPIO_ResetBits>
}
 8005efe:	b001      	add	sp, #4
 8005f00:	bd00      	pop	{pc}
 8005f02:	46c0      	nop			(mov r8, r8)
 8005f04:	40005000 	.word	0x40005000
 8005f08:	40010800 	.word	0x40010800

08005f0c <pcu_hal_close>:
	    return 1;
	}

	//##############################################################################
	void pcu_hal_close(void)
	{
 8005f0c:	b500      	push	{lr}
	    // Disable USART3 (PC UART)
	    USART_Cmd(USART3, DISABLE);
 8005f0e:	4803      	ldr	r0, [pc, #12]	(8005f1c <pcu_hal_close+0x10>)
	    return 1;
	}

	//##############################################################################
	void pcu_hal_close(void)
	{
 8005f10:	b081      	sub	sp, #4
	    // Disable USART3 (PC UART)
	    USART_Cmd(USART3, DISABLE);
 8005f12:	2100      	movs	r1, #0
 8005f14:	f001 fba0 	bl	8007658 <USART_Cmd>
	}
 8005f18:	b001      	add	sp, #4
 8005f1a:	bd00      	pop	{pc}
 8005f1c:	40004800 	.word	0x40004800

08005f20 <dxl_hal_open>:

#endif

#ifdef USING_DYNAMIXEL
//##############################################################################
u8 dxl_hal_open(u32 baudrate) {
 8005f20:	b530      	push	{r4, r5, lr}
 8005f22:	b085      	sub	sp, #20
 8005f24:	4604      	mov	r4, r0
	USART_InitTypeDef USART_InitStructure;

	USART_StructInit(&USART_InitStructure);
 8005f26:	4668      	mov	r0, sp
 8005f28:	f001 fb6a 	bl	8007600 <USART_StructInit>

	USART_InitStructure.USART_BaudRate = baudrate;
 8005f2c:	9400      	str	r4, [sp, #0]
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl =
	USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	USART_DeInit(USART1);
 8005f2e:	4c13      	ldr	r4, [pc, #76]	(8005f7c <dxl_hal_open+0x5c>)
	USART_InitTypeDef USART_InitStructure;

	USART_StructInit(&USART_InitStructure);

	USART_InitStructure.USART_BaudRate = baudrate;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8005f30:	f04f 0300 	mov.w	r3, #0	; 0x0
 8005f34:	f8ad 3004 	strh.w	r3, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8005f38:	f8ad 3006 	strh.w	r3, [sp, #6]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8005f3c:	f8ad 3008 	strh.w	r3, [sp, #8]
	USART_InitStructure.USART_HardwareFlowControl =
 8005f40:	f8ad 300c 	strh.w	r3, [sp, #12]
	USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	USART_DeInit(USART1);
 8005f44:	4620      	mov	r0, r4
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl =
	USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8005f46:	f04f 030c 	mov.w	r3, #12	; 0xc
 8005f4a:	f8ad 300a 	strh.w	r3, [sp, #10]

	USART_DeInit(USART1);
 8005f4e:	f001 fceb 	bl	8007928 <USART_DeInit>
	mDelay(10);
 8005f52:	200a      	movs	r0, #10
 8005f54:	f7ff fb18 	bl	8005588 <mDelay>
	// Configure USART1 (dynamixel)
	USART_Init(USART1, &USART_InitStructure);
 8005f58:	4620      	mov	r0, r4
 8005f5a:	4669      	mov	r1, sp
 8005f5c:	f001 fc96 	bl	800788c <USART_Init>

	// Enable USART1 (dynamixel) Receive interrupt
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
 8005f60:	4620      	mov	r0, r4
 8005f62:	2201      	movs	r2, #1
 8005f64:	f240 5125 	movw	r1, #1317	; 0x525
 8005f68:	f001 fb84 	bl	8007674 <USART_ITConfig>

	// Enable USART1 (dynamixel)
	USART_Cmd(USART1, ENABLE);
 8005f6c:	4620      	mov	r0, r4
 8005f6e:	2101      	movs	r1, #1
 8005f70:	f001 fb72 	bl	8007658 <USART_Cmd>
#ifdef USING_DYNAMIXEL
//##############################################################################
u8 dxl_hal_open(u32 baudrate) {
	USART_InitTypeDef USART_InitStructure;

	USART_StructInit(&USART_InitStructure);
 8005f74:	466d      	mov	r5, sp

	// Enable USART1 (dynamixel)
	USART_Cmd(USART1, ENABLE);

	return 1;
}
 8005f76:	2001      	movs	r0, #1
 8005f78:	b005      	add	sp, #20
 8005f7a:	bd30      	pop	{r4, r5, pc}
 8005f7c:	40013800 	.word	0x40013800

08005f80 <zgb_hal_open>:
#endif

#ifdef USING_ZIGBEE
//##############################################################################
u8 zgb_hal_open(u32 baudrate)
{
 8005f80:	b530      	push	{r4, r5, lr}
 8005f82:	b085      	sub	sp, #20
 8005f84:	4604      	mov	r4, r0
	USART_InitTypeDef USART_InitStructure;

	USART_StructInit(&USART_InitStructure);
 8005f86:	4668      	mov	r0, sp
 8005f88:	f001 fb3a 	bl	8007600 <USART_StructInit>

	USART_InitStructure.USART_BaudRate = baudrate;
 8005f8c:	9400      	str	r4, [sp, #0]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	USART_DeInit(UART5);
 8005f8e:	4c16      	ldr	r4, [pc, #88]	(8005fe8 <zgb_hal_open+0x68>)
	USART_InitTypeDef USART_InitStructure;

	USART_StructInit(&USART_InitStructure);

	USART_InitStructure.USART_BaudRate = baudrate;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8005f90:	f04f 0300 	mov.w	r3, #0	; 0x0
 8005f94:	f8ad 3004 	strh.w	r3, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8005f98:	f8ad 3006 	strh.w	r3, [sp, #6]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8005f9c:	f8ad 3008 	strh.w	r3, [sp, #8]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8005fa0:	f8ad 300c 	strh.w	r3, [sp, #12]
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	USART_DeInit(UART5);
 8005fa4:	4620      	mov	r0, r4
	USART_InitStructure.USART_BaudRate = baudrate;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8005fa6:	f04f 030c 	mov.w	r3, #12	; 0xc
 8005faa:	f8ad 300a 	strh.w	r3, [sp, #10]

	USART_DeInit(UART5);
 8005fae:	f001 fcbb 	bl	8007928 <USART_DeInit>
	mDelay(10);
 8005fb2:	200a      	movs	r0, #10
 8005fb4:	f7ff fae8 	bl	8005588 <mDelay>
	// Configure UART5 (ZigBee)
	USART_Init(UART5, &USART_InitStructure);
 8005fb8:	4620      	mov	r0, r4
 8005fba:	4669      	mov	r1, sp
 8005fbc:	f001 fc66 	bl	800788c <USART_Init>

	// Enable UART5 (ZigBee) Receive interrupt
	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);
 8005fc0:	2201      	movs	r2, #1
 8005fc2:	4620      	mov	r0, r4
 8005fc4:	f240 5125 	movw	r1, #1317	; 0x525
 8005fc8:	f001 fb54 	bl	8007674 <USART_ITConfig>

	// Enable UART5 (ZigBee)
	USART_Cmd(UART5, ENABLE);
 8005fcc:	4620      	mov	r0, r4
 8005fce:	2101      	movs	r1, #1
 8005fd0:	f001 fb42 	bl	8007658 <USART_Cmd>

	// De-activate Reset mode of ZIG-110 module
	//GPIO_SetBits(PORT_ZIGBEE_RESET, PIN_ZIGBEE_RESET);
	GPIO_ResetBits(PORT_ZIGBEE_RESET, PIN_ZIGBEE_RESET);
 8005fd4:	4805      	ldr	r0, [pc, #20]	(8005fec <zgb_hal_open+0x6c>)
 8005fd6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8005fda:	f000 fde9 	bl	8006bb0 <GPIO_ResetBits>
//##############################################################################
u8 zgb_hal_open(u32 baudrate)
{
	USART_InitTypeDef USART_InitStructure;

	USART_StructInit(&USART_InitStructure);
 8005fde:	466d      	mov	r5, sp
	// De-activate Reset mode of ZIG-110 module
	//GPIO_SetBits(PORT_ZIGBEE_RESET, PIN_ZIGBEE_RESET);
	GPIO_ResetBits(PORT_ZIGBEE_RESET, PIN_ZIGBEE_RESET);

	return 1;
}
 8005fe0:	2001      	movs	r0, #1
 8005fe2:	b005      	add	sp, #20
 8005fe4:	bd30      	pop	{r4, r5, pc}
 8005fe6:	46c0      	nop			(mov r8, r8)
 8005fe8:	40005000 	.word	0x40005000
 8005fec:	40010800 	.word	0x40010800

08005ff0 <pcu_hal_open>:
#endif


#ifdef USING_PC_UART
	u8 pcu_hal_open(u32 baudrate)
	{
 8005ff0:	b530      	push	{r4, r5, lr}
 8005ff2:	b085      	sub	sp, #20
 8005ff4:	4604      	mov	r4, r0
	    USART_InitTypeDef USART_InitStructure;

	    USART_StructInit(&USART_InitStructure);
 8005ff6:	4668      	mov	r0, sp
 8005ff8:	f001 fb02 	bl	8007600 <USART_StructInit>

	    USART_InitStructure.USART_BaudRate = baudrate;
 8005ffc:	9400      	str	r4, [sp, #0]
	    USART_InitStructure.USART_StopBits = USART_StopBits_1;
	    USART_InitStructure.USART_Parity = USART_Parity_No ;
	    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	    USART_DeInit(USART3);
 8005ffe:	4c13      	ldr	r4, [pc, #76]	(800604c <pcu_hal_open+0x5c>)
	    USART_InitTypeDef USART_InitStructure;

	    USART_StructInit(&USART_InitStructure);

	    USART_InitStructure.USART_BaudRate = baudrate;
	    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8006000:	f04f 0300 	mov.w	r3, #0	; 0x0
 8006004:	f8ad 3004 	strh.w	r3, [sp, #4]
	    USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8006008:	f8ad 3006 	strh.w	r3, [sp, #6]
	    USART_InitStructure.USART_Parity = USART_Parity_No ;
 800600c:	f8ad 3008 	strh.w	r3, [sp, #8]
	    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8006010:	f8ad 300c 	strh.w	r3, [sp, #12]
	    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	    USART_DeInit(USART3);
 8006014:	4620      	mov	r0, r4
	    USART_InitStructure.USART_BaudRate = baudrate;
	    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	    USART_InitStructure.USART_StopBits = USART_StopBits_1;
	    USART_InitStructure.USART_Parity = USART_Parity_No ;
	    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8006016:	f04f 030c 	mov.w	r3, #12	; 0xc
 800601a:	f8ad 300a 	strh.w	r3, [sp, #10]

	    USART_DeInit(USART3);
 800601e:	f001 fc83 	bl	8007928 <USART_DeInit>
	    mDelay(10);
 8006022:	200a      	movs	r0, #10
 8006024:	f7ff fab0 	bl	8005588 <mDelay>
	    // Configure USART3 (PC_UART)
	    USART_Init(USART3, &USART_InitStructure);
 8006028:	4620      	mov	r0, r4
 800602a:	4669      	mov	r1, sp
 800602c:	f001 fc2e 	bl	800788c <USART_Init>

	    // Enable USART3 (PC_UART) Receive interrupt
	    USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
 8006030:	4620      	mov	r0, r4
 8006032:	2201      	movs	r2, #1
 8006034:	f240 5125 	movw	r1, #1317	; 0x525
 8006038:	f001 fb1c 	bl	8007674 <USART_ITConfig>

	    // Enable USART3 (PC_UART)
	    USART_Cmd(USART3, ENABLE);
 800603c:	4620      	mov	r0, r4
 800603e:	2101      	movs	r1, #1
 8006040:	f001 fb0a 	bl	8007658 <USART_Cmd>
#ifdef USING_PC_UART
	u8 pcu_hal_open(u32 baudrate)
	{
	    USART_InitTypeDef USART_InitStructure;

	    USART_StructInit(&USART_InitStructure);
 8006044:	466d      	mov	r5, sp
	    USART_Cmd(USART3, ENABLE);

	//    PC_UART_Device = fdevopen( std_putchar, std_getchar );

	    return 1;
	}
 8006046:	2001      	movs	r0, #1
 8006048:	b005      	add	sp, #20
 800604a:	bd30      	pop	{r4, r5, pc}
 800604c:	40004800 	.word	0x40004800

08006050 <RxD_ZIG_Interrupt>:
	return numPacket;
}

//##############################################################################
void RxD_ZIG_Interrupt(void)
{
 8006050:	b510      	push	{r4, lr}
	u8 temp;
	if (USART_GetITStatus(UART5, USART_IT_RXNE)!=RESET)
 8006052:	481e      	ldr	r0, [pc, #120]	(80060cc <RxD_ZIG_Interrupt+0x7c>)
 8006054:	f240 5125 	movw	r1, #1317	; 0x525
 8006058:	f001 fbea 	bl	8007830 <USART_GetITStatus>
 800605c:	2800      	cmp	r0, #0
 800605e:	d034      	beq.n	80060ca <RxD_ZIG_Interrupt+0x7a>
	{
		temp = USART_ReceiveData(UART5);
 8006060:	481a      	ldr	r0, [pc, #104]	(80060cc <RxD_ZIG_Interrupt+0x7c>)
 8006062:	f001 fb77 	bl	8007754 <USART_ReceiveData>
 8006066:	b2c4      	uxtb	r4, r0
		if (temp=='#'){
 8006068:	2c23      	cmp	r4, #35
 800606a:	4a19      	ldr	r2, [pc, #100]	(80060d0 <RxD_ZIG_Interrupt+0x80>)
 800606c:	d103      	bne.n	8006076 <RxD_ZIG_Interrupt+0x26>
		ReBootToBootLoader++;
 800606e:	7813      	ldrb	r3, [r2, #0]
 8006070:	3301      	adds	r3, #1
 8006072:	b2db      	uxtb	r3, r3
 8006074:	e000      	b.n	8006078 <RxD_ZIG_Interrupt+0x28>

		}
		else
		ReBootToBootLoader=0;
 8006076:	2300      	movs	r3, #0
 8006078:	7013      	strb	r3, [r2, #0]

		if (ReBootToBootLoader>15)
 800607a:	4b15      	ldr	r3, [pc, #84]	(80060d0 <RxD_ZIG_Interrupt+0x80>)
		}
	}
	else
	return;

	SetLED(RXD, 1);
 800607c:	2101      	movs	r1, #1
 800607e:	2005      	movs	r0, #5

		}
		else
		ReBootToBootLoader=0;

		if (ReBootToBootLoader>15)
 8006080:	781b      	ldrb	r3, [r3, #0]
		}
	}
	else
	return;

	SetLED(RXD, 1);
 8006082:	f7ff fa25 	bl	80054d0 <SetLED>

	if (gbZigWrite<(ZIGBEE_BUFFER_LENGTH-1))
 8006086:	4a13      	ldr	r2, [pc, #76]	(80060d4 <RxD_ZIG_Interrupt+0x84>)
 8006088:	4913      	ldr	r1, [pc, #76]	(80060d8 <RxD_ZIG_Interrupt+0x88>)
 800608a:	7813      	ldrb	r3, [r2, #0]
 800608c:	2b3e      	cmp	r3, #62
 800608e:	d804      	bhi.n	800609a <RxD_ZIG_Interrupt+0x4a>
	{
		gbpZigBuffer[gbZigWrite++] = temp;
 8006090:	7813      	ldrb	r3, [r2, #0]
 8006092:	54cc      	strb	r4, [r1, r3]
 8006094:	3301      	adds	r3, #1
 8006096:	b2db      	uxtb	r3, r3
 8006098:	e002      	b.n	80060a0 <RxD_ZIG_Interrupt+0x50>
	}
	else
	{
		gbpZigBuffer[gbZigWrite] = temp;
 800609a:	7813      	ldrb	r3, [r2, #0]
 800609c:	54cc      	strb	r4, [r1, r3]
		gbZigWrite = 0;
 800609e:	2300      	movs	r3, #0
 80060a0:	7013      	strb	r3, [r2, #0]
	}

	if (gbZigRead==gbZigWrite)
 80060a2:	490e      	ldr	r1, [pc, #56]	(80060dc <RxD_ZIG_Interrupt+0x8c>)
 80060a4:	4a0b      	ldr	r2, [pc, #44]	(80060d4 <RxD_ZIG_Interrupt+0x84>)
 80060a6:	780b      	ldrb	r3, [r1, #0]
 80060a8:	7812      	ldrb	r2, [r2, #0]
 80060aa:	4293      	cmp	r3, r2
 80060ac:	d103      	bne.n	80060b6 <RxD_ZIG_Interrupt+0x66>
	gbZigRead++;
 80060ae:	780b      	ldrb	r3, [r1, #0]
 80060b0:	3301      	adds	r3, #1
 80060b2:	b2db      	uxtb	r3, r3
 80060b4:	700b      	strb	r3, [r1, #0]
	if (gbZigRead>(ZIGBEE_BUFFER_LENGTH-1))
 80060b6:	4a09      	ldr	r2, [pc, #36]	(80060dc <RxD_ZIG_Interrupt+0x8c>)
 80060b8:	7813      	ldrb	r3, [r2, #0]
 80060ba:	2b3f      	cmp	r3, #63
 80060bc:	d901      	bls.n	80060c2 <RxD_ZIG_Interrupt+0x72>
	gbZigRead=0;
 80060be:	2300      	movs	r3, #0
 80060c0:	7013      	strb	r3, [r2, #0]

	SetLED(RXD, 0);
 80060c2:	2005      	movs	r0, #5
 80060c4:	2100      	movs	r1, #0
 80060c6:	f7ff fa03 	bl	80054d0 <SetLED>
}
 80060ca:	bd10      	pop	{r4, pc}
 80060cc:	40005000 	.word	0x40005000
 80060d0:	200015d0 	.word	0x200015d0
 80060d4:	200011ce 	.word	0x200011ce
 80060d8:	200015d6 	.word	0x200015d6
 80060dc:	200011cf 	.word	0x200011cf

080060e0 <zgb_hal_tx>:
	GPIO_ResetBits(PORT_ZIGBEE_RESET, PIN_ZIGBEE_RESET);// correct?
}

//##############################################################################
u8 zgb_hal_tx(u8 *pPacket, u8 numPacket)
{
 80060e0:	b570      	push	{r4, r5, r6, lr}
 80060e2:	4606      	mov	r6, r0
 80060e4:	460d      	mov	r5, r1
 80060e6:	2400      	movs	r4, #0
 80060e8:	e012      	b.n	8006110 <zgb_hal_tx+0x30>
	u8 i;
	for (i=0; i<numPacket; i++)
	{
		SetLED(TXD, 1);
 80060ea:	2004      	movs	r0, #4
 80060ec:	2101      	movs	r1, #1
 80060ee:	f7ff f9ef 	bl	80054d0 <SetLED>

		USART_SendData(UART5,pPacket[i]);
 80060f2:	5d31      	ldrb	r1, [r6, r4]
 80060f4:	4809      	ldr	r0, [pc, #36]	(800611c <zgb_hal_tx+0x3c>)
 80060f6:	f001 fb29 	bl	800774c <USART_SendData>
		while (USART_GetFlagStatus(UART5, USART_FLAG_TC)==RESET);
 80060fa:	4808      	ldr	r0, [pc, #32]	(800611c <zgb_hal_tx+0x3c>)
 80060fc:	2140      	movs	r1, #64
 80060fe:	f001 fb8b 	bl	8007818 <USART_GetFlagStatus>
 8006102:	2800      	cmp	r0, #0
 8006104:	d0f9      	beq.n	80060fa <zgb_hal_tx+0x1a>

		SetLED(TXD, 0);
 8006106:	2004      	movs	r0, #4
 8006108:	2100      	movs	r1, #0
 800610a:	f7ff f9e1 	bl	80054d0 <SetLED>
 800610e:	3401      	adds	r4, #1

//##############################################################################
u8 zgb_hal_tx(u8 *pPacket, u8 numPacket)
{
	u8 i;
	for (i=0; i<numPacket; i++)
 8006110:	b2e3      	uxtb	r3, r4
 8006112:	42ab      	cmp	r3, r5
 8006114:	d3e9      	bcc.n	80060ea <zgb_hal_tx+0xa>

		SetLED(TXD, 0);
	}

	return numPacket;
}
 8006116:	4628      	mov	r0, r5
 8006118:	bd70      	pop	{r4, r5, r6, pc}
 800611a:	46c0      	nop			(mov r8, r8)
 800611c:	40005000 	.word	0x40005000

08006120 <pcu_put_queue>:
	    return data;
	}

	//##############################################################################
	void pcu_put_queue(void)
	{
 8006120:	b510      	push	{r4, lr}
	    u8 temp;
	    if (USART_GetITStatus(USART3, USART_IT_RXNE)!=RESET)
 8006122:	4822      	ldr	r0, [pc, #136]	(80061ac <pcu_put_queue+0x8c>)
 8006124:	f240 5125 	movw	r1, #1317	; 0x525
 8006128:	f001 fb82 	bl	8007830 <USART_GetITStatus>
 800612c:	2800      	cmp	r0, #0
 800612e:	d03b      	beq.n	80061a8 <pcu_put_queue+0x88>
	    {
	        temp = USART_ReceiveData(USART3);
 8006130:	481e      	ldr	r0, [pc, #120]	(80061ac <pcu_put_queue+0x8c>)
 8006132:	f001 fb0f 	bl	8007754 <USART_ReceiveData>
 8006136:	b2c4      	uxtb	r4, r0
	        if (temp=='#')
 8006138:	2c23      	cmp	r4, #35
 800613a:	4a1d      	ldr	r2, [pc, #116]	(80061b0 <pcu_put_queue+0x90>)
 800613c:	d103      	bne.n	8006146 <pcu_put_queue+0x26>
	            ReBootToBootLoader++;
 800613e:	7813      	ldrb	r3, [r2, #0]
 8006140:	3301      	adds	r3, #1
 8006142:	b2db      	uxtb	r3, r3
 8006144:	e000      	b.n	8006148 <pcu_put_queue+0x28>
	        else
	            ReBootToBootLoader=0;
 8006146:	2300      	movs	r3, #0
 8006148:	7013      	strb	r3, [r2, #0]

	        if (ReBootToBootLoader>15)
 800614a:	4b19      	ldr	r3, [pc, #100]	(80061b0 <pcu_put_queue+0x90>)
	        }
	    }
	    else
	        return;

	    SetLED(RXD, 1);
 800614c:	2101      	movs	r1, #1
 800614e:	2005      	movs	r0, #5
	        if (temp=='#')
	            ReBootToBootLoader++;
	        else
	            ReBootToBootLoader=0;

	        if (ReBootToBootLoader>15)
 8006150:	781b      	ldrb	r3, [r3, #0]
	        }
	    }
	    else
	        return;

	    SetLED(RXD, 1);
 8006152:	f7ff f9bd 	bl	80054d0 <SetLED>

	    if (gbPcuWrite<(PC_UART_BUFFER_LENGTH-1))
 8006156:	4917      	ldr	r1, [pc, #92]	(80061b4 <pcu_put_queue+0x94>)
 8006158:	f240 33fd 	movw	r3, #1021	; 0x3fd
 800615c:	880a      	ldrh	r2, [r1, #0]
 800615e:	429a      	cmp	r2, r3
 8006160:	4a15      	ldr	r2, [pc, #84]	(80061b8 <pcu_put_queue+0x98>)
 8006162:	d805      	bhi.n	8006170 <pcu_put_queue+0x50>
	    {
	        gbpPcuBuffer[gbPcuWrite++] = temp;
 8006164:	880b      	ldrh	r3, [r1, #0]
 8006166:	b29b      	uxth	r3, r3
 8006168:	54d4      	strb	r4, [r2, r3]
 800616a:	3301      	adds	r3, #1
 800616c:	b29b      	uxth	r3, r3
 800616e:	e004      	b.n	800617a <pcu_put_queue+0x5a>
	    }
	    else
	    {
	        gbpPcuBuffer[gbPcuWrite] = temp;
 8006170:	880b      	ldrh	r3, [r1, #0]
 8006172:	b29b      	uxth	r3, r3
 8006174:	54d4      	strb	r4, [r2, r3]
	        gbPcuWrite = 0;
 8006176:	f04f 0300 	mov.w	r3, #0	; 0x0
 800617a:	800b      	strh	r3, [r1, #0]
	    }

	    if (gbPcuRead==gbPcuWrite)
 800617c:	4a0d      	ldr	r2, [pc, #52]	(80061b4 <pcu_put_queue+0x94>)
 800617e:	490f      	ldr	r1, [pc, #60]	(80061bc <pcu_put_queue+0x9c>)
 8006180:	880b      	ldrh	r3, [r1, #0]
 8006182:	8812      	ldrh	r2, [r2, #0]
 8006184:	429a      	cmp	r2, r3
 8006186:	d103      	bne.n	8006190 <pcu_put_queue+0x70>
	        gbPcuRead++;
 8006188:	880b      	ldrh	r3, [r1, #0]
 800618a:	3301      	adds	r3, #1
 800618c:	b29b      	uxth	r3, r3
 800618e:	800b      	strh	r3, [r1, #0]
	    if (gbPcuRead>(PC_UART_BUFFER_LENGTH-1))
 8006190:	490a      	ldr	r1, [pc, #40]	(80061bc <pcu_put_queue+0x9c>)
 8006192:	f240 33fe 	movw	r3, #1022	; 0x3fe
 8006196:	880a      	ldrh	r2, [r1, #0]
 8006198:	429a      	cmp	r2, r3
	        gbPcuRead=0;
 800619a:	bf84      	itt	hi
 800619c:	2300      	movhi	r3, #0
 800619e:	800b      	strhhi	r3, [r1, #0]

	    SetLED(RXD, 0);
 80061a0:	2005      	movs	r0, #5
 80061a2:	2100      	movs	r1, #0
 80061a4:	f7ff f994 	bl	80054d0 <SetLED>
	}
 80061a8:	bd10      	pop	{r4, pc}
 80061aa:	46c0      	nop			(mov r8, r8)
 80061ac:	40004800 	.word	0x40004800
 80061b0:	200015d0 	.word	0x200015d0
 80061b4:	200015d2 	.word	0x200015d2
 80061b8:	200011d0 	.word	0x200011d0
 80061bc:	200015d4 	.word	0x200015d4

080061c0 <RxD_PCU_Interrupt>:
	        return (u8) (PC_UART_BUFFER_LENGTH-(gbPcuRead-gbPcuWrite));
	}

	//##############################################################################
	void RxD_PCU_Interrupt(void)
	{
 80061c0:	b500      	push	{lr}
 80061c2:	b081      	sub	sp, #4
	    pcu_put_queue();
 80061c4:	f7ff ffac 	bl	8006120 <pcu_put_queue>
	}
 80061c8:	b001      	add	sp, #4
 80061ca:	bd00      	pop	{pc}

080061cc <pcu_put_byte>:
	        return 0;
	}

	//##############################################################################
	void pcu_put_byte(u8 bTxdData)
	{
 80061cc:	b510      	push	{r4, lr}
 80061ce:	4604      	mov	r4, r0
	    SetLED(TXD, 1);
 80061d0:	2101      	movs	r1, #1
 80061d2:	2004      	movs	r0, #4

	    USART_SendData(USART3,bTxdData);
 80061d4:	b2a4      	uxth	r4, r4
	}

	//##############################################################################
	void pcu_put_byte(u8 bTxdData)
	{
	    SetLED(TXD, 1);
 80061d6:	f7ff f97b 	bl	80054d0 <SetLED>

	    USART_SendData(USART3,bTxdData);
 80061da:	4807      	ldr	r0, [pc, #28]	(80061f8 <pcu_put_byte+0x2c>)
 80061dc:	4621      	mov	r1, r4
 80061de:	f001 fab5 	bl	800774c <USART_SendData>
	    while (USART_GetFlagStatus(USART3, USART_FLAG_TC)==RESET);
 80061e2:	4805      	ldr	r0, [pc, #20]	(80061f8 <pcu_put_byte+0x2c>)
 80061e4:	2140      	movs	r1, #64
 80061e6:	f001 fb17 	bl	8007818 <USART_GetFlagStatus>
 80061ea:	2800      	cmp	r0, #0
 80061ec:	d0f9      	beq.n	80061e2 <pcu_put_byte+0x16>

	    SetLED(TXD, 0);
 80061ee:	2004      	movs	r0, #4
 80061f0:	2100      	movs	r1, #0
 80061f2:	f7ff f96d 	bl	80054d0 <SetLED>
	}
 80061f6:	bd10      	pop	{r4, pc}
 80061f8:	40004800 	.word	0x40004800

080061fc <pcu_hal_set_timeout>:
	    USART_Cmd(USART3, DISABLE);
	}

	//##############################################################################
	void pcu_hal_set_timeout(u8 NumRcvByte)
	{
 80061fc:	b500      	push	{lr}
 80061fe:	4603      	mov	r3, r0
	    // 200us; ~180 us to transmit one byte at 57600 bps
	    start_timeout_pcu(NumRcvByte*200);
 8006200:	20c8      	movs	r0, #200
	    USART_Cmd(USART3, DISABLE);
	}

	//##############################################################################
	void pcu_hal_set_timeout(u8 NumRcvByte)
	{
 8006202:	b081      	sub	sp, #4
	    // 200us; ~180 us to transmit one byte at 57600 bps
	    start_timeout_pcu(NumRcvByte*200);
 8006204:	fb00 f003 	mul.w	r0, r0, r3
 8006208:	f7ff f9fa 	bl	8005600 <start_timeout_pcu>
	}
 800620c:	b001      	add	sp, #4
 800620e:	bd00      	pop	{pc}

08006210 <ADC_Init>:
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8006210:	6843      	ldr	r3, [r0, #4]
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
 8006212:	680a      	ldr	r2, [r1, #0]
 8006214:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8006218:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800621c:	4313      	orrs	r3, r2
 800621e:	790a      	ldrb	r2, [r1, #4]
 8006220:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8006224:	6043      	str	r3, [r0, #4]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8006226:	68cb      	ldr	r3, [r1, #12]
 8006228:	688a      	ldr	r2, [r1, #8]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 800622a:	f8d0 c008 	ldr.w	ip, [r0, #8]
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 800622e:	431a      	orrs	r2, r3
 8006230:	4b08      	ldr	r3, [pc, #32]	(8006254 <ADC_Init+0x44>)
 8006232:	ea0c 0303 	and.w	r3, ip, r3
 8006236:	431a      	orrs	r2, r3
 8006238:	794b      	ldrb	r3, [r1, #5]
 800623a:	ea42 0243 	orr.w	r2, r2, r3, lsl #1
            ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 800623e:	6082      	str	r2, [r0, #8]
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
  tmpreg1 |= ((u32)tmpreg2 << 20);
 8006240:	7c0b      	ldrb	r3, [r1, #16]
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8006242:	6ac2      	ldr	r2, [r0, #44]
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
  tmpreg1 |= ((u32)tmpreg2 << 20);
 8006244:	3b01      	subs	r3, #1

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
 8006246:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
  tmpreg1 |= ((u32)tmpreg2 << 20);
 800624a:	b2db      	uxtb	r3, r3
 800624c:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8006250:	62c2      	str	r2, [r0, #44]
}
 8006252:	4770      	bx	lr
 8006254:	fff1f7fd 	.word	0xfff1f7fd

08006258 <ADC_StructInit>:
*******************************************************************************/
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
 8006258:	2300      	movs	r3, #0
 800625a:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 800625c:	7103      	strb	r3, [r0, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 800625e:	7143      	strb	r3, [r0, #5]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 8006260:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8006262:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_NbrOfChannel member */
  ADC_InitStruct->ADC_NbrOfChannel = 1;
 8006264:	2301      	movs	r3, #1
 8006266:	7403      	strb	r3, [r0, #16]
}
 8006268:	4770      	bx	lr
 800626a:	46c0      	nop			(mov r8, r8)

0800626c <ADC_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800626c:	b119      	cbz	r1, 8006276 <ADC_Cmd+0xa>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
 800626e:	6883      	ldr	r3, [r0, #8]
 8006270:	f043 0301 	orr.w	r3, r3, #1	; 0x1
 8006274:	e002      	b.n	800627c <ADC_Cmd+0x10>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
 8006276:	6883      	ldr	r3, [r0, #8]
 8006278:	f023 0301 	bic.w	r3, r3, #1	; 0x1
 800627c:	6083      	str	r3, [r0, #8]
  }
}
 800627e:	4770      	bx	lr

08006280 <ADC_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8006280:	b119      	cbz	r1, 800628a <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
 8006282:	6883      	ldr	r3, [r0, #8]
 8006284:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006288:	e002      	b.n	8006290 <ADC_DMACmd+0x10>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
 800628a:	6883      	ldr	r3, [r0, #8]
 800628c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006290:	6083      	str	r3, [r0, #8]
  }
}
 8006292:	4770      	bx	lr

08006294 <ADC_ITConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT));

  /* Get the ADC IT index */
  itmask = (u8)ADC_IT;
 8006294:	b2c9      	uxtb	r1, r1

  if (NewState != DISABLE)
 8006296:	b11a      	cbz	r2, 80062a0 <ADC_ITConfig+0xc>
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 8006298:	6843      	ldr	r3, [r0, #4]
 800629a:	ea41 0303 	orr.w	r3, r1, r3
 800629e:	e002      	b.n	80062a6 <ADC_ITConfig+0x12>
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(u32)itmask);
 80062a0:	6843      	ldr	r3, [r0, #4]
 80062a2:	ea23 0301 	bic.w	r3, r3, r1
 80062a6:	6043      	str	r3, [r0, #4]
  }
}
 80062a8:	4770      	bx	lr
 80062aa:	46c0      	nop			(mov r8, r8)

080062ac <ADC_ResetCalibration>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
 80062ac:	6883      	ldr	r3, [r0, #8]
 80062ae:	f043 0308 	orr.w	r3, r3, #8	; 0x8
 80062b2:	6083      	str	r3, [r0, #8]
}
 80062b4:	4770      	bx	lr
 80062b6:	46c0      	nop			(mov r8, r8)

080062b8 <ADC_GetResetCalibrationStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
 80062b8:	6880      	ldr	r0, [r0, #8]
 80062ba:	08c0      	lsrs	r0, r0, #3
 80062bc:	f000 0001 	and.w	r0, r0, #1	; 0x1
    bitstatus = RESET;
  }

  /* Return the RSTCAL bit status */
  return  bitstatus;
}
 80062c0:	4770      	bx	lr
 80062c2:	46c0      	nop			(mov r8, r8)

080062c4 <ADC_StartCalibration>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
 80062c4:	6883      	ldr	r3, [r0, #8]
 80062c6:	f043 0304 	orr.w	r3, r3, #4	; 0x4
 80062ca:	6083      	str	r3, [r0, #8]
}
 80062cc:	4770      	bx	lr
 80062ce:	46c0      	nop			(mov r8, r8)

080062d0 <ADC_GetCalibrationStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
 80062d0:	6880      	ldr	r0, [r0, #8]
 80062d2:	0880      	lsrs	r0, r0, #2
 80062d4:	f000 0001 	and.w	r0, r0, #1	; 0x1
    bitstatus = RESET;
  }

  /* Return the CAL bit status */
  return  bitstatus;
}
 80062d8:	4770      	bx	lr
 80062da:	46c0      	nop			(mov r8, r8)

080062dc <ADC_SoftwareStartConvCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80062dc:	b119      	cbz	r1, 80062e6 <ADC_SoftwareStartConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
 80062de:	6883      	ldr	r3, [r0, #8]
 80062e0:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 80062e4:	e002      	b.n	80062ec <ADC_SoftwareStartConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
 80062e6:	6883      	ldr	r3, [r0, #8]
 80062e8:	f423 03a0 	bic.w	r3, r3, #5242880	; 0x500000
 80062ec:	6083      	str	r3, [r0, #8]
  }
}
 80062ee:	4770      	bx	lr

080062f0 <ADC_GetSoftwareStartConvStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
 80062f0:	6880      	ldr	r0, [r0, #8]
 80062f2:	0d80      	lsrs	r0, r0, #22
 80062f4:	f000 0001 	and.w	r0, r0, #1	; 0x1
    bitstatus = RESET;
  }

  /* Return the SWSTART bit status */
  return  bitstatus;
}
 80062f8:	4770      	bx	lr
 80062fa:	46c0      	nop			(mov r8, r8)

080062fc <ADC_DiscModeChannelCountConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));

  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
 80062fc:	6843      	ldr	r3, [r0, #4]
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
 80062fe:	3901      	subs	r1, #1
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));

  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_Reset;
 8006300:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 13;
 8006304:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
 8006308:	6043      	str	r3, [r0, #4]
}
 800630a:	4770      	bx	lr

0800630c <ADC_DiscModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800630c:	b119      	cbz	r1, 8006316 <ADC_DiscModeCmd+0xa>
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CR1 |= CR1_DISCEN_Set;
 800630e:	6843      	ldr	r3, [r0, #4]
 8006310:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8006314:	e002      	b.n	800631c <ADC_DiscModeCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= CR1_DISCEN_Reset;
 8006316:	6843      	ldr	r3, [r0, #4]
 8006318:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800631c:	6043      	str	r3, [r0, #4]
  }
}
 800631e:	4770      	bx	lr

08006320 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8006320:	2909      	cmp	r1, #9
*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
{
 8006322:	b530      	push	{r4, r5, lr}
 8006324:	4694      	mov	ip, r2
 8006326:	460c      	mov	r4, r1
 8006328:	461d      	mov	r5, r3
 800632a:	ea4f 0241 	mov.w	r2, r1, lsl #1
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 800632e:	d90b      	bls.n	8006348 <ADC_RegularChannelConfig+0x28>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
 8006330:	1912      	adds	r2, r2, r4
 8006332:	3a1e      	subs	r2, #30
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 8006334:	2307      	movs	r3, #7
 8006336:	4093      	lsls	r3, r2
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 8006338:	fa15 f202 	lsls.w	r2, r5, r2

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 800633c:	68c1      	ldr	r1, [r0, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 800633e:	ea21 0103 	bic.w	r1, r1, r3
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 8006342:	4311      	orrs	r1, r2
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8006344:	60c1      	str	r1, [r0, #12]
 8006346:	e009      	b.n	800635c <ADC_RegularChannelConfig+0x3c>
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 8006348:	1912      	adds	r2, r2, r4
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 800634a:	2307      	movs	r3, #7
 800634c:	4093      	lsls	r3, r2
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 800634e:	fa15 f202 	lsls.w	r2, r5, r2
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8006352:	6901      	ldr	r1, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 8006354:	ea21 0103 	bic.w	r1, r1, r3
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 8006358:	4311      	orrs	r1, r2
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 800635a:	6101      	str	r1, [r0, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 800635c:	f1bc 0f06 	cmp.w	ip, #6	; 0x6
 8006360:	d80c      	bhi.n	800637c <ADC_RegularChannelConfig+0x5c>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
 8006362:	eb0c 028c 	add.w	r2, ip, ip, lsl #2
 8006366:	3a05      	subs	r2, #5
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8006368:	231f      	movs	r3, #31
 800636a:	4093      	lsls	r3, r2
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800636c:	fa14 f202 	lsls.w	r2, r4, r2
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8006370:	6b41      	ldr	r1, [r0, #52]
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8006372:	ea21 0103 	bic.w	r1, r1, r3
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8006376:	4311      	orrs	r1, r2
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8006378:	6341      	str	r1, [r0, #52]
 800637a:	e01b      	b.n	80063b4 <ADC_RegularChannelConfig+0x94>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 800637c:	f1bc 0f0c 	cmp.w	ip, #12	; 0xc
 8006380:	ea4f 028c 	mov.w	r2, ip, lsl #2
 8006384:	d80b      	bhi.n	800639e <ADC_RegularChannelConfig+0x7e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
 8006386:	4462      	add	r2, ip
 8006388:	3a23      	subs	r2, #35
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800638a:	231f      	movs	r3, #31
 800638c:	4093      	lsls	r3, r2
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800638e:	fa14 f202 	lsls.w	r2, r4, r2
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8006392:	6b01      	ldr	r1, [r0, #48]
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8006394:	ea21 0103 	bic.w	r1, r1, r3
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8006398:	4311      	orrs	r1, r2
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 800639a:	6301      	str	r1, [r0, #48]
 800639c:	e00a      	b.n	80063b4 <ADC_RegularChannelConfig+0x94>
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
 800639e:	4462      	add	r2, ip
 80063a0:	3a41      	subs	r2, #65
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80063a2:	231f      	movs	r3, #31
 80063a4:	4093      	lsls	r3, r2
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80063a6:	fa14 f202 	lsls.w	r2, r4, r2
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 80063aa:	6ac1      	ldr	r1, [r0, #44]
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80063ac:	ea21 0103 	bic.w	r1, r1, r3
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80063b0:	4311      	orrs	r1, r2
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 80063b2:	62c1      	str	r1, [r0, #44]
  }
}
 80063b4:	bd30      	pop	{r4, r5, pc}
 80063b6:	46c0      	nop			(mov r8, r8)

080063b8 <ADC_ExternalTrigConvCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80063b8:	b119      	cbz	r1, 80063c2 <ADC_ExternalTrigConvCmd+0xa>
  {
    /* Enable the selected ADC conversion on external event */
    ADCx->CR2 |= CR2_EXTTRIG_Set;
 80063ba:	6883      	ldr	r3, [r0, #8]
 80063bc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80063c0:	e002      	b.n	80063c8 <ADC_ExternalTrigConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event */
    ADCx->CR2 &= CR2_EXTTRIG_Reset;
 80063c2:	6883      	ldr	r3, [r0, #8]
 80063c4:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80063c8:	6083      	str	r3, [r0, #8]
  }
}
 80063ca:	4770      	bx	lr

080063cc <ADC_GetConversionValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Return the selected ADC conversion value */
  return (u16) ADCx->DR;
 80063cc:	6cc0      	ldr	r0, [r0, #76]
 80063ce:	b280      	uxth	r0, r0
}
 80063d0:	4770      	bx	lr
 80063d2:	46c0      	nop			(mov r8, r8)

080063d4 <ADC_GetDualModeConversionValue>:
* Return         : The Data conversion value.
*******************************************************************************/
u32 ADC_GetDualModeConversionValue(void)
{
  /* Return the dual mode conversion value */
  return (*(vu32 *) DR_ADDRESS);
 80063d4:	4b01      	ldr	r3, [pc, #4]	(80063dc <ADC_GetDualModeConversionValue+0x8>)
 80063d6:	6818      	ldr	r0, [r3, #0]
}
 80063d8:	4770      	bx	lr
 80063da:	46c0      	nop			(mov r8, r8)
 80063dc:	4001244c 	.word	0x4001244c

080063e0 <ADC_AutoInjectedConvCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80063e0:	b119      	cbz	r1, 80063ea <ADC_AutoInjectedConvCmd+0xa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CR1 |= CR1_JAUTO_Set;
 80063e2:	6843      	ldr	r3, [r0, #4]
 80063e4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80063e8:	e002      	b.n	80063f0 <ADC_AutoInjectedConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= CR1_JAUTO_Reset;
 80063ea:	6843      	ldr	r3, [r0, #4]
 80063ec:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80063f0:	6043      	str	r3, [r0, #4]
  }
}
 80063f2:	4770      	bx	lr

080063f4 <ADC_InjectedDiscModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80063f4:	b119      	cbz	r1, 80063fe <ADC_InjectedDiscModeCmd+0xa>
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CR1 |= CR1_JDISCEN_Set;
 80063f6:	6843      	ldr	r3, [r0, #4]
 80063f8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80063fc:	e002      	b.n	8006404 <ADC_InjectedDiscModeCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= CR1_JDISCEN_Reset;
 80063fe:	6843      	ldr	r3, [r0, #4]
 8006400:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8006404:	6043      	str	r3, [r0, #4]
  }
}
 8006406:	4770      	bx	lr

08006408 <ADC_ExternalTrigInjectedConvConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));

  /* Get the old register value */
  tmpreg = ADCx->CR2;
 8006408:	6883      	ldr	r3, [r0, #8]
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_Reset;
 800640a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
 800640e:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 8006410:	6081      	str	r1, [r0, #8]
}
 8006412:	4770      	bx	lr

08006414 <ADC_ExternalTrigInjectedConvCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8006414:	b119      	cbz	r1, 800641e <ADC_ExternalTrigInjectedConvCmd+0xa>
  {
    /* Enable the selected ADC external event selection for injected group */
    ADCx->CR2 |= CR2_JEXTTRIG_Set;
 8006416:	6883      	ldr	r3, [r0, #8]
 8006418:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800641c:	e002      	b.n	8006424 <ADC_ExternalTrigInjectedConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC external event selection for injected group */
    ADCx->CR2 &= CR2_JEXTTRIG_Reset;
 800641e:	6883      	ldr	r3, [r0, #8]
 8006420:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8006424:	6083      	str	r3, [r0, #8]
  }
}
 8006426:	4770      	bx	lr

08006428 <ADC_SoftwareStartInjectedConvCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8006428:	b119      	cbz	r1, 8006432 <ADC_SoftwareStartInjectedConvCmd+0xa>
  {
    /* Enable the selected ADC conversion for injected group on external event and start the selected
       ADC injected conversion */
    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
 800642a:	6883      	ldr	r3, [r0, #8]
 800642c:	f443 1302 	orr.w	r3, r3, #2129920	; 0x208000
 8006430:	e002      	b.n	8006438 <ADC_SoftwareStartInjectedConvCmd+0x10>
  }
  else
  {
    /* Disable the selected ADC conversion on external event for injected group and stop the selected
       ADC injected conversion */
    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
 8006432:	6883      	ldr	r3, [r0, #8]
 8006434:	f423 1302 	bic.w	r3, r3, #2129920	; 0x208000
 8006438:	6083      	str	r3, [r0, #8]
  }
}
 800643a:	4770      	bx	lr

0800643c <ADC_GetSoftwareStartInjectedConvCmdStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
 800643c:	6880      	ldr	r0, [r0, #8]
 800643e:	0d40      	lsrs	r0, r0, #21
 8006440:	f000 0001 	and.w	r0, r0, #1	; 0x1
    bitstatus = RESET;
  }

  /* Return the JSWSTART bit status */
  return  bitstatus;
}
 8006444:	4770      	bx	lr
 8006446:	46c0      	nop			(mov r8, r8)

08006448 <ADC_InjectedChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8006448:	2909      	cmp	r1, #9
*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
{
 800644a:	b530      	push	{r4, r5, lr}
 800644c:	468c      	mov	ip, r1
 800644e:	4615      	mov	r5, r2
 8006450:	461c      	mov	r4, r3
 8006452:	ea4f 0241 	mov.w	r2, r1, lsl #1
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8006456:	d90b      	bls.n	8006470 <ADC_InjectedChannelConfig+0x28>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
 8006458:	4462      	add	r2, ip
 800645a:	3a1e      	subs	r2, #30
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 800645c:	2307      	movs	r3, #7
 800645e:	4093      	lsls	r3, r2
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 8006460:	fa14 f202 	lsls.w	r2, r4, r2

  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8006464:	68c1      	ldr	r1, [r0, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 8006466:	ea21 0103 	bic.w	r1, r1, r3
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 800646a:	4311      	orrs	r1, r2
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 800646c:	60c1      	str	r1, [r0, #12]
 800646e:	e009      	b.n	8006484 <ADC_InjectedChannelConfig+0x3c>
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 8006470:	4462      	add	r2, ip
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 8006472:	2307      	movs	r3, #7
 8006474:	4093      	lsls	r3, r2
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 8006476:	fa14 f202 	lsls.w	r2, r4, r2
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 800647a:	6901      	ldr	r1, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    /* Clear the old discontinuous mode channel count */
    tmpreg1 &= ~tmpreg2;
 800647c:	ea21 0103 	bic.w	r1, r1, r3
    /* Calculate the mask to set */
    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
    /* Set the discontinuous mode channel count */
    tmpreg1 |= tmpreg2;
 8006480:	4311      	orrs	r1, r2
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8006482:	6101      	str	r1, [r0, #16]
  }

  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 8006484:	6b83      	ldr	r3, [r0, #56]
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 8006486:	211f      	movs	r1, #31
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
 8006488:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
 800648c:	ea6f 5212 	mvn.w	r2, r2, lsr #20
 8006490:	442a      	add	r2, r5
 8006492:	3203      	adds	r2, #3
 8006494:	b2d2      	uxtb	r2, r2
 8006496:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 800649a:	4091      	lsls	r1, r2
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
 800649c:	fa0c f202 	lsl.w	r2, ip, r2
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 80064a0:	ea23 0301 	bic.w	r3, r3, r1
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
 80064a4:	4313      	orrs	r3, r2
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 80064a6:	6383      	str	r3, [r0, #56]
}
 80064a8:	bd30      	pop	{r4, r5, pc}
 80064aa:	46c0      	nop			(mov r8, r8)

080064ac <ADC_InjectedSequencerLengthConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 80064ac:	6b83      	ldr	r3, [r0, #56]
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
 80064ae:	3901      	subs	r1, #1
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
  /* Clear the old injected sequnence lenght JL bits */
  tmpreg1 &= JSQR_JL_Reset;
 80064b0:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
  /* Set the injected sequnence lenght JL bits */
  tmpreg2 = Length - 1; 
  tmpreg1 |= tmpreg2 << 20;
 80064b4:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 80064b8:	6383      	str	r3, [r0, #56]
}
 80064ba:	4770      	bx	lr

080064bc <ADC_SetInjectedOffset>:
*                    This parameter must be a 12bit value.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
{
 80064bc:	b082      	sub	sp, #8
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));  

  /* Set the selected injected channel data offset */
  *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
 80064be:	500a      	str	r2, [r1, r0]
}
 80064c0:	b002      	add	sp, #8
 80064c2:	4770      	bx	lr

080064c4 <ADC_GetInjectedConversionValue>:
*                       - ADC_InjectedChannel_4: Injected Channel4 selected
* Output         : None
* Return         : The Data conversion value.
*******************************************************************************/
u16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
{
 80064c4:	b082      	sub	sp, #8
 80064c6:	9001      	str	r0, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  /* Returns the selected injected channel conversion data value */
  return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
 80064c8:	3028      	adds	r0, #40
 80064ca:	5840      	ldr	r0, [r0, r1]
 80064cc:	b280      	uxth	r0, r0
}
 80064ce:	b002      	add	sp, #8
 80064d0:	4770      	bx	lr
 80064d2:	46c0      	nop			(mov r8, r8)

080064d4 <ADC_AnalogWatchdogCmd>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));

  /* Get the old register value */
  tmpreg = ADCx->CR1;
 80064d4:	6843      	ldr	r3, [r0, #4]
  /* Clear AWDEN, AWDENJ and AWDSGL bits */
  tmpreg &= CR1_AWDMode_Reset;
 80064d6:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 80064da:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 80064de:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 80064e0:	6041      	str	r1, [r0, #4]
}
 80064e2:	4770      	bx	lr

080064e4 <ADC_AnalogWatchdogThresholdsConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));

  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
 80064e4:	6241      	str	r1, [r0, #36]
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
 80064e6:	6282      	str	r2, [r0, #40]
}
 80064e8:	4770      	bx	lr
 80064ea:	46c0      	nop			(mov r8, r8)

080064ec <ADC_AnalogWatchdogSingleChannelConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));

  /* Get the old register value */
  tmpreg = ADCx->CR1;
 80064ec:	6843      	ldr	r3, [r0, #4]
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_Reset;
 80064ee:	f023 031f 	bic.w	r3, r3, #31	; 0x1f
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
 80064f2:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 80064f4:	6041      	str	r1, [r0, #4]
}
 80064f6:	4770      	bx	lr

080064f8 <ADC_TempSensorVrefintCmd>:
void ADC_TempSensorVrefintCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80064f8:	b120      	cbz	r0, 8006504 <ADC_TempSensorVrefintCmd+0xc>
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC1->CR2 |= CR2_TSVREFE_Set;
 80064fa:	4a05      	ldr	r2, [pc, #20]	(8006510 <ADC_TempSensorVrefintCmd+0x18>)
 80064fc:	6893      	ldr	r3, [r2, #8]
 80064fe:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8006502:	e003      	b.n	800650c <ADC_TempSensorVrefintCmd+0x14>
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC1->CR2 &= CR2_TSVREFE_Reset;
 8006504:	4a02      	ldr	r2, [pc, #8]	(8006510 <ADC_TempSensorVrefintCmd+0x18>)
 8006506:	6893      	ldr	r3, [r2, #8]
 8006508:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800650c:	6093      	str	r3, [r2, #8]
  }
}
 800650e:	4770      	bx	lr
 8006510:	40012400 	.word	0x40012400

08006514 <ADC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
 8006514:	6803      	ldr	r3, [r0, #0]
 8006516:	4219      	tst	r1, r3
 8006518:	bf0c      	ite	eq
 800651a:	2000      	moveq	r0, #0
 800651c:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 800651e:	4770      	bx	lr

08006520 <ADC_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->SR = ~(u32)ADC_FLAG;
 8006520:	ea6f 0101 	mvn.w	r1, r1
 8006524:	6001      	str	r1, [r0, #0]
}
 8006526:	4770      	bx	lr

08006528 <ADC_GetITStatus>:

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
 8006528:	6842      	ldr	r2, [r0, #4]

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
 800652a:	6803      	ldr	r3, [r0, #0]
 800652c:	ea13 2311 	ands.w	r3, r3, r1, lsr #8
 8006530:	d101      	bne.n	8006536 <ADC_GetITStatus+0xe>
 8006532:	2000      	movs	r0, #0
 8006534:	e004      	b.n	8006540 <ADC_GetITStatus+0x18>
 8006536:	b2cb      	uxtb	r3, r1
 8006538:	4213      	tst	r3, r2
 800653a:	bf0c      	ite	eq
 800653c:	2000      	moveq	r0, #0
 800653e:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the ADC_IT status */
  return  bitstatus;
}
 8006540:	4770      	bx	lr
 8006542:	46c0      	nop			(mov r8, r8)

08006544 <ADC_ClearITPendingBit>:

  /* Get the ADC IT index */
  itmask = (u8)(ADC_IT >> 8);

  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(u32)itmask;
 8006544:	ea6f 2111 	mvn.w	r1, r1, lsr #8
 8006548:	6001      	str	r1, [r0, #0]
}
 800654a:	4770      	bx	lr

0800654c <ADC_DeInit>:
* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_DeInit(ADC_TypeDef* ADCx)
{
 800654c:	b500      	push	{lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  switch (*(u32*)&ADCx)
 800654e:	4b14      	ldr	r3, [pc, #80]	(80065a0 <ADC_DeInit+0x54>)
* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_DeInit(ADC_TypeDef* ADCx)
{
 8006550:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  switch (*(u32*)&ADCx)
 8006552:	4298      	cmp	r0, r3
* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void ADC_DeInit(ADC_TypeDef* ADCx)
{
 8006554:	9001      	str	r0, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  switch (*(u32*)&ADCx)
 8006556:	d00f      	beq.n	8006578 <ADC_DeInit+0x2c>
 8006558:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
 800655c:	4298      	cmp	r0, r3
 800655e:	d013      	beq.n	8006588 <ADC_DeInit+0x3c>
 8006560:	f5a3 53c0 	sub.w	r3, r3, #6144	; 0x1800
 8006564:	4298      	cmp	r0, r3
 8006566:	d119      	bne.n	800659c <ADC_DeInit+0x50>
  {
    case ADC1_BASE:
      /* Enable ADC1 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
 8006568:	f44f 7000 	mov.w	r0, #512	; 0x200
 800656c:	2101      	movs	r1, #1
 800656e:	f000 ff8d 	bl	800748c <RCC_APB2PeriphResetCmd>
      /* Release ADC1 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
 8006572:	f44f 7000 	mov.w	r0, #512	; 0x200
 8006576:	e00e      	b.n	8006596 <ADC_DeInit+0x4a>
      break;
    
    case ADC2_BASE:
      /* Enable ADC2 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
 8006578:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800657c:	2101      	movs	r1, #1
 800657e:	f000 ff85 	bl	800748c <RCC_APB2PeriphResetCmd>
      /* Release ADC2 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
 8006582:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8006586:	e006      	b.n	8006596 <ADC_DeInit+0x4a>
      break;
      
    case ADC3_BASE:
      /* Enable ADC3 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
 8006588:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800658c:	2101      	movs	r1, #1
 800658e:	f000 ff7d 	bl	800748c <RCC_APB2PeriphResetCmd>
      /* Release ADC3 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
 8006592:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8006596:	2100      	movs	r1, #0
 8006598:	f000 ff78 	bl	800748c <RCC_APB2PeriphResetCmd>
      break; 

    default:
      break;
  }
}
 800659c:	b003      	add	sp, #12
 800659e:	bd00      	pop	{pc}
 80065a0:	40012800 	.word	0x40012800

080065a4 <FLASH_SetLatency>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Sets the Latency value */
  FLASH->ACR &= ACR_LATENCY_Mask;
 80065a4:	4a04      	ldr	r2, [pc, #16]	(80065b8 <FLASH_SetLatency+0x14>)
 80065a6:	6813      	ldr	r3, [r2, #0]
 80065a8:	f003 0338 	and.w	r3, r3, #56	; 0x38
 80065ac:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_Latency;
 80065ae:	6813      	ldr	r3, [r2, #0]
 80065b0:	4318      	orrs	r0, r3
 80065b2:	6010      	str	r0, [r2, #0]
}
 80065b4:	4770      	bx	lr
 80065b6:	46c0      	nop			(mov r8, r8)
 80065b8:	40022000 	.word	0x40022000

080065bc <FLASH_HalfCycleAccessCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
  
  /* Enable or disable the Half cycle access */
  FLASH->ACR &= ACR_HLFCYA_Mask;
 80065bc:	4a04      	ldr	r2, [pc, #16]	(80065d0 <FLASH_HalfCycleAccessCmd+0x14>)
 80065be:	6813      	ldr	r3, [r2, #0]
 80065c0:	f023 0308 	bic.w	r3, r3, #8	; 0x8
 80065c4:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_HalfCycleAccess;
 80065c6:	6813      	ldr	r3, [r2, #0]
 80065c8:	4318      	orrs	r0, r3
 80065ca:	6010      	str	r0, [r2, #0]
}
 80065cc:	4770      	bx	lr
 80065ce:	46c0      	nop			(mov r8, r8)
 80065d0:	40022000 	.word	0x40022000

080065d4 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
  
  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 80065d4:	4a04      	ldr	r2, [pc, #16]	(80065e8 <FLASH_PrefetchBufferCmd+0x14>)
 80065d6:	6813      	ldr	r3, [r2, #0]
 80065d8:	f023 0310 	bic.w	r3, r3, #16	; 0x10
 80065dc:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 80065de:	6813      	ldr	r3, [r2, #0]
 80065e0:	4318      	orrs	r0, r3
 80065e2:	6010      	str	r0, [r2, #0]
}
 80065e4:	4770      	bx	lr
 80065e6:	46c0      	nop			(mov r8, r8)
 80065e8:	40022000 	.word	0x40022000

080065ec <FLASH_Unlock>:
* Return         : None
*******************************************************************************/
void FLASH_Unlock(void)
{
  /* Authorize the FPEC Access */
  FLASH->KEYR = FLASH_KEY1;
 80065ec:	4b03      	ldr	r3, [pc, #12]	(80065fc <FLASH_Unlock+0x10>)
 80065ee:	4a04      	ldr	r2, [pc, #16]	(8006600 <FLASH_Unlock+0x14>)
 80065f0:	605a      	str	r2, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 80065f2:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 80065f6:	605a      	str	r2, [r3, #4]
}
 80065f8:	4770      	bx	lr
 80065fa:	46c0      	nop			(mov r8, r8)
 80065fc:	40022000 	.word	0x40022000
 8006600:	45670123 	.word	0x45670123

08006604 <FLASH_Lock>:
* Return         : None
*******************************************************************************/
void FLASH_Lock(void)
{
  /* Set the Lock Bit to lock the FPEC and the FCR */
  FLASH->CR |= CR_LOCK_Set;
 8006604:	4a02      	ldr	r2, [pc, #8]	(8006610 <FLASH_Lock+0xc>)
 8006606:	6913      	ldr	r3, [r2, #16]
 8006608:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800660c:	6113      	str	r3, [r2, #16]
}
 800660e:	4770      	bx	lr
 8006610:	40022000 	.word	0x40022000

08006614 <FLASH_GetUserOptionByte>:
*                  and RST_STDBY(Bit2).
*******************************************************************************/
u32 FLASH_GetUserOptionByte(void)
{
  /* Return the User Option Byte */
  return (u32)(FLASH->OBR >> 2);
 8006614:	4b01      	ldr	r3, [pc, #4]	(800661c <FLASH_GetUserOptionByte+0x8>)
 8006616:	69d8      	ldr	r0, [r3, #28]
 8006618:	0880      	lsrs	r0, r0, #2
}
 800661a:	4770      	bx	lr
 800661c:	40022000 	.word	0x40022000

08006620 <FLASH_GetWriteProtectionOptionByte>:
* Return         : The FLASH Write Protection  Option Bytes Register value
*******************************************************************************/
u32 FLASH_GetWriteProtectionOptionByte(void)
{
  /* Return the Falsh write protection Register value */
  return (u32)(FLASH->WRPR);
 8006620:	4b01      	ldr	r3, [pc, #4]	(8006628 <FLASH_GetWriteProtectionOptionByte+0x8>)
 8006622:	6a18      	ldr	r0, [r3, #32]
}
 8006624:	4770      	bx	lr
 8006626:	46c0      	nop			(mov r8, r8)
 8006628:	40022000 	.word	0x40022000

0800662c <FLASH_GetReadOutProtectionStatus>:
*******************************************************************************/
FlagStatus FLASH_GetReadOutProtectionStatus(void)
{
  FlagStatus readoutstatus = RESET;

  if ((FLASH->OBR & RDPRT_Mask) != (u32)RESET)
 800662c:	4b02      	ldr	r3, [pc, #8]	(8006638 <FLASH_GetReadOutProtectionStatus+0xc>)
 800662e:	69d8      	ldr	r0, [r3, #28]
 8006630:	0840      	lsrs	r0, r0, #1
 8006632:	f000 0001 	and.w	r0, r0, #1	; 0x1
  else
  {
    readoutstatus = RESET;
  }
  return readoutstatus;
}
 8006636:	4770      	bx	lr
 8006638:	40022000 	.word	0x40022000

0800663c <FLASH_GetPrefetchBufferStatus>:
*******************************************************************************/
FlagStatus FLASH_GetPrefetchBufferStatus(void)
{
  FlagStatus bitstatus = RESET;
  
  if ((FLASH->ACR & ACR_PRFTBS_Mask) != (u32)RESET)
 800663c:	4b02      	ldr	r3, [pc, #8]	(8006648 <FLASH_GetPrefetchBufferStatus+0xc>)
 800663e:	6818      	ldr	r0, [r3, #0]
 8006640:	0940      	lsrs	r0, r0, #5
 8006642:	f000 0001 	and.w	r0, r0, #1	; 0x1
  {
    bitstatus = RESET;
  }
  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
  return bitstatus; 
}
 8006646:	4770      	bx	lr
 8006648:	40022000 	.word	0x40022000

0800664c <FLASH_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 800664c:	b121      	cbz	r1, 8006658 <FLASH_ITConfig+0xc>
  {
    /* Enable the interrupt sources */
    FLASH->CR |= FLASH_IT;
 800664e:	4a05      	ldr	r2, [pc, #20]	(8006664 <FLASH_ITConfig+0x18>)
 8006650:	6913      	ldr	r3, [r2, #16]
 8006652:	ea40 0303 	orr.w	r3, r0, r3
 8006656:	e003      	b.n	8006660 <FLASH_ITConfig+0x14>
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(u32)FLASH_IT;
 8006658:	4a02      	ldr	r2, [pc, #8]	(8006664 <FLASH_ITConfig+0x18>)
 800665a:	6913      	ldr	r3, [r2, #16]
 800665c:	ea23 0300 	bic.w	r3, r3, r0
 8006660:	6113      	str	r3, [r2, #16]
  }
}
 8006662:	4770      	bx	lr
 8006664:	40022000 	.word	0x40022000

08006668 <FLASH_GetFlagStatus>:
  FlagStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;

  if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
 8006668:	2801      	cmp	r0, #1
 800666a:	d104      	bne.n	8006676 <FLASH_GetFlagStatus+0xe>
  {
    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
 800666c:	4b05      	ldr	r3, [pc, #20]	(8006684 <FLASH_GetFlagStatus+0x1c>)
 800666e:	69db      	ldr	r3, [r3, #28]
 8006670:	f003 0001 	and.w	r0, r3, #1	; 0x1
 8006674:	e005      	b.n	8006682 <FLASH_GetFlagStatus+0x1a>
      bitstatus = RESET;
    }
  }
  else
  {
   if((FLASH->SR & FLASH_FLAG) != (u32)RESET)
 8006676:	4b03      	ldr	r3, [pc, #12]	(8006684 <FLASH_GetFlagStatus+0x1c>)
 8006678:	68db      	ldr	r3, [r3, #12]
 800667a:	4218      	tst	r0, r3
 800667c:	bf0c      	ite	eq
 800667e:	2000      	moveq	r0, #0
 8006680:	2001      	movne	r0, #1
      bitstatus = RESET;
    }
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus;
}
 8006682:	4770      	bx	lr
 8006684:	40022000 	.word	0x40022000

08006688 <FLASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8006688:	4b01      	ldr	r3, [pc, #4]	(8006690 <FLASH_ClearFlag+0x8>)
 800668a:	60d8      	str	r0, [r3, #12]
}
 800668c:	4770      	bx	lr
 800668e:	46c0      	nop			(mov r8, r8)
 8006690:	40022000 	.word	0x40022000

08006694 <FLASH_GetStatus>:
*******************************************************************************/
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8006694:	4a09      	ldr	r2, [pc, #36]	(80066bc <FLASH_GetStatus+0x28>)
 8006696:	68d3      	ldr	r3, [r2, #12]
 8006698:	f013 0f01 	tst.w	r3, #1	; 0x1
 800669c:	d001      	beq.n	80066a2 <FLASH_GetStatus+0xe>
 800669e:	2001      	movs	r0, #1
 80066a0:	e00b      	b.n	80066ba <FLASH_GetStatus+0x26>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if(FLASH->SR & FLASH_FLAG_PGERR)
 80066a2:	68d3      	ldr	r3, [r2, #12]
 80066a4:	f013 0f04 	tst.w	r3, #4	; 0x4
 80066a8:	d001      	beq.n	80066ae <FLASH_GetStatus+0x1a>
 80066aa:	2002      	movs	r0, #2
 80066ac:	e005      	b.n	80066ba <FLASH_GetStatus+0x26>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if(FLASH->SR & FLASH_FLAG_WRPRTERR)
 80066ae:	68d3      	ldr	r3, [r2, #12]
 80066b0:	f013 0f10 	tst.w	r3, #16	; 0x10
 80066b4:	bf14      	ite	ne
 80066b6:	2003      	movne	r0, #3
 80066b8:	2004      	moveq	r0, #4
      }
    }
  }
  /* Return the Flash Status */
  return flashstatus;
}
 80066ba:	4770      	bx	lr
 80066bc:	40022000 	.word	0x40022000

080066c0 <FLASH_WaitForLastOperation>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
{ 
 80066c0:	b510      	push	{r4, lr}
*******************************************************************************/
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 80066c2:	4a23      	ldr	r2, [pc, #140]	(8006750 <FLASH_WaitForLastOperation+0x90>)
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
{ 
 80066c4:	b082      	sub	sp, #8
*******************************************************************************/
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 80066c6:	68d3      	ldr	r3, [r2, #12]
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
{ 
 80066c8:	4601      	mov	r1, r0
*******************************************************************************/
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 80066ca:	f013 0f01 	tst.w	r3, #1	; 0x1
 80066ce:	d001      	beq.n	80066d4 <FLASH_WaitForLastOperation+0x14>
 80066d0:	2001      	movs	r0, #1
 80066d2:	e02a      	b.n	800672a <FLASH_WaitForLastOperation+0x6a>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if(FLASH->SR & FLASH_FLAG_PGERR)
 80066d4:	68d3      	ldr	r3, [r2, #12]
 80066d6:	f013 0f04 	tst.w	r3, #4	; 0x4
 80066da:	d001      	beq.n	80066e0 <FLASH_WaitForLastOperation+0x20>
 80066dc:	2002      	movs	r0, #2
 80066de:	e024      	b.n	800672a <FLASH_WaitForLastOperation+0x6a>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if(FLASH->SR & FLASH_FLAG_WRPRTERR)
 80066e0:	68d3      	ldr	r3, [r2, #12]
 80066e2:	f013 0f10 	tst.w	r3, #16	; 0x10
 80066e6:	bf14      	ite	ne
 80066e8:	2003      	movne	r0, #3
 80066ea:	2004      	moveq	r0, #4
 80066ec:	e01d      	b.n	800672a <FLASH_WaitForLastOperation+0x6a>
* Output         : None
* Return         : None
*******************************************************************************/
static void delay(void)
{
  vu32 i = 0;
 80066ee:	9401      	str	r4, [sp, #4]

  for(i = 0xFF; i != 0; i--)
 80066f0:	f8cd c004 	str.w	ip, [sp, #4]
 80066f4:	e002      	b.n	80066fc <FLASH_WaitForLastOperation+0x3c>
 80066f6:	9b01      	ldr	r3, [sp, #4]
 80066f8:	3b01      	subs	r3, #1
 80066fa:	9301      	str	r3, [sp, #4]
 80066fc:	9b01      	ldr	r3, [sp, #4]
 80066fe:	2b00      	cmp	r3, #0
 8006700:	d1f9      	bne.n	80066f6 <FLASH_WaitForLastOperation+0x36>
*******************************************************************************/
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8006702:	68d3      	ldr	r3, [r2, #12]
 8006704:	f013 0f01 	tst.w	r3, #1	; 0x1
 8006708:	d001      	beq.n	800670e <FLASH_WaitForLastOperation+0x4e>
 800670a:	2001      	movs	r0, #1
 800670c:	e00b      	b.n	8006726 <FLASH_WaitForLastOperation+0x66>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if(FLASH->SR & FLASH_FLAG_PGERR)
 800670e:	68d3      	ldr	r3, [r2, #12]
 8006710:	f013 0f04 	tst.w	r3, #4	; 0x4
 8006714:	d001      	beq.n	800671a <FLASH_WaitForLastOperation+0x5a>
 8006716:	2002      	movs	r0, #2
 8006718:	e005      	b.n	8006726 <FLASH_WaitForLastOperation+0x66>
    { 
      flashstatus = FLASH_ERROR_PG;
    }
    else 
    {
      if(FLASH->SR & FLASH_FLAG_WRPRTERR)
 800671a:	68d3      	ldr	r3, [r2, #12]
 800671c:	f013 0f10 	tst.w	r3, #16	; 0x10
 8006720:	bf14      	ite	ne
 8006722:	2003      	movne	r0, #3
 8006724:	2004      	moveq	r0, #4
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
  {
    delay();
    status = FLASH_GetStatus();
    Timeout--;
 8006726:	3901      	subs	r1, #1
 8006728:	e003      	b.n	8006732 <FLASH_WaitForLastOperation+0x72>
*******************************************************************************/
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 800672a:	4a09      	ldr	r2, [pc, #36]	(8006750 <FLASH_WaitForLastOperation+0x90>)
* Output         : None
* Return         : None
*******************************************************************************/
static void delay(void)
{
  vu32 i = 0;
 800672c:	2400      	movs	r4, #0

  for(i = 0xFF; i != 0; i--)
 800672e:	f04f 0cff 	mov.w	ip, #255	; 0xff
   
  /* Check for the Flash Status */
  status = FLASH_GetStatus();

  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8006732:	1e0b      	subs	r3, r1, #0
 8006734:	bf18      	it	ne
 8006736:	2301      	movne	r3, #1
 8006738:	2801      	cmp	r0, #1
 800673a:	bf14      	ite	ne
 800673c:	2300      	movne	r3, #0
 800673e:	f003 0301 	andeq.w	r3, r3, #1	; 0x1
 8006742:	2b00      	cmp	r3, #0
 8006744:	d1d3      	bne.n	80066ee <FLASH_WaitForLastOperation+0x2e>
    delay();
    status = FLASH_GetStatus();
    Timeout--;
  }

  if(Timeout == 0x00 )
 8006746:	2900      	cmp	r1, #0
 8006748:	bf08      	it	eq
 800674a:	2005      	moveq	r0, #5
    status = FLASH_TIMEOUT;
  }

  /* Return the operation status */
  return status;
}
 800674c:	b002      	add	sp, #8
 800674e:	bd10      	pop	{r4, pc}
 8006750:	40022000 	.word	0x40022000

08006754 <FLASH_UserOptionByteConfig>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
{
 8006754:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
 8006756:	4b13      	ldr	r3, [pc, #76]	(80067a4 <FLASH_UserOptionByteConfig+0x50>)
 8006758:	4c13      	ldr	r4, [pc, #76]	(80067a8 <FLASH_UserOptionByteConfig+0x54>)
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
{
 800675a:	b081      	sub	sp, #4
  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
 800675c:	60a3      	str	r3, [r4, #8]
  FLASH->OPTKEYR = FLASH_KEY2;
 800675e:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
{
 8006762:	4605      	mov	r5, r0
  assert_param(IS_OB_STOP_SOURCE(OB_STOP));
  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));

  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
  FLASH->OPTKEYR = FLASH_KEY2;
 8006764:	60a3      	str	r3, [r4, #8]
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006766:	200f      	movs	r0, #15
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
{
 8006768:	460e      	mov	r6, r1
 800676a:	4617      	mov	r7, r2
  /* Authorize the small information block programming */
  FLASH->OPTKEYR = FLASH_KEY1;
  FLASH->OPTKEYR = FLASH_KEY2;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800676c:	f7ff ffa8 	bl	80066c0 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8006770:	2804      	cmp	r0, #4
 8006772:	d115      	bne.n	80067a0 <FLASH_UserOptionByteConfig+0x4c>
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 8006774:	6923      	ldr	r3, [r4, #16]
           
    OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
 8006776:	4a0d      	ldr	r2, [pc, #52]	(80067ac <FLASH_UserOptionByteConfig+0x58>)
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {  
    /* Enable the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 8006778:	f043 0310 	orr.w	r3, r3, #16	; 0x10
 800677c:	6123      	str	r3, [r4, #16]
           
    OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
 800677e:	f045 03f8 	orr.w	r3, r5, #248	; 0xf8
 8006782:	ea46 0303 	orr.w	r3, r6, r3
 8006786:	ea47 0303 	orr.w	r3, r7, r3
 800678a:	8053      	strh	r3, [r2, #2]
  
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800678c:	200f      	movs	r0, #15
 800678e:	f7ff ff97 	bl	80066c0 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 8006792:	2801      	cmp	r0, #1
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 8006794:	bf1f      	itttt	ne
 8006796:	6922      	ldrne	r2, [r4, #16]
 8006798:	f641 73ef 	movwne	r3, #8175	; 0x1fef
 800679c:	4013      	andne	r3, r2
 800679e:	6123      	strne	r3, [r4, #16]
    }
  }    
  /* Return the Option Byte program Status */
  return status;
}
 80067a0:	b001      	add	sp, #4
 80067a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80067a4:	45670123 	.word	0x45670123
 80067a8:	40022000 	.word	0x40022000
 80067ac:	1ffff800 	.word	0x1ffff800

080067b0 <FLASH_ReadOutProtection>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
{
 80067b0:	b530      	push	{r4, r5, lr}
 80067b2:	4605      	mov	r5, r0
 80067b4:	b081      	sub	sp, #4
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  status = FLASH_WaitForLastOperation(EraseTimeout);
 80067b6:	f640 70ff 	movw	r0, #4095	; 0xfff
 80067ba:	f7ff ff81 	bl	80066c0 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 80067be:	2804      	cmp	r0, #4
 80067c0:	d13c      	bne.n	800683c <FLASH_ReadOutProtection+0x8c>
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 80067c2:	4c1f      	ldr	r4, [pc, #124]	(8006840 <FLASH_ReadOutProtection+0x90>)
 80067c4:	4b1f      	ldr	r3, [pc, #124]	(8006844 <FLASH_ReadOutProtection+0x94>)

    FLASH->CR |= CR_OPTER_Set;
    FLASH->CR |= CR_STRT_Set;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 80067c6:	f500 607e 	add.w	r0, r0, #4064	; 0xfe0
  status = FLASH_WaitForLastOperation(EraseTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 80067ca:	60a3      	str	r3, [r4, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 80067cc:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 80067d0:	60a3      	str	r3, [r4, #8]

    FLASH->CR |= CR_OPTER_Set;
 80067d2:	6923      	ldr	r3, [r4, #16]
    FLASH->CR |= CR_STRT_Set;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 80067d4:	301b      	adds	r0, #27
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;

    FLASH->CR |= CR_OPTER_Set;
 80067d6:	f043 0320 	orr.w	r3, r3, #32	; 0x20
 80067da:	6123      	str	r3, [r4, #16]
    FLASH->CR |= CR_STRT_Set;
 80067dc:	6923      	ldr	r3, [r4, #16]
 80067de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80067e2:	6123      	str	r3, [r4, #16]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 80067e4:	f7ff ff6c 	bl	80066c0 <FLASH_WaitForLastOperation>

    if(status == FLASH_COMPLETE)
 80067e8:	2804      	cmp	r0, #4
 80067ea:	d120      	bne.n	800682e <FLASH_ReadOutProtection+0x7e>
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
 80067ec:	6923      	ldr	r3, [r4, #16]
 80067ee:	f641 72df 	movw	r2, #8159	; 0x1fdf
 80067f2:	ea03 0202 	and.w	r2, r3, r2
 80067f6:	6122      	str	r2, [r4, #16]

      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set; 
 80067f8:	6923      	ldr	r3, [r4, #16]
 80067fa:	f043 0310 	orr.w	r3, r3, #16	; 0x10
 80067fe:	6123      	str	r3, [r4, #16]

      if(NewState != DISABLE)
 8006800:	b11d      	cbz	r5, 800680a <FLASH_ReadOutProtection+0x5a>
      {
        OB->RDP = 0x00;
 8006802:	4b11      	ldr	r3, [pc, #68]	(8006848 <FLASH_ReadOutProtection+0x98>)
 8006804:	f04f 0200 	mov.w	r2, #0	; 0x0
 8006808:	e002      	b.n	8006810 <FLASH_ReadOutProtection+0x60>
      }
      else
      {
        OB->RDP = RDP_Key;  
 800680a:	4b0f      	ldr	r3, [pc, #60]	(8006848 <FLASH_ReadOutProtection+0x98>)
 800680c:	f04f 02a5 	mov.w	r2, #165	; 0xa5
 8006810:	801a      	strh	r2, [r3, #0]
      }

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(EraseTimeout); 
 8006812:	f640 70ff 	movw	r0, #4095	; 0xfff
 8006816:	f7ff ff53 	bl	80066c0 <FLASH_WaitForLastOperation>
    
      if(status != FLASH_BUSY)
 800681a:	2801      	cmp	r0, #1
 800681c:	d00e      	beq.n	800683c <FLASH_ReadOutProtection+0x8c>
      {
        /* if the program operation is completed, disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 800681e:	4908      	ldr	r1, [pc, #32]	(8006840 <FLASH_ReadOutProtection+0x90>)
 8006820:	f641 73ef 	movw	r3, #8175	; 0x1fef
 8006824:	690a      	ldr	r2, [r1, #16]
 8006826:	ea02 0303 	and.w	r3, r2, r3
 800682a:	610b      	str	r3, [r1, #16]
 800682c:	e006      	b.n	800683c <FLASH_ReadOutProtection+0x8c>
      }
    }
    else 
    {
      if(status != FLASH_BUSY)
 800682e:	2801      	cmp	r0, #1
      {
        /* Disable the OPTER Bit */
        FLASH->CR &= CR_OPTER_Reset;
 8006830:	bf1f      	itttt	ne
 8006832:	6922      	ldrne	r2, [r4, #16]
 8006834:	f641 73df 	movwne	r3, #8159	; 0x1fdf
 8006838:	4013      	andne	r3, r2
 800683a:	6123      	strne	r3, [r4, #16]
      }
    }
  }
  /* Return the protection operation Status */
  return status;      
}
 800683c:	b001      	add	sp, #4
 800683e:	bd30      	pop	{r4, r5, pc}
 8006840:	40022000 	.word	0x40022000
 8006844:	45670123 	.word	0x45670123
 8006848:	1ffff800 	.word	0x1ffff800

0800684c <FLASH_EnableWriteProtection>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
{
 800684c:	b510      	push	{r4, lr}
 800684e:	4604      	mov	r4, r0
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006850:	200f      	movs	r0, #15
 8006852:	f7ff ff35 	bl	80066c0 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8006856:	2804      	cmp	r0, #4
 8006858:	d150      	bne.n	80068fc <FLASH_EnableWriteProtection+0xb0>
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800685a:	4a29      	ldr	r2, [pc, #164]	(8006900 <FLASH_EnableWriteProtection+0xb4>)
 800685c:	4b29      	ldr	r3, [pc, #164]	(8006904 <FLASH_EnableWriteProtection+0xb8>)
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
 800685e:	ea6f 0404 	mvn.w	r4, r4
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8006862:	6093      	str	r3, [r2, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 8006864:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 8006868:	6093      	str	r3, [r2, #8]
    FLASH->CR |= CR_OPTPG_Set;
 800686a:	6913      	ldr	r3, [r2, #16]
  
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
 800686c:	b2e1      	uxtb	r1, r4
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
 800686e:	f043 0310 	orr.w	r3, r3, #16	; 0x10

    if(WRP0_Data != 0xFF)
 8006872:	29ff      	cmp	r1, #255
  if(status == FLASH_COMPLETE)
  {
    /* Authorizes the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;
 8006874:	6113      	str	r3, [r2, #16]

    if(WRP0_Data != 0xFF)
 8006876:	d004      	beq.n	8006882 <FLASH_EnableWriteProtection+0x36>
    {
      OB->WRP0 = WRP0_Data;
 8006878:	4b23      	ldr	r3, [pc, #140]	(8006908 <FLASH_EnableWriteProtection+0xbc>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800687a:	200f      	movs	r0, #15
    FLASH->OPTKEYR = FLASH_KEY2;
    FLASH->CR |= CR_OPTPG_Set;

    if(WRP0_Data != 0xFF)
    {
      OB->WRP0 = WRP0_Data;
 800687c:	8119      	strh	r1, [r3, #8]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800687e:	f7ff ff1f 	bl	80066c0 <FLASH_WaitForLastOperation>
  /* Check the parameters */
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
 8006882:	f404 437f 	and.w	r3, r4, #65280	; 0xff00
 8006886:	0a1a      	lsrs	r2, r3, #8
      OB->WRP0 = WRP0_Data;
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
 8006888:	f1b2 03ff 	subs.w	r3, r2, #255	; 0xff
 800688c:	bf18      	it	ne
 800688e:	2301      	movne	r3, #1
 8006890:	2804      	cmp	r0, #4
 8006892:	bf14      	ite	ne
 8006894:	2300      	movne	r3, #0
 8006896:	f003 0301 	andeq.w	r3, r3, #1	; 0x1
 800689a:	b123      	cbz	r3, 80068a6 <FLASH_EnableWriteProtection+0x5a>
    {
      OB->WRP1 = WRP1_Data;
 800689c:	4b1a      	ldr	r3, [pc, #104]	(8006908 <FLASH_EnableWriteProtection+0xbc>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 800689e:	200f      	movs	r0, #15
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    {
      OB->WRP1 = WRP1_Data;
 80068a0:	815a      	strh	r2, [r3, #10]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 80068a2:	f7ff ff0d 	bl	80066c0 <FLASH_WaitForLastOperation>
  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
 80068a6:	f404 037f 	and.w	r3, r4, #16711680	; 0xff0000
 80068aa:	0c1a      	lsrs	r2, r3, #16
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }

    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
 80068ac:	f1b2 03ff 	subs.w	r3, r2, #255	; 0xff
 80068b0:	bf18      	it	ne
 80068b2:	2301      	movne	r3, #1
 80068b4:	2804      	cmp	r0, #4
 80068b6:	bf14      	ite	ne
 80068b8:	2300      	movne	r3, #0
 80068ba:	f003 0301 	andeq.w	r3, r3, #1	; 0x1
 80068be:	b123      	cbz	r3, 80068ca <FLASH_EnableWriteProtection+0x7e>
    {
      OB->WRP2 = WRP2_Data;
 80068c0:	4b11      	ldr	r3, [pc, #68]	(8006908 <FLASH_EnableWriteProtection+0xbc>)
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 80068c2:	200f      	movs	r0, #15
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }

    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    {
      OB->WRP2 = WRP2_Data;
 80068c4:	819a      	strh	r2, [r3, #12]
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 80068c6:	f7ff fefb 	bl	80066c0 <FLASH_WaitForLastOperation>
  
  FLASH_Pages = (u32)(~FLASH_Pages);
  WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
  WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
  WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
  WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
 80068ca:	0e22      	lsrs	r2, r4, #24
      
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
 80068cc:	f1b2 03ff 	subs.w	r3, r2, #255	; 0xff
 80068d0:	bf18      	it	ne
 80068d2:	2301      	movne	r3, #1
 80068d4:	2804      	cmp	r0, #4
 80068d6:	bf14      	ite	ne
 80068d8:	2300      	movne	r3, #0
 80068da:	f003 0301 	andeq.w	r3, r3, #1	; 0x1
 80068de:	b123      	cbz	r3, 80068ea <FLASH_EnableWriteProtection+0x9e>
    {
      OB->WRP3 = WRP3_Data;
 80068e0:	4b09      	ldr	r3, [pc, #36]	(8006908 <FLASH_EnableWriteProtection+0xbc>)
     
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 80068e2:	200f      	movs	r0, #15
      status = FLASH_WaitForLastOperation(ProgramTimeout);
    }
    
    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
    {
      OB->WRP3 = WRP3_Data;
 80068e4:	81da      	strh	r2, [r3, #14]
     
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 80068e6:	f7ff feeb 	bl	80066c0 <FLASH_WaitForLastOperation>
    }
          
    if(status != FLASH_BUSY)
 80068ea:	2801      	cmp	r0, #1
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 80068ec:	bf1f      	itttt	ne
 80068ee:	4904      	ldrne	r1, [pc, #16]	(8006900 <FLASH_EnableWriteProtection+0xb4>)
 80068f0:	f641 73ef 	movwne	r3, #8175	; 0x1fef
 80068f4:	690a      	ldrne	r2, [r1, #16]
 80068f6:	4013      	andne	r3, r2
 80068f8:	bf18      	it	ne
 80068fa:	610b      	strne	r3, [r1, #16]
    }
  } 
  /* Return the write protection operation Status */
  return status;       
}
 80068fc:	bd10      	pop	{r4, pc}
 80068fe:	46c0      	nop			(mov r8, r8)
 8006900:	40022000 	.word	0x40022000
 8006904:	45670123 	.word	0x45670123
 8006908:	1ffff800 	.word	0x1ffff800

0800690c <FLASH_ProgramOptionByteData>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT. 
*******************************************************************************/
FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
{
 800690c:	b570      	push	{r4, r5, r6, lr}
 800690e:	4606      	mov	r6, r0
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));

  status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006910:	200f      	movs	r0, #15
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT. 
*******************************************************************************/
FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
{
 8006912:	460d      	mov	r5, r1
  FLASH_Status status = FLASH_COMPLETE;

  /* Check the parameters */
  assert_param(IS_OB_DATA_ADDRESS(Address));

  status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006914:	f7ff fed4 	bl	80066c0 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 8006918:	2804      	cmp	r0, #4
 800691a:	d114      	bne.n	8006946 <FLASH_ProgramOptionByteData+0x3a>
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 800691c:	4c0a      	ldr	r4, [pc, #40]	(8006948 <FLASH_ProgramOptionByteData+0x3c>)
 800691e:	4b0b      	ldr	r3, [pc, #44]	(800694c <FLASH_ProgramOptionByteData+0x40>)
    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
    *(vu16*)Address = Data;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006920:	200f      	movs	r0, #15
  status = FLASH_WaitForLastOperation(ProgramTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 8006922:	60a3      	str	r3, [r4, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 8006924:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 8006928:	60a3      	str	r3, [r4, #8]

    /* Enables the Option Bytes Programming operation */
    FLASH->CR |= CR_OPTPG_Set; 
 800692a:	6923      	ldr	r3, [r4, #16]
 800692c:	f043 0310 	orr.w	r3, r3, #16	; 0x10
 8006930:	6123      	str	r3, [r4, #16]
    *(vu16*)Address = Data;
 8006932:	8035      	strh	r5, [r6, #0]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006934:	f7ff fec4 	bl	80066c0 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 8006938:	2801      	cmp	r0, #1
    {
      /* if the program operation is completed, disable the OPTPG Bit */
      FLASH->CR &= CR_OPTPG_Reset;
 800693a:	bf1f      	itttt	ne
 800693c:	6922      	ldrne	r2, [r4, #16]
 800693e:	f641 73ef 	movwne	r3, #8175	; 0x1fef
 8006942:	4013      	andne	r3, r2
 8006944:	6123      	strne	r3, [r4, #16]
    }
  }    
  /* Return the Option Byte Data Program Status */
  return status;      
}
 8006946:	bd70      	pop	{r4, r5, r6, pc}
 8006948:	40022000 	.word	0x40022000
 800694c:	45670123 	.word	0x45670123

08006950 <FLASH_ProgramHalfWord>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT. 
*******************************************************************************/
FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
{
 8006950:	b570      	push	{r4, r5, r6, lr}
 8006952:	4606      	mov	r6, r0

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006954:	200f      	movs	r0, #15
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT. 
*******************************************************************************/
FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
{
 8006956:	460d      	mov	r5, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006958:	f7ff feb2 	bl	80066c0 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 800695c:	2804      	cmp	r0, #4
 800695e:	d10f      	bne.n	8006980 <FLASH_ProgramHalfWord+0x30>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR |= CR_PG_Set;
 8006960:	4c08      	ldr	r4, [pc, #32]	(8006984 <FLASH_ProgramHalfWord+0x34>)
  
    *(vu16*)Address = Data;
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006962:	200f      	movs	r0, #15
  status = FLASH_WaitForLastOperation(ProgramTimeout);
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR |= CR_PG_Set;
 8006964:	6923      	ldr	r3, [r4, #16]
 8006966:	f043 0301 	orr.w	r3, r3, #1	; 0x1
 800696a:	6123      	str	r3, [r4, #16]
  
    *(vu16*)Address = Data;
 800696c:	8035      	strh	r5, [r6, #0]
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800696e:	f7ff fea7 	bl	80066c0 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 8006972:	2801      	cmp	r0, #1
    {
      /* if the program operation is completed, disable the PG Bit */
      FLASH->CR &= CR_PG_Reset;
 8006974:	bf1f      	itttt	ne
 8006976:	6922      	ldrne	r2, [r4, #16]
 8006978:	f641 73fe 	movwne	r3, #8190	; 0x1ffe
 800697c:	4013      	andne	r3, r2
 800697e:	6123      	strne	r3, [r4, #16]
    }
  } 
  /* Return the Program Status */
  return status;
}
 8006980:	bd70      	pop	{r4, r5, r6, pc}
 8006982:	46c0      	nop			(mov r8, r8)
 8006984:	40022000 	.word	0x40022000

08006988 <FLASH_ProgramWord>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT. 
*******************************************************************************/
FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
{
 8006988:	b570      	push	{r4, r5, r6, lr}
 800698a:	4606      	mov	r6, r0

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 800698c:	200f      	movs	r0, #15
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT. 
*******************************************************************************/
FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
{
 800698e:	460d      	mov	r5, r1

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006990:	f7ff fe96 	bl	80066c0 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8006994:	2804      	cmp	r0, #4
 8006996:	d117      	bne.n	80069c8 <FLASH_ProgramWord+0x40>
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
 8006998:	4c0c      	ldr	r4, [pc, #48]	(80069cc <FLASH_ProgramWord+0x44>)
  
    *(vu16*)Address = (u16)Data;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 800699a:	200f      	movs	r0, #15
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to program the new first 
    half word */
    FLASH->CR |= CR_PG_Set;
 800699c:	6923      	ldr	r3, [r4, #16]
 800699e:	f043 0301 	orr.w	r3, r3, #1	; 0x1
 80069a2:	6123      	str	r3, [r4, #16]
  
    *(vu16*)Address = (u16)Data;
 80069a4:	b2ab      	uxth	r3, r5
 80069a6:	8033      	strh	r3, [r6, #0]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(ProgramTimeout);
 80069a8:	f7ff fe8a 	bl	80066c0 <FLASH_WaitForLastOperation>
 
    if(status == FLASH_COMPLETE)
 80069ac:	2804      	cmp	r0, #4
 80069ae:	d104      	bne.n	80069ba <FLASH_ProgramWord+0x32>
    {
      /* if the previous operation is completed, proceed to program the new second 
      half word */
      *(vu16*)(Address + 2) = Data >> 16;
 80069b0:	0c2b      	lsrs	r3, r5, #16
 80069b2:	8073      	strh	r3, [r6, #2]
    
      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 80069b4:	200f      	movs	r0, #15
 80069b6:	f7ff fe83 	bl	80066c0 <FLASH_WaitForLastOperation>
        FLASH->CR &= CR_PG_Reset;
      }
    }
    else
    {
      if (status != FLASH_BUSY)
 80069ba:	2801      	cmp	r0, #1
      {
        /* Disable the PG Bit */
        FLASH->CR &= CR_PG_Reset;
 80069bc:	bf1f      	itttt	ne
 80069be:	6922      	ldrne	r2, [r4, #16]
 80069c0:	f641 73fe 	movwne	r3, #8190	; 0x1ffe
 80069c4:	4013      	andne	r3, r2
 80069c6:	6123      	strne	r3, [r4, #16]
      }
     }
  }
  /* Return the Program Status */
  return status;
}
 80069c8:	bd70      	pop	{r4, r5, r6, pc}
 80069ca:	46c0      	nop			(mov r8, r8)
 80069cc:	40022000 	.word	0x40022000

080069d0 <FLASH_EraseOptionBytes>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_EraseOptionBytes(void)
{
 80069d0:	b510      	push	{r4, lr}
  FLASH_Status status = FLASH_COMPLETE;
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
 80069d2:	f640 70ff 	movw	r0, #4095	; 0xfff
 80069d6:	f7ff fe73 	bl	80066c0 <FLASH_WaitForLastOperation>

  if(status == FLASH_COMPLETE)
 80069da:	2804      	cmp	r0, #4
 80069dc:	d12c      	bne.n	8006a38 <FLASH_EraseOptionBytes+0x68>
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 80069de:	4c17      	ldr	r4, [pc, #92]	(8006a3c <FLASH_EraseOptionBytes+0x6c>)
 80069e0:	4b17      	ldr	r3, [pc, #92]	(8006a40 <FLASH_EraseOptionBytes+0x70>)
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
    FLASH->CR |= CR_STRT_Set;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 80069e2:	f500 607e 	add.w	r0, r0, #4064	; 0xfe0
  status = FLASH_WaitForLastOperation(EraseTimeout);

  if(status == FLASH_COMPLETE)
  {
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
 80069e6:	60a3      	str	r3, [r4, #8]
    FLASH->OPTKEYR = FLASH_KEY2;
 80069e8:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 80069ec:	60a3      	str	r3, [r4, #8]
    
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
 80069ee:	6923      	ldr	r3, [r4, #16]
    FLASH->CR |= CR_STRT_Set;

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 80069f0:	301b      	adds	r0, #27
    /* Authorize the small information block programming */
    FLASH->OPTKEYR = FLASH_KEY1;
    FLASH->OPTKEYR = FLASH_KEY2;
    
    /* if the previous operation is completed, proceed to erase the option bytes */
    FLASH->CR |= CR_OPTER_Set;
 80069f2:	f043 0320 	orr.w	r3, r3, #32	; 0x20
 80069f6:	6123      	str	r3, [r4, #16]
    FLASH->CR |= CR_STRT_Set;
 80069f8:	6923      	ldr	r3, [r4, #16]
 80069fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80069fe:	6123      	str	r3, [r4, #16]

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 8006a00:	f7ff fe5e 	bl	80066c0 <FLASH_WaitForLastOperation>
    
    if(status == FLASH_COMPLETE)
 8006a04:	2804      	cmp	r0, #4
 8006a06:	d110      	bne.n	8006a2a <FLASH_EraseOptionBytes+0x5a>
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
 8006a08:	6922      	ldr	r2, [r4, #16]
 8006a0a:	f641 73df 	movw	r3, #8159	; 0x1fdf
 8006a0e:	ea02 0303 	and.w	r3, r2, r3
 8006a12:	6123      	str	r3, [r4, #16]
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
 8006a14:	6923      	ldr	r3, [r4, #16]

      /* Enable the readout access */
      OB->RDP= RDP_Key; 
 8006a16:	f04f 02a5 	mov.w	r2, #165	; 0xa5
    {
      /* if the erase operation is completed, disable the OPTER Bit */
      FLASH->CR &= CR_OPTER_Reset;
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;
 8006a1a:	f043 0310 	orr.w	r3, r3, #16	; 0x10
 8006a1e:	6123      	str	r3, [r4, #16]

      /* Enable the readout access */
      OB->RDP= RDP_Key; 
 8006a20:	4b08      	ldr	r3, [pc, #32]	(8006a44 <FLASH_EraseOptionBytes+0x74>)

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006a22:	200f      	movs	r0, #15
       
      /* Enable the Option Bytes Programming operation */
      FLASH->CR |= CR_OPTPG_Set;

      /* Enable the readout access */
      OB->RDP= RDP_Key; 
 8006a24:	801a      	strh	r2, [r3, #0]

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation(ProgramTimeout);
 8006a26:	f7ff fe4b 	bl	80066c0 <FLASH_WaitForLastOperation>
        FLASH->CR &= CR_OPTPG_Reset;
      }
    }
    else
    {
      if (status != FLASH_BUSY)
 8006a2a:	2801      	cmp	r0, #1
      {
        /* Disable the OPTPG Bit */
        FLASH->CR &= CR_OPTPG_Reset;
 8006a2c:	bf1f      	itttt	ne
 8006a2e:	6922      	ldrne	r2, [r4, #16]
 8006a30:	f641 73ef 	movwne	r3, #8175	; 0x1fef
 8006a34:	4013      	andne	r3, r2
 8006a36:	6123      	strne	r3, [r4, #16]
      }
    }  
  }
  /* Return the erase status */
  return status;
}
 8006a38:	bd10      	pop	{r4, pc}
 8006a3a:	46c0      	nop			(mov r8, r8)
 8006a3c:	40022000 	.word	0x40022000
 8006a40:	45670123 	.word	0x45670123
 8006a44:	1ffff800 	.word	0x1ffff800

08006a48 <FLASH_EraseAllPages>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_EraseAllPages(void)
{
 8006a48:	b510      	push	{r4, lr}
  FLASH_Status status = FLASH_COMPLETE;

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
 8006a4a:	f640 70ff 	movw	r0, #4095	; 0xfff
 8006a4e:	f7ff fe37 	bl	80066c0 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8006a52:	2804      	cmp	r0, #4
 8006a54:	d113      	bne.n	8006a7e <FLASH_EraseAllPages+0x36>
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
 8006a56:	4c0a      	ldr	r4, [pc, #40]	(8006a80 <FLASH_EraseAllPages+0x38>)
 8006a58:	6923      	ldr	r3, [r4, #16]
 8006a5a:	4303      	orrs	r3, r0
 8006a5c:	6123      	str	r3, [r4, #16]
     FLASH->CR |= CR_STRT_Set;
 8006a5e:	6923      	ldr	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 8006a60:	f500 607e 	add.w	r0, r0, #4064	; 0xfe0
  
  if(status == FLASH_COMPLETE)
  {
    /* if the previous operation is completed, proceed to erase all pages */
     FLASH->CR |= CR_MER_Set;
     FLASH->CR |= CR_STRT_Set;
 8006a64:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006a68:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 8006a6a:	301b      	adds	r0, #27
 8006a6c:	f7ff fe28 	bl	80066c0 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 8006a70:	2801      	cmp	r0, #1
    {
      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= CR_MER_Reset;
 8006a72:	bf1f      	itttt	ne
 8006a74:	6922      	ldrne	r2, [r4, #16]
 8006a76:	f641 73fb 	movwne	r3, #8187	; 0x1ffb
 8006a7a:	4013      	andne	r3, r2
 8006a7c:	6123      	strne	r3, [r4, #16]
    }
  }	   
  /* Return the Erase Status */
  return status;
}
 8006a7e:	bd10      	pop	{r4, pc}
 8006a80:	40022000 	.word	0x40022000

08006a84 <FLASH_ErasePage>:
* Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
*                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
*                  FLASH_TIMEOUT.
*******************************************************************************/
FLASH_Status FLASH_ErasePage(u32 Page_Address)
{
 8006a84:	b530      	push	{r4, r5, lr}
 8006a86:	4605      	mov	r5, r0
 8006a88:	b081      	sub	sp, #4

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Page_Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
 8006a8a:	f640 70ff 	movw	r0, #4095	; 0xfff
 8006a8e:	f7ff fe17 	bl	80066c0 <FLASH_WaitForLastOperation>
  
  if(status == FLASH_COMPLETE)
 8006a92:	2804      	cmp	r0, #4
 8006a94:	d115      	bne.n	8006ac2 <FLASH_ErasePage+0x3e>
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
 8006a96:	4c0c      	ldr	r4, [pc, #48]	(8006ac8 <FLASH_ErasePage+0x44>)
    FLASH->AR = Page_Address; 
    FLASH->CR|= CR_STRT_Set;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 8006a98:	f500 607e 	add.w	r0, r0, #4064	; 0xfe0
  status = FLASH_WaitForLastOperation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
 8006a9c:	6923      	ldr	r3, [r4, #16]
    FLASH->AR = Page_Address; 
    FLASH->CR|= CR_STRT_Set;
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 8006a9e:	301b      	adds	r0, #27
  status = FLASH_WaitForLastOperation(EraseTimeout);
  
  if(status == FLASH_COMPLETE)
  { 
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
 8006aa0:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 8006aa4:	6123      	str	r3, [r4, #16]
    FLASH->AR = Page_Address; 
 8006aa6:	6165      	str	r5, [r4, #20]
    FLASH->CR|= CR_STRT_Set;
 8006aa8:	6923      	ldr	r3, [r4, #16]
 8006aaa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006aae:	6123      	str	r3, [r4, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation(EraseTimeout);
 8006ab0:	f7ff fe06 	bl	80066c0 <FLASH_WaitForLastOperation>

    if(status != FLASH_BUSY)
 8006ab4:	2801      	cmp	r0, #1
    {
      /* if the erase operation is completed, disable the PER Bit */
      FLASH->CR &= CR_PER_Reset;
 8006ab6:	bf1f      	itttt	ne
 8006ab8:	6922      	ldrne	r2, [r4, #16]
 8006aba:	f641 73fd 	movwne	r3, #8189	; 0x1ffd
 8006abe:	4013      	andne	r3, r2
 8006ac0:	6123      	strne	r3, [r4, #16]
    }
  }
  /* Return the Erase Status */
  return status;
}
 8006ac2:	b001      	add	sp, #4
 8006ac4:	bd30      	pop	{r4, r5, pc}
 8006ac6:	46c0      	nop			(mov r8, r8)
 8006ac8:	40022000 	.word	0x40022000

08006acc <GPIO_Init>:
*                    peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8006acc:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
 8006ace:	78cd      	ldrb	r5, [r1, #3]
    currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
  }

/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
 8006ad0:	880e      	ldrh	r6, [r1, #0]
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);

  if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
 8006ad2:	f015 0f10 	tst.w	r5, #16	; 0x10
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
 8006ad6:	bf18      	it	ne
 8006ad8:	788b      	ldrbne	r3, [r1, #2]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
 8006ada:	f005 070f 	and.w	r7, r5, #15	; 0xf
  if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
 8006ade:	bf18      	it	ne
 8006ae0:	431f      	orrne	r7, r3
  }

/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
 8006ae2:	f016 0fff 	tst.w	r6, #255	; 0xff
*                    peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8006ae6:	b083      	sub	sp, #12
    currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
  }

/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
 8006ae8:	d01e      	beq.n	8006b28 <GPIO_Init+0x5c>
  {
    tmpreg = GPIOx->CRL;
 8006aea:	6804      	ldr	r4, [r0, #0]
 8006aec:	2100      	movs	r1, #0

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = ((u32)0x01) << pinpos;
 8006aee:	2201      	movs	r2, #1
 8006af0:	fa12 f301 	lsls.w	r3, r2, r1
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8006af4:	ea03 0c06 	and.w	ip, r3, r6

      if (currentpin == pos)
 8006af8:	459c      	cmp	ip, r3
 8006afa:	d111      	bne.n	8006b20 <GPIO_Init+0x54>
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
 8006afc:	008a      	lsls	r2, r1, #2
        tmpreg &= ~pinmask;
 8006afe:	230f      	movs	r3, #15
 8006b00:	4093      	lsls	r3, r2

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8006b02:	fa17 f202 	lsls.w	r2, r7, r2
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
 8006b06:	ea24 0403 	bic.w	r4, r4, r3

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8006b0a:	4314      	orrs	r4, r2

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8006b0c:	2d28      	cmp	r5, #40
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
 8006b0e:	9301      	str	r3, [sp, #4]
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
 8006b10:	bf08      	it	eq
 8006b12:	f8c0 c014 	streq.w	ip, [r0, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8006b16:	d003      	beq.n	8006b20 <GPIO_Init+0x54>
          GPIOx->BRR = (((u32)0x01) << pinpos);
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8006b18:	2d48      	cmp	r5, #72
          {
            GPIOx->BSRR = (((u32)0x01) << pinpos);
 8006b1a:	bf08      	it	eq
 8006b1c:	f8c0 c010 	streq.w	ip, [r0, #16]
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8006b20:	3101      	adds	r1, #1
 8006b22:	2908      	cmp	r1, #8
 8006b24:	d1e3      	bne.n	8006aee <GPIO_Init+0x22>
            GPIOx->BSRR = (((u32)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8006b26:	6004      	str	r4, [r0, #0]
  }

/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8006b28:	2eff      	cmp	r6, #255
 8006b2a:	d920      	bls.n	8006b6e <GPIO_Init+0xa2>
  {
    tmpreg = GPIOx->CRH;
 8006b2c:	6844      	ldr	r4, [r0, #4]
 8006b2e:	2100      	movs	r1, #0
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
 8006b30:	2201      	movs	r2, #1
 8006b32:	f101 0308 	add.w	r3, r1, #8	; 0x8
 8006b36:	fa12 f303 	lsls.w	r3, r2, r3
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8006b3a:	ea03 0c06 	and.w	ip, r3, r6
      if (currentpin == pos)
 8006b3e:	459c      	cmp	ip, r3
 8006b40:	d111      	bne.n	8006b66 <GPIO_Init+0x9a>
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
 8006b42:	008a      	lsls	r2, r1, #2
        tmpreg &= ~pinmask;
 8006b44:	230f      	movs	r3, #15
 8006b46:	4093      	lsls	r3, r2

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8006b48:	fa17 f202 	lsls.w	r2, r7, r2
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
 8006b4c:	ea24 0403 	bic.w	r4, r4, r3

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8006b50:	4314      	orrs	r4, r2

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8006b52:	2d28      	cmp	r5, #40
      if (currentpin == pos)
      {
        pos = pinpos << 2;
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
        tmpreg &= ~pinmask;
 8006b54:	9301      	str	r3, [sp, #4]
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
 8006b56:	bf08      	it	eq
 8006b58:	f8c0 c014 	streq.w	ip, [r0, #20]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8006b5c:	d003      	beq.n	8006b66 <GPIO_Init+0x9a>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8006b5e:	2d48      	cmp	r5, #72
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
 8006b60:	bf08      	it	eq
 8006b62:	f8c0 c010 	streq.w	ip, [r0, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8006b66:	3101      	adds	r1, #1
 8006b68:	2908      	cmp	r1, #8
 8006b6a:	d1e1      	bne.n	8006b30 <GPIO_Init+0x64>
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8006b6c:	6044      	str	r4, [r0, #4]
  }
}
 8006b6e:	b003      	add	sp, #12
 8006b70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006b72:	46c0      	nop			(mov r8, r8)

08006b74 <GPIO_StructInit>:
* Return         : None
*******************************************************************************/
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8006b74:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006b78:	8003      	strh	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8006b7a:	2302      	movs	r3, #2
 8006b7c:	7083      	strb	r3, [r0, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8006b7e:	2304      	movs	r3, #4
 8006b80:	70c3      	strb	r3, [r0, #3]
}
 8006b82:	4770      	bx	lr

08006b84 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
 8006b84:	6883      	ldr	r3, [r0, #8]
 8006b86:	4219      	tst	r1, r3
 8006b88:	bf0c      	ite	eq
 8006b8a:	2000      	moveq	r0, #0
 8006b8c:	2001      	movne	r0, #1
  else
  {
    bitstatus = (u8)Bit_RESET;
  }
  return bitstatus;
}
 8006b8e:	4770      	bx	lr

08006b90 <GPIO_ReadInputData>:
u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((u16)GPIOx->IDR);
 8006b90:	6880      	ldr	r0, [r0, #8]
 8006b92:	b280      	uxth	r0, r0
}
 8006b94:	4770      	bx	lr
 8006b96:	46c0      	nop			(mov r8, r8)

08006b98 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
 8006b98:	68c3      	ldr	r3, [r0, #12]
 8006b9a:	4219      	tst	r1, r3
 8006b9c:	bf0c      	ite	eq
 8006b9e:	2000      	moveq	r0, #0
 8006ba0:	2001      	movne	r0, #1
  else
  {
    bitstatus = (u8)Bit_RESET;
  }
  return bitstatus;
}
 8006ba2:	4770      	bx	lr

08006ba4 <GPIO_ReadOutputData>:
u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((u16)GPIOx->ODR);
 8006ba4:	68c0      	ldr	r0, [r0, #12]
 8006ba6:	b280      	uxth	r0, r0
}
 8006ba8:	4770      	bx	lr
 8006baa:	46c0      	nop			(mov r8, r8)

08006bac <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8006bac:	6101      	str	r1, [r0, #16]
}
 8006bae:	4770      	bx	lr

08006bb0 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8006bb0:	6141      	str	r1, [r0, #20]
}
 8006bb2:	4770      	bx	lr

08006bb4 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
 8006bb4:	b10a      	cbz	r2, 8006bba <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8006bb6:	6101      	str	r1, [r0, #16]
 8006bb8:	e000      	b.n	8006bbc <GPIO_WriteBit+0x8>
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
 8006bba:	6141      	str	r1, [r0, #20]
  }
}
 8006bbc:	4770      	bx	lr
 8006bbe:	46c0      	nop			(mov r8, r8)

08006bc0 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 8006bc0:	60c1      	str	r1, [r0, #12]
}
 8006bc2:	4770      	bx	lr

08006bc4 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8006bc4:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8006bc8:	6183      	str	r3, [r0, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8006bca:	6181      	str	r1, [r0, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8006bcc:	6183      	str	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8006bce:	6983      	ldr	r3, [r0, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8006bd0:	6983      	ldr	r3, [r0, #24]
}
 8006bd2:	4770      	bx	lr

08006bd4 <GPIO_EventOutputConfig>:

  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 8006bd4:	f8df c018 	ldr.w	ip, [pc, #24]	; 8006bf0 <GPIO_EventOutputConfig+0x1c>
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
 8006bd8:	f64f 7380 	movw	r3, #65408	; 0xff80

  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
 8006bdc:	f8dc 2000 	ldr.w	r2, [ip]
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
  tmpreg |= (u32)GPIO_PortSource << 0x04;
 8006be0:	ea41 1100 	orr.w	r1, r1, r0, lsl #4
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
 8006be4:	ea02 0303 	and.w	r3, r2, r3
  tmpreg |= (u32)GPIO_PortSource << 0x04;
  tmpreg |= GPIO_PinSource;
 8006be8:	4319      	orrs	r1, r3

  AFIO->EVCR = tmpreg;
 8006bea:	f8cc 1000 	str.w	r1, [ip]
}
 8006bee:	4770      	bx	lr
 8006bf0:	40010000 	.word	0x40010000

08006bf4 <GPIO_EventOutputCmd>:
void GPIO_EventOutputCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
 8006bf4:	4b01      	ldr	r3, [pc, #4]	(8006bfc <GPIO_EventOutputCmd+0x8>)
 8006bf6:	6018      	str	r0, [r3, #0]
}
 8006bf8:	4770      	bx	lr
 8006bfa:	46c0      	nop			(mov r8, r8)
 8006bfc:	4220001c 	.word	0x4220001c

08006c00 <GPIO_PinRemapConfig>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
{
 8006c00:	b530      	push	{r4, r5, lr}
  tmpreg = AFIO->MAPR;

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8006c02:	f400 1340 	and.w	r3, r0, #3145728	; 0x300000
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  tmpreg = AFIO->MAPR;

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 8006c06:	0404      	lsls	r4, r0, #16
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
{
 8006c08:	460d      	mov	r5, r1

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  tmpreg = AFIO->MAPR;
 8006c0a:	4914      	ldr	r1, [pc, #80]	(8006c5c <GPIO_PinRemapConfig+0x5c>)

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;
 8006c0c:	0c24      	lsrs	r4, r4, #16

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8006c0e:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  tmpreg = AFIO->MAPR;
 8006c12:	f8d1 c004 	ldr.w	ip, [r1, #4]

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8006c16:	d106      	bne.n	8006c26 <GPIO_PinRemapConfig+0x26>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8006c18:	684b      	ldr	r3, [r1, #4]
  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
  tmp = GPIO_Remap & LSB_MASK;

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8006c1a:	f02c 6270 	bic.w	r2, ip, #251658240	; 0xf000000
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8006c1e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8006c22:	604b      	str	r3, [r1, #4]
 8006c24:	e010      	b.n	8006c48 <GPIO_PinRemapConfig+0x48>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8006c26:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
 8006c2a:	d005      	beq.n	8006c38 <GPIO_PinRemapConfig+0x38>
  {
    tmp1 = ((u32)0x03) << tmpmask;
    tmpreg &= ~tmp1;
 8006c2c:	f400 2270 	and.w	r2, r0, #983040	; 0xf0000
 8006c30:	0c12      	lsrs	r2, r2, #16
 8006c32:	2303      	movs	r3, #3
 8006c34:	4093      	lsls	r3, r2
 8006c36:	e003      	b.n	8006c40 <GPIO_PinRemapConfig+0x40>
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8006c38:	0d43      	lsrs	r3, r0, #21
 8006c3a:	011b      	lsls	r3, r3, #4
 8006c3c:	fa14 f303 	lsls.w	r3, r4, r3
 8006c40:	ea2c 0303 	bic.w	r3, ip, r3
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8006c44:	f043 6270 	orr.w	r2, r3, #251658240	; 0xf000000
  }

  if (NewState != DISABLE)
 8006c48:	b125      	cbz	r5, 8006c54 <GPIO_PinRemapConfig+0x54>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 8006c4a:	0d43      	lsrs	r3, r0, #21
 8006c4c:	011b      	lsls	r3, r3, #4
 8006c4e:	fa14 f303 	lsls.w	r3, r4, r3
 8006c52:	431a      	orrs	r2, r3
  }

  AFIO->MAPR = tmpreg;
 8006c54:	4b01      	ldr	r3, [pc, #4]	(8006c5c <GPIO_PinRemapConfig+0x5c>)
 8006c56:	605a      	str	r2, [r3, #4]
}
 8006c58:	bd30      	pop	{r4, r5, pc}
 8006c5a:	46c0      	nop			(mov r8, r8)
 8006c5c:	40010000 	.word	0x40010000

08006c60 <GPIO_EXTILineConfig>:
*                   This parameter can be GPIO_PinSourcex where x can be (0..15).
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
{
 8006c60:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
 8006c62:	f001 0403 	and.w	r4, r1, #3	; 0x3
 8006c66:	00a4      	lsls	r4, r4, #2

  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 8006c68:	230f      	movs	r3, #15
 8006c6a:	40a3      	lsls	r3, r4
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
 8006c6c:	40a0      	lsls	r0, r4
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));

  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
 8006c6e:	f8df c020 	ldr.w	ip, [pc, #32]	; 8006c90 <GPIO_EXTILineConfig+0x30>
 8006c72:	0889      	lsrs	r1, r1, #2
 8006c74:	3102      	adds	r1, #2
 8006c76:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
 8006c7a:	ea22 0203 	bic.w	r2, r2, r3
 8006c7e:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
 8006c82:	f85c 3021 	ldr.w	r3, [ip, r1, lsl #2]
 8006c86:	4318      	orrs	r0, r3
 8006c88:	f84c 0021 	str.w	r0, [ip, r1, lsl #2]
}
 8006c8c:	bd10      	pop	{r4, pc}
 8006c8e:	46c0      	nop			(mov r8, r8)
 8006c90:	40010000 	.word	0x40010000

08006c94 <GPIO_AFIODeInit>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_AFIODeInit(void)
{
 8006c94:	b500      	push	{lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 8006c96:	2001      	movs	r0, #1
 8006c98:	2101      	movs	r1, #1
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_AFIODeInit(void)
{
 8006c9a:	b081      	sub	sp, #4
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
 8006c9c:	f000 fbf6 	bl	800748c <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
 8006ca0:	2001      	movs	r0, #1
 8006ca2:	2100      	movs	r1, #0
 8006ca4:	f000 fbf2 	bl	800748c <RCC_APB2PeriphResetCmd>
}
 8006ca8:	b001      	add	sp, #4
 8006caa:	bd00      	pop	{pc}

08006cac <GPIO_DeInit>:
* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8006cac:	b500      	push	{lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  switch (*(u32*)&GPIOx)
 8006cae:	4b27      	ldr	r3, [pc, #156]	(8006d4c <GPIO_DeInit+0xa0>)
* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8006cb0:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  switch (*(u32*)&GPIOx)
 8006cb2:	4298      	cmp	r0, r3
* Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8006cb4:	9001      	str	r0, [sp, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  switch (*(u32*)&GPIOx)
 8006cb6:	d02b      	beq.n	8006d10 <GPIO_DeInit+0x64>
 8006cb8:	d80c      	bhi.n	8006cd4 <GPIO_DeInit+0x28>
 8006cba:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 8006cbe:	4298      	cmp	r0, r3
 8006cc0:	d01a      	beq.n	8006cf8 <GPIO_DeInit+0x4c>
 8006cc2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8006cc6:	4298      	cmp	r0, r3
 8006cc8:	d01c      	beq.n	8006d04 <GPIO_DeInit+0x58>
 8006cca:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 8006cce:	4298      	cmp	r0, r3
 8006cd0:	d13a      	bne.n	8006d48 <GPIO_DeInit+0x9c>
 8006cd2:	e00b      	b.n	8006cec <GPIO_DeInit+0x40>
 8006cd4:	4b1e      	ldr	r3, [pc, #120]	(8006d50 <GPIO_DeInit+0xa4>)
 8006cd6:	4298      	cmp	r0, r3
 8006cd8:	d026      	beq.n	8006d28 <GPIO_DeInit+0x7c>
 8006cda:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8006cde:	4298      	cmp	r0, r3
 8006ce0:	d028      	beq.n	8006d34 <GPIO_DeInit+0x88>
 8006ce2:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 8006ce6:	4298      	cmp	r0, r3
 8006ce8:	d12e      	bne.n	8006d48 <GPIO_DeInit+0x9c>
 8006cea:	e017      	b.n	8006d1c <GPIO_DeInit+0x70>
  {
    case GPIOA_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
 8006cec:	2004      	movs	r0, #4
 8006cee:	2101      	movs	r1, #1
 8006cf0:	f000 fbcc 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
 8006cf4:	2004      	movs	r0, #4
 8006cf6:	e024      	b.n	8006d42 <GPIO_DeInit+0x96>
      break;

    case GPIOB_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
 8006cf8:	2008      	movs	r0, #8
 8006cfa:	2101      	movs	r1, #1
 8006cfc:	f000 fbc6 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
 8006d00:	2008      	movs	r0, #8
 8006d02:	e01e      	b.n	8006d42 <GPIO_DeInit+0x96>
      break;

    case GPIOC_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
 8006d04:	2010      	movs	r0, #16
 8006d06:	2101      	movs	r1, #1
 8006d08:	f000 fbc0 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
 8006d0c:	2010      	movs	r0, #16
 8006d0e:	e018      	b.n	8006d42 <GPIO_DeInit+0x96>
      break;

    case GPIOD_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
 8006d10:	2020      	movs	r0, #32
 8006d12:	2101      	movs	r1, #1
 8006d14:	f000 fbba 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
 8006d18:	2020      	movs	r0, #32
 8006d1a:	e012      	b.n	8006d42 <GPIO_DeInit+0x96>
      break;
      
    case GPIOE_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
 8006d1c:	2040      	movs	r0, #64
 8006d1e:	2101      	movs	r1, #1
 8006d20:	f000 fbb4 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
 8006d24:	2040      	movs	r0, #64
 8006d26:	e00c      	b.n	8006d42 <GPIO_DeInit+0x96>
      break; 

    case GPIOF_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
 8006d28:	2080      	movs	r0, #128
 8006d2a:	2101      	movs	r1, #1
 8006d2c:	f000 fbae 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
 8006d30:	2080      	movs	r0, #128
 8006d32:	e006      	b.n	8006d42 <GPIO_DeInit+0x96>
      break;

    case GPIOG_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
 8006d34:	f44f 7080 	mov.w	r0, #256	; 0x100
 8006d38:	2101      	movs	r1, #1
 8006d3a:	f000 fba7 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
 8006d3e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8006d42:	2100      	movs	r1, #0
 8006d44:	f000 fba2 	bl	800748c <RCC_APB2PeriphResetCmd>
      break;                       

    default:
      break;
  }
}
 8006d48:	b003      	add	sp, #12
 8006d4a:	bd00      	pop	{pc}
 8006d4c:	40011400 	.word	0x40011400
 8006d50:	40011c00 	.word	0x40011c00

08006d54 <NVIC_DeInit>:
*******************************************************************************/
void NVIC_DeInit(void)
{
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
 8006d54:	4b0b      	ldr	r3, [pc, #44]	(8006d84 <NVIC_DeInit+0x30>)
 8006d56:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  NVIC->ICER[1] = 0x0FFFFFFF;
 8006d5a:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
*******************************************************************************/
void NVIC_DeInit(void)
{
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
 8006d5e:	f8c3 1080 	str.w	r1, [r3, #128]
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x0FFFFFFF;
  
  for(index = 0; index < 0x0F; index++)
  {
     NVIC->IPR[index] = 0x00000000;
 8006d62:	4618      	mov	r0, r3
void NVIC_DeInit(void)
{
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x0FFFFFFF;
 8006d64:	f8c3 2084 	str.w	r2, [r3, #132]
  NVIC->ICPR[0] = 0xFFFFFFFF;
 8006d68:	f8c3 1180 	str.w	r1, [r3, #384]
  NVIC->ICPR[1] = 0x0FFFFFFF;
 8006d6c:	f8c3 2184 	str.w	r2, [r3, #388]
  
  for(index = 0; index < 0x0F; index++)
  {
     NVIC->IPR[index] = 0x00000000;
 8006d70:	2100      	movs	r1, #0
  u32 index = 0;
  
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x0FFFFFFF;
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x0FFFFFFF;
 8006d72:	2200      	movs	r2, #0
  
  for(index = 0; index < 0x0F; index++)
  {
     NVIC->IPR[index] = 0x00000000;
 8006d74:	f102 03c0 	add.w	r3, r2, #192	; 0xc0
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x0FFFFFFF;
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x0FFFFFFF;
  
  for(index = 0; index < 0x0F; index++)
 8006d78:	3201      	adds	r2, #1
 8006d7a:	2a0f      	cmp	r2, #15
  {
     NVIC->IPR[index] = 0x00000000;
 8006d7c:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
  NVIC->ICER[0] = 0xFFFFFFFF;
  NVIC->ICER[1] = 0x0FFFFFFF;
  NVIC->ICPR[0] = 0xFFFFFFFF;
  NVIC->ICPR[1] = 0x0FFFFFFF;
  
  for(index = 0; index < 0x0F; index++)
 8006d80:	d1f8      	bne.n	8006d74 <NVIC_DeInit+0x20>
  {
     NVIC->IPR[index] = 0x00000000;
  } 
}
 8006d82:	4770      	bx	lr
 8006d84:	e000e100 	.word	0xe000e100

08006d88 <NVIC_SCBDeInit>:
*******************************************************************************/
void NVIC_SCBDeInit(void)
{
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
 8006d88:	4a09      	ldr	r2, [pc, #36]	(8006db0 <NVIC_SCBDeInit+0x28>)
 8006d8a:	f04f 6320 	mov.w	r3, #167772160	; 0xa000000
  SCB->VTOR = 0x00000000;
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
 8006d8e:	4909      	ldr	r1, [pc, #36]	(8006db4 <NVIC_SCBDeInit+0x2c>)
*******************************************************************************/
void NVIC_SCBDeInit(void)
{
  u32 index = 0x00;
  
  SCB->ICSR = 0x0A000000;
 8006d90:	6053      	str	r3, [r2, #4]
  SCB->VTOR = 0x00000000;
 8006d92:	2300      	movs	r3, #0
 8006d94:	6093      	str	r3, [r2, #8]
  SCB->AIRCR = AIRCR_VECTKEY_MASK;
 8006d96:	60d1      	str	r1, [r2, #12]
  SCB->SCR = 0x00000000;
 8006d98:	6113      	str	r3, [r2, #16]
  SCB->CCR = 0x00000000;
 8006d9a:	6153      	str	r3, [r2, #20]
  for(index = 0; index < 0x03; index++)
  {
     SCB->SHPR[index] = 0;
 8006d9c:	6193      	str	r3, [r2, #24]
 8006d9e:	61d3      	str	r3, [r2, #28]
 8006da0:	6213      	str	r3, [r2, #32]
  }
  SCB->SHCSR = 0x00000000;
 8006da2:	6253      	str	r3, [r2, #36]
  SCB->CFSR = 0xFFFFFFFF;
 8006da4:	3b01      	subs	r3, #1
 8006da6:	6293      	str	r3, [r2, #40]
  SCB->HFSR = 0xFFFFFFFF;
 8006da8:	62d3      	str	r3, [r2, #44]
  SCB->DFSR = 0xFFFFFFFF;
 8006daa:	6313      	str	r3, [r2, #48]
}
 8006dac:	4770      	bx	lr
 8006dae:	46c0      	nop			(mov r8, r8)
 8006db0:	e000ed00 	.word	0xe000ed00
 8006db4:	05fa0000 	.word	0x05fa0000

08006db8 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8006db8:	f040 60be 	orr.w	r0, r0, #99614720	; 0x5f00000
 8006dbc:	4b02      	ldr	r3, [pc, #8]	(8006dc8 <NVIC_PriorityGroupConfig+0x10>)
 8006dbe:	f440 2020 	orr.w	r0, r0, #655360	; 0xa0000
 8006dc2:	60d8      	str	r0, [r3, #12]
}
 8006dc4:	4770      	bx	lr
 8006dc6:	46c0      	nop			(mov r8, r8)
 8006dc8:	e000ed00 	.word	0xe000ed00

08006dcc <NVIC_Init>:
*                    specified NVIC peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8006dcc:	b530      	push	{r4, r5, lr}
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8006dce:	78c3      	ldrb	r3, [r0, #3]
 8006dd0:	7805      	ldrb	r5, [r0, #0]
 8006dd2:	b35b      	cbz	r3, 8006e2c <NVIC_Init+0x60>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 8006dd4:	4b1a      	ldr	r3, [pc, #104]	(8006e40 <NVIC_Init+0x74>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8006dd6:	7841      	ldrb	r1, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 8006dd8:	68da      	ldr	r2, [r3, #12]
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 8006dda:	4c1a      	ldr	r4, [pc, #104]	(8006e44 <NVIC_Init+0x78>)
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 8006ddc:	ea6f 0202 	mvn.w	r2, r2
 8006de0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8006de4:	0a12      	lsrs	r2, r2, #8
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8006de6:	f1c2 0304 	rsb	r3, r2, #4	; 0x4
 8006dea:	4099      	lsls	r1, r3
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8006dec:	230f      	movs	r3, #15
 8006dee:	40d3      	lsrs	r3, r2
 8006df0:	7882      	ldrb	r2, [r0, #2]

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 8006df2:	f005 0003 	and.w	r0, r5, #3	; 0x3
    tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8006df6:	4013      	ands	r3, r2
 8006df8:	430b      	orrs	r3, r1

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 8006dfa:	00c0      	lsls	r0, r0, #3
    tmpsub = tmpsub >> tmppriority;
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
 8006dfc:	011b      	lsls	r3, r3, #4
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 8006dfe:	22ff      	movs	r2, #255
 8006e00:	4082      	lsls	r2, r0
    
    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 8006e02:	4083      	lsls	r3, r0
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 8006e04:	ea4f 0c95 	mov.w	ip, r5, lsr #2
 8006e08:	f10c 0cc0 	add.w	ip, ip, #192	; 0xc0
 8006e0c:	f854 102c 	ldr.w	r1, [r4, ip, lsl #2]
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    tmppriority &= tmpmask;  
    tmpreg |= tmppriority;
 8006e10:	4013      	ands	r3, r2
    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    
    tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
 8006e12:	ea21 0102 	bic.w	r1, r1, r2
    tmppriority &= tmpmask;  
    tmpreg |= tmppriority;
 8006e16:	430b      	orrs	r3, r1

    NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 8006e18:	f844 302c 	str.w	r3, [r4, ip, lsl #2]
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 8006e1c:	f005 021f 	and.w	r2, r5, #31	; 0x1f
 8006e20:	2301      	movs	r3, #1
 8006e22:	4093      	lsls	r3, r2
 8006e24:	0969      	lsrs	r1, r5, #5
 8006e26:	f844 3021 	str.w	r3, [r4, r1, lsl #2]
 8006e2a:	e008      	b.n	8006e3e <NVIC_Init+0x72>
      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 8006e2c:	f005 021f 	and.w	r2, r5, #31	; 0x1f
 8006e30:	2301      	movs	r3, #1
 8006e32:	4093      	lsls	r3, r2
 8006e34:	0969      	lsrs	r1, r5, #5
 8006e36:	4a03      	ldr	r2, [pc, #12]	(8006e44 <NVIC_Init+0x78>)
 8006e38:	3120      	adds	r1, #32
 8006e3a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
      (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
  }
}
 8006e3e:	bd30      	pop	{r4, r5, pc}
 8006e40:	e000ed00 	.word	0xe000ed00
 8006e44:	e000e100 	.word	0xe000e100

08006e48 <NVIC_StructInit>:
* Return         : None
*******************************************************************************/
void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
{
  /* NVIC_InitStruct members default value */
  NVIC_InitStruct->NVIC_IRQChannel = 0x00;
 8006e48:	2300      	movs	r3, #0
 8006e4a:	7003      	strb	r3, [r0, #0]
  NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
 8006e4c:	7043      	strb	r3, [r0, #1]
  NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
 8006e4e:	7083      	strb	r3, [r0, #2]
  NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
 8006e50:	70c3      	strb	r3, [r0, #3]
}
 8006e52:	4770      	bx	lr

08006e54 <NVIC_GetCurrentPendingIRQChannel>:
* Output         : None
* Return         : Pending IRQ Channel Identifier.
*******************************************************************************/
u16 NVIC_GetCurrentPendingIRQChannel(void)
{
  return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
 8006e54:	4b03      	ldr	r3, [pc, #12]	(8006e64 <NVIC_GetCurrentPendingIRQChannel+0x10>)
 8006e56:	4804      	ldr	r0, [pc, #16]	(8006e68 <NVIC_GetCurrentPendingIRQChannel+0x14>)
 8006e58:	685b      	ldr	r3, [r3, #4]
 8006e5a:	ea03 0000 	and.w	r0, r3, r0
 8006e5e:	0b00      	lsrs	r0, r0, #12
}
 8006e60:	4770      	bx	lr
 8006e62:	46c0      	nop			(mov r8, r8)
 8006e64:	e000ed00 	.word	0xe000ed00
 8006e68:	003ff000 	.word	0x003ff000

08006e6c <NVIC_GetIRQChannelPendingBitStatus>:
  u32 tmp = 0x00;
  
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
 8006e6c:	f000 031f 	and.w	r3, r0, #31	; 0x1f
 8006e70:	2201      	movs	r2, #1
 8006e72:	409a      	lsls	r2, r3

  if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
 8006e74:	0940      	lsrs	r0, r0, #5
 8006e76:	4b05      	ldr	r3, [pc, #20]	(8006e8c <NVIC_GetIRQChannelPendingBitStatus+0x20>)
 8006e78:	3040      	adds	r0, #64
 8006e7a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8006e7e:	4010      	ands	r0, r2
 8006e80:	4290      	cmp	r0, r2
 8006e82:	bf14      	ite	ne
 8006e84:	2000      	movne	r0, #0
 8006e86:	2001      	moveq	r0, #1
  else
  {
    pendingirqstatus = RESET;
  }
  return pendingirqstatus;
}
 8006e88:	4770      	bx	lr
 8006e8a:	46c0      	nop			(mov r8, r8)
 8006e8c:	e000e100 	.word	0xe000e100

08006e90 <NVIC_SetIRQChannelPendingBit>:
void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
{
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
 8006e90:	4b01      	ldr	r3, [pc, #4]	(8006e98 <NVIC_SetIRQChannelPendingBit+0x8>)
 8006e92:	6018      	str	r0, [r3, #0]
}
 8006e94:	4770      	bx	lr
 8006e96:	46c0      	nop			(mov r8, r8)
 8006e98:	e000ef00 	.word	0xe000ef00

08006e9c <NVIC_ClearIRQChannelPendingBit>:
void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
{
  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
 8006e9c:	0941      	lsrs	r1, r0, #5
 8006e9e:	2301      	movs	r3, #1
 8006ea0:	f000 001f 	and.w	r0, r0, #31	; 0x1f
 8006ea4:	4083      	lsls	r3, r0
 8006ea6:	4a02      	ldr	r2, [pc, #8]	(8006eb0 <NVIC_ClearIRQChannelPendingBit+0x14>)
 8006ea8:	3160      	adds	r1, #96
 8006eaa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 8006eae:	4770      	bx	lr
 8006eb0:	e000e100 	.word	0xe000e100

08006eb4 <NVIC_GetCurrentActiveHandler>:
* Output         : None
* Return         : Active Handler Identifier.
*******************************************************************************/
u16 NVIC_GetCurrentActiveHandler(void)
{
  return ((u16)(SCB->ICSR & (u32)0x3FF));
 8006eb4:	4b02      	ldr	r3, [pc, #8]	(8006ec0 <NVIC_GetCurrentActiveHandler+0xc>)
 8006eb6:	6858      	ldr	r0, [r3, #4]
 8006eb8:	0580      	lsls	r0, r0, #22
 8006eba:	0d80      	lsrs	r0, r0, #22
}
 8006ebc:	4770      	bx	lr
 8006ebe:	46c0      	nop			(mov r8, r8)
 8006ec0:	e000ed00 	.word	0xe000ed00

08006ec4 <NVIC_GetIRQChannelActiveBitStatus>:
  u32 tmp = 0x00;

  /* Check the parameters */
  assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
  
  tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
 8006ec4:	f000 031f 	and.w	r3, r0, #31	; 0x1f
 8006ec8:	2201      	movs	r2, #1
 8006eca:	409a      	lsls	r2, r3

  if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
 8006ecc:	0940      	lsrs	r0, r0, #5
 8006ece:	4b05      	ldr	r3, [pc, #20]	(8006ee4 <NVIC_GetIRQChannelActiveBitStatus+0x20>)
 8006ed0:	3080      	adds	r0, #128
 8006ed2:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8006ed6:	4010      	ands	r0, r2
 8006ed8:	4290      	cmp	r0, r2
 8006eda:	bf14      	ite	ne
 8006edc:	2000      	movne	r0, #0
 8006ede:	2001      	moveq	r0, #1
  else
  {
    activeirqstatus = RESET;
  }
  return activeirqstatus;
}
 8006ee0:	4770      	bx	lr
 8006ee2:	46c0      	nop			(mov r8, r8)
 8006ee4:	e000e100 	.word	0xe000e100

08006ee8 <NVIC_GetCPUID>:
* Output         : None
* Return         : CPU ID.
*******************************************************************************/
u32 NVIC_GetCPUID(void)
{
  return (SCB->CPUID);
 8006ee8:	4b01      	ldr	r3, [pc, #4]	(8006ef0 <NVIC_GetCPUID+0x8>)
 8006eea:	6818      	ldr	r0, [r3, #0]
}
 8006eec:	4770      	bx	lr
 8006eee:	46c0      	nop			(mov r8, r8)
 8006ef0:	e000ed00 	.word	0xe000ed00

08006ef4 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
 8006ef4:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8006ef8:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8006efc:	4b01      	ldr	r3, [pc, #4]	(8006f04 <NVIC_SetVectorTable+0x10>)
 8006efe:	4301      	orrs	r1, r0
 8006f00:	6099      	str	r1, [r3, #8]
}
 8006f02:	4770      	bx	lr
 8006f04:	e000ed00 	.word	0xe000ed00

08006f08 <NVIC_GenerateSystemReset>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_GenerateSystemReset(void)
{
  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
 8006f08:	4a01      	ldr	r2, [pc, #4]	(8006f10 <NVIC_GenerateSystemReset+0x8>)
 8006f0a:	4b02      	ldr	r3, [pc, #8]	(8006f14 <NVIC_GenerateSystemReset+0xc>)
 8006f0c:	60da      	str	r2, [r3, #12]
}
 8006f0e:	4770      	bx	lr
 8006f10:	05fa0004 	.word	0x05fa0004
 8006f14:	e000ed00 	.word	0xe000ed00

08006f18 <NVIC_GenerateCoreReset>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_GenerateCoreReset(void)
{
  SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
 8006f18:	4a01      	ldr	r2, [pc, #4]	(8006f20 <NVIC_GenerateCoreReset+0x8>)
 8006f1a:	4b02      	ldr	r3, [pc, #8]	(8006f24 <NVIC_GenerateCoreReset+0xc>)
 8006f1c:	60da      	str	r2, [r3, #12]
}
 8006f1e:	4770      	bx	lr
 8006f20:	05fa0001 	.word	0x05fa0001
 8006f24:	e000ed00 	.word	0xe000ed00

08006f28 <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8006f28:	b121      	cbz	r1, 8006f34 <NVIC_SystemLPConfig+0xc>
  {
    SCB->SCR |= LowPowerMode;
 8006f2a:	4a05      	ldr	r2, [pc, #20]	(8006f40 <NVIC_SystemLPConfig+0x18>)
 8006f2c:	6913      	ldr	r3, [r2, #16]
 8006f2e:	ea40 0303 	orr.w	r3, r0, r3
 8006f32:	e003      	b.n	8006f3c <NVIC_SystemLPConfig+0x14>
  }
  else
  {
    SCB->SCR &= (u32)(~(u32)LowPowerMode);
 8006f34:	4a02      	ldr	r2, [pc, #8]	(8006f40 <NVIC_SystemLPConfig+0x18>)
 8006f36:	6913      	ldr	r3, [r2, #16]
 8006f38:	ea23 0300 	bic.w	r3, r3, r0
 8006f3c:	6113      	str	r3, [r2, #16]
  }
}
 8006f3e:	4770      	bx	lr
 8006f40:	e000ed00 	.word	0xe000ed00

08006f44 <NVIC_SystemHandlerConfig>:

  /* Check the parameters */
  assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
 8006f44:	f000 001f 	and.w	r0, r0, #31	; 0x1f
 8006f48:	2301      	movs	r3, #1
 8006f4a:	fa13 f000 	lsls.w	r0, r3, r0

  if (NewState != DISABLE)
 8006f4e:	b121      	cbz	r1, 8006f5a <NVIC_SystemHandlerConfig+0x16>
  {
    SCB->SHCSR |= tmpreg;
 8006f50:	4a05      	ldr	r2, [pc, #20]	(8006f68 <NVIC_SystemHandlerConfig+0x24>)
 8006f52:	6a53      	ldr	r3, [r2, #36]
 8006f54:	ea40 0303 	orr.w	r3, r0, r3
 8006f58:	e003      	b.n	8006f62 <NVIC_SystemHandlerConfig+0x1e>
  }
  else
  {
    SCB->SHCSR &= ~tmpreg;
 8006f5a:	4a03      	ldr	r2, [pc, #12]	(8006f68 <NVIC_SystemHandlerConfig+0x24>)
 8006f5c:	6a53      	ldr	r3, [r2, #36]
 8006f5e:	ea23 0300 	bic.w	r3, r3, r0
 8006f62:	6253      	str	r3, [r2, #36]
  }
}
 8006f64:	4770      	bx	lr
 8006f66:	46c0      	nop			(mov r8, r8)
 8006f68:	e000ed00 	.word	0xe000ed00

08006f6c <NVIC_SystemHandlerPriorityConfig>:
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
                                      u8 SystemHandlerSubPriority)
{
 8006f6c:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    
  tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
 8006f6e:	4c14      	ldr	r4, [pc, #80]	(8006fc0 <NVIC_SystemHandlerPriorityConfig+0x54>)
 8006f70:	68e3      	ldr	r3, [r4, #12]
 8006f72:	ea6f 0303 	mvn.w	r3, r3
 8006f76:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8006f7a:	0a1b      	lsrs	r3, r3, #8
  tmp1 = (0x4 - tmppriority);
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
 8006f7c:	f1c3 0c04 	rsb	ip, r3, #4	; 0x4
 8006f80:	fa01 f10c 	lsl.w	r1, r1, ip
  tmppriority |=  SystemHandlerSubPriority & tmp2;
 8006f84:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8006f88:	fa2c f303 	lsr.w	r3, ip, r3
 8006f8c:	401a      	ands	r2, r3
 8006f8e:	430a      	orrs	r2, r1

  tmppriority = tmppriority << 0x04;
  tmp1 = SystemHandler & (u32)0xC0;
 8006f90:	f000 01c0 	and.w	r1, r0, #192	; 0xc0
  tmp1 = tmp1 >> 0x06; 
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
 8006f94:	0940      	lsrs	r0, r0, #5
 8006f96:	f000 0018 	and.w	r0, r0, #24	; 0x18
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
 8006f9a:	fa0c fc00 	lsl.w	ip, ip, r0
  tmp2 = tmp2 >> tmppriority;
    
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
  tmppriority |=  SystemHandlerSubPriority & tmp2;

  tmppriority = tmppriority << 0x04;
 8006f9e:	0112      	lsls	r2, r2, #4
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
  SCB->SHPR[tmp1] |= tmppriority;
 8006fa0:	4082      	lsls	r2, r0
  tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
  tmppriority |=  SystemHandlerSubPriority & tmp2;

  tmppriority = tmppriority << 0x04;
  tmp1 = SystemHandler & (u32)0xC0;
  tmp1 = tmp1 >> 0x06; 
 8006fa2:	0989      	lsrs	r1, r1, #6
  tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
  tmppriority = tmppriority << (tmp2 * 0x08);
  handlermask = (u32)0xFF << (tmp2 * 0x08);
  
  SCB->SHPR[tmp1] &= ~handlermask;
 8006fa4:	3106      	adds	r1, #6
 8006fa6:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 8006faa:	ea23 030c 	bic.w	r3, r3, ip
 8006fae:	f844 3021 	str.w	r3, [r4, r1, lsl #2]
  SCB->SHPR[tmp1] |= tmppriority;
 8006fb2:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 8006fb6:	431a      	orrs	r2, r3
 8006fb8:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
}
 8006fbc:	bd10      	pop	{r4, pc}
 8006fbe:	46c0      	nop			(mov r8, r8)
 8006fc0:	e000ed00 	.word	0xe000ed00

08006fc4 <NVIC_GetSystemHandlerPendingBitStatus>:
  u32 tmp = 0x00, tmppos = 0x00;

  /* Check the parameters */
  assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
  
  tmppos = (SystemHandler >> 0x0A);
 8006fc4:	0a80      	lsrs	r0, r0, #10
  tmppos &= (u32)0x0F;

  tmppos = (u32)0x01 << tmppos;
 8006fc6:	f000 000f 	and.w	r0, r0, #15	; 0xf
 8006fca:	2301      	movs	r3, #1
 8006fcc:	4083      	lsls	r3, r0

  tmp = SCB->SHCSR & tmppos;
 8006fce:	4a04      	ldr	r2, [pc, #16]	(8006fe0 <NVIC_GetSystemHandlerPendingBitStatus+0x1c>)
 8006fd0:	6a50      	ldr	r0, [r2, #36]
 8006fd2:	ea03 0000 	and.w	r0, r3, r0
 8006fd6:	4298      	cmp	r0, r3
 8006fd8:	bf14      	ite	ne
 8006fda:	2000      	movne	r0, #0
 8006fdc:	2001      	moveq	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8006fde:	4770      	bx	lr
 8006fe0:	e000ed00 	.word	0xe000ed00

08006fe4 <NVIC_SetSystemHandlerPendingBit>:
  assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
  
  /* Get the System Handler pending bit position */
  tmp = SystemHandler & (u32)0x1F;
  /* Set the corresponding System Handler pending bit */
  SCB->ICSR |= ((u32)0x01 << tmp);
 8006fe4:	f000 001f 	and.w	r0, r0, #31	; 0x1f
 8006fe8:	2301      	movs	r3, #1
 8006fea:	4083      	lsls	r3, r0
 8006fec:	4a02      	ldr	r2, [pc, #8]	(8006ff8 <NVIC_SetSystemHandlerPendingBit+0x14>)
 8006fee:	6851      	ldr	r1, [r2, #4]
 8006ff0:	430b      	orrs	r3, r1
 8006ff2:	6053      	str	r3, [r2, #4]
}
 8006ff4:	4770      	bx	lr
 8006ff6:	46c0      	nop			(mov r8, r8)
 8006ff8:	e000ed00 	.word	0xe000ed00

08006ffc <NVIC_ClearSystemHandlerPendingBit>:
  assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
  
  /* Get the System Handler pending bit position */
  tmp = SystemHandler & (u32)0x1F;
  /* Clear the corresponding System Handler pending bit */
  SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
 8006ffc:	f000 001f 	and.w	r0, r0, #31	; 0x1f
 8007000:	3801      	subs	r0, #1
 8007002:	2301      	movs	r3, #1
 8007004:	4083      	lsls	r3, r0
 8007006:	4a02      	ldr	r2, [pc, #8]	(8007010 <NVIC_ClearSystemHandlerPendingBit+0x14>)
 8007008:	6851      	ldr	r1, [r2, #4]
 800700a:	430b      	orrs	r3, r1
 800700c:	6053      	str	r3, [r2, #4]
}
 800700e:	4770      	bx	lr
 8007010:	e000ed00 	.word	0xe000ed00

08007014 <NVIC_GetSystemHandlerActiveBitStatus>:
  /* Check the parameters */
  assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
  
  tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;

  tmppos = (u32)0x01 << tmppos;
 8007014:	0b80      	lsrs	r0, r0, #14
 8007016:	f000 000f 	and.w	r0, r0, #15	; 0xf
 800701a:	2301      	movs	r3, #1
 800701c:	4083      	lsls	r3, r0

  tmp = SCB->SHCSR & tmppos;
 800701e:	4a04      	ldr	r2, [pc, #16]	(8007030 <NVIC_GetSystemHandlerActiveBitStatus+0x1c>)
 8007020:	6a50      	ldr	r0, [r2, #36]
 8007022:	ea03 0000 	and.w	r0, r3, r0
 8007026:	4298      	cmp	r0, r3
 8007028:	bf14      	ite	ne
 800702a:	2000      	movne	r0, #0
 800702c:	2001      	moveq	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800702e:	4770      	bx	lr
 8007030:	e000ed00 	.word	0xe000ed00

08007034 <NVIC_GetFaultHandlerSources>:
  u32 tmpreg = 0x00, tmppos = 0x00;

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
 8007034:	0c83      	lsrs	r3, r0, #18
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;

  if (tmpreg == 0x00)
 8007036:	f013 0303 	ands.w	r3, r3, #3	; 0x3
 800703a:	d102      	bne.n	8007042 <NVIC_GetFaultHandlerSources+0xe>
  {
    faultsources = SCB->HFSR;
 800703c:	4b0d      	ldr	r3, [pc, #52]	(8007074 <NVIC_GetFaultHandlerSources+0x40>)
 800703e:	6ad8      	ldr	r0, [r3, #44]
 8007040:	e017      	b.n	8007072 <NVIC_GetFaultHandlerSources+0x3e>
  }
  else if (tmpreg == 0x01)
 8007042:	2b01      	cmp	r3, #1
 8007044:	d113      	bne.n	800706e <NVIC_GetFaultHandlerSources+0x3a>
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
 8007046:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800704a:	f503 436c 	add.w	r3, r3, #60416	; 0xec00
 800704e:	33fe      	adds	r3, #254

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;
 8007050:	0d02      	lsrs	r2, r0, #20
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
 8007052:	3301      	adds	r3, #1

  /* Check the parameters */
  assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
  
  tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
  tmppos = (SystemHandler >> 0x14) & (u32)0x03;
 8007054:	f002 0203 	and.w	r2, r2, #3	; 0x3
  {
    faultsources = SCB->HFSR;
  }
  else if (tmpreg == 0x01)
  {
    faultsources = SCB->CFSR >> (tmppos * 0x08);
 8007058:	6a99      	ldr	r1, [r3, #40]
 800705a:	00d3      	lsls	r3, r2, #3
 800705c:	fa31 f003 	lsrs.w	r0, r1, r3
    if (tmppos != 0x02)
 8007060:	2a02      	cmp	r2, #2
    {
      faultsources &= (u32)0x0F;
 8007062:	bf14      	ite	ne
 8007064:	f000 000f 	andne.w	r0, r0, #15	; 0xf
    }
    else
    {
      faultsources &= (u32)0xFF;
 8007068:	f000 00ff 	andeq.w	r0, r0, #255	; 0xff
 800706c:	e001      	b.n	8007072 <NVIC_GetFaultHandlerSources+0x3e>
    }
  }
  else
  {
    faultsources = SCB->DFSR;
 800706e:	4b01      	ldr	r3, [pc, #4]	(8007074 <NVIC_GetFaultHandlerSources+0x40>)
 8007070:	6b18      	ldr	r0, [r3, #48]
  }
  return faultsources;
}
 8007072:	4770      	bx	lr
 8007074:	e000ed00 	.word	0xe000ed00

08007078 <NVIC_GetFaultAddress>:
  /* Check the parameters */
  assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
  
  tmp = (SystemHandler >> 0x16) & (u32)0x01;

  if (tmp == 0x00)
 8007078:	f410 0f80 	tst.w	r0, #4194304	; 0x400000
  {
    faultaddress = SCB->MMFAR;
 800707c:	bf0b      	itete	eq
 800707e:	4b02      	ldreq	r3, [pc, #8]	(8007088 <NVIC_GetFaultAddress+0x10>)
  }
  else
  {
    faultaddress = SCB->BFAR;
 8007080:	4b01      	ldrne	r3, [pc, #4]	(8007088 <NVIC_GetFaultAddress+0x10>)
  
  tmp = (SystemHandler >> 0x16) & (u32)0x01;

  if (tmp == 0x00)
  {
    faultaddress = SCB->MMFAR;
 8007082:	6b58      	ldreq	r0, [r3, #52]
  }
  else
  {
    faultaddress = SCB->BFAR;
 8007084:	6b98      	ldrne	r0, [r3, #56]
  }
  return faultaddress;
}
 8007086:	4770      	bx	lr
 8007088:	e000ed00 	.word	0xe000ed00

0800708c <NVIC_GetBASEPRI>:
* Input          : None
* Output         : None
* Return         : BASEPRI register value
*******************************************************************************/
u32 NVIC_GetBASEPRI(void)
{
 800708c:	b500      	push	{lr}
 800708e:	b081      	sub	sp, #4
  return (__GetBASEPRI());
 8007090:	f000 fcc4 	bl	8007a1c <__GetBASEPRI>
}
 8007094:	b001      	add	sp, #4
 8007096:	bd00      	pop	{pc}

08007098 <NVIC_BASEPRICONFIG>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_BASEPRICONFIG(u32 NewPriority)
{
 8007098:	b500      	push	{lr}
  /* Check the parameters */
  assert_param(IS_NVIC_BASE_PRI(NewPriority));
  
  __BASEPRICONFIG(NewPriority << 0x04);
 800709a:	0100      	lsls	r0, r0, #4
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_BASEPRICONFIG(u32 NewPriority)
{
 800709c:	b081      	sub	sp, #4
  /* Check the parameters */
  assert_param(IS_NVIC_BASE_PRI(NewPriority));
  
  __BASEPRICONFIG(NewPriority << 0x04);
 800709e:	f000 fcba 	bl	8007a16 <__BASEPRICONFIG>
}
 80070a2:	b001      	add	sp, #4
 80070a4:	bd00      	pop	{pc}
 80070a6:	46c0      	nop			(mov r8, r8)

080070a8 <NVIC_RESETFAULTMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_RESETFAULTMASK(void)
{
 80070a8:	b500      	push	{lr}
 80070aa:	b081      	sub	sp, #4
  __RESETFAULTMASK();
 80070ac:	f000 fcb1 	bl	8007a12 <__RESETFAULTMASK>
}
 80070b0:	b001      	add	sp, #4
 80070b2:	bd00      	pop	{pc}

080070b4 <NVIC_SETFAULTMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SETFAULTMASK(void)
{
 80070b4:	b500      	push	{lr}
 80070b6:	b081      	sub	sp, #4
  __SETFAULTMASK();
 80070b8:	f000 fca9 	bl	8007a0e <__SETFAULTMASK>
}
 80070bc:	b001      	add	sp, #4
 80070be:	bd00      	pop	{pc}

080070c0 <NVIC_RESETPRIMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_RESETPRIMASK(void)
{
 80070c0:	b500      	push	{lr}
 80070c2:	b081      	sub	sp, #4
  __RESETPRIMASK();
 80070c4:	f000 fca1 	bl	8007a0a <__RESETPRIMASK>
}
 80070c8:	b001      	add	sp, #4
 80070ca:	bd00      	pop	{pc}

080070cc <NVIC_SETPRIMASK>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void NVIC_SETPRIMASK(void)
{
 80070cc:	b500      	push	{lr}
 80070ce:	b081      	sub	sp, #4
  __SETPRIMASK();
 80070d0:	f000 fc99 	bl	8007a06 <__SETPRIMASK>
}
 80070d4:	b001      	add	sp, #4
 80070d6:	bd00      	pop	{pc}

080070d8 <PWR_BackupAccessCmd>:
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_DBP_BB = (u32)NewState;
 80070d8:	4b01      	ldr	r3, [pc, #4]	(80070e0 <PWR_BackupAccessCmd+0x8>)
 80070da:	6018      	str	r0, [r3, #0]
}
 80070dc:	4770      	bx	lr
 80070de:	46c0      	nop			(mov r8, r8)
 80070e0:	420e0020 	.word	0x420e0020

080070e4 <PWR_PVDCmd>:
void PWR_PVDCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_PVDE_BB = (u32)NewState;
 80070e4:	4b01      	ldr	r3, [pc, #4]	(80070ec <PWR_PVDCmd+0x8>)
 80070e6:	6018      	str	r0, [r3, #0]
}
 80070e8:	4770      	bx	lr
 80070ea:	46c0      	nop			(mov r8, r8)
 80070ec:	420e0010 	.word	0x420e0010

080070f0 <PWR_PVDLevelConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));

  tmpreg = PWR->CR;
 80070f0:	4a03      	ldr	r2, [pc, #12]	(8007100 <PWR_PVDLevelConfig+0x10>)
 80070f2:	6813      	ldr	r3, [r2, #0]

  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_Mask;
 80070f4:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0

  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 80070f8:	4318      	orrs	r0, r3

  /* Store the new value */
  PWR->CR = tmpreg;
 80070fa:	6010      	str	r0, [r2, #0]
}
 80070fc:	4770      	bx	lr
 80070fe:	46c0      	nop			(mov r8, r8)
 8007100:	40007000 	.word	0x40007000

08007104 <PWR_WakeUpPinCmd>:
void PWR_WakeUpPinCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CSR_EWUP_BB = (u32)NewState;
 8007104:	4b01      	ldr	r3, [pc, #4]	(800710c <PWR_WakeUpPinCmd+0x8>)
 8007106:	6018      	str	r0, [r3, #0]
}
 8007108:	4770      	bx	lr
 800710a:	46c0      	nop			(mov r8, r8)
 800710c:	420e00a0 	.word	0x420e00a0

08007110 <PWR_GetFlagStatus>:
  FlagStatus bitstatus = RESET;

  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (u32)RESET)
 8007110:	4b03      	ldr	r3, [pc, #12]	(8007120 <PWR_GetFlagStatus+0x10>)
 8007112:	685b      	ldr	r3, [r3, #4]
 8007114:	4218      	tst	r0, r3
 8007116:	bf0c      	ite	eq
 8007118:	2000      	moveq	r0, #0
 800711a:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 800711c:	4770      	bx	lr
 800711e:	46c0      	nop			(mov r8, r8)
 8007120:	40007000 	.word	0x40007000

08007124 <PWR_ClearFlag>:
void PWR_ClearFlag(u32 PWR_FLAG)
{
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 8007124:	4a02      	ldr	r2, [pc, #8]	(8007130 <PWR_ClearFlag+0xc>)
 8007126:	6813      	ldr	r3, [r2, #0]
 8007128:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
 800712c:	6013      	str	r3, [r2, #0]
}
 800712e:	4770      	bx	lr
 8007130:	40007000 	.word	0x40007000

08007134 <PWR_EnterSTANDBYMode>:
* Return         : None
*******************************************************************************/
void PWR_EnterSTANDBYMode(void)
{
  /* Clear Wake-up flag */
  PWR->CR |= CR_CWUF_Set;
 8007134:	4a0b      	ldr	r2, [pc, #44]	(8007164 <PWR_EnterSTANDBYMode+0x30>)
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void PWR_EnterSTANDBYMode(void)
{
 8007136:	b500      	push	{lr}
  /* Clear Wake-up flag */
  PWR->CR |= CR_CWUF_Set;
 8007138:	6813      	ldr	r3, [r2, #0]
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void PWR_EnterSTANDBYMode(void)
{
 800713a:	b081      	sub	sp, #4
  /* Clear Wake-up flag */
  PWR->CR |= CR_CWUF_Set;
 800713c:	f043 0304 	orr.w	r3, r3, #4	; 0x4
 8007140:	6013      	str	r3, [r2, #0]

  /* Select STANDBY mode */
  PWR->CR |= CR_PDDS_Set;
 8007142:	6813      	ldr	r3, [r2, #0]
 8007144:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 8007148:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
 800714a:	f102 4220 	add.w	r2, r2, #2684354560	; 0xa0000000
 800714e:	f502 42fa 	add.w	r2, r2, #32000	; 0x7d00
 8007152:	3210      	adds	r2, #16
 8007154:	6813      	ldr	r3, [r2, #0]
 8007156:	f043 0304 	orr.w	r3, r3, #4	; 0x4
 800715a:	6013      	str	r3, [r2, #0]

  /* Request Wait For Interrupt */
  __WFI();
 800715c:	f000 fc2e 	bl	80079bc <__WFI>
}
 8007160:	b001      	add	sp, #4
 8007162:	bd00      	pop	{pc}
 8007164:	40007000 	.word	0x40007000

08007168 <PWR_EnterSTOPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 8007168:	4a0c      	ldr	r2, [pc, #48]	(800719c <PWR_EnterSTOPMode+0x34>)
*                       - PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
* Output         : None
* Return         : None
*******************************************************************************/
void PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry)
{
 800716a:	b500      	push	{lr}
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 800716c:	6813      	ldr	r3, [r2, #0]
*                       - PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
* Output         : None
* Return         : None
*******************************************************************************/
void PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry)
{
 800716e:	b081      	sub	sp, #4
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;

  /* Clear PDDS and LPDS bits */
  tmpreg &= CR_DS_Mask;
 8007170:	f023 0303 	bic.w	r3, r3, #3	; 0x3

  /* Set LPDS bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 8007174:	4318      	orrs	r0, r3

  /* Store the new value */
  PWR->CR = tmpreg;
 8007176:	6010      	str	r0, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
 8007178:	f102 4220 	add.w	r2, r2, #2684354560	; 0xa0000000
 800717c:	f502 42fa 	add.w	r2, r2, #32000	; 0x7d00
 8007180:	3210      	adds	r2, #16
 8007182:	6813      	ldr	r3, [r2, #0]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 8007184:	2901      	cmp	r1, #1

  /* Store the new value */
  PWR->CR = tmpreg;

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  *(vu32 *) SCB_SysCtrl |= SysCtrl_SLEEPDEEP_Set;
 8007186:	f043 0304 	orr.w	r3, r3, #4	; 0x4
 800718a:	6013      	str	r3, [r2, #0]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 800718c:	d102      	bne.n	8007194 <PWR_EnterSTOPMode+0x2c>
  {   
    /* Request Wait For Interrupt */
    __WFI();
 800718e:	f000 fc15 	bl	80079bc <__WFI>
 8007192:	e001      	b.n	8007198 <PWR_EnterSTOPMode+0x30>
  }
  else
  {
    /* Request Wait For Event */
    __WFE();
 8007194:	f000 fc14 	bl	80079c0 <__WFE>
  }
}
 8007198:	b001      	add	sp, #4
 800719a:	bd00      	pop	{pc}
 800719c:	40007000 	.word	0x40007000

080071a0 <PWR_DeInit>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void PWR_DeInit(void)
{
 80071a0:	b510      	push	{r4, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 80071a2:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
 80071a6:	4620      	mov	r0, r4
 80071a8:	2101      	movs	r1, #1
 80071aa:	f000 f97d 	bl	80074a8 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 80071ae:	4620      	mov	r0, r4
 80071b0:	2100      	movs	r1, #0
 80071b2:	f000 f979 	bl	80074a8 <RCC_APB1PeriphResetCmd>
}
 80071b6:	bd10      	pop	{r4, pc}

080071b8 <RCC_DeInit>:
* Return         : None
*******************************************************************************/
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (u32)0x00000001;
 80071b8:	4a0d      	ldr	r2, [pc, #52]	(80071f0 <RCC_DeInit+0x38>)
 80071ba:	6813      	ldr	r3, [r2, #0]
 80071bc:	f043 0301 	orr.w	r3, r3, #1	; 0x1
 80071c0:	6013      	str	r3, [r2, #0]

  /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits */
  RCC->CFGR &= (u32)0xF8FF0000;
 80071c2:	6851      	ldr	r1, [r2, #4]
 80071c4:	4b0b      	ldr	r3, [pc, #44]	(80071f4 <RCC_DeInit+0x3c>)
 80071c6:	ea01 0303 	and.w	r3, r1, r3
 80071ca:	6053      	str	r3, [r2, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (u32)0xFEF6FFFF;
 80071cc:	6813      	ldr	r3, [r2, #0]
 80071ce:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 80071d2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80071d6:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (u32)0xFFFBFFFF;
 80071d8:	6813      	ldr	r3, [r2, #0]
 80071da:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80071de:	6013      	str	r3, [r2, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
  RCC->CFGR &= (u32)0xFF80FFFF;
 80071e0:	6853      	ldr	r3, [r2, #4]
 80071e2:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 80071e6:	6053      	str	r3, [r2, #4]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80071e8:	2300      	movs	r3, #0
 80071ea:	6093      	str	r3, [r2, #8]
}
 80071ec:	4770      	bx	lr
 80071ee:	46c0      	nop			(mov r8, r8)
 80071f0:	40021000 	.word	0x40021000
 80071f4:	f8ff0000 	.word	0xf8ff0000

080071f8 <RCC_HSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80071f8:	4a0b      	ldr	r2, [pc, #44]	(8007228 <RCC_HSEConfig+0x30>)

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;

  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80071fa:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80071fe:	6813      	ldr	r3, [r2, #0]
 8007200:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8007204:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 8007206:	6813      	ldr	r3, [r2, #0]
 8007208:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800720c:	6013      	str	r3, [r2, #0]

  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 800720e:	d003      	beq.n	8007218 <RCC_HSEConfig+0x20>
 8007210:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8007214:	d107      	bne.n	8007226 <RCC_HSEConfig+0x2e>
 8007216:	e002      	b.n	800721e <RCC_HSEConfig+0x26>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 8007218:	6813      	ldr	r3, [r2, #0]
 800721a:	4303      	orrs	r3, r0
 800721c:	e002      	b.n	8007224 <RCC_HSEConfig+0x2c>
      break;
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 800721e:	6813      	ldr	r3, [r2, #0]
 8007220:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 8007224:	6013      	str	r3, [r2, #0]
      break;            
      
    default:
      break;      
  }
}
 8007226:	4770      	bx	lr
 8007228:	40021000 	.word	0x40021000

0800722c <RCC_WaitForHSEStartUp>:
* Return         : An ErrorStatus enumuration value:
*                         - SUCCESS: HSE oscillator is stable and ready to use
*                         - ERROR: HSE oscillator not yet ready
*******************************************************************************/
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800722c:	b082      	sub	sp, #8
  vu32 StartUpCounter = 0;
 800722e:	2300      	movs	r3, #0
  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8007230:	4909      	ldr	r1, [pc, #36]	(8007258 <RCC_WaitForHSEStartUp+0x2c>)
*                         - SUCCESS: HSE oscillator is stable and ready to use
*                         - ERROR: HSE oscillator not yet ready
*******************************************************************************/
ErrorStatus RCC_WaitForHSEStartUp(void)
{
  vu32 StartUpCounter = 0;
 8007232:	9301      	str	r3, [sp, #4]
  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8007234:	680a      	ldr	r2, [r1, #0]
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
 8007236:	9b01      	ldr	r3, [sp, #4]
 8007238:	3301      	adds	r3, #1
  } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
 800723a:	f412 3f00 	tst.w	r2, #131072	; 0x20000
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    StartUpCounter++;  
 800723e:	9301      	str	r3, [sp, #4]
  } while((HSEStatus == RESET) && (StartUpCounter != HSEStartUp_TimeOut));
 8007240:	d103      	bne.n	800724a <RCC_WaitForHSEStartUp+0x1e>
 8007242:	9b01      	ldr	r3, [sp, #4]
 8007244:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8007248:	d1f4      	bne.n	8007234 <RCC_WaitForHSEStartUp+0x8>
  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 800724a:	4b03      	ldr	r3, [pc, #12]	(8007258 <RCC_WaitForHSEStartUp+0x2c>)
 800724c:	6818      	ldr	r0, [r3, #0]
 800724e:	0c40      	lsrs	r0, r0, #17
 8007250:	f000 0001 	and.w	r0, r0, #1	; 0x1
  {
    status = ERROR;
  }  

  return (status);
}
 8007254:	b002      	add	sp, #8
 8007256:	4770      	bx	lr
 8007258:	40021000 	.word	0x40021000

0800725c <RCC_AdjustHSICalibrationValue>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 800725c:	4a03      	ldr	r2, [pc, #12]	(800726c <RCC_AdjustHSICalibrationValue+0x10>)
 800725e:	6813      	ldr	r3, [r2, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
 8007260:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (u32)HSICalibrationValue << 3;
 8007264:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 8007268:	6013      	str	r3, [r2, #0]
}
 800726a:	4770      	bx	lr
 800726c:	40021000 	.word	0x40021000

08007270 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_HSION_BB = (u32)NewState;
 8007270:	4b01      	ldr	r3, [pc, #4]	(8007278 <RCC_HSICmd+0x8>)
 8007272:	6018      	str	r0, [r3, #0]
}
 8007274:	4770      	bx	lr
 8007276:	46c0      	nop			(mov r8, r8)
 8007278:	42420000 	.word	0x42420000

0800727c <RCC_PLLConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 800727c:	4a03      	ldr	r2, [pc, #12]	(800728c <RCC_PLLConfig+0x10>)
 800727e:	6853      	ldr	r3, [r2, #4]

  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;

  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8007280:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8007284:	4318      	orrs	r0, r3
 8007286:	4308      	orrs	r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8007288:	6050      	str	r0, [r2, #4]
}
 800728a:	4770      	bx	lr
 800728c:	40021000 	.word	0x40021000

08007290 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_PLLON_BB = (u32)NewState;
 8007290:	4b01      	ldr	r3, [pc, #4]	(8007298 <RCC_PLLCmd+0x8>)
 8007292:	6018      	str	r0, [r3, #0]
}
 8007294:	4770      	bx	lr
 8007296:	46c0      	nop			(mov r8, r8)
 8007298:	42420060 	.word	0x42420060

0800729c <RCC_SYSCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 800729c:	4a03      	ldr	r2, [pc, #12]	(80072ac <RCC_SYSCLKConfig+0x10>)
 800729e:	6853      	ldr	r3, [r2, #4]

  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 80072a0:	f023 0303 	bic.w	r3, r3, #3	; 0x3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80072a4:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80072a6:	6050      	str	r0, [r2, #4]
}
 80072a8:	4770      	bx	lr
 80072aa:	46c0      	nop			(mov r8, r8)
 80072ac:	40021000 	.word	0x40021000

080072b0 <RCC_GetSYSCLKSource>:
*                       - 0x04: HSE used as system clock
*                       - 0x08: PLL used as system clock
*******************************************************************************/
u8 RCC_GetSYSCLKSource(void)
{
  return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
 80072b0:	4b02      	ldr	r3, [pc, #8]	(80072bc <RCC_GetSYSCLKSource+0xc>)
 80072b2:	6858      	ldr	r0, [r3, #4]
 80072b4:	f000 000c 	and.w	r0, r0, #12	; 0xc
}
 80072b8:	4770      	bx	lr
 80072ba:	46c0      	nop			(mov r8, r8)
 80072bc:	40021000 	.word	0x40021000

080072c0 <RCC_HCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 80072c0:	4a03      	ldr	r2, [pc, #12]	(80072d0 <RCC_HCLKConfig+0x10>)
 80072c2:	6853      	ldr	r3, [r2, #4]

  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 80072c4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 80072c8:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80072ca:	6050      	str	r0, [r2, #4]
}
 80072cc:	4770      	bx	lr
 80072ce:	46c0      	nop			(mov r8, r8)
 80072d0:	40021000 	.word	0x40021000

080072d4 <RCC_PCLK1Config>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80072d4:	4a03      	ldr	r2, [pc, #12]	(80072e4 <RCC_PCLK1Config+0x10>)
 80072d6:	6853      	ldr	r3, [r2, #4]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 80072d8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80072dc:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80072de:	6050      	str	r0, [r2, #4]
}
 80072e0:	4770      	bx	lr
 80072e2:	46c0      	nop			(mov r8, r8)
 80072e4:	40021000 	.word	0x40021000

080072e8 <RCC_PCLK2Config>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 80072e8:	4a03      	ldr	r2, [pc, #12]	(80072f8 <RCC_PCLK2Config+0x10>)
 80072ea:	6853      	ldr	r3, [r2, #4]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 80072ec:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80072f0:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80072f4:	6053      	str	r3, [r2, #4]
}
 80072f6:	4770      	bx	lr
 80072f8:	40021000 	.word	0x40021000

080072fc <RCC_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80072fc:	b121      	cbz	r1, 8007308 <RCC_ITConfig+0xc>
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
    *(vu8 *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80072fe:	4a05      	ldr	r2, [pc, #20]	(8007314 <RCC_ITConfig+0x18>)
 8007300:	7813      	ldrb	r3, [r2, #0]
 8007302:	ea40 0303 	orr.w	r3, r0, r3
 8007306:	e003      	b.n	8007310 <RCC_ITConfig+0x14>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
    *(vu8 *) CIR_BYTE2_ADDRESS &= (u8)~RCC_IT;
 8007308:	4a02      	ldr	r2, [pc, #8]	(8007314 <RCC_ITConfig+0x18>)
 800730a:	7813      	ldrb	r3, [r2, #0]
 800730c:	ea23 0300 	bic.w	r3, r3, r0
 8007310:	7013      	strb	r3, [r2, #0]
  }
}
 8007312:	4770      	bx	lr
 8007314:	40021009 	.word	0x40021009

08007318 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 8007318:	4b01      	ldr	r3, [pc, #4]	(8007320 <RCC_USBCLKConfig+0x8>)
 800731a:	6018      	str	r0, [r3, #0]
}
 800731c:	4770      	bx	lr
 800731e:	46c0      	nop			(mov r8, r8)
 8007320:	424200d8 	.word	0x424200d8

08007324 <RCC_ADCCLKConfig>:
  u32 tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));

  tmpreg = RCC->CFGR;
 8007324:	4a03      	ldr	r2, [pc, #12]	(8007334 <RCC_ADCCLKConfig+0x10>)
 8007326:	6853      	ldr	r3, [r2, #4]

  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 8007328:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000

  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 800732c:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800732e:	6050      	str	r0, [r2, #4]
}
 8007330:	4770      	bx	lr
 8007332:	46c0      	nop			(mov r8, r8)
 8007334:	40021000 	.word	0x40021000

08007338 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
 8007338:	4a06      	ldr	r2, [pc, #24]	(8007354 <RCC_LSEConfig+0x1c>)
 800733a:	2300      	movs	r3, #0

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 800733c:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
 800733e:	7013      	strb	r3, [r2, #0]

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;
 8007340:	7013      	strb	r3, [r2, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
 8007342:	bf08      	it	eq
 8007344:	7010      	strbeq	r0, [r2, #0]

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 8007346:	d003      	beq.n	8007350 <RCC_LSEConfig+0x18>
 8007348:	2804      	cmp	r0, #4
 800734a:	d101      	bne.n	8007350 <RCC_LSEConfig+0x18>
      *(vu8 *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(vu8 *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 800734c:	2305      	movs	r3, #5
 800734e:	7013      	strb	r3, [r2, #0]
      break;            
      
    default:
      break;      
  }
}
 8007350:	4770      	bx	lr
 8007352:	46c0      	nop			(mov r8, r8)
 8007354:	40021020 	.word	0x40021020

08007358 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CSR_LSION_BB = (u32)NewState;
 8007358:	4b01      	ldr	r3, [pc, #4]	(8007360 <RCC_LSICmd+0x8>)
 800735a:	6018      	str	r0, [r3, #0]
}
 800735c:	4770      	bx	lr
 800735e:	46c0      	nop			(mov r8, r8)
 8007360:	42420480 	.word	0x42420480

08007364 <RCC_RTCCLKConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8007364:	4a02      	ldr	r2, [pc, #8]	(8007370 <RCC_RTCCLKConfig+0xc>)
 8007366:	6a13      	ldr	r3, [r2, #32]
 8007368:	4318      	orrs	r0, r3
 800736a:	6210      	str	r0, [r2, #32]
}
 800736c:	4770      	bx	lr
 800736e:	46c0      	nop			(mov r8, r8)
 8007370:	40021000 	.word	0x40021000

08007374 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
 8007374:	4b01      	ldr	r3, [pc, #4]	(800737c <RCC_RTCCLKCmd+0x8>)
 8007376:	6018      	str	r0, [r3, #0]
}
 8007378:	4770      	bx	lr
 800737a:	46c0      	nop			(mov r8, r8)
 800737c:	4242043c 	.word	0x4242043c

08007380 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8007380:	4929      	ldr	r1, [pc, #164]	(8007428 <RCC_GetClocksFreq+0xa8>)
*                    will hold the clocks frequencies.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8007382:	4684      	mov	ip, r0
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8007384:	684b      	ldr	r3, [r1, #4]

  switch (tmp)
 8007386:	f003 030c 	and.w	r3, r3, #12	; 0xc
 800738a:	2b04      	cmp	r3, #4
 800738c:	d021      	beq.n	80073d2 <RCC_GetClocksFreq+0x52>
 800738e:	2b08      	cmp	r3, #8
 8007390:	d11f      	bne.n	80073d2 <RCC_GetClocksFreq+0x52>
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
      break;

    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8007392:	684b      	ldr	r3, [r1, #4]
      pllmull = ( pllmull >> 18) + 2;
 8007394:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8007398:	0c9b      	lsrs	r3, r3, #18
 800739a:	1c9a      	adds	r2, r3, #2

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 800739c:	684b      	ldr	r3, [r1, #4]

      if (pllsource == 0x00)
 800739e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
 80073a2:	bf08      	it	eq
 80073a4:	ebc2 1342 	rsbeq	r3, r2, r2, lsl #5
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
      pllmull = ( pllmull >> 18) + 2;

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;

      if (pllsource == 0x00)
 80073a8:	d006      	beq.n	80073b8 <RCC_GetClocksFreq+0x38>
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
      }
      else
      {/* HSE selected as PLL clock entry */

        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
 80073aa:	684b      	ldr	r3, [r1, #4]
 80073ac:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80073b0:	ea4f 1342 	mov.w	r3, r2, lsl #5
 80073b4:	d006      	beq.n	80073c4 <RCC_GetClocksFreq+0x44>
        {/* HSE oscillator clock divided by 2 */

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 80073b6:	1a9b      	subs	r3, r3, r2
 80073b8:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 80073bc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80073c0:	021b      	lsls	r3, r3, #8
 80073c2:	e007      	b.n	80073d4 <RCC_GetClocksFreq+0x54>
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 80073c4:	1a9b      	subs	r3, r3, r2
 80073c6:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 80073ca:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80073ce:	025b      	lsls	r3, r3, #9
 80073d0:	e000      	b.n	80073d4 <RCC_GetClocksFreq+0x54>
        }
      }
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 80073d2:	4b16      	ldr	r3, [pc, #88]	(800742c <RCC_GetClocksFreq+0xac>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80073d4:	4814      	ldr	r0, [pc, #80]	(8007428 <RCC_GetClocksFreq+0xa8>)
        }
      }
      break;

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 80073d6:	f8cc 3000 	str.w	r3, [ip]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80073da:	6843      	ldr	r3, [r0, #4]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80073dc:	4a14      	ldr	r2, [pc, #80]	(8007430 <RCC_GetClocksFreq+0xb0>)
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80073de:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80073e2:	091b      	lsrs	r3, r3, #4
 80073e4:	5cd3      	ldrb	r3, [r2, r3]
 80073e6:	f8dc 1000 	ldr.w	r1, [ip]
 80073ea:	40d9      	lsrs	r1, r3
 80073ec:	f8cc 1004 	str.w	r1, [ip, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 80073f0:	6843      	ldr	r3, [r0, #4]
 80073f2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  tmp = tmp >> 8;
  presc = APBAHBPrescTable[tmp];

  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80073f6:	0a1b      	lsrs	r3, r3, #8
 80073f8:	5cd3      	ldrb	r3, [r2, r3]
 80073fa:	fa31 f303 	lsrs.w	r3, r1, r3
 80073fe:	f8cc 3008 	str.w	r3, [ip, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 8007402:	6843      	ldr	r3, [r0, #4]
 8007404:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
  tmp = tmp >> 11;
  presc = APBAHBPrescTable[tmp];

  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8007408:	0adb      	lsrs	r3, r3, #11
 800740a:	5cd3      	ldrb	r3, [r2, r3]
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];

  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 800740c:	4a09      	ldr	r2, [pc, #36]	(8007434 <RCC_GetClocksFreq+0xb4>)
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
  tmp = tmp >> 11;
  presc = APBAHBPrescTable[tmp];

  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800740e:	40d9      	lsrs	r1, r3
 8007410:	f8cc 100c 	str.w	r1, [ip, #12]

  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8007414:	6843      	ldr	r3, [r0, #4]
 8007416:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  tmp = tmp >> 14;
  presc = ADCPrescTable[tmp];

  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 800741a:	0b9b      	lsrs	r3, r3, #14
 800741c:	5cd3      	ldrb	r3, [r2, r3]
 800741e:	fbb1 f1f3 	udiv	r1, r1, r3
 8007422:	f8cc 1010 	str.w	r1, [ip, #16]
}
 8007426:	4770      	bx	lr
 8007428:	40021000 	.word	0x40021000
 800742c:	007a1200 	.word	0x007a1200
 8007430:	08007c76 	.word	0x08007c76
 8007434:	08007c86 	.word	0x08007c86

08007438 <RCC_AHBPeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8007438:	b121      	cbz	r1, 8007444 <RCC_AHBPeriphClockCmd+0xc>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800743a:	4a05      	ldr	r2, [pc, #20]	(8007450 <RCC_AHBPeriphClockCmd+0x18>)
 800743c:	6953      	ldr	r3, [r2, #20]
 800743e:	ea40 0303 	orr.w	r3, r0, r3
 8007442:	e003      	b.n	800744c <RCC_AHBPeriphClockCmd+0x14>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8007444:	4a02      	ldr	r2, [pc, #8]	(8007450 <RCC_AHBPeriphClockCmd+0x18>)
 8007446:	6953      	ldr	r3, [r2, #20]
 8007448:	ea23 0300 	bic.w	r3, r3, r0
 800744c:	6153      	str	r3, [r2, #20]
  }
}
 800744e:	4770      	bx	lr
 8007450:	40021000 	.word	0x40021000

08007454 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8007454:	b121      	cbz	r1, 8007460 <RCC_APB2PeriphClockCmd+0xc>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8007456:	4a05      	ldr	r2, [pc, #20]	(800746c <RCC_APB2PeriphClockCmd+0x18>)
 8007458:	6993      	ldr	r3, [r2, #24]
 800745a:	ea40 0303 	orr.w	r3, r0, r3
 800745e:	e003      	b.n	8007468 <RCC_APB2PeriphClockCmd+0x14>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8007460:	4a02      	ldr	r2, [pc, #8]	(800746c <RCC_APB2PeriphClockCmd+0x18>)
 8007462:	6993      	ldr	r3, [r2, #24]
 8007464:	ea23 0300 	bic.w	r3, r3, r0
 8007468:	6193      	str	r3, [r2, #24]
  }
}
 800746a:	4770      	bx	lr
 800746c:	40021000 	.word	0x40021000

08007470 <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8007470:	b121      	cbz	r1, 800747c <RCC_APB1PeriphClockCmd+0xc>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8007472:	4a05      	ldr	r2, [pc, #20]	(8007488 <RCC_APB1PeriphClockCmd+0x18>)
 8007474:	69d3      	ldr	r3, [r2, #28]
 8007476:	ea40 0303 	orr.w	r3, r0, r3
 800747a:	e003      	b.n	8007484 <RCC_APB1PeriphClockCmd+0x14>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800747c:	4a02      	ldr	r2, [pc, #8]	(8007488 <RCC_APB1PeriphClockCmd+0x18>)
 800747e:	69d3      	ldr	r3, [r2, #28]
 8007480:	ea23 0300 	bic.w	r3, r3, r0
 8007484:	61d3      	str	r3, [r2, #28]
  }
}
 8007486:	4770      	bx	lr
 8007488:	40021000 	.word	0x40021000

0800748c <RCC_APB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800748c:	b121      	cbz	r1, 8007498 <RCC_APB2PeriphResetCmd+0xc>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800748e:	4a05      	ldr	r2, [pc, #20]	(80074a4 <RCC_APB2PeriphResetCmd+0x18>)
 8007490:	68d3      	ldr	r3, [r2, #12]
 8007492:	ea40 0303 	orr.w	r3, r0, r3
 8007496:	e003      	b.n	80074a0 <RCC_APB2PeriphResetCmd+0x14>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8007498:	4a02      	ldr	r2, [pc, #8]	(80074a4 <RCC_APB2PeriphResetCmd+0x18>)
 800749a:	68d3      	ldr	r3, [r2, #12]
 800749c:	ea23 0300 	bic.w	r3, r3, r0
 80074a0:	60d3      	str	r3, [r2, #12]
  }
}
 80074a2:	4770      	bx	lr
 80074a4:	40021000 	.word	0x40021000

080074a8 <RCC_APB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80074a8:	b121      	cbz	r1, 80074b4 <RCC_APB1PeriphResetCmd+0xc>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80074aa:	4a05      	ldr	r2, [pc, #20]	(80074c0 <RCC_APB1PeriphResetCmd+0x18>)
 80074ac:	6913      	ldr	r3, [r2, #16]
 80074ae:	ea40 0303 	orr.w	r3, r0, r3
 80074b2:	e003      	b.n	80074bc <RCC_APB1PeriphResetCmd+0x14>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80074b4:	4a02      	ldr	r2, [pc, #8]	(80074c0 <RCC_APB1PeriphResetCmd+0x18>)
 80074b6:	6913      	ldr	r3, [r2, #16]
 80074b8:	ea23 0300 	bic.w	r3, r3, r0
 80074bc:	6113      	str	r3, [r2, #16]
  }
}
 80074be:	4770      	bx	lr
 80074c0:	40021000 	.word	0x40021000

080074c4 <RCC_BackupResetCmd>:
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
 80074c4:	4b01      	ldr	r3, [pc, #4]	(80074cc <RCC_BackupResetCmd+0x8>)
 80074c6:	6018      	str	r0, [r3, #0]
}
 80074c8:	4770      	bx	lr
 80074ca:	46c0      	nop			(mov r8, r8)
 80074cc:	42420440 	.word	0x42420440

080074d0 <RCC_ClockSecuritySystemCmd>:
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_CSSON_BB = (u32)NewState;
 80074d0:	4b01      	ldr	r3, [pc, #4]	(80074d8 <RCC_ClockSecuritySystemCmd+0x8>)
 80074d2:	6018      	str	r0, [r3, #0]
}
 80074d4:	4770      	bx	lr
 80074d6:	46c0      	nop			(mov r8, r8)
 80074d8:	4242004c 	.word	0x4242004c

080074dc <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO[2:0] bits to select the MCO source */
  *(vu8 *) CFGR_BYTE4_ADDRESS = RCC_MCO;
 80074dc:	4b01      	ldr	r3, [pc, #4]	(80074e4 <RCC_MCOConfig+0x8>)
 80074de:	7018      	strb	r0, [r3, #0]
}
 80074e0:	4770      	bx	lr
 80074e2:	46c0      	nop			(mov r8, r8)
 80074e4:	40021007 	.word	0x40021007

080074e8 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 80074e8:	0943      	lsrs	r3, r0, #5

  if (tmp == 1)               /* The flag to check is in CR register */
 80074ea:	2b01      	cmp	r3, #1
 80074ec:	d108      	bne.n	8007500 <RCC_GetFlagStatus+0x18>
  {
    statusreg = RCC->CR;
 80074ee:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80074f2:	f503 3302 	add.w	r3, r3, #133120	; 0x20800
 80074f6:	f503 63ff 	add.w	r3, r3, #2040	; 0x7f8
 80074fa:	3307      	adds	r3, #7
 80074fc:	681b      	ldr	r3, [r3, #0]
 80074fe:	e00c      	b.n	800751a <RCC_GetFlagStatus+0x32>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8007500:	2b02      	cmp	r3, #2
 8007502:	d108      	bne.n	8007516 <RCC_GetFlagStatus+0x2e>
  {
    statusreg = RCC->BDCR;
 8007504:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007508:	f503 3302 	add.w	r3, r3, #133120	; 0x20800
 800750c:	f503 63ff 	add.w	r3, r3, #2040	; 0x7f8
 8007510:	3306      	adds	r3, #6
 8007512:	6a1b      	ldr	r3, [r3, #32]
 8007514:	e001      	b.n	800751a <RCC_GetFlagStatus+0x32>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8007516:	4b04      	ldr	r3, [pc, #16]	(8007528 <RCC_GetFlagStatus+0x40>)
 8007518:	6a5b      	ldr	r3, [r3, #36]
 800751a:	f000 001f 	and.w	r0, r0, #31	; 0x1f
 800751e:	fa33 f000 	lsrs.w	r0, r3, r0
 8007522:	f000 0001 	and.w	r0, r0, #1	; 0x1
    bitstatus = RESET;
  }

  /* Return the flag status */
  return bitstatus;
}
 8007526:	4770      	bx	lr
 8007528:	40021000 	.word	0x40021000

0800752c <RCC_ClearFlag>:
* Return         : None
*******************************************************************************/
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 800752c:	4a02      	ldr	r2, [pc, #8]	(8007538 <RCC_ClearFlag+0xc>)
 800752e:	6a53      	ldr	r3, [r2, #36]
 8007530:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8007534:	6253      	str	r3, [r2, #36]
}
 8007536:	4770      	bx	lr
 8007538:	40021000 	.word	0x40021000

0800753c <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (u32)RESET)
 800753c:	4b03      	ldr	r3, [pc, #12]	(800754c <RCC_GetITStatus+0x10>)
 800753e:	689b      	ldr	r3, [r3, #8]
 8007540:	4218      	tst	r0, r3
 8007542:	bf0c      	ite	eq
 8007544:	2000      	moveq	r0, #0
 8007546:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the RCC_IT status */
  return  bitstatus;
}
 8007548:	4770      	bx	lr
 800754a:	46c0      	nop			(mov r8, r8)
 800754c:	40021000 	.word	0x40021000

08007550 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(vu8 *) CIR_BYTE3_ADDRESS = RCC_IT;
 8007550:	4b01      	ldr	r3, [pc, #4]	(8007558 <RCC_ClearITPendingBit+0x8>)
 8007552:	7018      	strb	r0, [r3, #0]
}
 8007554:	4770      	bx	lr
 8007556:	46c0      	nop			(mov r8, r8)
 8007558:	4002100a 	.word	0x4002100a

0800755c <SysTick_CLKSourceConfig>:
void SysTick_CLKSourceConfig(u32 SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));

  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 800755c:	2804      	cmp	r0, #4
 800755e:	d103      	bne.n	8007568 <SysTick_CLKSourceConfig+0xc>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8007560:	4a04      	ldr	r2, [pc, #16]	(8007574 <SysTick_CLKSourceConfig+0x18>)
 8007562:	6813      	ldr	r3, [r2, #0]
 8007564:	4303      	orrs	r3, r0
 8007566:	e003      	b.n	8007570 <SysTick_CLKSourceConfig+0x14>
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8007568:	4a02      	ldr	r2, [pc, #8]	(8007574 <SysTick_CLKSourceConfig+0x18>)
 800756a:	6813      	ldr	r3, [r2, #0]
 800756c:	f023 0304 	bic.w	r3, r3, #4	; 0x4
 8007570:	6013      	str	r3, [r2, #0]
  }
}
 8007572:	4770      	bx	lr
 8007574:	e000e010 	.word	0xe000e010

08007578 <SysTick_SetReload>:
void SysTick_SetReload(u32 Reload)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_RELOAD(Reload));

  SysTick->LOAD = Reload;
 8007578:	4b01      	ldr	r3, [pc, #4]	(8007580 <SysTick_SetReload+0x8>)
 800757a:	6058      	str	r0, [r3, #4]
}
 800757c:	4770      	bx	lr
 800757e:	46c0      	nop			(mov r8, r8)
 8007580:	e000e010 	.word	0xe000e010

08007584 <SysTick_CounterCmd>:
void SysTick_CounterCmd(u32 SysTick_Counter)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_COUNTER(SysTick_Counter));

  if (SysTick_Counter == SysTick_Counter_Enable)
 8007584:	2801      	cmp	r0, #1
 8007586:	d103      	bne.n	8007590 <SysTick_CounterCmd+0xc>
  {
    SysTick->CTRL |= SysTick_Counter_Enable;
 8007588:	4a08      	ldr	r2, [pc, #32]	(80075ac <SysTick_CounterCmd+0x28>)
 800758a:	6813      	ldr	r3, [r2, #0]
 800758c:	4303      	orrs	r3, r0
 800758e:	e006      	b.n	800759e <SysTick_CounterCmd+0x1a>
  }
  else if (SysTick_Counter == SysTick_Counter_Disable) 
 8007590:	f110 0f02 	cmn.w	r0, #2	; 0x2
 8007594:	d105      	bne.n	80075a2 <SysTick_CounterCmd+0x1e>
  {
    SysTick->CTRL &= SysTick_Counter_Disable;
 8007596:	4a05      	ldr	r2, [pc, #20]	(80075ac <SysTick_CounterCmd+0x28>)
 8007598:	6813      	ldr	r3, [r2, #0]
 800759a:	f023 0301 	bic.w	r3, r3, #1	; 0x1
 800759e:	6013      	str	r3, [r2, #0]
 80075a0:	e002      	b.n	80075a8 <SysTick_CounterCmd+0x24>
  }
  else /* SysTick_Counter == SysTick_Counter_Clear */
  {
    SysTick->VAL = SysTick_Counter_Clear;
 80075a2:	4b02      	ldr	r3, [pc, #8]	(80075ac <SysTick_CounterCmd+0x28>)
 80075a4:	2200      	movs	r2, #0
 80075a6:	609a      	str	r2, [r3, #8]
  }    
}
 80075a8:	4770      	bx	lr
 80075aa:	46c0      	nop			(mov r8, r8)
 80075ac:	e000e010 	.word	0xe000e010

080075b0 <SysTick_ITConfig>:
void SysTick_ITConfig(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80075b0:	b120      	cbz	r0, 80075bc <SysTick_ITConfig+0xc>
  {
    SysTick->CTRL |= CTRL_TICKINT_Set;
 80075b2:	4a05      	ldr	r2, [pc, #20]	(80075c8 <SysTick_ITConfig+0x18>)
 80075b4:	6813      	ldr	r3, [r2, #0]
 80075b6:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 80075ba:	e003      	b.n	80075c4 <SysTick_ITConfig+0x14>
  }
  else
  {
    SysTick->CTRL &= CTRL_TICKINT_Reset;
 80075bc:	4a02      	ldr	r2, [pc, #8]	(80075c8 <SysTick_ITConfig+0x18>)
 80075be:	6813      	ldr	r3, [r2, #0]
 80075c0:	f023 0302 	bic.w	r3, r3, #2	; 0x2
 80075c4:	6013      	str	r3, [r2, #0]
  }
}
 80075c6:	4770      	bx	lr
 80075c8:	e000e010 	.word	0xe000e010

080075cc <SysTick_GetCounter>:
* Output         : None
* Return         : SysTick current value
*******************************************************************************/
u32 SysTick_GetCounter(void)
{
  return(SysTick->VAL);
 80075cc:	4b01      	ldr	r3, [pc, #4]	(80075d4 <SysTick_GetCounter+0x8>)
 80075ce:	6898      	ldr	r0, [r3, #8]
}
 80075d0:	4770      	bx	lr
 80075d2:	46c0      	nop			(mov r8, r8)
 80075d4:	e000e010 	.word	0xe000e010

080075d8 <SysTick_GetFlagStatus>:
  assert_param(IS_SYSTICK_FLAG(SysTick_FLAG));

  /* Get the SysTick register index */
  tmp = SysTick_FLAG >> 3;

  if (tmp == 2) /* The flag to check is in CTRL register */
 80075d8:	08c3      	lsrs	r3, r0, #3
 80075da:	2b02      	cmp	r3, #2
*                       - SysTick_FLAG_NOREF
* Output         : None
* Return         : None
*******************************************************************************/
FlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG)
{
 80075dc:	4602      	mov	r2, r0
  assert_param(IS_SYSTICK_FLAG(SysTick_FLAG));

  /* Get the SysTick register index */
  tmp = SysTick_FLAG >> 3;

  if (tmp == 2) /* The flag to check is in CTRL register */
 80075de:	d106      	bne.n	80075ee <SysTick_GetFlagStatus+0x16>
  {
    statusreg = SysTick->CTRL;
 80075e0:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 80075e4:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
 80075e8:	330e      	adds	r3, #14
 80075ea:	6818      	ldr	r0, [r3, #0]
 80075ec:	e001      	b.n	80075f2 <SysTick_GetFlagStatus+0x1a>
  }
  else          /* The flag to check is in CALIB register */
  {
    statusreg = SysTick->CALIB;
 80075ee:	4b03      	ldr	r3, [pc, #12]	(80075fc <SysTick_GetFlagStatus+0x24>)
 80075f0:	68d8      	ldr	r0, [r3, #12]
 80075f2:	40d0      	lsrs	r0, r2
 80075f4:	f000 0001 	and.w	r0, r0, #1	; 0x1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80075f8:	4770      	bx	lr
 80075fa:	46c0      	nop			(mov r8, r8)
 80075fc:	e000e010 	.word	0xe000e010

08007600 <USART_StructInit>:
* Return         : None
*******************************************************************************/
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 8007600:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8007604:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 8007606:	f04f 0300 	mov.w	r3, #0	; 0x0
 800760a:	8083      	strh	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 800760c:	80c3      	strh	r3, [r0, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 800760e:	8103      	strh	r3, [r0, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8007610:	f04f 030c 	mov.w	r3, #12	; 0xc
 8007614:	8143      	strh	r3, [r0, #10]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 8007616:	f04f 0300 	mov.w	r3, #0	; 0x0
 800761a:	8183      	strh	r3, [r0, #12]
}
 800761c:	4770      	bx	lr
 800761e:	46c0      	nop			(mov r8, r8)

08007620 <USART_ClockInit>:
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
 8007620:	f8b1 c000 	ldrh.w	ip, [r1]
 8007624:	884b      	ldrh	r3, [r1, #2]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8007626:	8a02      	ldrh	r2, [r0, #16]
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
 8007628:	ea43 030c 	orr.w	r3, r3, ip
 800762c:	f8b1 c004 	ldrh.w	ip, [r1, #4]
 8007630:	88c9      	ldrh	r1, [r1, #6]
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
 8007632:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
 8007636:	ea43 030c 	orr.w	r3, r3, ip
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
 800763a:	0412      	lsls	r2, r2, #16
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
 800763c:	430b      	orrs	r3, r1
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= CR2_CLOCK_CLEAR_Mask;
 800763e:	0c12      	lsrs	r2, r2, #16
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;

  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
 8007640:	b29b      	uxth	r3, r3
 8007642:	4313      	orrs	r3, r2
 8007644:	8203      	strh	r3, [r0, #16]
}
 8007646:	4770      	bx	lr

08007648 <USART_ClockStructInit>:
* Return         : None
*******************************************************************************/
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 8007648:	f04f 0300 	mov.w	r3, #0	; 0x0
 800764c:	8003      	strh	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 800764e:	8043      	strh	r3, [r0, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8007650:	8083      	strh	r3, [r0, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8007652:	80c3      	strh	r3, [r0, #6]
}
 8007654:	4770      	bx	lr
 8007656:	46c0      	nop			(mov r8, r8)

08007658 <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007658:	b121      	cbz	r1, 8007664 <USART_Cmd+0xc>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 800765a:	8983      	ldrh	r3, [r0, #12]
 800765c:	b29b      	uxth	r3, r3
 800765e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8007662:	e004      	b.n	800766e <USART_Cmd+0x16>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 8007664:	8983      	ldrh	r3, [r0, #12]
 8007666:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800766a:	041b      	lsls	r3, r3, #16
 800766c:	0c1b      	lsrs	r3, r3, #16
 800766e:	8183      	strh	r3, [r0, #12]
  }
}
 8007670:	4770      	bx	lr
 8007672:	46c0      	nop			(mov r8, r8)

08007674 <USART_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  usartxbase = (*(u32*)&(USARTx));

  /* Get the USART register index */
  usartreg = (((u8)USART_IT) >> 0x05);
 8007674:	b2cb      	uxtb	r3, r1
 8007676:	ea4f 1c53 	mov.w	ip, r3, lsr #5

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;

  itmask = (((u32)0x01) << itpos);
 800767a:	f001 011f 	and.w	r1, r1, #31	; 0x1f
 800767e:	2301      	movs	r3, #1
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
{
 8007680:	b082      	sub	sp, #8
  usartreg = (((u8)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;

  itmask = (((u32)0x01) << itpos);
 8007682:	fa13 f101 	lsls.w	r1, r3, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8007686:	f1bc 0f01 	cmp.w	ip, #1	; 0x1
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
{
 800768a:	9001      	str	r0, [sp, #4]
  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;

  itmask = (((u32)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 800768c:	d101      	bne.n	8007692 <USART_ITConfig+0x1e>
  {
    usartxbase += 0x0C;
 800768e:	300c      	adds	r0, #12
 8007690:	e005      	b.n	800769e <USART_ITConfig+0x2a>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8007692:	f1bc 0f02 	cmp.w	ip, #2	; 0x2
 8007696:	d101      	bne.n	800769c <USART_ITConfig+0x28>
  {
    usartxbase += 0x10;
 8007698:	3010      	adds	r0, #16
 800769a:	e000      	b.n	800769e <USART_ITConfig+0x2a>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 800769c:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
 800769e:	b112      	cbz	r2, 80076a6 <USART_ITConfig+0x32>
  {
    *(vu32*)usartxbase  |= itmask;
 80076a0:	6803      	ldr	r3, [r0, #0]
 80076a2:	430b      	orrs	r3, r1
 80076a4:	e002      	b.n	80076ac <USART_ITConfig+0x38>
  }
  else
  {
    *(vu32*)usartxbase &= ~itmask;
 80076a6:	6803      	ldr	r3, [r0, #0]
 80076a8:	ea23 0301 	bic.w	r3, r3, r1
 80076ac:	6003      	str	r3, [r0, #0]
  }
}
 80076ae:	b002      	add	sp, #8
 80076b0:	4770      	bx	lr
 80076b2:	46c0      	nop			(mov r8, r8)

080076b4 <USART_DMACmd>:
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80076b4:	b122      	cbz	r2, 80076c0 <USART_DMACmd+0xc>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80076b6:	8a83      	ldrh	r3, [r0, #20]
 80076b8:	b29b      	uxth	r3, r3
 80076ba:	ea41 0303 	orr.w	r3, r1, r3
 80076be:	e003      	b.n	80076c8 <USART_DMACmd+0x14>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (u16)~USART_DMAReq;
 80076c0:	8a83      	ldrh	r3, [r0, #20]
 80076c2:	b29b      	uxth	r3, r3
 80076c4:	ea23 0301 	bic.w	r3, r3, r1
 80076c8:	8283      	strh	r3, [r0, #20]
  }
}
 80076ca:	4770      	bx	lr

080076cc <USART_SetAddress>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= CR2_Address_Mask;
 80076cc:	8a03      	ldrh	r3, [r0, #16]
 80076ce:	f023 030f 	bic.w	r3, r3, #15	; 0xf
 80076d2:	041b      	lsls	r3, r3, #16
 80076d4:	0c1b      	lsrs	r3, r3, #16
 80076d6:	8203      	strh	r3, [r0, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
 80076d8:	8a03      	ldrh	r3, [r0, #16]
 80076da:	b29b      	uxth	r3, r3
 80076dc:	430b      	orrs	r3, r1
 80076de:	8203      	strh	r3, [r0, #16]
}
 80076e0:	4770      	bx	lr
 80076e2:	46c0      	nop			(mov r8, r8)

080076e4 <USART_WakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= CR1_WAKE_Mask;
 80076e4:	8983      	ldrh	r3, [r0, #12]
 80076e6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80076ea:	041b      	lsls	r3, r3, #16
 80076ec:	0c1b      	lsrs	r3, r3, #16
 80076ee:	8183      	strh	r3, [r0, #12]
  USARTx->CR1 |= USART_WakeUp;
 80076f0:	8983      	ldrh	r3, [r0, #12]
 80076f2:	b29b      	uxth	r3, r3
 80076f4:	4319      	orrs	r1, r3
 80076f6:	8181      	strh	r1, [r0, #12]
}
 80076f8:	4770      	bx	lr
 80076fa:	46c0      	nop			(mov r8, r8)

080076fc <USART_ReceiverWakeUpCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 80076fc:	b121      	cbz	r1, 8007708 <USART_ReceiverWakeUpCmd+0xc>
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= CR1_RWU_Set;
 80076fe:	8983      	ldrh	r3, [r0, #12]
 8007700:	b29b      	uxth	r3, r3
 8007702:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 8007706:	e004      	b.n	8007712 <USART_ReceiverWakeUpCmd+0x16>
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= CR1_RWU_Reset;
 8007708:	8983      	ldrh	r3, [r0, #12]
 800770a:	f023 0302 	bic.w	r3, r3, #2	; 0x2
 800770e:	041b      	lsls	r3, r3, #16
 8007710:	0c1b      	lsrs	r3, r3, #16
 8007712:	8183      	strh	r3, [r0, #12]
  }
}
 8007714:	4770      	bx	lr
 8007716:	46c0      	nop			(mov r8, r8)

08007718 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= CR2_LBDL_Mask;
 8007718:	8a03      	ldrh	r3, [r0, #16]
 800771a:	f023 0320 	bic.w	r3, r3, #32	; 0x20
 800771e:	041b      	lsls	r3, r3, #16
 8007720:	0c1b      	lsrs	r3, r3, #16
 8007722:	8203      	strh	r3, [r0, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 8007724:	8a03      	ldrh	r3, [r0, #16]
 8007726:	b29b      	uxth	r3, r3
 8007728:	4319      	orrs	r1, r3
 800772a:	8201      	strh	r1, [r0, #16]
}
 800772c:	4770      	bx	lr
 800772e:	46c0      	nop			(mov r8, r8)

08007730 <USART_LINCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8007730:	b121      	cbz	r1, 800773c <USART_LINCmd+0xc>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= CR2_LINEN_Set;
 8007732:	8a03      	ldrh	r3, [r0, #16]
 8007734:	b29b      	uxth	r3, r3
 8007736:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800773a:	e004      	b.n	8007746 <USART_LINCmd+0x16>
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= CR2_LINEN_Reset;
 800773c:	8a03      	ldrh	r3, [r0, #16]
 800773e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007742:	041b      	lsls	r3, r3, #16
 8007744:	0c1b      	lsrs	r3, r3, #16
 8007746:	8203      	strh	r3, [r0, #16]
  }
}
 8007748:	4770      	bx	lr
 800774a:	46c0      	nop			(mov r8, r8)

0800774c <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (u16)0x01FF);
 800774c:	05c9      	lsls	r1, r1, #23
 800774e:	0dc9      	lsrs	r1, r1, #23
 8007750:	8081      	strh	r1, [r0, #4]
}
 8007752:	4770      	bx	lr

08007754 <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (u16)(USARTx->DR & (u16)0x01FF);
 8007754:	8880      	ldrh	r0, [r0, #4]
 8007756:	05c0      	lsls	r0, r0, #23
 8007758:	0dc0      	lsrs	r0, r0, #23
}
 800775a:	4770      	bx	lr

0800775c <USART_SendBreak>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= CR1_SBK_Set;
 800775c:	8983      	ldrh	r3, [r0, #12]
 800775e:	b29b      	uxth	r3, r3
 8007760:	f043 0301 	orr.w	r3, r3, #1	; 0x1
 8007764:	8183      	strh	r3, [r0, #12]
}
 8007766:	4770      	bx	lr

08007768 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= GTPR_LSB_Mask;
 8007768:	8b03      	ldrh	r3, [r0, #24]
 800776a:	b2db      	uxtb	r3, r3
 800776c:	8303      	strh	r3, [r0, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
 800776e:	8b03      	ldrh	r3, [r0, #24]
 8007770:	b29b      	uxth	r3, r3
 8007772:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007776:	8303      	strh	r3, [r0, #24]
}
 8007778:	4770      	bx	lr
 800777a:	46c0      	nop			(mov r8, r8)

0800777c <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= GTPR_MSB_Mask;
 800777c:	8b03      	ldrh	r3, [r0, #24]
 800777e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8007782:	8303      	strh	r3, [r0, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8007784:	8b03      	ldrh	r3, [r0, #24]
 8007786:	b29b      	uxth	r3, r3
 8007788:	430b      	orrs	r3, r1
 800778a:	8303      	strh	r3, [r0, #24]
}
 800778c:	4770      	bx	lr
 800778e:	46c0      	nop			(mov r8, r8)

08007790 <USART_SmartCardCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8007790:	b121      	cbz	r1, 800779c <USART_SmartCardCmd+0xc>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= CR3_SCEN_Set;
 8007792:	8a83      	ldrh	r3, [r0, #20]
 8007794:	b29b      	uxth	r3, r3
 8007796:	f043 0320 	orr.w	r3, r3, #32	; 0x20
 800779a:	e004      	b.n	80077a6 <USART_SmartCardCmd+0x16>
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= CR3_SCEN_Reset;
 800779c:	8a83      	ldrh	r3, [r0, #20]
 800779e:	f023 0320 	bic.w	r3, r3, #32	; 0x20
 80077a2:	041b      	lsls	r3, r3, #16
 80077a4:	0c1b      	lsrs	r3, r3, #16
 80077a6:	8283      	strh	r3, [r0, #20]
  }
}
 80077a8:	4770      	bx	lr
 80077aa:	46c0      	nop			(mov r8, r8)

080077ac <USART_SmartCardNACKCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80077ac:	b121      	cbz	r1, 80077b8 <USART_SmartCardNACKCmd+0xc>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= CR3_NACK_Set;
 80077ae:	8a83      	ldrh	r3, [r0, #20]
 80077b0:	b29b      	uxth	r3, r3
 80077b2:	f043 0310 	orr.w	r3, r3, #16	; 0x10
 80077b6:	e004      	b.n	80077c2 <USART_SmartCardNACKCmd+0x16>
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= CR3_NACK_Reset;
 80077b8:	8a83      	ldrh	r3, [r0, #20]
 80077ba:	f023 0310 	bic.w	r3, r3, #16	; 0x10
 80077be:	041b      	lsls	r3, r3, #16
 80077c0:	0c1b      	lsrs	r3, r3, #16
 80077c2:	8283      	strh	r3, [r0, #20]
  }
}
 80077c4:	4770      	bx	lr
 80077c6:	46c0      	nop			(mov r8, r8)

080077c8 <USART_HalfDuplexCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80077c8:	b121      	cbz	r1, 80077d4 <USART_HalfDuplexCmd+0xc>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= CR3_HDSEL_Set;
 80077ca:	8a83      	ldrh	r3, [r0, #20]
 80077cc:	b29b      	uxth	r3, r3
 80077ce:	f043 0308 	orr.w	r3, r3, #8	; 0x8
 80077d2:	e004      	b.n	80077de <USART_HalfDuplexCmd+0x16>
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= CR3_HDSEL_Reset;
 80077d4:	8a83      	ldrh	r3, [r0, #20]
 80077d6:	f023 0308 	bic.w	r3, r3, #8	; 0x8
 80077da:	041b      	lsls	r3, r3, #16
 80077dc:	0c1b      	lsrs	r3, r3, #16
 80077de:	8283      	strh	r3, [r0, #20]
  }
}
 80077e0:	4770      	bx	lr
 80077e2:	46c0      	nop			(mov r8, r8)

080077e4 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= CR3_IRLP_Mask;
 80077e4:	8a83      	ldrh	r3, [r0, #20]
 80077e6:	f023 0304 	bic.w	r3, r3, #4	; 0x4
 80077ea:	041b      	lsls	r3, r3, #16
 80077ec:	0c1b      	lsrs	r3, r3, #16
 80077ee:	8283      	strh	r3, [r0, #20]
  USARTx->CR3 |= USART_IrDAMode;
 80077f0:	8a83      	ldrh	r3, [r0, #20]
 80077f2:	b29b      	uxth	r3, r3
 80077f4:	4319      	orrs	r1, r3
 80077f6:	8281      	strh	r1, [r0, #20]
}
 80077f8:	4770      	bx	lr
 80077fa:	46c0      	nop			(mov r8, r8)

080077fc <USART_IrDACmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 80077fc:	b121      	cbz	r1, 8007808 <USART_IrDACmd+0xc>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= CR3_IREN_Set;
 80077fe:	8a83      	ldrh	r3, [r0, #20]
 8007800:	b29b      	uxth	r3, r3
 8007802:	f043 0302 	orr.w	r3, r3, #2	; 0x2
 8007806:	e004      	b.n	8007812 <USART_IrDACmd+0x16>
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= CR3_IREN_Reset;
 8007808:	8a83      	ldrh	r3, [r0, #20]
 800780a:	f023 0302 	bic.w	r3, r3, #2	; 0x2
 800780e:	041b      	lsls	r3, r3, #16
 8007810:	0c1b      	lsrs	r3, r3, #16
 8007812:	8283      	strh	r3, [r0, #20]
  }
}
 8007814:	4770      	bx	lr
 8007816:	46c0      	nop			(mov r8, r8)

08007818 <USART_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_FLAG(USART_FLAG));
  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   

  if ((USARTx->SR & USART_FLAG) != (u16)RESET)
 8007818:	8803      	ldrh	r3, [r0, #0]
 800781a:	4219      	tst	r1, r3
 800781c:	bf0c      	ite	eq
 800781e:	2000      	moveq	r0, #0
 8007820:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8007822:	4770      	bx	lr

08007824 <USART_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
  assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART4 and UART5 */   
   
  USARTx->SR = (u16)~USART_FLAG;
 8007824:	ea6f 0101 	mvn.w	r1, r1
 8007828:	b289      	uxth	r1, r1
 800782a:	8001      	strh	r1, [r0, #0]
}
 800782c:	4770      	bx	lr
 800782e:	46c0      	nop			(mov r8, r8)

08007830 <USART_GetITStatus>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_GET_IT(USART_IT));
  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */  
  
  /* Get the USART register index */
  usartreg = (((u8)USART_IT) >> 0x05);
 8007830:	b2cb      	uxtb	r3, r1
 8007832:	ea4f 1c53 	mov.w	ip, r3, lsr #5

  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;

  itmask = (u32)0x01 << itmask;
 8007836:	f001 021f 	and.w	r2, r1, #31	; 0x1f
 800783a:	2301      	movs	r3, #1
 800783c:	fa13 f202 	lsls.w	r2, r3, r2
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8007840:	f1bc 0f01 	cmp.w	ip, #1	; 0x1
  {
    itmask &= USARTx->CR1;
 8007844:	bf08      	it	eq
 8007846:	8983      	ldrheq	r3, [r0, #12]
  /* Get the interrupt position */
  itmask = USART_IT & IT_Mask;

  itmask = (u32)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8007848:	d004      	beq.n	8007854 <USART_GetITStatus+0x24>
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 800784a:	f1bc 0f02 	cmp.w	ip, #2	; 0x2
  {
    itmask &= USARTx->CR2;
 800784e:	bf0c      	ite	eq
 8007850:	8a03      	ldrheq	r3, [r0, #16]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8007852:	8a83      	ldrhne	r3, [r0, #20]
 8007854:	b29b      	uxth	r3, r3
 8007856:	ea02 0c03 	and.w	ip, r2, r3
  }
  
  bitpos = USART_IT >> 0x08;

  bitpos = (u32)0x01 << bitpos;
 800785a:	0a0b      	lsrs	r3, r1, #8
 800785c:	2201      	movs	r2, #1
 800785e:	409a      	lsls	r2, r3
  bitpos &= USARTx->SR;
 8007860:	8803      	ldrh	r3, [r0, #0]
 8007862:	b29b      	uxth	r3, r3

  if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
 8007864:	421a      	tst	r2, r3
 8007866:	bf0c      	ite	eq
 8007868:	2000      	moveq	r0, #0
 800786a:	2001      	movne	r0, #1
 800786c:	f1bc 0f00 	cmp.w	ip, #0	; 0x0
 8007870:	bf0c      	ite	eq
 8007872:	2000      	moveq	r0, #0
 8007874:	f000 0001 	andne.w	r0, r0, #1	; 0x1
  {
    bitstatus = RESET;
  }
  
  return bitstatus;  
}
 8007878:	4770      	bx	lr
 800787a:	46c0      	nop			(mov r8, r8)

0800787c <USART_ClearITPendingBit>:
  assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UART4 and UART5 */
  
  bitpos = USART_IT >> 0x08;

  itmask = (u16)((u16)0x01 << bitpos);
  USARTx->SR = (u16)~itmask;
 800787c:	0a09      	lsrs	r1, r1, #8
 800787e:	2301      	movs	r3, #1
 8007880:	408b      	lsls	r3, r1
 8007882:	ea6f 0303 	mvn.w	r3, r3
 8007886:	b29b      	uxth	r3, r3
 8007888:	8003      	strh	r3, [r0, #0]
}
 800788a:	4770      	bx	lr

0800788c <USART_Init>:
  assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
  
  usartxbase = (*(u32*)&USARTx);

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 800788c:	8a03      	ldrh	r3, [r0, #16]
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (u32)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
 800788e:	88ca      	ldrh	r2, [r1, #6]
  usartxbase = (*(u32*)&USARTx);

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 8007890:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8007894:	041b      	lsls	r3, r3, #16
 8007896:	0c1b      	lsrs	r3, r3, #16
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (u32)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (u16)tmpreg;
 8007898:	4313      	orrs	r3, r2
 800789a:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 800789c:	8982      	ldrh	r2, [r0, #12]
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800789e:	b570      	push	{r4, r5, r6, lr}
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
 80078a0:	890b      	ldrh	r3, [r1, #8]
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80078a2:	460e      	mov	r6, r1
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
 80078a4:	8889      	ldrh	r1, [r1, #4]
  USARTx->CR2 = (u16)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80078a6:	f422 52b0 	bic.w	r2, r2, #5632	; 0x1600
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
 80078aa:	430b      	orrs	r3, r1
 80078ac:	8971      	ldrh	r1, [r6, #10]
  USARTx->CR2 = (u16)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80078ae:	f022 020c 	bic.w	r2, r2, #12	; 0xc
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
 80078b2:	430b      	orrs	r3, r1
  USARTx->CR2 = (u16)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80078b4:	0412      	lsls	r2, r2, #16
 80078b6:	0c12      	lsrs	r2, r2, #16
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (u16)tmpreg;
 80078b8:	b29b      	uxth	r3, r3
 80078ba:	4313      	orrs	r3, r2
 80078bc:	8183      	strh	r3, [r0, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80078be:	8a83      	ldrh	r3, [r0, #20]
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (u16)tmpreg;
 80078c0:	89b2      	ldrh	r2, [r6, #12]
  USARTx->CR1 = (u16)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 80078c2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80078c6:	041b      	lsls	r3, r3, #16
 80078c8:	0c1b      	lsrs	r3, r3, #16
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80078ca:	b088      	sub	sp, #32
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (u16)tmpreg;
 80078cc:	4313      	orrs	r3, r2
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80078ce:	4605      	mov	r5, r0
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (u16)tmpreg;
 80078d0:	8283      	strh	r3, [r0, #20]
*                    specified USART peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80078d2:	9001      	str	r0, [sp, #4]
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  /* The hardware flow control is available only for USART1, USART2 and USART3 */          
  assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
  
  usartxbase = (*(u32*)&USARTx);
 80078d4:	4604      	mov	r4, r0
  /* Write to USART CR3 */
  USARTx->CR3 = (u16)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 80078d6:	a803      	add	r0, sp, #12
 80078d8:	f7ff fd52 	bl	8007380 <RCC_GetClocksFreq>
  if (usartxbase == USART1_BASE)
 80078dc:	4b10      	ldr	r3, [pc, #64]	(8007920 <USART_Init+0x94>)
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }

  /* Determine the integer part */
  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
  tmpreg = (integerdivider / 0x64) << 0x04;
 80078de:	4811      	ldr	r0, [pc, #68]	(8007924 <USART_Init+0x98>)
  USARTx->CR3 = (u16)tmpreg;

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
  if (usartxbase == USART1_BASE)
 80078e0:	429d      	cmp	r5, r3
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 80078e2:	bf0c      	ite	eq
 80078e4:	9b06      	ldreq	r3, [sp, #24]
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 80078e6:	9b05      	ldrne	r3, [sp, #20]
  }

  /* Determine the integer part */
  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
 80078e8:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 80078ec:	6833      	ldr	r3, [r6, #0]
 80078ee:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 80078f2:	009b      	lsls	r3, r3, #2
 80078f4:	fbb1 f1f3 	udiv	r1, r1, r3
  tmpreg = (integerdivider / 0x64) << 0x04;
 80078f8:	fba1 2300 	umull	r2, r3, r1, r0

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 80078fc:	2264      	movs	r2, #100
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }

  /* Determine the integer part */
  integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
  tmpreg = (integerdivider / 0x64) << 0x04;
 80078fe:	ea4f 1c53 	mov.w	ip, r3, lsr #5

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 8007902:	fb0c 1212 	mls	r2, ip, r2, r1
 8007906:	0112      	lsls	r2, r2, #4
 8007908:	3232      	adds	r2, #50
 800790a:	fba2 2300 	umull	r2, r3, r2, r0
 800790e:	095b      	lsrs	r3, r3, #5
 8007910:	f003 030f 	and.w	r3, r3, #15	; 0xf

  /* Write to USART BRR */
  USARTx->BRR = (u16)tmpreg;
 8007914:	ea43 130c 	orr.w	r3, r3, ip, lsl #4
 8007918:	b29b      	uxth	r3, r3
 800791a:	812b      	strh	r3, [r5, #8]
}
 800791c:	b008      	add	sp, #32
 800791e:	bd70      	pop	{r4, r5, r6, pc}
 8007920:	40013800 	.word	0x40013800
 8007924:	51eb851f 	.word	0x51eb851f

08007928 <USART_DeInit>:
*                     - USART1, USART2, USART3, UART4 or UART5.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_DeInit(USART_TypeDef* USARTx)
{
 8007928:	b500      	push	{lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
 800792a:	4b22      	ldr	r3, [pc, #136]	(80079b4 <USART_DeInit+0x8c>)
*                     - USART1, USART2, USART3, UART4 or UART5.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_DeInit(USART_TypeDef* USARTx)
{
 800792c:	b083      	sub	sp, #12
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
 800792e:	4298      	cmp	r0, r3
*                     - USART1, USART2, USART3, UART4 or UART5.
* Output         : None
* Return         : None
*******************************************************************************/
void USART_DeInit(USART_TypeDef* USARTx)
{
 8007930:	9001      	str	r0, [sp, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  switch (*(u32*)&USARTx)
 8007932:	d02b      	beq.n	800798c <USART_DeInit+0x64>
 8007934:	d808      	bhi.n	8007948 <USART_DeInit+0x20>
 8007936:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 800793a:	4298      	cmp	r0, r3
 800793c:	d016      	beq.n	800796c <USART_DeInit+0x44>
 800793e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8007942:	4298      	cmp	r0, r3
 8007944:	d134      	bne.n	80079b0 <USART_DeInit+0x88>
 8007946:	e019      	b.n	800797c <USART_DeInit+0x54>
 8007948:	4b1b      	ldr	r3, [pc, #108]	(80079b8 <USART_DeInit+0x90>)
 800794a:	4298      	cmp	r0, r3
 800794c:	d026      	beq.n	800799c <USART_DeInit+0x74>
 800794e:	f503 4368 	add.w	r3, r3, #59392	; 0xe800
 8007952:	4298      	cmp	r0, r3
 8007954:	d12c      	bne.n	80079b0 <USART_DeInit+0x88>
  {
    case USART1_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 8007956:	2101      	movs	r1, #1
 8007958:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800795c:	f7ff fd96 	bl	800748c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 8007960:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8007964:	2100      	movs	r1, #0
 8007966:	f7ff fd91 	bl	800748c <RCC_APB2PeriphResetCmd>
 800796a:	e021      	b.n	80079b0 <USART_DeInit+0x88>
      break;

    case USART2_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 800796c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8007970:	2101      	movs	r1, #1
 8007972:	f7ff fd99 	bl	80074a8 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 8007976:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800797a:	e016      	b.n	80079aa <USART_DeInit+0x82>
      break;

    case USART3_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 800797c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8007980:	2101      	movs	r1, #1
 8007982:	f7ff fd91 	bl	80074a8 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 8007986:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800798a:	e00e      	b.n	80079aa <USART_DeInit+0x82>
      break;
    
    case UART4_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 800798c:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8007990:	2101      	movs	r1, #1
 8007992:	f7ff fd89 	bl	80074a8 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 8007996:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800799a:	e006      	b.n	80079aa <USART_DeInit+0x82>
      break;
    
    case UART5_BASE:
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 800799c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80079a0:	2101      	movs	r1, #1
 80079a2:	f7ff fd81 	bl	80074a8 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 80079a6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80079aa:	2100      	movs	r1, #0
 80079ac:	f7ff fd7c 	bl	80074a8 <RCC_APB1PeriphResetCmd>
      break;            

    default:
      break;
  }
}
 80079b0:	b003      	add	sp, #12
 80079b2:	bd00      	pop	{pc}
 80079b4:	40004c00 	.word	0x40004c00
 80079b8:	40005000 	.word	0x40005000

080079bc <__WFI>:
; Return         : None
;******************************************************************************/
.thumb_func
__WFI: 
 
    WFI
 80079bc:	bf30      	wfi
    BX r14
 80079be:	4770      	bx	lr

080079c0 <__WFE>:
; Return         : None
;******************************************************************************/
.thumb_func
__WFE:

    WFE
 80079c0:	bf20      	wfe
    BX r14
 80079c2:	4770      	bx	lr

080079c4 <__SEV>:
; Return         : None
;******************************************************************************/
.thumb_func
__SEV:

    SEV
 80079c4:	bf40      	sev
    BX r14
 80079c6:	4770      	bx	lr

080079c8 <__ISB>:
; Return         : None
;******************************************************************************/
.thumb_func
__ISB:

    ISB
 80079c8:	f3bf 8f6f 	isb	sy
    BX r14
 80079cc:	4770      	bx	lr

080079ce <__DSB>:
; Return         : None
;******************************************************************************/
.thumb_func
__DSB:

    DSB
 80079ce:	f3bf 8f4f 	dsb	sy
    BX r14
 80079d2:	4770      	bx	lr

080079d4 <__DMB>:
; Return         : None
;******************************************************************************/
.thumb_func
__DMB:

    DMB
 80079d4:	f3bf 8f5f 	dmb	sy
    BX r14
 80079d8:	4770      	bx	lr

080079da <__SVC>:
; Return         : None
;******************************************************************************/
.thumb_func
__SVC:

    SVC 0x01
 80079da:	df01      	svc	1
    BX r14
 80079dc:	4770      	bx	lr

080079de <__MRS_CONTROL>:
; Return         : - r4 : Cortex-M3 CONTROL register value.
;******************************************************************************/
.thumb_func
__MRS_CONTROL:

  MRS  r0,control
 80079de:	f3ef 8014 	mrs	r0, CONTROL
  BX r14
 80079e2:	4770      	bx	lr

080079e4 <__MSR_CONTROL>:
; Return         : None
;******************************************************************************/
.thumb_func
__MSR_CONTROL:

  MSR control, r0
 80079e4:	f380 8814 	msr	CONTROL, r0
  ISB
 80079e8:	f3bf 8f6f 	isb	sy
  BX r14
 80079ec:	4770      	bx	lr

080079ee <__MRS_PSP>:
; Return         : - r0 : Process Stack value.
;******************************************************************************/
.thumb_func
__MRS_PSP:

  MRS r0, psp
 80079ee:	f3ef 8009 	mrs	r0, PSP
  BX r14
 80079f2:	4770      	bx	lr

080079f4 <__MSR_PSP>:
; Return         : None
;******************************************************************************/
.thumb_func
__MSR_PSP:
 
    MSR psp,  r0      /* set Process Stack value*/
 80079f4:	f380 8809 	msr	PSP, r0
    BX r14
 80079f8:	4770      	bx	lr

080079fa <__MRS_MSP>:
; Return         : - r0 : Main Stack value.
;******************************************************************************/
.thumb_func
__MRS_MSP:

  MRS r0, msp
 80079fa:	f3ef 8008 	mrs	r0, MSP
  BX r14
 80079fe:	4770      	bx	lr

08007a00 <__MSR_MSP>:
; Return         : None
;******************************************************************************/
.thumb_func
__MSR_MSP: 
 
    MSR msp, r0  /*; set Main Stack value*/
 8007a00:	f380 8808 	msr	MSP, r0
    BX r14
 8007a04:	4770      	bx	lr

08007a06 <__SETPRIMASK>:
; Return         : None
;******************************************************************************/
.thumb_func
__SETPRIMASK:

  CPSID i
 8007a06:	b672      	cpsid	i
  BX r14
 8007a08:	4770      	bx	lr

08007a0a <__RESETPRIMASK>:
; Return         : None
;******************************************************************************/
.thumb_func
__RESETPRIMASK:

  CPSIE i
 8007a0a:	b662      	cpsie	i
  BX r14
 8007a0c:	4770      	bx	lr

08007a0e <__SETFAULTMASK>:
; Return         : None
;******************************************************************************/
.thumb_func
__SETFAULTMASK:

  CPSID f
 8007a0e:	b671      	cpsid	f
  BX r14
 8007a10:	4770      	bx	lr

08007a12 <__RESETFAULTMASK>:
; Return         : None
;******************************************************************************/
.thumb_func
__RESETFAULTMASK:

  CPSIE f
 8007a12:	b661      	cpsie	f
  BX r14
 8007a14:	4770      	bx	lr

08007a16 <__BASEPRICONFIG>:
; Return         : None
;******************************************************************************/
.thumb_func
__BASEPRICONFIG:

  MSR basepri, r0
 8007a16:	f380 8811 	msr	BASEPRI, r0
  BX r14
 8007a1a:	4770      	bx	lr

08007a1c <__GetBASEPRI>:
; Return         : - r0 : Base Priority value 
;******************************************************************************/
.thumb_func
__GetBASEPRI:

  MRS r0, basepri_max
 8007a1c:	f3ef 8012 	mrs	r0, BASEPRI_MASK
  BX r14
 8007a20:	4770      	bx	lr

08007a22 <__REV_HalfWord>:
; Return         : - r0 : holds tve variable value after byte reversing.
;******************************************************************************/
.thumb_func
__REV_HalfWord: 
 
  REV16 r0, r0
 8007a22:	ba40      	rev16	r0, r0
  BX r14
 8007a24:	4770      	bx	lr

08007a26 <__REV_Word>:
; Return         : - r0 : holds tve variable value after byte reversing.
;******************************************************************************/
.thumb_func
__REV_Word: 
 
  REV r0, r0
 8007a26:	ba00      	rev	r0, r0
  BX r14
 8007a28:	4770      	bx	lr
	...

08007a2c <Reset_Handler>:
* Input          :
* Output         :
* Return         :
*******************************************************************************/
void Reset_Handler(void)
{
 8007a2c:	f02d 0107 	bic.w	r1, sp, #7	; 0x7
 8007a30:	4668      	mov	r0, sp
 8007a32:	468d      	mov	sp, r1
 8007a34:	b501      	push	{r0, lr}
 8007a36:	2200      	movs	r2, #0

    //
    // Copy the data segment initializers from flash to SRAM.
    //
    pulSrc = &_sidata;
    for(pulDest = &_sdata; pulDest < &_edata; )
 8007a38:	490c      	ldr	r1, [pc, #48]	(8007a6c <Reset_Handler+0x40>)
 8007a3a:	f8df c034 	ldr.w	ip, [pc, #52]	; 8007a70 <Reset_Handler+0x44>
    {
        *(pulDest++) = *(pulSrc++);
 8007a3e:	480d      	ldr	r0, [pc, #52]	(8007a74 <Reset_Handler+0x48>)
 8007a40:	e002      	b.n	8007a48 <Reset_Handler+0x1c>
 8007a42:	5883      	ldr	r3, [r0, r2]
 8007a44:	508b      	str	r3, [r1, r2]
 8007a46:	3204      	adds	r2, #4

    //
    // Copy the data segment initializers from flash to SRAM.
    //
    pulSrc = &_sidata;
    for(pulDest = &_sdata; pulDest < &_edata; )
 8007a48:	eb01 0302 	add.w	r3, r1, r2
 8007a4c:	4563      	cmp	r3, ip
 8007a4e:	d3f8      	bcc.n	8007a42 <Reset_Handler+0x16>
 8007a50:	4b09      	ldr	r3, [pc, #36]	(8007a78 <Reset_Handler+0x4c>)
    }

    //
    // Zero fill the bss segment.
    //
    for(pulDest = &_sbss; pulDest < &_ebss; )
 8007a52:	490a      	ldr	r1, [pc, #40]	(8007a7c <Reset_Handler+0x50>)
    {
        *(pulDest++) = 0;
 8007a54:	2200      	movs	r2, #0
 8007a56:	e001      	b.n	8007a5c <Reset_Handler+0x30>
 8007a58:	f843 2b04 	str.w	r2, [r3], #4
    }

    //
    // Zero fill the bss segment.
    //
    for(pulDest = &_sbss; pulDest < &_ebss; )
 8007a5c:	428b      	cmp	r3, r1
 8007a5e:	d3fb      	bcc.n	8007a58 <Reset_Handler+0x2c>
    }

    //
    // Call the application's entry point.
    //
    main();
 8007a60:	f7fb fb6a 	bl	8003138 <main>
}
 8007a64:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
 8007a68:	4685      	mov	sp, r0
 8007a6a:	4770      	bx	lr
 8007a6c:	20000000 	.word	0x20000000
 8007a70:	200004e0 	.word	0x200004e0
 8007a74:	080083e0 	.word	0x080083e0
 8007a78:	200004e0 	.word	0x200004e0
 8007a7c:	20001a18 	.word	0x20001a18

08007a80 <exit>:
 8007a80:	e3a01000 	mov	r1, #0	; 0x0
 8007a84:	e1a04000 	mov	r4, r0
 8007a88:	eb000008 	bl	8007ab0 <__call_exitprocs>
 8007a8c:	e59f3018 	ldr	r3, [pc, #24]	; 8007aac <exit+0x2c>
 8007a90:	e5930000 	ldr	r0, [r3]
 8007a94:	e590203c 	ldr	r2, [r0, #60]
 8007a98:	e3520000 	cmp	r2, #0	; 0x0
 8007a9c:	11a0e00f 	movne	lr, pc
 8007aa0:	112fff12 	bxne	r2
 8007aa4:	e1a00004 	mov	r0, r4
 8007aa8:	faffeda1 	blx	8003134 <_exit>
 8007aac:	08007c8c 	.word	0x08007c8c

08007ab0 <__call_exitprocs>:
 8007ab0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007ab4:	e59f30fc 	ldr	r3, [pc, #252]	; 8007bb8 <__call_exitprocs+0x108>
 8007ab8:	e593a000 	ldr	sl, [r3]
 8007abc:	e24dd00c 	sub	sp, sp, #12	; 0xc
 8007ac0:	e59a3148 	ldr	r3, [sl, #328]
 8007ac4:	e58d0004 	str	r0, [sp, #4]
 8007ac8:	e1a07001 	mov	r7, r1
 8007acc:	e3a09001 	mov	r9, #1	; 0x1
 8007ad0:	e3a0b000 	mov	fp, #0	; 0x0
 8007ad4:	e2536000 	subs	r6, r3, #0	; 0x0
 8007ad8:	0a00000d 	beq	8007b14 <__call_exitprocs+0x64>
 8007adc:	e5933004 	ldr	r3, [r3, #4]
 8007ae0:	e2535001 	subs	r5, r3, #1	; 0x1
 8007ae4:	4a00000a 	bmi	8007b14 <__call_exitprocs+0x64>
 8007ae8:	e2833042 	add	r3, r3, #66	; 0x42
 8007aec:	e1a03103 	lsl	r3, r3, #2
 8007af0:	e0864003 	add	r4, r6, r3
 8007af4:	e3570000 	cmp	r7, #0	; 0x0
 8007af8:	0a000008 	beq	8007b20 <__call_exitprocs+0x70>
 8007afc:	e5143004 	ldr	r3, [r4, #-4]
 8007b00:	e1530007 	cmp	r3, r7
 8007b04:	0a000005 	beq	8007b20 <__call_exitprocs+0x70>
 8007b08:	e2555001 	subs	r5, r5, #1	; 0x1
 8007b0c:	e2444004 	sub	r4, r4, #4	; 0x4
 8007b10:	5afffff7 	bpl	8007af4 <__call_exitprocs+0x44>
 8007b14:	e28dd00c 	add	sp, sp, #12	; 0xc
 8007b18:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007b1c:	e12fff1e 	bx	lr
 8007b20:	e5963004 	ldr	r3, [r6, #4]
 8007b24:	e514c104 	ldr	ip, [r4, #-260]
 8007b28:	e2433001 	sub	r3, r3, #1	; 0x1
 8007b2c:	e1530005 	cmp	r3, r5
 8007b30:	05865004 	streq	r5, [r6, #4]
 8007b34:	1504b104 	strne	fp, [r4, #-260]
 8007b38:	e35c0000 	cmp	ip, #0	; 0x0
 8007b3c:	0afffff1 	beq	8007b08 <__call_exitprocs+0x58>
 8007b40:	e1a02519 	lsl	r2, r9, r5
 8007b44:	e5963188 	ldr	r3, [r6, #392]
 8007b48:	e1120003 	tst	r2, r3
 8007b4c:	e5968004 	ldr	r8, [r6, #4]
 8007b50:	0a00000b 	beq	8007b84 <__call_exitprocs+0xd4>
 8007b54:	e596318c 	ldr	r3, [r6, #396]
 8007b58:	e1120003 	tst	r2, r3
 8007b5c:	1a000011 	bne	8007ba8 <__call_exitprocs+0xf8>
 8007b60:	e59d0004 	ldr	r0, [sp, #4]
 8007b64:	e5141084 	ldr	r1, [r4, #-132]
 8007b68:	e1a0e00f 	mov	lr, pc
 8007b6c:	e12fff1c 	bx	ip
 8007b70:	e5963004 	ldr	r3, [r6, #4]
 8007b74:	e1530008 	cmp	r3, r8
 8007b78:	0a000006 	beq	8007b98 <__call_exitprocs+0xe8>
 8007b7c:	e59a3148 	ldr	r3, [sl, #328]
 8007b80:	eaffffd3 	b	8007ad4 <__call_exitprocs+0x24>
 8007b84:	e1a0e00f 	mov	lr, pc
 8007b88:	e12fff1c 	bx	ip
 8007b8c:	e5963004 	ldr	r3, [r6, #4]
 8007b90:	e1530008 	cmp	r3, r8
 8007b94:	1afffff8 	bne	8007b7c <__call_exitprocs+0xcc>
 8007b98:	e59a3148 	ldr	r3, [sl, #328]
 8007b9c:	e1530006 	cmp	r3, r6
 8007ba0:	1affffcb 	bne	8007ad4 <__call_exitprocs+0x24>
 8007ba4:	eaffffd7 	b	8007b08 <__call_exitprocs+0x58>
 8007ba8:	e5140084 	ldr	r0, [r4, #-132]
 8007bac:	e1a0e00f 	mov	lr, pc
 8007bb0:	e12fff1c 	bx	ip
 8007bb4:	eaffffed 	b	8007b70 <__call_exitprocs+0xc0>
 8007bb8:	08007c8c 	.word	0x08007c8c

08007bbc <AX12_ENABLED>:
 8007bbc:	01010100 	.word	0x01010100
 8007bc0:	01010101 	.word	0x01010101
 8007bc4:	01010101 	.word	0x01010101
 8007bc8:	01010101 	.word	0x01010101
 8007bcc:	00010101 	.word	0x00010101
 8007bd0:	00000000 	.word	0x00000000
	...

08007bd6 <SERVO_MAX_VALUES>:
 8007bd6:	0320      	.short	0x0320
 8007bd8:	033403ff 	.word	0x033403ff
 8007bdc:	03520382 	.word	0x03520382
 8007be0:	02000352 	.word	0x02000352
 8007be4:	021d02e7 	.word	0x021d02e7
 8007be8:	02800307 	.word	0x02800307
 8007bec:	020c03c8 	.word	0x020c03c8
 8007bf0:	035203f7 	.word	0x035203f7
 8007bf4:	023c0259 	.word	0x023c0259
 8007bf8:	02d9      	.short	0x02d9

08007bfa <SERVO_MIN_VALUES>:
 8007bfa:	0000      	.short	0x0000
 8007bfc:	008200c8 	.word	0x008200c8
 8007c00:	00a700fd 	.word	0x00a700fd
 8007c04:	011800d5 	.word	0x011800d5
 8007c08:	00f80200 	.word	0x00f80200
 8007c0c:	003101e2 	.word	0x003101e2
 8007c10:	001c017f 	.word	0x001c017f
 8007c14:	01a601f3 	.word	0x01a601f3
 8007c18:	012600b5 	.word	0x012600b5
 8007c1c:	000001bc 	.word	0x000001bc

08007c20 <motion_pointer_pages>:
 8007c20:	08043200 	.word	0x08043200

08007c24 <AX12Servos>:
 8007c24:	01010100 	.word	0x01010100
 8007c28:	01010101 	.word	0x01010101
 8007c2c:	01010101 	.word	0x01010101
 8007c30:	01010101 	.word	0x01010101
 8007c34:	00010101 	.word	0x00010101
 8007c38:	00000000 	.word	0x00000000
	...

08007c3e <AX12_IDS>:
 8007c3e:	0201      	.short	0x0201
 8007c40:	06050403 	.word	0x06050403
 8007c44:	0a090807 	.word	0x0a090807
 8007c48:	0e0d0c0b 	.word	0x0e0d0c0b
 8007c4c:	1211100f 	.word	0x1211100f

08007c50 <InitialValues>:
 8007c50:	031400eb 	.word	0x031400eb
 8007c54:	02e80117 	.word	0x02e80117
 8007c58:	023101ce 	.word	0x023101ce
 8007c5c:	029a0166 	.word	0x029a0166
 8007c60:	020401fb 	.word	0x020401fb
 8007c64:	02aa0155 	.word	0x02aa0155
 8007c68:	030f00f0 	.word	0x030f00f0
 8007c6c:	01780287 	.word	0x01780287
 8007c70:	020401fb 	.word	0x020401fb

08007c74 <InitialPlayTime>:
 8007c74:	0190      	.short	0x0190

08007c76 <APBAHBPrescTable>:
 8007c76:	0000      	.short	0x0000
 8007c78:	02010000 	.word	0x02010000
 8007c7c:	02010403 	.word	0x02010403
 8007c80:	07060403 	.word	0x07060403
 8007c84:	0908      	.short	0x0908

08007c86 <ADCPrescTable>:
 8007c86:	0402      	.short	0x0402
 8007c88:	00000806 	.word	0x00000806

08007c8c <_global_impure_ptr>:
 8007c8c:	200000e0 	.word	0x200000e0
 8007c90:	72617453 	.word	0x72617453
 8007c94:	676e6974 	.word	0x676e6974
 8007c98:	6f725020 	.word	0x6f725020
 8007c9c:	6d617267 	.word	0x6d617267
 8007ca0:	20796220 	.word	0x20796220
 8007ca4:	6e727574 	.word	0x6e727574
 8007ca8:	20676e69 	.word	0x20676e69
 8007cac:	50206e6f 	.word	0x50206e6f
 8007cb0:	5245574f 	.word	0x5245574f
 8007cb4:	44454c20 	.word	0x44454c20
 8007cb8:	000a0d21 	.word	0x000a0d21
 8007cbc:	3a554350 	.word	0x3a554350
 8007cc0:	70622800 	.word	0x70622800
 8007cc4:	000a2973 	.word	0x000a2973
 8007cc8:	3a47495a 	.word	0x3a47495a
 8007ccc:	4c584400 	.word	0x4c584400
 8007cd0:	2a20003a 	.word	0x2a20003a
 8007cd4:	202a0920 	.word	0x202a0920
 8007cd8:	6e727554 	.word	0x6e727554
 8007cdc:	206e6f20 	.word	0x206e6f20
 8007ce0:	7344454c 	.word	0x7344454c
 8007ce4:	000a0d21 	.word	0x000a0d21
 8007ce8:	09202a20 	.word	0x09202a20
 8007cec:	7554202a 	.word	0x7554202a
 8007cf0:	6f206e72 	.word	0x6f206e72
 8007cf4:	4c206666 	.word	0x4c206666
 8007cf8:	21734445 	.word	0x21734445
 8007cfc:	7b000a0d 	.word	0x7b000a0d
 8007d00:	202a2c00 	.word	0x202a2c00
 8007d04:	202c2a00 	.word	0x202c2a00
 8007d08:	41282000 	.word	0x41282000
 8007d0c:	32312d58 	.word	0x32312d58
 8007d10:	28200029 	.word	0x28200029
 8007d14:	312d5841 	.word	0x312d5841
 8007d18:	20002938 	.word	0x20002938
 8007d1c:	2d584128 	.word	0x2d584128
 8007d20:	00293153 	.word	0x00293153
 8007d24:	58412820 	.word	0x58412820
 8007d28:	3032532d 	.word	0x3032532d
 8007d2c:	28200029 	.word	0x28200029
 8007d30:	462d484a 	.word	0x462d484a
 8007d34:	00295350 	.word	0x00295350
 8007d38:	584d2820 	.word	0x584d2820
 8007d3c:	2938322d 	.word	0x2938322d
 8007d40:	0a207d00 	.word	0x0a207d00
 8007d44:	58440a00 	.word	0x58440a00
 8007d48:	4544204c 	.word	0x4544204c
 8007d4c:	45434956 	.word	0x45434956
 8007d50:	0a003a53 	.word	0x0a003a53
 8007d54:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d58:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d5c:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d60:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d64:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d68:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d6c:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d70:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d74:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d78:	7e7e7e7e 	.word	0x7e7e7e7e
 8007d7c:	500a000a 	.word	0x500a000a
 8007d80:	6979616c 	.word	0x6979616c
 8007d84:	5320676e 	.word	0x5320676e
 8007d88:	20656d6f 	.word	0x20656d6f
 8007d8c:	6973756d 	.word	0x6973756d
 8007d90:	0a000a63 	.word	0x0a000a63
 8007d94:	5f524928 	.word	0x5f524928
 8007d98:	49202c4c 	.word	0x49202c4c
 8007d9c:	2c525f52 	.word	0x2c525f52
 8007da0:	534d4420 	.word	0x534d4420
 8007da4:	28093a29 	.word	0x28093a29
 8007da8:	50550a00 	.word	0x50550a00
 8007dac:	20505520 	.word	0x20505520
 8007db0:	69205055 	.word	0x69205055
 8007db4:	72702073 	.word	0x72702073
 8007db8:	65737365 	.word	0x65737365
 8007dbc:	000a2164 	.word	0x000a2164
 8007dc0:	574f440a 	.word	0x574f440a
 8007dc4:	4f44204e 	.word	0x4f44204e
 8007dc8:	44204e57 	.word	0x44204e57
 8007dcc:	204e574f 	.word	0x204e574f
 8007dd0:	70207369 	.word	0x70207369
 8007dd4:	73736572 	.word	0x73736572
 8007dd8:	0a216465 	.word	0x0a216465
 8007ddc:	454c0a00 	.word	0x454c0a00
 8007de0:	4c205446 	.word	0x4c205446
 8007de4:	20544645 	.word	0x20544645
 8007de8:	5446454c 	.word	0x5446454c
 8007dec:	20736920 	.word	0x20736920
 8007df0:	73657270 	.word	0x73657270
 8007df4:	21646573 	.word	0x21646573
 8007df8:	520a000a 	.word	0x520a000a
 8007dfc:	54484749 	.word	0x54484749
 8007e00:	47495220 	.word	0x47495220
 8007e04:	52205448 	.word	0x52205448
 8007e08:	54484749 	.word	0x54484749
 8007e0c:	20736920 	.word	0x20736920
 8007e10:	73657270 	.word	0x73657270
 8007e14:	21646573 	.word	0x21646573
 8007e18:	530a000a 	.word	0x530a000a
 8007e1c:	54524154 	.word	0x54524154
 8007e20:	41545320 	.word	0x41545320
 8007e24:	53205452 	.word	0x53205452
 8007e28:	54524154 	.word	0x54524154
 8007e2c:	20736920 	.word	0x20736920
 8007e30:	73657270 	.word	0x73657270
 8007e34:	21646573 	.word	0x21646573
 8007e38:	4d0a000a 	.word	0x4d0a000a
 8007e3c:	4d204349 	.word	0x4d204349
 8007e40:	4d204349 	.word	0x4d204349
 8007e44:	4d204349 	.word	0x4d204349
 8007e48:	4d204349 	.word	0x4d204349
 8007e4c:	4d204349 	.word	0x4d204349
 8007e50:	43494d49 	.word	0x43494d49
 8007e54:	43494d20 	.word	0x43494d20
 8007e58:	4d494d20 	.word	0x4d494d20
 8007e5c:	4d204349 	.word	0x4d204349
 8007e60:	4d204349 	.word	0x4d204349
 8007e64:	43494d49 	.word	0x43494d49
 8007e68:	43494d20 	.word	0x43494d20
 8007e6c:	4d494d20 	.word	0x4d494d20
 8007e70:	4d204349 	.word	0x4d204349
 8007e74:	4d204349 	.word	0x4d204349
 8007e78:	43494d49 	.word	0x43494d49
 8007e7c:	43494d20 	.word	0x43494d20
 8007e80:	4d494d20 	.word	0x4d494d20
 8007e84:	4d204349 	.word	0x4d204349
 8007e88:	4d204349 	.word	0x4d204349
 8007e8c:	43494d49 	.word	0x43494d49
 8007e90:	43494d20 	.word	0x43494d20
 8007e94:	4d494d20 	.word	0x4d494d20
 8007e98:	4d204349 	.word	0x4d204349
 8007e9c:	4d204349 	.word	0x4d204349
 8007ea0:	43494d49 	.word	0x43494d49
 8007ea4:	43494d20 	.word	0x43494d20
 8007ea8:	69494d20 	.word	0x69494d20
 8007eac:	72702073 	.word	0x72702073
 8007eb0:	65737365 	.word	0x65737365
 8007eb4:	000a2164 	.word	0x000a2164
 8007eb8:	6961570a 	.word	0x6961570a
 8007ebc:	6f662074 	.word	0x6f662074
 8007ec0:	6f632072 	.word	0x6f632072
 8007ec4:	6e616d6d 	.word	0x6e616d6d
 8007ec8:	0a000a64 	.word	0x0a000a64
 8007ecc:	5f4c5844 	.word	0x5f4c5844
 8007ed0:	41465854 	.word	0x41465854
 8007ed4:	203a4c49 	.word	0x203a4c49
 8007ed8:	6c696146 	.word	0x6c696146
 8007edc:	74206465 	.word	0x74206465
 8007ee0:	736e6172 	.word	0x736e6172
 8007ee4:	2074696d 	.word	0x2074696d
 8007ee8:	74736e69 	.word	0x74736e69
 8007eec:	74637572 	.word	0x74637572
 8007ef0:	206e6f69 	.word	0x206e6f69
 8007ef4:	6b636170 	.word	0x6b636170
 8007ef8:	0a217465 	.word	0x0a217465
 8007efc:	58440a00 	.word	0x58440a00
 8007f00:	58525f4c 	.word	0x58525f4c
 8007f04:	4c494146 	.word	0x4c494146
 8007f08:	6146203a 	.word	0x6146203a
 8007f0c:	64656c69 	.word	0x64656c69
 8007f10:	74656720 	.word	0x74656720
 8007f14:	61747320 	.word	0x61747320
 8007f18:	20737574 	.word	0x20737574
 8007f1c:	6b636170 	.word	0x6b636170
 8007f20:	66207465 	.word	0x66207465
 8007f24:	206d6f72 	.word	0x206d6f72
 8007f28:	69766564 	.word	0x69766564
 8007f2c:	0a216563 	.word	0x0a216563
 8007f30:	58440a00 	.word	0x58440a00
 8007f34:	58545f4c 	.word	0x58545f4c
 8007f38:	4f525245 	.word	0x4f525245
 8007f3c:	49203a52 	.word	0x49203a52
 8007f40:	726f636e 	.word	0x726f636e
 8007f44:	74636572 	.word	0x74636572
 8007f48:	736e6920 	.word	0x736e6920
 8007f4c:	63757274 	.word	0x63757274
 8007f50:	6e6f6974 	.word	0x6e6f6974
 8007f54:	63617020 	.word	0x63617020
 8007f58:	2174656b 	.word	0x2174656b
 8007f5c:	440a000a 	.word	0x440a000a
 8007f60:	425f4c58 	.word	0x425f4c58
 8007f64:	495f4441 	.word	0x495f4441
 8007f68:	3a54534e 	.word	0x3a54534e
 8007f6c:	766e4920 	.word	0x766e4920
 8007f70:	64696c61 	.word	0x64696c61
 8007f74:	736e4920 	.word	0x736e4920
 8007f78:	63757274 	.word	0x63757274
 8007f7c:	6e6f6974 	.word	0x6e6f6974
 8007f80:	74796220 	.word	0x74796220
 8007f84:	0a000a65 	.word	0x0a000a65
 8007f88:	5f4c5844 	.word	0x5f4c5844
 8007f8c:	5f444142 	.word	0x5f444142
 8007f90:	203a4449 	.word	0x203a4449
 8007f94:	73274449 	.word	0x73274449
 8007f98:	746f6e20 	.word	0x746f6e20
 8007f9c:	6d617320 	.word	0x6d617320
 8007fa0:	6f662065 	.word	0x6f662065
 8007fa4:	6e692072 	.word	0x6e692072
 8007fa8:	75727473 	.word	0x75727473
 8007fac:	6f697463 	.word	0x6f697463
 8007fb0:	6e61206e 	.word	0x6e61206e
 8007fb4:	74732064 	.word	0x74732064
 8007fb8:	73757461 	.word	0x73757461
 8007fbc:	63617020 	.word	0x63617020
 8007fc0:	7374656b 	.word	0x7374656b
 8007fc4:	440a000a 	.word	0x440a000a
 8007fc8:	525f4c58 	.word	0x525f4c58
 8007fcc:	49415758 	.word	0x49415758
 8007fd0:	474e4954 	.word	0x474e4954
 8007fd4:	6f4e203a 	.word	0x6f4e203a
 8007fd8:	65722077 	.word	0x65722077
 8007fdc:	76696563 	.word	0x76696563
 8007fe0:	20676e69 	.word	0x20676e69
 8007fe4:	74617473 	.word	0x74617473
 8007fe8:	70207375 	.word	0x70207375
 8007fec:	656b6361 	.word	0x656b6361
 8007ff0:	000a2174 	.word	0x000a2174
 8007ff4:	4c58440a 	.word	0x4c58440a
 8007ff8:	5458525f 	.word	0x5458525f
 8007ffc:	4f454d49 	.word	0x4f454d49
 8008000:	203a5455 	.word	0x203a5455
 8008004:	72656854 	.word	0x72656854
 8008008:	73692065 	.word	0x73692065
 800800c:	206f6e20 	.word	0x206f6e20
 8008010:	74617473 	.word	0x74617473
 8008014:	70207375 	.word	0x70207375
 8008018:	656b6361 	.word	0x656b6361
 800801c:	000a2174 	.word	0x000a2174
 8008020:	4c58440a 	.word	0x4c58440a
 8008024:	4358525f 	.word	0x4358525f
 8008028:	4b434548 	.word	0x4b434548
 800802c:	3a4d5553 	.word	0x3a4d5553
 8008030:	636e4920 	.word	0x636e4920
 8008034:	6572726f 	.word	0x6572726f
 8008038:	73207463 	.word	0x73207463
 800803c:	75746174 	.word	0x75746174
 8008040:	61702073 	.word	0x61702073
 8008044:	74656b63 	.word	0x74656b63
 8008048:	65686320 	.word	0x65686320
 800804c:	75736b63 	.word	0x75736b63
 8008050:	000a216d 	.word	0x000a216d
 8008054:	706e490a 	.word	0x706e490a
 8008058:	76207475 	.word	0x76207475
 800805c:	61746c6f 	.word	0x61746c6f
 8008060:	65206567 	.word	0x65206567
 8008064:	726f7272 	.word	0x726f7272
 8008068:	0a000a21 	.word	0x0a000a21
 800806c:	6c676e41 	.word	0x6c676e41
 8008070:	696c2065 	.word	0x696c2065
 8008074:	2074696d 	.word	0x2074696d
 8008078:	6f727265 	.word	0x6f727265
 800807c:	000a2172 	.word	0x000a2172
 8008080:	65764f0a 	.word	0x65764f0a
 8008084:	61656872 	.word	0x61656872
 8008088:	72652074 	.word	0x72652074
 800808c:	21726f72 	.word	0x21726f72
 8008090:	4f0a000a 	.word	0x4f0a000a
 8008094:	6f207475 	.word	0x6f207475
 8008098:	61722066 	.word	0x61722066
 800809c:	2065676e 	.word	0x2065676e
 80080a0:	6f727265 	.word	0x6f727265
 80080a4:	000a2172 	.word	0x000a2172
 80080a8:	6568430a 	.word	0x6568430a
 80080ac:	75736b63 	.word	0x75736b63
 80080b0:	7265206d 	.word	0x7265206d
 80080b4:	21726f72 	.word	0x21726f72
 80080b8:	4f0a000a 	.word	0x4f0a000a
 80080bc:	6c726576 	.word	0x6c726576
 80080c0:	2064616f 	.word	0x2064616f
 80080c4:	6f727265 	.word	0x6f727265
 80080c8:	000a2172 	.word	0x000a2172
 80080cc:	736e490a 	.word	0x736e490a
 80080d0:	63757274 	.word	0x63757274
 80080d4:	6e6f6974 	.word	0x6e6f6974
 80080d8:	646f6320 	.word	0x646f6320
 80080dc:	72652065 	.word	0x72652065
 80080e0:	21726f72 	.word	0x21726f72
 80080e4:	6f6d000a 	.word	0x6f6d000a
 80080e8:	6e6f6974 	.word	0x6e6f6974
 80080ec:	203a632e 	.word	0x203a632e
 80080f0:	72727543 	.word	0x72727543
 80080f4:	4d746e65 	.word	0x4d746e65
 80080f8:	6f69746f 	.word	0x6f69746f
 80080fc:	000a3a6e 	.word	0x000a3a6e
 8008100:	70655220 	.word	0x70655220
 8008104:	54746165 	.word	0x54746165
 8008108:	3d656d69 	.word	0x3d656d69
 800810c:	0a206425 	.word	0x0a206425
 8008110:	65745320 	.word	0x65745320
 8008114:	253d7370 	.word	0x253d7370
 8008118:	200a2064 	.word	0x200a2064
 800811c:	65657053 	.word	0x65657053
 8008120:	74615264 	.word	0x74615264
 8008124:	3d303165 	.word	0x3d303165
 8008128:	0a206425 	.word	0x0a206425
 800812c:	656e4920 	.word	0x656e4920
 8008130:	61697472 	.word	0x61697472
 8008134:	726f466c 	.word	0x726f466c
 8008138:	253d6563 	.word	0x253d6563
 800813c:	200a2064 	.word	0x200a2064
 8008140:	7478654e 	.word	0x7478654e
 8008144:	65676150 	.word	0x65676150
 8008148:	2064253d 	.word	0x2064253d
 800814c:	7845200a 	.word	0x7845200a
 8008150:	61507469 	.word	0x61507469
 8008154:	253d6567 	.word	0x253d6567
 8008158:	000a2064 	.word	0x000a2064
 800815c:	65745320 	.word	0x65745320
 8008160:	0a3a7370 	.word	0x0a3a7370
 8008164:	20202000 	.word	0x20202000
 8008168:	70657473 	.word	0x70657473
 800816c:	3a692520 	.word	0x3a692520
 8008170:	616c7020 	.word	0x616c7020
 8008174:	64253d79 	.word	0x64253d79
 8008178:	75617020 	.word	0x75617020
 800817c:	253d6573 	.word	0x253d6573
 8008180:	20200a64 	.word	0x20200a64
 8008184:	20642500 	.word	0x20642500
 8008188:	696f4a00 	.word	0x696f4a00
 800818c:	6620746e 	.word	0x6620746e
 8008190:	3a78656c 	.word	0x3a78656c
 8008194:	0a00200a 	.word	0x0a00200a
 8008198:	4d746573 	.word	0x4d746573
 800819c:	6f69746f 	.word	0x6f69746f
 80081a0:	6761506e 	.word	0x6761506e
 80081a4:	696f4a65 	.word	0x696f4a65
 80081a8:	6c46746e 	.word	0x6c46746e
 80081ac:	62697865 	.word	0x62697865
 80081b0:	74696c69 	.word	0x74696c69
 80081b4:	43432079 	.word	0x43432079
 80081b8:	44492057 	.word	0x44492057
 80081bc:	2d206925 	.word	0x2d206925
 80081c0:	550a0020 	.word	0x550a0020
 80081c4:	6361706e 	.word	0x6361706e
 80081c8:	6f4d206b 	.word	0x6f4d206b
 80081cc:	6e6f6974 	.word	0x6e6f6974
 80081d0:	67615020 	.word	0x67615020
 80081d4:	69252065 	.word	0x69252065
 80081d8:	7453202c 	.word	0x7453202c
 80081dc:	25207065 	.word	0x25207065
 80081e0:	202d2069 	.word	0x202d2069
 80081e4:	62627572 	.word	0x62627572
 80081e8:	20687369 	.word	0x20687369
 80081ec:	61746164 	.word	0x61746164
 80081f0:	5453202e 	.word	0x5453202e
 80081f4:	002e504f 	.word	0x002e504f
 80081f8:	7265530a 	.word	0x7265530a
 80081fc:	49206f76 	.word	0x49206f76
 8008200:	2c692544 	.word	0x2c692544
 8008204:	65745320 	.word	0x65745320
 8008208:	61562070 	.word	0x61562070
 800820c:	2065756c 	.word	0x2065756c
 8008210:	6925203d 	.word	0x6925203d
 8008214:	694d202c 	.word	0x694d202c
 8008218:	203d206e 	.word	0x203d206e
 800821c:	202c6925 	.word	0x202c6925
 8008220:	2078614d 	.word	0x2078614d
 8008224:	6925203d 	.word	0x6925203d
 8008228:	0a000a20 	.word	0x0a000a20
 800822c:	666e6f43 	.word	0x666e6f43
 8008230:	72756769 	.word	0x72756769
 8008234:	6f697461 	.word	0x6f697461
 8008238:	666f206e 	.word	0x666f206e
 800823c:	616e6520 	.word	0x616e6520
 8008240:	64656c62 	.word	0x64656c62
 8008244:	2d584120 	.word	0x2d584120
 8008248:	73203231 	.word	0x73203231
 800824c:	6f767265 	.word	0x6f767265
 8008250:	6f642073 	.word	0x6f642073
 8008254:	6e207365 	.word	0x6e207365
 8008258:	6d20746f 	.word	0x6d20746f
 800825c:	68637461 	.word	0x68637461
 8008260:	746f6d20 	.word	0x746f6d20
 8008264:	2e6e6f69 	.word	0x2e6e6f69
 8008268:	41202e68 	.word	0x41202e68
 800826c:	54524f42 	.word	0x54524f42
 8008270:	0a000a21 	.word	0x0a000a21
 8008274:	63657865 	.word	0x63657865
 8008278:	4d657475 	.word	0x4d657475
 800827c:	6f69746f 	.word	0x6f69746f
 8008280:	7165536e 	.word	0x7165536e
 8008284:	636e6575 	.word	0x636e6575
 8008288:	6c412065 	.word	0x6c412065
 800828c:	206d7261 	.word	0x206d7261
 8008290:	69254449 	.word	0x69254449
 8008294:	45202d20 	.word	0x45202d20
 8008298:	726f7272 	.word	0x726f7272
 800829c:	646f4320 	.word	0x646f4320
 80082a0:	69252065 	.word	0x69252065
 80082a4:	6f4d000a 	.word	0x6f4d000a
 80082a8:	6e6f6974 	.word	0x6e6f6974
 80082ac:	65747320 	.word	0x65747320
 80082b0:	69662070 	.word	0x69662070
 80082b4:	6873696e 	.word	0x6873696e
 80082b8:	203a6465 	.word	0x203a6465
 80082bc:	7478656e 	.word	0x7478656e
 80082c0:	65676150 	.word	0x65676150
 80082c4:	0a642520 	.word	0x0a642520
 80082c8:	696f4700 	.word	0x696f4700
 80082cc:	7420676e 	.word	0x7420676e
 80082d0:	7865206f 	.word	0x7865206f
 80082d4:	70207469 	.word	0x70207469
 80082d8:	20656761 	.word	0x20656761
 80082dc:	6f726628 	.word	0x6f726628
 80082e0:	7865206d 	.word	0x7865206d
 80082e4:	70207469 	.word	0x70207469
 80082e8:	29656761 	.word	0x29656761
 80082ec:	6425203a 	.word	0x6425203a
 80082f0:	6552000a 	.word	0x6552000a
 80082f4:	74616570 	.word	0x74616570
 80082f8:	20676e69 	.word	0x20676e69
 80082fc:	69746f6d 	.word	0x69746f6d
 8008300:	70206e6f 	.word	0x70206e6f
 8008304:	20656761 	.word	0x20656761
 8008308:	27642528 	.word	0x27642528
 800830c:	74206874 	.word	0x74206874
 8008310:	29656d69 	.word	0x29656d69
 8008314:	6425203a 	.word	0x6425203a
 8008318:	7753000a 	.word	0x7753000a
 800831c:	68637469 	.word	0x68637469
 8008320:	20676e69 	.word	0x20676e69
 8008324:	6e206f74 	.word	0x6e206f74
 8008328:	20747865 	.word	0x20747865
 800832c:	69746f6d 	.word	0x69746f6d
 8008330:	70206e6f 	.word	0x70206e6f
 8008334:	3a656761 	.word	0x3a656761
 8008338:	20642520 	.word	0x20642520
 800833c:	25203e2d 	.word	0x25203e2d
 8008340:	46000a64 	.word	0x46000a64
 8008344:	73696e69 	.word	0x73696e69
 8008348:	20646568 	.word	0x20646568
 800834c:	69746f6d 	.word	0x69746f6d
 8008350:	70206e6f 	.word	0x70206e6f
 8008354:	3a656761 	.word	0x3a656761
 8008358:	0a642520 	.word	0x0a642520
 800835c:	74657300 	.word	0x74657300
 8008360:	6e696f4a 	.word	0x6e696f4a
 8008364:	66664f74 	.word	0x66664f74
 8008368:	42746573 	.word	0x42746573
 800836c:	3a644979 	.word	0x3a644979
 8008370:	766e6920 	.word	0x766e6920
 8008374:	64696c61 	.word	0x64696c61
 8008378:	72657320 	.word	0x72657320
 800837c:	69206f76 	.word	0x69206f76
 8008380:	64202c64 	.word	0x64202c64
 8008384:	79206469 	.word	0x79206469
 8008388:	7020756f 	.word	0x7020756f
 800838c:	61687265 	.word	0x61687265
 8008390:	73207370 	.word	0x73207370
 8008394:	20646e65 	.word	0x20646e65
 8008398:	20656874 	.word	0x20656874
 800839c:	65646e69 	.word	0x65646e69
 80083a0:	000a3f78 	.word	0x000a3f78
 80083a4:	766f6d0a 	.word	0x766f6d0a
 80083a8:	476f5465 	.word	0x476f5465
 80083ac:	506c616f 	.word	0x506c616f
 80083b0:	2065736f 	.word	0x2065736f
 80083b4:	72616c41 	.word	0x72616c41
 80083b8:	4449206d 	.word	0x4449206d
 80083bc:	2d206925 	.word	0x2d206925
 80083c0:	72724520 	.word	0x72724520
 80083c4:	4320726f 	.word	0x4320726f
 80083c8:	2065646f 	.word	0x2065646f
 80083cc:	000a6925 	.word	0x000a6925
 80083d0:	6b6c6177 	.word	0x6b6c6177
 80083d4:	696e695f 	.word	0x696e695f
 80083d8:	00000a74 	.word	0x00000a74
 80083dc:	00000043 	.word	0x00000043

Disassembly of section .data:

20000000 <_sdata>:
20000000:	00000002 	.word	0x00000002

20000004 <EasyEPort>:
20000004:	40010800 	.word	0x40010800
20000008:	00000001 	.word	0x00000001
2000000c:	40010800 	.word	0x40010800
20000010:	00000002 	.word	0x00000002
20000014:	40010800 	.word	0x40010800
20000018:	00000004 	.word	0x00000004
2000001c:	40010800 	.word	0x40010800
20000020:	00000008 	.word	0x00000008
20000024:	40011000 	.word	0x40011000
20000028:	00000040 	.word	0x00000040
2000002c:	40011000 	.word	0x40011000
20000030:	00000080 	.word	0x00000080
20000034:	40011000 	.word	0x40011000
20000038:	00000100 	.word	0x00000100
2000003c:	40011000 	.word	0x40011000
20000040:	00000200 	.word	0x00000200
20000044:	40010800 	.word	0x40010800
20000048:	00000100 	.word	0x00000100
2000004c:	40010800 	.word	0x40010800
20000050:	00000800 	.word	0x00000800
20000054:	40010c00 	.word	0x40010c00
20000058:	00000100 	.word	0x00000100
2000005c:	40010c00 	.word	0x40010c00
20000060:	00000200 	.word	0x00000200

20000064 <EasyButton>:
20000064:	40011000 	.word	0x40011000
20000068:	00000800 	.word	0x00000800
2000006c:	40011000 	.word	0x40011000
20000070:	00000400 	.word	0x00000400
20000074:	40010800 	.word	0x40010800
20000078:	00008000 	.word	0x00008000
2000007c:	40010800 	.word	0x40010800
20000080:	00004000 	.word	0x00004000
20000084:	40010c00 	.word	0x40010c00
20000088:	00000008 	.word	0x00000008
2000008c:	40011000 	.word	0x40011000
20000090:	00000010 	.word	0x00000010

20000094 <EasyLED>:
20000094:	40011000 	.word	0x40011000
20000098:	00002000 	.word	0x00002000
2000009c:	40010c00 	.word	0x40010c00
200000a0:	00002000 	.word	0x00002000
200000a4:	40010c00 	.word	0x40010c00
200000a8:	00004000 	.word	0x00004000
200000ac:	40010c00 	.word	0x40010c00
200000b0:	00008000 	.word	0x00008000
200000b4:	40011000 	.word	0x40011000
200000b8:	00004000 	.word	0x00004000
200000bc:	40011000 	.word	0x40011000
200000c0:	00008000 	.word	0x00008000
200000c4:	40010c00 	.word	0x40010c00
200000c8:	00001000 	.word	0x00001000

200000cc <Baudrate_DXL>:
200000cc:	000f4240 	.word	0x000f4240

200000d0 <Baudrate_ZIG>:
200000d0:	0000e100 	.word	0x0000e100

200000d4 <Baudrate_PCU>:
200000d4:	0000e100 	.word	0x0000e100

200000d8 <_impure_ptr>:
200000d8:	200000e0 	.word	0x200000e0
200000dc:	00000000 	.word	0x00000000

200000e0 <impure_data>:
200000e0:	00000000 	.word	0x00000000
200000e4:	200003cc 	.word	0x200003cc
200000e8:	20000428 	.word	0x20000428
200000ec:	20000484 	.word	0x20000484
	...
20000114:	080083dc 	.word	0x080083dc
	...
20000188:	00000001 	.word	0x00000001
2000018c:	00000000 	.word	0x00000000
20000190:	abcd330e 	.word	0xabcd330e
20000194:	e66d1234 	.word	0xe66d1234
20000198:	0005deec 	.word	0x0005deec
2000019c:	0000000b 	.word	0x0000000b
	...

Disassembly of section .bss:

200004e0 <_sbss>:
	...

200008e0 <gbPcuWrite>:
	...

200008e2 <gbPcuRead>:
	...

200008e4 <gbInstructionPacket>:
	...

20000984 <gbStatusPacket>:
	...

200009d4 <gbRxPacketLength>:
	...

200009d5 <gbRxGetLength>:
	...

200009d6 <giBusUsing>:
	...

200009d8 <gbZigRead>:
	...

200009d9 <gbZigWrite>:
	...

200009da <gbRcvPacket>:
200009da:	0000      	.short	0x0000
200009dc:	00000000 	.word	0x00000000

200009e0 <gbRcvPacketArduino>:
	...

200009e9 <gbRcvPacketNum>:
	...

200009ea <gwRcvData>:
	...

200009ec <gbRcvFlag>:
	...

200009ed <right_V>:
	...

200009ee <right_H>:
	...

200009ef <left_V>:
	...

200009f0 <left_H>:
	...

200009f1 <buttons_>:
	...

200009f2 <extra>:
	...

200009f4 <motion_state>:
200009f4:	00000000 	.word	0x00000000

200009f8 <pause_start_time>:
200009f8:	00000000 	.word	0x00000000

200009fc <repeat_counter>:
	...

200009fd <exit_flag>:
200009fd:	00          	.byte	0x00
	...

20000a00 <step_start_time>:
20000a00:	00000000 	.word	0x00000000

20000a04 <step_finish_time>:
20000a04:	00000000 	.word	0x00000000

20000a08 <block_time>:
20000a08:	00000000 	.word	0x00000000

20000a0c <current_motion_start_time>:
20000a0c:	00000000 	.word	0x00000000

20000a10 <last_joint_flex>:
	...

20000a24 <motion_pointer>:
	...

20000e24 <CurrentMotion>:
	...

20000f54 <buzzerFinished>:
	...

20000f56 <adc_sensor_val>:
	...

20000f62 <adc_battery_val>:
	...

20000f64 <adc_gyrox_center>:
	...

20000f66 <adc_gyroy_center>:
	...

20000f68 <adc_accelx>:
	...

20000f6a <adc_accely>:
	...

20000f6c <adc_accelx_center>:
	...

20000f6e <adc_accely_center>:
	...

20000f70 <adc_ultrasonic_distance>:
	...

20000f72 <adc_dms_distance>:
	...

20000f74 <bioloid_command>:
	...

20000f75 <last_bioloid_command>:
	...

20000f76 <new_command>:
	...

20000f77 <flag_receive_ready>:
	...

20000f78 <major_alarm>:
	...

20000f79 <current_motion_page>:
	...

20000f7a <next_motion_page>:
	...

20000f7b <current_step>:
	...

20000f7c <pid_input>:
	...

20000f84 <pid_output>:
	...

20000f8c <pid_setpoint>:
	...

20000f94 <pid_unscaled_output>:
	...

20000f9c <buzzerSequence>:
20000f9c:	00000000 	.word	0x00000000

20000fa0 <current_pose>:
	...

20000fc4 <motion_step_servos_moving>:
	...

20001042 <motion_servos_moving>:
	...

20001054 <pose_mode>:
	...

20001056 <goal_pose>:
	...

2000107a <goal_pose_shadow>:
	...

2000109e <goal_speed>:
	...

200010c2 <goal_pose_adjusted>:
	...

200010e8 <offset_timings>:
	...

20001130 <offsets>:
	...

20001154 <offsets_shadow>:
	...

20001178 <offsets_speeds>:
	...

2000119c <goal_time>:
2000119c:	00000000 	.word	0x00000000

200011a0 <walk_state>:
	...

200011a1 <walk_command>:
200011a1:	00          	.byte	0x00
	...

200011a4 <msSystickCounter>:
200011a4:	00000000 	.word	0x00000000

200011a8 <glDelayCounter>:
200011a8:	00000000 	.word	0x00000000

200011ac <glCountdownCounter>:
200011ac:	00000000 	.word	0x00000000

200011b0 <glDxlTimeoutCounter>:
200011b0:	00000000 	.word	0x00000000

200011b4 <glPcuTimeoutCounter>:
200011b4:	00000000 	.word	0x00000000

200011b8 <glBuzzerCounter>:
200011b8:	00000000 	.word	0x00000000

200011bc <gbCounterCount>:
200011bc:	00000000 	.word	0x00000000

200011c0 <Millis>:
200011c0:	00000000 	.word	0x00000000

200011c4 <msMillis>:
200011c4:	00000000 	.word	0x00000000

200011c8 <ReBootToBootLoader>:
	...

200011ca <gbDxlWrite>:
	...

200011cc <gbDxlRead>:
	...

200011ce <gbZigWrite>:
	...

200011cf <gbZigRead>:
	...

200011d0 <gbpPcuBuffer>:
	...

200015d0 <ReBootToBootLoader>:
	...

200015d2 <gbPcuWrite>:
	...

200015d4 <gbPcuRead>:
	...

200015d6 <gbpZigBuffer>:
	...

20001617 <gbpDxlBuffer>:
	...

Disassembly of section ._usrstack:

20001a18 <_susrstack>:
	...

Disassembly of section .comment:

00000000 <.comment>:
   0:	43434700 	movtmi	r4, #14080	; 0x3700
   4:	5728203a 	undefined
   8:	52416e69 	subpl	r6, r1, #1680	; 0x690
   c:	614d204d 	cmpvs	sp, sp, asr #32
  10:	20686372 	rsbcs	r6, r8, r2, ror r3
  14:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  18:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  1c:	00302e33 	eorseq	r2, r0, r3, lsr lr
  20:	43434700 	movtmi	r4, #14080	; 0x3700
  24:	5728203a 	undefined
  28:	52416e69 	subpl	r6, r1, #1680	; 0x690
  2c:	614d204d 	cmpvs	sp, sp, asr #32
  30:	20686372 	rsbcs	r6, r8, r2, ror r3
  34:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  38:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  3c:	00302e33 	eorseq	r2, r0, r3, lsr lr
  40:	43434700 	movtmi	r4, #14080	; 0x3700
  44:	5728203a 	undefined
  48:	52416e69 	subpl	r6, r1, #1680	; 0x690
  4c:	614d204d 	cmpvs	sp, sp, asr #32
  50:	20686372 	rsbcs	r6, r8, r2, ror r3
  54:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  58:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  5c:	00302e33 	eorseq	r2, r0, r3, lsr lr
  60:	43434700 	movtmi	r4, #14080	; 0x3700
  64:	5728203a 	undefined
  68:	52416e69 	subpl	r6, r1, #1680	; 0x690
  6c:	614d204d 	cmpvs	sp, sp, asr #32
  70:	20686372 	rsbcs	r6, r8, r2, ror r3
  74:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  78:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  7c:	00302e33 	eorseq	r2, r0, r3, lsr lr
  80:	43434700 	movtmi	r4, #14080	; 0x3700
  84:	5728203a 	undefined
  88:	52416e69 	subpl	r6, r1, #1680	; 0x690
  8c:	614d204d 	cmpvs	sp, sp, asr #32
  90:	20686372 	rsbcs	r6, r8, r2, ror r3
  94:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  98:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  9c:	00302e33 	eorseq	r2, r0, r3, lsr lr
  a0:	43434700 	movtmi	r4, #14080	; 0x3700
  a4:	5728203a 	undefined
  a8:	52416e69 	subpl	r6, r1, #1680	; 0x690
  ac:	614d204d 	cmpvs	sp, sp, asr #32
  b0:	20686372 	rsbcs	r6, r8, r2, ror r3
  b4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  b8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  bc:	00302e33 	eorseq	r2, r0, r3, lsr lr
  c0:	43434700 	movtmi	r4, #14080	; 0x3700
  c4:	5728203a 	undefined
  c8:	52416e69 	subpl	r6, r1, #1680	; 0x690
  cc:	614d204d 	cmpvs	sp, sp, asr #32
  d0:	20686372 	rsbcs	r6, r8, r2, ror r3
  d4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  d8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
  dc:	00302e33 	eorseq	r2, r0, r3, lsr lr
  e0:	43434700 	movtmi	r4, #14080	; 0x3700
  e4:	5728203a 	undefined
  e8:	52416e69 	subpl	r6, r1, #1680	; 0x690
  ec:	614d204d 	cmpvs	sp, sp, asr #32
  f0:	20686372 	rsbcs	r6, r8, r2, ror r3
  f4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
  f8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
  fc:	00302e33 	eorseq	r2, r0, r3, lsr lr
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
 100:	43434700 	movtmi	r4, #14080	; 0x3700

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
 104:	5728203a 	undefined
 108:	52416e69 	subpl	r6, r1, #1680	; 0x690
	nextframe_ = getMillis() + frameLength;
 10c:	614d204d 	cmpvs	sp, sp, asr #32
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
 110:	20686372 	rsbcs	r6, r8, r2, ror r3
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
 114:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 118:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
 11c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 120:	43434700 	movtmi	r4, #14080	; 0x3700
 124:	5728203a 	undefined
		if (nextpose_[i] > pose_[i]) {
 128:	52416e69 	subpl	r6, r1, #1680	; 0x690
 12c:	614d204d 	cmpvs	sp, sp, asr #32
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
 130:	20686372 	rsbcs	r6, r8, r2, ror r3
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
 134:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 138:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 13c:	00302e33 	eorseq	r2, r0, r3, lsr lr
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
 140:	43434700 	movtmi	r4, #14080	; 0x3700
 144:	5728203a 	undefined
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
 148:	52416e69 	subpl	r6, r1, #1680	; 0x690
 14c:	614d204d 	cmpvs	sp, sp, asr #32
}
 150:	20686372 	rsbcs	r6, r8, r2, ror r3
 154:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 158:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 15c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 160:	43434700 	movtmi	r4, #14080	; 0x3700
 164:	5728203a 	undefined
 168:	52416e69 	subpl	r6, r1, #1680	; 0x690
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
 16c:	614d204d 	cmpvs	sp, sp, asr #32
 170:	20686372 	rsbcs	r6, r8, r2, ror r3
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
 174:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 178:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 17c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 180:	43434700 	movtmi	r4, #14080	; 0x3700
		nextpose_[i] = 512;
 184:	5728203a 	undefined
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
 188:	52416e69 	subpl	r6, r1, #1680	; 0x690
		pose_[i] = 512;
 18c:	614d204d 	cmpvs	sp, sp, asr #32
		nextpose_[i] = 512;
 190:	20686372 	rsbcs	r6, r8, r2, ror r3
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
 194:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 198:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
 19c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 1a0:	43434700 	movtmi	r4, #14080	; 0x3700
	nextframe_ = getMillis();
 1a4:	5728203a 	undefined
 1a8:	52416e69 	subpl	r6, r1, #1680	; 0x690
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
 1ac:	614d204d 	cmpvs	sp, sp, asr #32
 1b0:	20686372 	rsbcs	r6, r8, r2, ror r3
 1b4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 1b8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 1bc:	00302e33 	eorseq	r2, r0, r3, lsr lr
 1c0:	43434700 	movtmi	r4, #14080	; 0x3700
 1c4:	5728203a 	undefined
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
 1c8:	52416e69 	subpl	r6, r1, #1680	; 0x690
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
 1cc:	614d204d 	cmpvs	sp, sp, asr #32
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 1d0:	20686372 	rsbcs	r6, r8, r2, ror r3
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
 1d4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 1d8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
 1dc:	00302e33 	eorseq	r2, r0, r3, lsr lr
 1e0:	43434700 	movtmi	r4, #14080	; 0x3700
		pose_[i] = 512;
		nextpose_[i] = 512;
 1e4:	5728203a 	undefined
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 1e8:	52416e69 	subpl	r6, r1, #1680	; 0x690
		nextpose_[i] = 512;
 1ec:	614d204d 	cmpvs	sp, sp, asr #32
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
 1f0:	20686372 	rsbcs	r6, r8, r2, ror r3
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
 1f4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 1f8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	interpolating = 0;
 1fc:	00302e33 	eorseq	r2, r0, r3, lsr lr
	nextframe_ = getMillis();
 200:	43434700 	movtmi	r4, #14080	; 0x3700
 204:	5728203a 	undefined
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
 208:	52416e69 	subpl	r6, r1, #1680	; 0x690
 20c:	614d204d 	cmpvs	sp, sp, asr #32
 210:	20686372 	rsbcs	r6, r8, r2, ror r3
 214:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 218:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 21c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 220:	43434700 	movtmi	r4, #14080	; 0x3700
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
 224:	5728203a 	undefined
 228:	52416e69 	subpl	r6, r1, #1680	; 0x690
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
 22c:	614d204d 	cmpvs	sp, sp, asr #32
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
 230:	20686372 	rsbcs	r6, r8, r2, ror r3
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
 234:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 238:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	dxl_set_txpacket_parameter(1, 2);
 23c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 240:	43434700 	movtmi	r4, #14080	; 0x3700
 244:	5728203a 	undefined
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 248:	52416e69 	subpl	r6, r1, #1680	; 0x690
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
 24c:	614d204d 	cmpvs	sp, sp, asr #32
 250:	20686372 	rsbcs	r6, r8, r2, ror r3
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 254:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 258:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 25c:	00302e33 	eorseq	r2, r0, r3, lsr lr
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 260:	43434700 	movtmi	r4, #14080	; 0x3700
 264:	5728203a 	undefined
 268:	52416e69 	subpl	r6, r1, #1680	; 0x690
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
 26c:	614d204d 	cmpvs	sp, sp, asr #32
 270:	20686372 	rsbcs	r6, r8, r2, ror r3
 274:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 278:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
 27c:	00302e33 	eorseq	r2, r0, r3, lsr lr
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
 280:	43434700 	movtmi	r4, #14080	; 0x3700
 284:	5728203a 	undefined
 288:	52416e69 	subpl	r6, r1, #1680	; 0x690
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
 28c:	614d204d 	cmpvs	sp, sp, asr #32
 290:	20686372 	rsbcs	r6, r8, r2, ror r3
 294:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
	dxl_txrx_packet();
 298:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	u16 CommStatus = dxl_get_result();
 29c:	00302e33 	eorseq	r2, r0, r3, lsr lr
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
 2a0:	43434700 	movtmi	r4, #14080	; 0x3700
		PrintErrorCode();
 2a4:	5728203a 	undefined
	else
		PrintCommStatus(CommStatus);
 2a8:	52416e69 	subpl	r6, r1, #1680	; 0x690
#endif
}
 2ac:	614d204d 	cmpvs	sp, sp, asr #32
 2b0:	20686372 	rsbcs	r6, r8, r2, ror r3
 2b4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 2b8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
 2bc:	00302e33 	eorseq	r2, r0, r3, lsr lr
 2c0:	43434700 	movtmi	r4, #14080	; 0x3700

	if (interpolating == 0)
 2c4:	5728203a 	undefined
		return 0;
	int i;
	int complete = poseSize;
 2c8:	52416e69 	subpl	r6, r1, #1680	; 0x690
	if (!fWait) {
 2cc:	614d204d 	cmpvs	sp, sp, asr #32
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
 2d0:	20686372 	rsbcs	r6, r8, r2, ror r3
 2d4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 2d8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
			return (getMillis() - nextframe_); // We still have some time to do something...
 2dc:	00302e33 	eorseq	r2, r0, r3, lsr lr
 2e0:	43434700 	movtmi	r4, #14080	; 0x3700
 2e4:	5728203a 	undefined
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
 2e8:	52416e69 	subpl	r6, r1, #1680	; 0x690
 2ec:	614d204d 	cmpvs	sp, sp, asr #32
 2f0:	20686372 	rsbcs	r6, r8, r2, ror r3
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
 2f4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 2f8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 2fc:	00302e33 	eorseq	r2, r0, r3, lsr lr
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
 300:	43434700 	movtmi	r4, #14080	; 0x3700
 304:	5728203a 	undefined
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 308:	52416e69 	subpl	r6, r1, #1680	; 0x690
		int diff = nextpose_[i] - pose_[i];
 30c:	614d204d 	cmpvs	sp, sp, asr #32
 310:	20686372 	rsbcs	r6, r8, r2, ror r3
 314:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 318:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 31c:	00302e33 	eorseq	r2, r0, r3, lsr lr
		if (diff == 0) {
 320:	43434700 	movtmi	r4, #14080	; 0x3700
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
 324:	5728203a 	undefined
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
 328:	52416e69 	subpl	r6, r1, #1680	; 0x690
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
 32c:	614d204d 	cmpvs	sp, sp, asr #32
					pose_[i] = nextpose_[i];
 330:	20686372 	rsbcs	r6, r8, r2, ror r3
					complete--;
 334:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
 338:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 33c:	00302e33 	eorseq	r2, r0, r3, lsr lr
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
 340:	43434700 	movtmi	r4, #14080	; 0x3700
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
 344:	5728203a 	undefined
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
 348:	52416e69 	subpl	r6, r1, #1680	; 0x690
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 34c:	614d204d 	cmpvs	sp, sp, asr #32
 350:	20686372 	rsbcs	r6, r8, r2, ror r3
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
 354:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
		interpolating = 0;
 358:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
	BioloidControllerEx_writePose();
 35c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 360:	43434700 	movtmi	r4, #14080	; 0x3700
	return 0;
}
 364:	5728203a 	undefined
 368:	52416e69 	subpl	r6, r1, #1680	; 0x690
 36c:	614d204d 	cmpvs	sp, sp, asr #32
 370:	20686372 	rsbcs	r6, r8, r2, ror r3
 374:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 378:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 37c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 380:	43434700 	movtmi	r4, #14080	; 0x3700
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
 384:	5728203a 	undefined
 388:	52416e69 	subpl	r6, r1, #1680	; 0x690
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
 38c:	614d204d 	cmpvs	sp, sp, asr #32
 390:	20686372 	rsbcs	r6, r8, r2, ror r3
 394:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 398:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 39c:	00302e33 	eorseq	r2, r0, r3, lsr lr
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
 3a0:	43434700 	movtmi	r4, #14080	; 0x3700

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
 3a4:	5728203a 	undefined
 3a8:	52416e69 	subpl	r6, r1, #1680	; 0x690
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
 3ac:	614d204d 	cmpvs	sp, sp, asr #32
 3b0:	20686372 	rsbcs	r6, r8, r2, ror r3
 3b4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 3b8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
 3bc:	00302e33 	eorseq	r2, r0, r3, lsr lr
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
 3c0:	43434700 	movtmi	r4, #14080	; 0x3700
 3c4:	5728203a 	undefined
 3c8:	52416e69 	subpl	r6, r1, #1680	; 0x690
 3cc:	614d204d 	cmpvs	sp, sp, asr #32
 3d0:	20686372 	rsbcs	r6, r8, r2, ror r3
 3d4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 3d8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
 3dc:	00302e33 	eorseq	r2, r0, r3, lsr lr
 3e0:	43434700 	movtmi	r4, #14080	; 0x3700
 3e4:	5728203a 	undefined
 3e8:	52416e69 	subpl	r6, r1, #1680	; 0x690
 3ec:	614d204d 	cmpvs	sp, sp, asr #32
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
 3f0:	20686372 	rsbcs	r6, r8, r2, ror r3
 3f4:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 3f8:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 3fc:	00302e33 	eorseq	r2, r0, r3, lsr lr
 400:	43434700 	movtmi	r4, #14080	; 0x3700
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
 404:	5728203a 	undefined
 408:	52416e69 	subpl	r6, r1, #1680	; 0x690
 40c:	614d204d 	cmpvs	sp, sp, asr #32
 410:	20686372 	rsbcs	r6, r8, r2, ror r3
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
 414:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 418:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 41c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 420:	43434700 	movtmi	r4, #14080	; 0x3700
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
 424:	5728203a 	undefined
 428:	52416e69 	subpl	r6, r1, #1680	; 0x690
 42c:	614d204d 	cmpvs	sp, sp, asr #32
 430:	20686372 	rsbcs	r6, r8, r2, ror r3
 434:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 438:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
 43c:	00302e33 	eorseq	r2, r0, r3, lsr lr
 440:	43434700 	movtmi	r4, #14080	; 0x3700
 444:	5728203a 	undefined
 448:	52416e69 	subpl	r6, r1, #1680	; 0x690
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
 44c:	614d204d 	cmpvs	sp, sp, asr #32
 450:	20686372 	rsbcs	r6, r8, r2, ror r3
 454:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 458:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 45c:	00302e33 	eorseq	r2, r0, r3, lsr lr
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
 460:	43434700 	movtmi	r4, #14080	; 0x3700
 464:	5728203a 	undefined
 468:	52416e69 	subpl	r6, r1, #1680	; 0x690
 46c:	614d204d 	cmpvs	sp, sp, asr #32
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
 470:	20686372 	rsbcs	r6, r8, r2, ror r3
 474:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 478:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 47c:	00302e33 	eorseq	r2, r0, r3, lsr lr
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
 480:	43434700 	movtmi	r4, #14080	; 0x3700
 484:	5728203a 	undefined
 488:	52416e69 	subpl	r6, r1, #1680	; 0x690
 48c:	614d204d 	cmpvs	sp, sp, asr #32
 490:	20686372 	rsbcs	r6, r8, r2, ror r3
 494:	38303032 	ldmdacc	r0!, {r1, r4, r5, ip, sp}
 498:	2e342029 	cdpcs	0, 3, cr2, cr4, cr9, {1}
 49c:	00302e33 	eorseq	r2, r0, r3, lsr lr

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	00000024 	andeq	r0, r0, r4, lsr #32
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
	...
  14:	0000000c 	andeq	r0, r0, ip
  18:	00000000 	andeq	r0, r0, r0
  1c:	0000000c 	andeq	r0, r0, ip
	...
  28:	0000001c 	andeq	r0, r0, ip, lsl r0
  2c:	004d0002 	subeq	r0, sp, r2
  30:	00040000 	andeq	r0, r4, r0
	...
  3c:	00000104 	andeq	r0, r0, r4, lsl #2
	...
  48:	0000001c 	andeq	r0, r0, ip, lsl r0
  4c:	00d10002 	sbcseq	r0, r1, r2
  50:	00040000 	andeq	r0, r4, r0
  54:	00000000 	andeq	r0, r0, r0
  58:	08003134 	stmdaeq	r0, {r2, r4, r5, r8, ip, sp}
  5c:	00000318 	andeq	r0, r0, r8, lsl r3
	...
  68:	0000001c 	andeq	r0, r0, ip, lsl r0
  6c:	05e20002 	strbeq	r0, [r2, #2]!
  70:	00040000 	andeq	r0, r4, r0
  74:	00000000 	andeq	r0, r0, r0
  78:	0800344c 	stmdaeq	r0, {r2, r3, r6, sl, ip, sp}
  7c:	00000134 	andeq	r0, r0, r4, lsr r1
	...
  88:	0000001c 	andeq	r0, r0, ip, lsl r0
  8c:	0c4f0002 	mcrreq	0, 0, r0, pc, cr2
  90:	00040000 	andeq	r0, r4, r0
	...
  9c:	000021cc 	andeq	r2, r0, ip, asr #3
	...
  a8:	0000001c 	andeq	r0, r0, ip, lsl r0
  ac:	27140002 	ldrcs	r0, [r4, -r2]
  b0:	00040000 	andeq	r0, r4, r0
	...
  bc:	000003bc 	strheq	r0, [r0], -ip
	...
  c8:	0000001c 	andeq	r0, r0, ip, lsl r0
  cc:	2e940002 	cdpcs	0, 9, cr0, cr4, cr2, {0}
  d0:	00040000 	andeq	r0, r4, r0
  d4:	00000000 	andeq	r0, r0, r0
  d8:	08003580 	stmdaeq	r0, {r7, r8, sl, ip, sp}
  dc:	000006b6 	strheq	r0, [r0], -r6
	...
  e8:	0000001c 	andeq	r0, r0, ip, lsl r0
  ec:	36cf0002 	strbcc	r0, [pc], r2
  f0:	00040000 	andeq	r0, r4, r0
  f4:	00000000 	andeq	r0, r0, r0
  f8:	08003c38 	stmdaeq	r0, {r3, r4, r5, sl, fp, ip, sp}
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
  fc:	00000610 	andeq	r0, r0, r0, lsl r6
	...
	int i;
	int frames = (time/frameLength) + 1;
 108:	0000001c 	andeq	r0, r0, ip, lsl r0
	nextframe_ = getMillis() + frameLength;
 10c:	40ee0002 	rscmi	r0, lr, r2
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
 110:	00040000 	andeq	r0, r4, r0
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
 114:	00000000 	andeq	r0, r0, r0
 118:	08004248 	stmdaeq	r0, {r3, r6, r9, lr}
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
 11c:	00000340 	andeq	r0, r0, r0, asr #6
	...
		if (nextpose_[i] > pose_[i]) {
 128:	0000001c 	andeq	r0, r0, ip, lsl r0
 12c:	45650002 	strbmi	r0, [r5, #-2]!
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
 130:	00040000 	andeq	r0, r4, r0
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
 134:	00000000 	andeq	r0, r0, r0
 138:	08004588 	stmdaeq	r0, {r3, r7, r8, sl, lr}
 13c:	0000078c 	andeq	r0, r0, ip, lsl #15
	...
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
 148:	0000001c 	andeq	r0, r0, ip, lsl r0
 14c:	52d00002 	sbcspl	r0, r0, #2	; 0x2
}
 150:	00040000 	andeq	r0, r4, r0
 154:	00000000 	andeq	r0, r0, r0
 158:	08004d14 	stmdaeq	r0, {r2, r4, r8, sl, fp, lr}
 15c:	00000404 	andeq	r0, r0, r4, lsl #8
	...
 168:	0000001c 	andeq	r0, r0, ip, lsl r0
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
 16c:	5a950002 	bpl	fe54017c <SCS_BASE+0x1e53217c>
 170:	00040000 	andeq	r0, r4, r0
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
 174:	00000000 	andeq	r0, r0, r0
 178:	08005118 	stmdaeq	r0, {r3, r4, r8, ip, lr}
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 17c:	000001f4 	strdeq	r0, [r0], -r4
	...
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
 188:	0000001c 	andeq	r0, r0, ip, lsl r0
		pose_[i] = 512;
 18c:	5cf10002 	ldclpl	0, cr0, [r1], #8
		nextpose_[i] = 512;
 190:	00040000 	andeq	r0, r4, r0
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
 194:	00000000 	andeq	r0, r0, r0
 198:	0800530c 	stmdaeq	r0, {r2, r3, r8, r9, ip, lr}
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
 19c:	0000019e 	muleq	r0, lr, r1
	...
	nextframe_ = getMillis();
 1a8:	0000001c 	andeq	r0, r0, ip, lsl r0
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
 1ac:	60ea0002 	rscvs	r0, sl, r2
 1b0:	00040000 	andeq	r0, r4, r0
 1b4:	00000000 	andeq	r0, r0, r0
 1b8:	080054ac 	stmdaeq	r0, {r2, r3, r5, r7, sl, ip, lr}
 1bc:	00000024 	andeq	r0, r0, r4, lsr #32
	...
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
 1c8:	0000001c 	andeq	r0, r0, ip, lsl r0
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
 1cc:	62af0002 	adcvs	r0, pc, #2	; 0x2
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 1d0:	00040000 	andeq	r0, r4, r0
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
 1d4:	00000000 	andeq	r0, r0, r0
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 1d8:	080054d0 	stmdaeq	r0, {r4, r6, r7, sl, ip, lr}
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
 1dc:	0000002c 	andeq	r0, r0, ip, lsr #32
	...
		pose_[i] = 512;
 1e8:	0000001c 	andeq	r0, r0, ip, lsl r0
		nextpose_[i] = 512;
 1ec:	64710002 	ldrbtvs	r0, [r1], #-2
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
 1f0:	00040000 	andeq	r0, r4, r0
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
 1f4:	00000000 	andeq	r0, r0, r0
 1f8:	080054fc 	stmdaeq	r0, {r2, r3, r4, r5, r6, r7, sl, ip, lr}
	interpolating = 0;
 1fc:	0000004a 	andeq	r0, r0, sl, asr #32
	...
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
 208:	0000001c 	andeq	r0, r0, ip, lsl r0
 20c:	66820002 	strvs	r0, [r2], r2
 210:	00040000 	andeq	r0, r4, r0
 214:	00000000 	andeq	r0, r0, r0
 218:	08005548 	stmdaeq	r0, {r3, r6, r8, sl, ip, lr}
 21c:	00000290 	muleq	r0, r0, r2
	...
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
 228:	0000001c 	andeq	r0, r0, ip, lsl r0
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
 22c:	69360002 	ldmdbvs	r6!, {r1}
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
 230:	00040000 	andeq	r0, r4, r0
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
 234:	00000000 	andeq	r0, r0, r0
 238:	080057d8 	stmdaeq	r0, {r3, r4, r6, r7, r8, r9, sl, ip, lr}
	dxl_set_txpacket_parameter(1, 2);
 23c:	00000454 	andeq	r0, r0, r4, asr r4
	...
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 248:	0000001c 	andeq	r0, r0, ip, lsl r0
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
 24c:	6ee10002 	cdpvs	0, 14, cr0, cr1, cr2, {0}
 250:	00040000 	andeq	r0, r4, r0
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 254:	00000000 	andeq	r0, r0, r0
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 258:	08005c2c 	stmdaeq	r0, {r2, r3, r5, sl, fp, ip, lr}
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 25c:	000005e4 	andeq	r0, r0, r4, ror #11
	...
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 268:	0000001c 	andeq	r0, r0, ip, lsl r0
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
 26c:	76ce0002 	strbvc	r0, [lr], r2
 270:	00040000 	andeq	r0, r4, r0
 274:	00000000 	andeq	r0, r0, r0
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 278:	08006210 	stmdaeq	r0, {r4, r9, sp, lr}
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
 27c:	00000394 	muleq	r0, r4, r3
	...
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
 288:	0000001c 	andeq	r0, r0, ip, lsl r0
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
 28c:	81ed0002 	mvnhi	r0, r2
 290:	00040000 	andeq	r0, r4, r0
 294:	00000000 	andeq	r0, r0, r0
	dxl_txrx_packet();
 298:	080065a4 	stmdaeq	r0, {r2, r5, r7, r8, sl, sp, lr}
	u16 CommStatus = dxl_get_result();
 29c:	00000528 	andeq	r0, r0, r8, lsr #10
	...
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
		PrintErrorCode();
	else
		PrintCommStatus(CommStatus);
 2a8:	0000001c 	andeq	r0, r0, ip, lsl r0
#endif
}
 2ac:	89270002 	stmdbhi	r7!, {r1}
 2b0:	00040000 	andeq	r0, r4, r0
 2b4:	00000000 	andeq	r0, r0, r0
 2b8:	08006acc 	stmdaeq	r0, {r2, r3, r6, r7, r9, fp, sp, lr}
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
 2bc:	00000288 	andeq	r0, r0, r8, lsl #5
	...

	if (interpolating == 0)
		return 0;
	int i;
	int complete = poseSize;
 2c8:	0000001c 	andeq	r0, r0, ip, lsl r0
	if (!fWait) {
 2cc:	8f6f0002 	svchi	0x006f0002
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
 2d0:	00040000 	andeq	r0, r4, r0
 2d4:	00000000 	andeq	r0, r0, r0
 2d8:	08006d54 	stmdaeq	r0, {r2, r4, r6, r8, sl, fp, sp, lr}
			return (getMillis() - nextframe_); // We still have some time to do something...
 2dc:	00000384 	andeq	r0, r0, r4, lsl #7
	...
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
 2e8:	0000001c 	andeq	r0, r0, ip, lsl r0
 2ec:	98560002 	ldmdals	r6, {r1}^
 2f0:	00040000 	andeq	r0, r4, r0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
 2f4:	00000000 	andeq	r0, r0, r0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 2f8:	080070d8 	stmdaeq	r0, {r3, r4, r6, r7, ip, sp, lr}
 2fc:	000000e0 	andeq	r0, r0, r0, ror #1
	...
 308:	0000001c 	andeq	r0, r0, ip, lsl r0
		int diff = nextpose_[i] - pose_[i];
 30c:	9a9d0002 	bls	fe74031c <SCS_BASE+0x1e73231c>
 310:	00040000 	andeq	r0, r4, r0
 314:	00000000 	andeq	r0, r0, r0
 318:	080071b8 	stmdaeq	r0, {r3, r4, r5, r7, r8, ip, sp, lr}
 31c:	000003a4 	andeq	r0, r0, r4, lsr #7
	...
			if (diff > 0) {
				if (diff < speed_[i]) {
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
 328:	0000001c 	andeq	r0, r0, ip, lsl r0
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
 32c:	a35a0002 	cmpge	sl, #2	; 0x2
					pose_[i] = nextpose_[i];
 330:	00040000 	andeq	r0, r4, r0
					complete--;
 334:	00000000 	andeq	r0, r0, r0
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
 338:	0800755c 	stmdaeq	r0, {r2, r3, r4, r6, r8, sl, ip, sp, lr}
 33c:	000000a4 	andeq	r0, r0, r4, lsr #1
	...
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
 348:	0000001c 	andeq	r0, r0, ip, lsl r0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 34c:	a5490002 	strbge	r0, [r9, #-2]
 350:	00040000 	andeq	r0, r4, r0
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
 354:	00000000 	andeq	r0, r0, r0
		interpolating = 0;
 358:	08007600 	stmdaeq	r0, {r9, sl, ip, sp, lr}
	BioloidControllerEx_writePose();
 35c:	000003bc 	strheq	r0, [r0], -ip
	...
	return 0;
}
 368:	0000001c 	andeq	r0, r0, ip, lsl r0
 36c:	ae990002 	cdpge	0, 9, cr0, cr9, cr2, {0}
 370:	00040000 	andeq	r0, r4, r0
 374:	00000000 	andeq	r0, r0, r0
 378:	080079bc 	stmdaeq	r0, {r2, r3, r4, r5, r7, r8, fp, ip, sp, lr}
 37c:	0000006e 	andeq	r0, r0, lr, rrx
	...
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
 388:	0000001c 	andeq	r0, r0, ip, lsl r0
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
 38c:	af230002 	svcge	0x00230002
 390:	00040000 	andeq	r0, r4, r0
 394:	00000000 	andeq	r0, r0, r0
 398:	08007a2c 	stmdaeq	r0, {r2, r3, r5, r9, fp, ip, sp, lr}
 39c:	00000054 	andeq	r0, r0, r4, asr r0
	...

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
 3a8:	0000001c 	andeq	r0, r0, ip, lsl r0
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
 3ac:	b0290002 	eorlt	r0, r9, r2
 3b0:	00040000 	andeq	r0, r4, r0
	...
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
 3bc:	00000028 	andeq	r0, r0, r8, lsr #32
	...
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
 3c8:	0000001c 	andeq	r0, r0, ip, lsl r0
 3cc:	b0ee0002 	rsclt	r0, lr, r2
 3d0:	00040000 	andeq	r0, r4, r0
 3d4:	00000000 	andeq	r0, r0, r0
 3d8:	08007a80 	stmdaeq	r0, {r7, r9, fp, ip, sp, lr}
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
 3dc:	00000030 	andeq	r0, r0, r0, lsr r0
	...
 3e8:	0000001c 	andeq	r0, r0, ip, lsl r0
 3ec:	c3620002 	cmngt	r2, #2	; 0x2
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
 3f0:	00040000 	andeq	r0, r4, r0
	...
 3fc:	000000c8 	andeq	r0, r0, r8, asr #1
	...
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
 408:	0000001c 	andeq	r0, r0, ip, lsl r0
 40c:	c4a80002 	strtgt	r0, [r8], #2
 410:	00040000 	andeq	r0, r4, r0
	...
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
 41c:	000000fc 	strdeq	r0, [r0], -ip
	...
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
 428:	0000001c 	andeq	r0, r0, ip, lsl r0
 42c:	c5b60002 	ldrgt	r0, [r6, #2]!
 430:	00040000 	andeq	r0, r4, r0
	...
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
 43c:	000000d0 	ldrdeq	r0, [r0], -r0
	...
 448:	0000001c 	andeq	r0, r0, ip, lsl r0
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
 44c:	c6c90002 	strbgt	r0, [r9], r2
 450:	00040000 	andeq	r0, r4, r0
	...
 45c:	0000009c 	muleq	r0, ip, r0
	...
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
 468:	0000001c 	andeq	r0, r0, ip, lsl r0
 46c:	d06e0002 	rsble	r0, lr, r2
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
 470:	00040000 	andeq	r0, r4, r0
 474:	00000000 	andeq	r0, r0, r0
 478:	08007ab0 	stmdaeq	r0, {r4, r5, r7, r9, fp, ip, sp, lr}
 47c:	0000010c 	andeq	r0, r0, ip, lsl #2
	...
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
 488:	00000024 	andeq	r0, r0, r4, lsr #32
 48c:	da200002 	ble	80049c <__Stack_Size+0x80009c>
 490:	00040000 	andeq	r0, r4, r0
	...
 49c:	0000000c 	andeq	r0, r0, ip
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
 4a0:	00000000 	andeq	r0, r0, r0
 4a4:	0000000c 	andeq	r0, r0, ip
	...

Disassembly of section .debug_pubnames:

00000000 <.debug_pubnames>:
       0:	00000021 	andeq	r0, r0, r1, lsr #32
       4:	00d10002 	sbcseq	r0, r1, r2
       8:	05110000 	ldreq	r0, [r1]
       c:	03600000 	cmneq	r0, #0	; 0x0
      10:	655f0000 	ldrbvs	r0, [pc, #0]	; 18 <_Minimum_Stack_Size-0xe8>
      14:	00746978 	rsbseq	r6, r4, r8, ror r9
      18:	00000373 	andeq	r0, r0, r3, ror r3
      1c:	6e69616d 	powvsez	f6, f1, #5.0
      20:	00000000 	andeq	r0, r0, r0
      24:	00063800 	andeq	r3, r6, r0, lsl #16
      28:	e2000200 	and	r0, r0, #0	; 0x0
      2c:	6d000005 	stcvs	0, cr0, [r0, #-20]
      30:	67000006 	strvs	r0, [r0, -r6]
      34:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
      38:	7845494d 	stmdavc	r5, {r0, r2, r3, r6, r8, fp, lr}^
      3c:	74706563 	ldrbtvc	r6, [r0], #-1379
      40:	006e6f69 	rsbeq	r6, lr, r9, ror #30
      44:	0000007a 	andeq	r0, r0, sl, ror r0
      48:	64726148 	ldrbtvs	r6, [r2], #-328
      4c:	6c756146 	ldfvse	f6, [r5], #-280
      50:	63784574 	cmnvs	r8, #486539264	; 0x1d000000
      54:	69747065 	ldmdbvs	r4!, {r0, r2, r5, r6, ip, sp, lr}^
      58:	8d006e6f 	stchi	14, cr6, [r0, #-444]
      5c:	4d000000 	stcmi	0, cr0, [r0]
      60:	614d6d65 	cmpvs	sp, r5, ror #26
      64:	6567616e 	strbvs	r6, [r7, #-366]!
      68:	65637845 	strbvs	r7, [r3, #-2117]!
      6c:	6f697470 	svcvs	0x00697470
      70:	00a0006e 	adceq	r0, r0, lr, rrx
      74:	75420000 	strbvc	r0, [r2]
      78:	75614673 	strbvc	r4, [r1, #-1651]!
      7c:	7845746c 	stmdavc	r5, {r2, r3, r5, r6, sl, ip, sp, lr}^
      80:	74706563 	ldrbtvc	r6, [r0], #-1379
      84:	006e6f69 	rsbeq	r6, lr, r9, ror #30
      88:	000000b3 	strheq	r0, [r0], -r3
      8c:	67617355 	undefined
      90:	75614665 	strbvc	r4, [r1, #-1637]!
      94:	7845746c 	stmdavc	r5, {r2, r3, r5, r6, sl, ip, sp, lr}^
      98:	74706563 	ldrbtvc	r6, [r0], #-1379
      9c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
      a0:	000000c6 	andeq	r0, r0, r6, asr #1
      a4:	75626544 	strbvc	r6, [r2, #-1348]!
      a8:	6e6f4d67 	cdpvs	13, 6, cr4, cr15, cr7, {3}
      ac:	726f7469 	rsbvc	r7, pc, #1761607680	; 0x69000000
      b0:	0000d900 	andeq	sp, r0, r0, lsl #18
      b4:	43565300 	cmpmi	r6, #0	; 0x0
      b8:	646e6148 	strbtvs	r6, [lr], #-328
      bc:	0072656c 	rsbseq	r6, r2, ip, ror #10
      c0:	000000ec 	andeq	r0, r0, ip, ror #1
      c4:	646e6550 	strbtvs	r6, [lr], #-1360
      c8:	00435653 	subeq	r5, r3, r3, asr r6
      cc:	000000ff 	strdeq	r0, [r0], -pc
      d0:	47445757 	smlsldmi	r5, r4, r7, r7
      d4:	5152495f 	cmppl	r2, pc, asr r9
      d8:	646e6148 	strbtvs	r6, [lr], #-328
      dc:	0072656c 	rsbseq	r6, r2, ip, ror #10
      e0:	00000112 	andeq	r0, r0, r2, lsl r1
      e4:	5f445650 	svcpl	0x00445650
      e8:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
      ec:	6c646e61 	stclvs	14, cr6, [r4], #-388
      f0:	25007265 	strcs	r7, [r0, #-613]
      f4:	54000001 	strpl	r0, [r0], #-1
      f8:	45504d41 	ldrbmi	r4, [r0, #-3393]
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
      fc:	52495f52 	subpl	r5, r9, #328	; 0x148
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
     100:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
     104:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     108:	00013800 	andeq	r3, r1, r0, lsl #16
	nextframe_ = getMillis() + frameLength;
     10c:	43545200 	cmpmi	r4, #0	; 0x0
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     110:	5152495f 	cmppl	r2, pc, asr r9
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
     114:	646e6148 	strbtvs	r6, [lr], #-328
     118:	0072656c 	rsbseq	r6, r2, ip, ror #10
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     11c:	0000014b 	andeq	r0, r0, fp, asr #2
     120:	53414c46 	movtpl	r4, #7238	; 0x1c46
     124:	52495f48 	subpl	r5, r9, #288	; 0x120
		if (nextpose_[i] > pose_[i]) {
     128:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     12c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
     130:	00015e00 	andeq	r5, r1, r0, lsl #28
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
     134:	43435200 	movtmi	r5, #12800	; 0x3200
     138:	5152495f 	cmppl	r2, pc, asr r9
     13c:	646e6148 	strbtvs	r6, [lr], #-328
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     140:	0072656c 	rsbseq	r6, r2, ip, ror #10
     144:	00000171 	andeq	r0, r0, r1, ror r1
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
     148:	49545845 	ldmdbmi	r4, {r0, r2, r6, fp, ip, lr}^
     14c:	52495f30 	subpl	r5, r9, #192	; 0xc0
}
     150:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     154:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     158:	00018400 	andeq	r8, r1, r0, lsl #8
     15c:	54584500 	ldrbpl	r4, [r8], #-1280
     160:	495f3149 	ldmdbmi	pc, {r0, r3, r6, r8, ip, sp}^
     164:	61485152 	cmpvs	r8, r2, asr r1
     168:	656c646e 	strbvs	r6, [ip, #-1134]!
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
     16c:	01970072 	orrseq	r0, r7, r2, ror r0
     170:	58450000 	stmdapl	r5, {}^
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
     174:	5f324954 	svcpl	0x00324954
     178:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     17c:	6c646e61 	stclvs	14, cr6, [r4], #-388
     180:	aa007265 	bge	1cb1c <__Stack_Size+0x1c71c>
		nextpose_[i] = 512;
     184:	45000001 	strmi	r0, [r0, #-1]
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
     188:	33495458 	movtcc	r5, #37976	; 0x9458
		pose_[i] = 512;
     18c:	5152495f 	cmppl	r2, pc, asr r9
		nextpose_[i] = 512;
     190:	646e6148 	strbtvs	r6, [lr], #-328
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
     194:	0072656c 	rsbseq	r6, r2, ip, ror #10
     198:	000001bd 	strheq	r0, [r0], -sp
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
     19c:	49545845 	ldmdbmi	r4, {r0, r2, r6, fp, ip, lr}^
     1a0:	52495f34 	subpl	r5, r9, #208	; 0xd0
	nextframe_ = getMillis();
     1a4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     1a8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     1ac:	0001d100 	andeq	sp, r1, r0, lsl #2
     1b0:	414d4400 	cmpmi	sp, r0, lsl #8
     1b4:	68435f31 	stmdavs	r3, {r0, r4, r5, r8, r9, sl, fp, ip, lr}^
     1b8:	656e6e61 	strbvs	r6, [lr, #-3681]!
     1bc:	495f316c 	ldmdbmi	pc, {r2, r3, r5, r6, r8, ip, sp}^
     1c0:	61485152 	cmpvs	r8, r2, asr r1
     1c4:	656c646e 	strbvs	r6, [ip, #-1134]!
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1c8:	01e50072 	mvneq	r0, r2, ror r0
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
     1cc:	4d440000 	stclmi	0, cr0, [r4]
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d0:	435f3141 	cmpmi	pc, #1073741840	; 0x40000010
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1d4:	6e6e6168 	powvsez	f6, f6, #0.0
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d8:	5f326c65 	svcpl	0x00326c65
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
     1dc:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     1e0:	6c646e61 	stclvs	14, cr6, [r4], #-388
		pose_[i] = 512;
		nextpose_[i] = 512;
     1e4:	f9007265 	undefined instruction 0xf9007265
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1e8:	44000001 	strmi	r0, [r0], #-1
		nextpose_[i] = 512;
     1ec:	5f31414d 	svcpl	0x0031414d
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
     1f0:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
     1f4:	336c656e 	cmncc	ip, #461373440	; 0x1b800000
     1f8:	5152495f 	cmppl	r2, pc, asr r9
	interpolating = 0;
     1fc:	646e6148 	strbtvs	r6, [lr], #-328
	nextframe_ = getMillis();
     200:	0072656c 	rsbseq	r6, r2, ip, ror #10
     204:	0000020d 	andeq	r0, r0, sp, lsl #4
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     208:	31414d44 	cmpcc	r1, r4, asr #26
     20c:	6168435f 	cmnvs	r8, pc, asr r3
     210:	6c656e6e 	stclvs	14, cr6, [r5], #-440
     214:	52495f34 	subpl	r5, r9, #208	; 0xd0
     218:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     21c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     220:	00022100 	andeq	r2, r2, r0, lsl #2
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
     224:	414d4400 	cmpmi	sp, r0, lsl #8
     228:	68435f31 	stmdavs	r3, {r0, r4, r5, r8, r9, sl, fp, ip, lr}^
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
     22c:	656e6e61 	strbvs	r6, [lr, #-3681]!
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
     230:	495f356c 	ldmdbmi	pc, {r2, r3, r5, r6, r8, sl, ip, sp}^
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
     234:	61485152 	cmpvs	r8, r2, asr r1
     238:	656c646e 	strbvs	r6, [ip, #-1134]!
	dxl_set_txpacket_parameter(1, 2);
     23c:	02350072 	eorseq	r0, r5, #114	; 0x72
     240:	4d440000 	stclmi	0, cr0, [r4]
     244:	435f3141 	cmpmi	pc, #1073741840	; 0x40000010
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     248:	6e6e6168 	powvsez	f6, f6, #0.0
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
     24c:	5f366c65 	svcpl	0x00366c65
     250:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     254:	6c646e61 	stclvs	14, cr6, [r4], #-388
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     258:	49007265 	stmdbmi	r0, {r0, r2, r5, r6, r9, ip, sp, lr}
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     25c:	44000002 	strmi	r0, [r0], #-2
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     260:	5f31414d 	svcpl	0x0031414d
     264:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     268:	376c656e 	strbcc	r6, [ip, -lr, ror #10]!
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     26c:	5152495f 	cmppl	r2, pc, asr r9
     270:	646e6148 	strbtvs	r6, [lr], #-328
     274:	0072656c 	rsbseq	r6, r2, ip, ror #10
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     278:	0000025d 	andeq	r0, r0, sp, asr r2
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     27c:	31434441 	cmpcc	r3, r1, asr #8
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
     280:	495f325f 	ldmdbmi	pc, {r0, r1, r2, r3, r4, r6, r9, ip, sp}^
     284:	61485152 	cmpvs	r8, r2, asr r1
     288:	656c646e 	strbvs	r6, [ip, #-1134]!
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
     28c:	02710072 	rsbseq	r0, r1, #114	; 0x72
     290:	53550000 	cmppl	r5, #0	; 0x0
     294:	50485f42 	subpl	r5, r8, r2, asr #30
	dxl_txrx_packet();
     298:	4e41435f 	mcrmi	3, 2, r4, cr1, cr15, {2}
	u16 CommStatus = dxl_get_result();
     29c:	5f58545f 	svcpl	0x0058545f
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
     2a0:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
		PrintErrorCode();
     2a4:	6c646e61 	stclvs	14, cr6, [r4], #-388
	else
		PrintCommStatus(CommStatus);
     2a8:	85007265 	strhi	r7, [r0, #-613]
#endif
}
     2ac:	55000002 	strpl	r0, [r0, #-2]
     2b0:	4c5f4253 	lfmmi	f4, 2, [pc], {83}
     2b4:	41435f50 	cmpmi	r3, r0, asr pc
     2b8:	58525f4e 	ldmdapl	r2, {r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
     2bc:	52495f30 	subpl	r5, r9, #192	; 0xc0
     2c0:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}

	if (interpolating == 0)
     2c4:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
		return 0;
	int i;
	int complete = poseSize;
     2c8:	00029900 	andeq	r9, r2, r0, lsl #18
	if (!fWait) {
     2cc:	4e414300 	cdpmi	3, 4, cr4, cr1, cr0, {0}
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
     2d0:	3158525f 	cmpcc	r8, pc, asr r2
     2d4:	5152495f 	cmppl	r2, pc, asr r9
     2d8:	646e6148 	strbtvs	r6, [lr], #-328
			return (getMillis() - nextframe_); // We still have some time to do something...
     2dc:	0072656c 	rsbseq	r6, r2, ip, ror #10
     2e0:	000002ad 	andeq	r0, r0, sp, lsr #5
     2e4:	5f4e4143 	svcpl	0x004e4143
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
     2e8:	5f454353 	svcpl	0x00454353
     2ec:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     2f0:	6c646e61 	stclvs	14, cr6, [r4], #-388
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     2f4:	c1007265 	tstgt	r0, r5, ror #4
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     2f8:	45000002 	strmi	r0, [r0, #-2]
     2fc:	39495458 	stmdbcc	r9, {r3, r4, r6, sl, ip, lr}^
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     300:	495f355f 	ldmdbmi	pc, {r0, r1, r2, r3, r4, r6, r8, sl, ip, sp}^
     304:	61485152 	cmpvs	r8, r2, asr r1
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     308:	656c646e 	strbvs	r6, [ip, #-1134]!
		int diff = nextpose_[i] - pose_[i];
     30c:	02d50072 	sbcseq	r0, r5, #114	; 0x72
     310:	49540000 	ldmdbmi	r4, {}^
     314:	425f314d 	subsmi	r3, pc, #1073741843	; 0x40000013
     318:	495f4b52 	ldmdbmi	pc, {r1, r4, r6, r8, r9, fp, lr}^
     31c:	61485152 	cmpvs	r8, r2, asr r1
		if (diff == 0) {
     320:	656c646e 	strbvs	r6, [ip, #-1134]!
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     324:	02e90072 	rsceq	r0, r9, #114	; 0x72
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
     328:	49540000 	ldmdbmi	r4, {}^
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     32c:	555f314d 	ldrbpl	r3, [pc, #-333]	; 1e7 <_Minimum_Stack_Size+0xe7>
					pose_[i] = nextpose_[i];
     330:	52495f50 	subpl	r5, r9, #320	; 0x140
					complete--;
     334:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     338:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     33c:	0002fd00 	andeq	pc, r2, r0, lsl #26
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     340:	4d495400 	cfstrdmi	mvd5, [r9]
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     344:	52545f31 	subspl	r5, r4, #196	; 0xc4
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     348:	4f435f47 	svcmi	0x00435f47
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     34c:	52495f4d 	subpl	r5, r9, #308	; 0x134
     350:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
     354:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
		interpolating = 0;
     358:	00031100 	andeq	r1, r3, r0, lsl #2
	BioloidControllerEx_writePose();
     35c:	4d495400 	cfstrdmi	mvd5, [r9]
     360:	43435f31 	movtmi	r5, #16177	; 0x3f31
	return 0;
}
     364:	5152495f 	cmppl	r2, pc, asr r9
     368:	646e6148 	strbtvs	r6, [lr], #-328
     36c:	0072656c 	rsbseq	r6, r2, ip, ror #10
     370:	00000325 	andeq	r0, r0, r5, lsr #6
     374:	324d4954 	subcc	r4, sp, #1376256	; 0x150000
     378:	5152495f 	cmppl	r2, pc, asr r9
     37c:	646e6148 	strbtvs	r6, [lr], #-328
     380:	0072656c 	rsbseq	r6, r2, ip, ror #10
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
     384:	00000339 	andeq	r0, r0, r9, lsr r3
     388:	334d4954 	movtcc	r4, #55636	; 0xd954
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
     38c:	5152495f 	cmppl	r2, pc, asr r9
     390:	646e6148 	strbtvs	r6, [lr], #-328
     394:	0072656c 	rsbseq	r6, r2, ip, ror #10
     398:	0000034d 	andeq	r0, r0, sp, asr #6
     39c:	344d4954 	strbcc	r4, [sp], #-2388
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
     3a0:	5152495f 	cmppl	r2, pc, asr r9

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
     3a4:	646e6148 	strbtvs	r6, [lr], #-328
     3a8:	0072656c 	rsbseq	r6, r2, ip, ror #10
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
     3ac:	00000361 	andeq	r0, r0, r1, ror #6
     3b0:	31433249 	cmpcc	r3, r9, asr #4
     3b4:	5f56455f 	svcpl	0x0056455f
     3b8:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
     3bc:	6c646e61 	stclvs	14, cr6, [r4], #-388
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
     3c0:	75007265 	strvc	r7, [r0, #-613]
     3c4:	49000003 	stmdbmi	r0, {r0, r1}
     3c8:	5f314332 	svcpl	0x00314332
     3cc:	495f5245 	ldmdbmi	pc, {r0, r2, r6, r9, ip, lr}^
     3d0:	61485152 	cmpvs	r8, r2, asr r1
     3d4:	656c646e 	strbvs	r6, [ip, #-1134]!
     3d8:	03890072 	orreq	r0, r9, #114	; 0x72
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
     3dc:	32490000 	subcc	r0, r9, #0	; 0x0
     3e0:	455f3243 	ldrbmi	r3, [pc, #-579]	; 1a5 <_Minimum_Stack_Size+0xa5>
     3e4:	52495f56 	subpl	r5, r9, #344	; 0x158
     3e8:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     3ec:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     3f0:	00039d00 	andeq	r9, r3, r0, lsl #26
     3f4:	43324900 	teqmi	r2, #0	; 0x0
     3f8:	52455f32 	subpl	r5, r5, #200	; 0xc8
     3fc:	5152495f 	cmppl	r2, pc, asr r9
     400:	646e6148 	strbtvs	r6, [lr], #-328
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
     404:	0072656c 	rsbseq	r6, r2, ip, ror #10
     408:	000003b1 	strheq	r0, [r0], -r1
     40c:	31495053 	qdaddcc	r5, r3, r9
     410:	5152495f 	cmppl	r2, pc, asr r9
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
     414:	646e6148 	strbtvs	r6, [lr], #-328
     418:	0072656c 	rsbseq	r6, r2, ip, ror #10
     41c:	000003c5 	andeq	r0, r0, r5, asr #7
     420:	32495053 	subcc	r5, r9, #83	; 0x53
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
     424:	5152495f 	cmppl	r2, pc, asr r9
     428:	646e6148 	strbtvs	r6, [lr], #-328
     42c:	0072656c 	rsbseq	r6, r2, ip, ror #10
     430:	000003d9 	ldrdeq	r0, [r0], -r9
     434:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
     438:	495f3254 	ldmdbmi	pc, {r2, r4, r6, r9, ip, sp}^
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     43c:	61485152 	cmpvs	r8, r2, asr r1
     440:	656c646e 	strbvs	r6, [ip, #-1134]!
     444:	03ed0072 	mvneq	r0, #114	; 0x72
     448:	58450000 	stmdapl	r5, {}^
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     44c:	35314954 	ldrcc	r4, [r1, #-2388]!
     450:	5f30315f 	svcpl	0x0030315f
     454:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     458:	6c646e61 	stclvs	14, cr6, [r4], #-388
     45c:	01007265 	tsteq	r0, r5, ror #4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     460:	52000004 	andpl	r0, r0, #4	; 0x4
     464:	6c414354 	mcrrvs	3, 5, r4, r1, cr4
     468:	5f6d7261 	svcpl	0x006d7261
     46c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     470:	6c646e61 	stclvs	14, cr6, [r4], #-388
     474:	15007265 	strne	r7, [r0, #-613]
     478:	55000004 	strpl	r0, [r0, #-4]
     47c:	61574253 	cmpvs	r7, r3, asr r2
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
     480:	7055656b 	subsvc	r6, r5, fp, ror #10
     484:	5152495f 	cmppl	r2, pc, asr r9
     488:	646e6148 	strbtvs	r6, [lr], #-328
     48c:	0072656c 	rsbseq	r6, r2, ip, ror #10
     490:	00000429 	andeq	r0, r0, r9, lsr #8
     494:	384d4954 	stmdacc	sp, {r2, r4, r6, r8, fp, lr}^
     498:	4b52425f 	blmi	1490e1c <__Stack_Size+0x1490a1c>
     49c:	5152495f 	cmppl	r2, pc, asr r9
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     4a0:	646e6148 	strbtvs	r6, [lr], #-328
     4a4:	0072656c 	rsbseq	r6, r2, ip, ror #10
     4a8:	0000043d 	andeq	r0, r0, sp, lsr r4
     4ac:	384d4954 	stmdacc	sp, {r2, r4, r6, r8, fp, lr}^
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     4b0:	5f50555f 	svcpl	0x0050555f
     4b4:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     4b8:	6c646e61 	stclvs	14, cr6, [r4], #-388
     4bc:	51007265 	tstpl	r0, r5, ror #4
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     4c0:	54000004 	strpl	r0, [r0], #-4
     4c4:	5f384d49 	svcpl	0x00384d49
     4c8:	5f475254 	svcpl	0x00475254
		GaitPosY[GaitCurrentLegNr] = 0;
     4cc:	5f4d4f43 	svcpl	0x004d4f43
     4d0:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
	}

	//Move body forward
	else {
		GaitPosX[GaitCurrentLegNr] = GaitPosX[GaitCurrentLegNr]
     4d4:	6c646e61 	stclvs	14, cr6, [r4], #-388
     4d8:	65007265 	strvs	r7, [r0, #-613]
     4dc:	54000004 	strpl	r0, [r0], #-4
     4e0:	5f384d49 	svcpl	0x00384d49
     4e4:	495f4343 	ldmdbmi	pc, {r0, r1, r6, r8, r9, lr}^
     4e8:	61485152 	cmpvs	r8, r2, asr r1
				- (g_InControlState.TravelLength.x
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitPosY[GaitCurrentLegNr] = 0;
     4ec:	656c646e 	strbvs	r6, [ip, #-1134]!
     4f0:	04790072 	ldrbteq	r0, [r9], #-114
     4f4:	44410000 	strbmi	r0, [r1]
		GaitPosZ[GaitCurrentLegNr] = GaitPosZ[GaitCurrentLegNr]
     4f8:	495f3343 	ldmdbmi	pc, {r0, r1, r6, r8, r9, ip, sp}^
     4fc:	61485152 	cmpvs	r8, r2, asr r1
     500:	656c646e 	strbvs	r6, [ip, #-1134]!
     504:	048d0072 	streq	r0, [sp], #114
				- (g_InControlState.TravelLength.z
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitRotY[GaitCurrentLegNr] = GaitRotY[GaitCurrentLegNr]
     508:	53460000 	movtpl	r0, #24576	; 0x6000
     50c:	495f434d 	ldmdbmi	pc, {r0, r2, r3, r6, r8, r9, lr}^
     510:	61485152 	cmpvs	r8, r2, asr r1
     514:	656c646e 	strbvs	r6, [ip, #-1134]!
				- (g_InControlState.TravelLength.y
						/ (short) g_InControlState.gaitCur.TLDivFactor);
	}

}
     518:	04a10072 	strteq	r0, [r1], #114
     51c:	44530000 	ldrbmi	r0, [r3]
     520:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^
     524:	61485152 	cmpvs	r8, r2, asr r1
     528:	656c646e 	strbvs	r6, [ip, #-1134]!
     52c:	04b50072 	ldrteq	r0, [r5], #114
     530:	49540000 	ldmdbmi	r4, {}^

}

//--------------------------------------------------------------------
//[GAIT Sequence]
void GaitSeq(void) {
     534:	495f354d 	ldmdbmi	pc, {r0, r2, r3, r6, r8, sl, ip, sp}^
	//Check if the Gait is in motion - If not if we are going to start a motion try to align our Gaitstep to start with a good foot
	// for the direction we are about to go...

	if (fWalking || (g_InControlState.ForceGaitStepCnt != 0))
     538:	61485152 	cmpvs	r8, r2, asr r1
     53c:	656c646e 	strbvs	r6, [ip, #-1134]!
     540:	04c90072 	strbeq	r0, [r9], #114
		TravelRequest = true;   // Is walking or was walking...
     544:	50530000 	subspl	r0, r3, r0
     548:	495f3349 	ldmdbmi	pc, {r0, r3, r6, r8, r9, ip, sp}^
	else {
		TravelRequest = (abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
     54c:	61485152 	cmpvs	r8, r2, asr r1
     550:	656c646e 	strbvs	r6, [ip, #-1134]!
     554:	04dd0072 	ldrbeq	r0, [sp], #114
     558:	41550000 	cmpmi	r5, r0
     55c:	5f345452 	svcpl	0x00345452
     560:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     564:	6c646e61 	stclvs	14, cr6, [r4], #-388
     568:	f1007265 	undefined instruction 0xf1007265
     56c:	54000004 	strpl	r0, [r0], #-4
     570:	5f364d49 	svcpl	0x00364d49
     574:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     578:	6c646e61 	stclvs	14, cr6, [r4], #-388
     57c:	05007265 	streq	r7, [r0, #-613]
				|| (abs(g_InControlState.TravelLength.y) > cTravelDeadZone);

		if (TravelRequest) {

		} else {    //Clear values under the cTravelDeadZone
			g_InControlState.TravelLength.x = 0;
     580:	54000005 	strpl	r0, [r0], #-5
			g_InControlState.TravelLength.z = 0;
     584:	5f374d49 	svcpl	0x00374d49
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     588:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     58c:	6c646e61 	stclvs	14, cr6, [r4], #-388
     590:	19007265 	stmdbne	r0, {r0, r2, r5, r6, r9, ip, sp, lr}
		Gait(LegIndex);
     594:	44000005 	strmi	r0, [r0], #-5
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     598:	5f32414d 	svcpl	0x0032414d
     59c:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     5a0:	316c656e 	cmncc	ip, lr, ror #10
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5a4:	5152495f 	cmppl	r2, pc, asr r9
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5a8:	646e6148 	strbtvs	r6, [lr], #-328
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5ac:	0072656c 	rsbseq	r6, r2, ip, ror #10
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5b0:	0000052d 	andeq	r0, r0, sp, lsr #10
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5b4:	32414d44 	subcc	r4, r1, #4352	; 0x1100
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
		g_InControlState.GaitStep = 1;
     5b8:	6168435f 	cmnvs	r8, pc, asr r3
     5bc:	6c656e6e 	stclvs	14, cr6, [r5], #-440

	// If we have a force count decrement it now...
	if (g_InControlState.ForceGaitStepCnt)
     5c0:	52495f32 	subpl	r5, r9, #200	; 0xc8
     5c4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
		g_InControlState.ForceGaitStepCnt--;
     5c8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
}
     5cc:	00054100 	andeq	r4, r5, r0, lsl #2
     5d0:	414d4400 	cmpmi	sp, r0, lsl #8
     5d4:	68435f32 	stmdavs	r3, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
     5d8:	656e6e61 	strbvs	r6, [lr, #-3681]!
     5dc:	495f336c 	ldmdbmi	pc, {r2, r3, r5, r6, r8, r9, ip, sp}^
}
//--------------------------------------------------------------------
//[BalanceBody]
void BalanceBody(void) {

	TotalTransZ = TotalTransZ / BalanceDivFactor;
     5e0:	61485152 	cmpvs	r8, r2, asr r1
     5e4:	656c646e 	strbvs	r6, [ip, #-1134]!
     5e8:	05550072 	ldrbeq	r0, [r5, #-114]
     5ec:	4d440000 	stclmi	0, cr0, [r4]
     5f0:	435f3241 	cmpmi	pc, #268435460	; 0x10000004
	TotalTransX = TotalTransX / BalanceDivFactor;
     5f4:	6e6e6168 	powvsez	f6, f6, #0.0
     5f8:	5f346c65 	svcpl	0x00346c65
     5fc:	52495f35 	subpl	r5, r9, #212	; 0xd4
	TotalTransY = TotalTransY / BalanceDivFactor;
     600:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     604:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     608:	00056900 	andeq	r6, r5, r0, lsl #18
     60c:	52415500 	subpl	r5, r1, #0	; 0x0

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     610:	495f3554 	ldmdbmi	pc, {r2, r4, r6, r8, sl, ip, sp}^
     614:	61485152 	cmpvs	r8, r2, asr r1
	TotalTransX = TotalTransX / BalanceDivFactor;
	TotalTransY = TotalTransY / BalanceDivFactor;

#ifndef QUADMODE // ??? on PhantomX Hex at no movment YBal1 = 1800, on Quad = 0...  Need to experiment
	if (TotalYBal1 > 0)        //Rotate balance circle by +/- 180 deg
		TotalYBal1 -= 1800;
     618:	656c646e 	strbvs	r6, [ip, #-1134]!
     61c:	057f0072 	ldrbeq	r0, [pc, #-114]!	; 5b2 <__Stack_Size+0x1b2>
	else
		TotalYBal1 += 1800;
     620:	53550000 	cmppl	r5, #0	; 0x0
#endif

	if (TotalZBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     624:	33545241 	cmpcc	r4, #268435460	; 0x10000004
     628:	5152495f 	cmppl	r2, pc, asr r9
     62c:	646e6148 	strbtvs	r6, [lr], #-328
		TotalZBal1 += 3600;
     630:	0072656c 	rsbseq	r6, r2, ip, ror #10
     634:	00000595 	muleq	r0, r5, r5

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     638:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
     63c:	495f3154 	ldmdbmi	pc, {r2, r4, r6, r8, ip, sp}^
		TotalXBal1 += 3600;
     640:	61485152 	cmpvs	r8, r2, asr r1
     644:	656c646e 	strbvs	r6, [ip, #-1134]!

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     648:	05ab0072 	streq	r0, [fp, #114]!
     64c:	79530000 	ldmdbvc	r3, {}^
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     650:	63695473 	cmnvs	r9, #1929379840	; 0x73000000
     654:	6e61486b 	cdpvs	8, 6, cr4, cr1, cr11, {3}
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     658:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     65c:	00000000 	andeq	r0, r0, r0
     660:	00096f00 	andeq	r6, r9, r0, lsl #30
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     664:	4f000200 	svcmi	0x00000200
     668:	c500000c 	strgt	r0, [r0, #-12]

}
     66c:	4e00001a 	mcrmi	0, 0, r0, cr0, cr10, {0}
     670:	43000006 	movwmi	r0, #6	; 0x6
     674:	616d6d6f 	cmnvs	sp, pc, ror #26
     678:	7265646e 	rsbvc	r6, r5, #1845493760	; 0x6e000000
     67c:	75706e49 	ldrbvc	r6, [r0, #-3657]!
     680:	6e6f4374 	mcrvs	3, 3, r4, cr15, cr4, {3}
     684:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
     688:	5f72656c 	svcpl	0x0072656c
//sin4        - Output Sinus of AngleDeg
//cos4          - Output Cosinus of AngleDeg
void GetSinCos(short AngleDeg1) {
	short ABSAngleDeg1;   //Absolute value of the Angle in Degrees, decimals = 1
	//Get the absolute value of AngleDeg
	if (AngleDeg1 < 0)
     68c:	74696e49 	strbtvc	r6, [r9], #-3657
     690:	00065d00 	andeq	r5, r6, r0, lsl #26
		ABSAngleDeg1 = AngleDeg1 * -1;
     694:	6d6f4300 	stclvs	3, cr4, [pc]
     698:	646e616d 	strbtvs	r6, [lr], #-365
	else
		ABSAngleDeg1 = AngleDeg1;

	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
     69c:	6e497265 	cdpvs	2, 4, cr7, cr9, cr5, {3}
     6a0:	43747570 	cmnmi	r4, #469762048	; 0x1c000000
     6a4:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
     6a8:	656c6c6f 	strbvs	r6, [ip, #-3183]!
     6ac:	6c415f72 	mcrrvs	15, 7, r5, r1, cr2
     6b0:	43776f6c 	cmnmi	r7, #432	; 0x1b0
     6b4:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
     6b8:	656c6c6f 	strbvs	r6, [ip, #-3183]!
     6bc:	746e4972 	strbtvc	r4, [lr], #-2418
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
     6c0:	75727265 	ldrbvc	r7, [r2, #-613]!
     6c4:	00737470 	rsbseq	r7, r3, r0, ror r4
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6c8:	00000678 	andeq	r0, r0, r8, ror r6
     6cc:	6d6d6f43 	stclvs	15, cr6, [sp, #-268]!
     6d0:	65646e61 	strbvs	r6, [r4, #-3681]!
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6d4:	72755472 	rsbsvc	r5, r5, #1912602624	; 0x72000000
     6d8:	626f526e 	rsbvs	r5, pc, #-536870906	; 0xe0000006
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6dc:	664f746f 	strbvs	r7, [pc], -pc, ror #8
     6e0:	068c0066 	streq	r0, [ip], r6, rrx
     6e4:	6f430000 	svcvs	0x00430000
     6e8:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
     6ec:	5f726564 	svcpl	0x00726564
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6f0:	6d6d6f43 	stclvs	15, cr6, [sp, #-268]!
     6f4:	65646e61 	strbvs	r6, [r4, #-3681]!
     6f8:	069f0072 	undefined
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
     6fc:	6f430000 	svcvs	0x00430000
     700:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
     704:	5f726564 	svcpl	0x00726564
     708:	69676562 	stmdbvs	r7!, {r1, r5, r6, r8, sl, sp, lr}^
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     70c:	06c6006e 	strbeq	r0, [r6], lr, rrx
     710:	61430000 	cmpvs	r3, r0
     714:	6c75636c 	ldclvs	3, cr6, [r5], #-432
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     718:	41657461 	cmnmi	r5, r1, ror #8
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     71c:	4d323158 	ldfmis	f3, [r2, #-352]!
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     720:	5365766f 	cmnpl	r5, #116391936	; 0x6f00000
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     724:	64656570 	strbtvs	r6, [r5], #-1392
     728:	00073400 	andeq	r3, r7, r0, lsl #8
     72c:	61657200 	cmnvs	r5, r0, lsl #4
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     730:	6e655364 	cdpvs	3, 6, cr5, cr5, cr4, {3}
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     734:	73726f73 	cmnvc	r2, #460	; 0x1cc
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     738:	00074800 	andeq	r4, r7, r0, lsl #16
     73c:	69725700 	ldmdbvs	r2!, {r8, r9, sl, ip, lr}^
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
     740:	754f6574 	strbvc	r6, [pc, #-1396]	; 1d4 <_Minimum_Stack_Size+0xd4>
     744:	74757074 	ldrbtvc	r7, [r5], #-116
     748:	07570073 	undefined
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     74c:	69530000 	ldmdbvs	r3, {}^
     750:	656c676e 	strbvs	r6, [ip, #-1902]!
     754:	4367654c 	cmnmi	r7, #318767104	; 0x13000000
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     758:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     75c:	6d006c6f 	stcvs	12, cr6, [r0, #-444]
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     760:	47000007 	strmi	r0, [r0, -r7]
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     764:	53746961 	cmnpl	r4, #1589248	; 0x184000
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     768:	63656c65 	cmnvs	r5, #25856	; 0x6500
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     76c:	077e0074 	undefined
     770:	61470000 	cmpvs	r7, r0
     774:	b9007469 	stmdblt	r0, {r0, r3, r5, r6, sl, ip, sp, lr}
     778:	47000007 	strmi	r0, [r0, -r7]
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     77c:	53746961 	cmnpl	r4, #1589248	; 0x184000
     780:	cf007165 	svcgt	0x00007165
     784:	42000007 	andmi	r0, r0, #7	; 0x7
     788:	6e616c61 	cdpvs	12, 6, cr6, cr1, cr1, {3}
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
     78c:	6f426563 	svcvs	0x00426563
     790:	e5007964 	str	r7, [r0, #-2404]
     794:	47000007 	strmi	r0, [r0, -r7]
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     798:	69537465 	ldmdbvs	r3, {r0, r2, r5, r6, sl, ip, sp, lr}^
     79c:	736f436e 	cmnvc	pc, #-1207959551	; 0xb8000001
     7a0:	00082000 	andeq	r2, r8, r0
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7a4:	74654700 	strbtvc	r4, [r5], #-1792
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7a8:	43637241 	cmnmi	r3, #268435460	; 0x10000004
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7ac:	5f00736f 	svcpl	0x0000736f
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b0:	69000008 	stmdbvs	r0, {r3}
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7b4:	74727173 	ldrbtvc	r7, [r2], #-371
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b8:	b4003233 	strlt	r3, [r0], #-563
     7bc:	47000008 	strmi	r0, [r0, -r8]
     7c0:	54417465 	strbpl	r7, [r1], #-1125
     7c4:	00326e61 	eorseq	r6, r2, r1, ror #28
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7c8:	000008f3 	strdeq	r0, [r0], -r3
     7cc:	436c6142 	cmnmi	ip, #-2147483632	; 0x80000010
     7d0:	4f636c61 	svcmi	0x00636c61
	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));
     7d4:	654c656e 	strbvs	r6, [ip, #-1390]
     7d8:	09860067 	stmibeq	r6, {r0, r1, r2, r5, r6}
     7dc:	6f420000 	svcvs	0x00420000
     7e0:	4b467964 	blmi	119ed78 <__Stack_Size+0x119e978>
     7e4:	000a7700 	andeq	r7, sl, r0, lsl #14
     7e8:	67654c00 	strbvs	r4, [r5, -r0, lsl #24]!
     7ec:	27004b49 	strcs	r4, [r0, -r9, asr #22]
     7f0:	4300000b 	movwmi	r0, #11	; 0xb
     7f4:	6b636568 	blvs	18d9d9c <__Stack_Size+0x18d999c>
     7f8:	76726553 	undefined
	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
	}
}
     7fc:	676e416f 	strbvs	r4, [lr, -pc, ror #2]!
     800:	6f42656c 	svcvs	0x0042656c
     804:	73646e75 	cmnvc	r4, #1872	; 0x750
     808:	000b6400 	andeq	r6, fp, r0, lsl #8
     80c:	65684300 	strbvs	r4, [r8, #-768]!
//cos4        - Input Cosinus
//AngleRad4     - Output Angle in AngleRad4
long GetArcCos(short cos4) {
	boolean NegativeValue/*:1*/;    //If the the value is Negative
	//Check for negative value
	if (cos4 < 0) {
     810:	6e416b63 	fnmacdvs	d22, d1, d19
     814:	73656c67 	cmnvc	r5, #26368	; 0x6700
     818:	000c2100 	andeq	r2, ip, r0, lsl #2
		cos4 = -cos4;
     81c:	6f6d5300 	svcvs	0x006d5300
     820:	4368746f 	cmnmi	r8, #1862270976	; 0x6f000000
		NegativeValue = 1;
	} else
		NegativeValue = 0;

	//Limit cos4 to his maximal value
	cos4 = min(cos4, c4DEC);
     824:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
     828:	6a006c6f 	bvs	1b9ec <__Stack_Size+0x1b5ec>
     82c:	4700000c 	strmi	r0, [r0, -ip]

	if ((cos4 >= 0) && (cos4 < 9000)) {
     830:	654c7465 	strbvs	r7, [ip, #-1125]
     834:	5a587367 	bpl	161d5d8 <__Stack_Size+0x161d1d8>
     838:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
		AngleRad4 = (byte) pgm_read_byte(&GetACos[cos4 / 79]);
     83c:	84006874 	strhi	r6, [r0], #-2164
     840:	4100000c 	tstmi	r0, ip
     844:	73756a64 	cmnvc	r5, #409600	; 0x64000
		AngleRad4 = ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255) ;
     848:	67654c74 	undefined
     84c:	69736f50 	ldmdbvs	r3!, {r4, r6, r8, r9, sl, fp, sp, lr}^
	} else if ((cos4 >= 9000) && (cos4 < 9900)) {
     850:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     854:	0cbb0073 	ldceq	0, cr0, [fp], #460
     858:	65520000 	ldrbvs	r0, [r2]
     85c:	4c746573 	cfldr64mi	mvdx6, [r4], #-460
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9000) / 8 + 114]);
     860:	6e496765 	cdpvs	7, 4, cr6, cr9, cr5, {3}
     864:	6e417469 	cdpvs	4, 4, cr7, cr1, cr9, {3}
     868:	73656c67 	cmnvc	r5, #26368	; 0x6700
     86c:	000cca00 	andeq	ip, ip, r0, lsl #20
     870:	746f5200 	strbtvc	r5, [pc], #512	; 878 <__Stack_Size+0x478>
     874:	4c657461 	cfstrdmi	mvd7, [r5], #-388
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     878:	6e496765 	cdpvs	7, 4, cr6, cr9, cr5, {3}
	} else if ((cos4 >= 9900) && (cos4 <= 10000)) {
     87c:	6e417469 	cdpvs	4, 4, cr7, cr1, cr9, {3}
     880:	73656c67 	cmnvc	r5, #26368	; 0x6700
     884:	000ce500 	andeq	lr, ip, r0, lsl #10
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9900) / 2 + 227]);
     888:	6a644100 	bvs	1910c90 <__Stack_Size+0x1910890>
     88c:	4c747375 	ldclmi	3, cr7, [r4], #-468
     890:	6f506765 	svcvs	0x00506765
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     894:	69746973 	ldmdbvs	r4!, {r0, r1, r4, r5, r6, r8, fp, sp, lr}^
     898:	54736e6f 	ldrbtpl	r6, [r3], #-3695
     89c:	646f426f 	strbtvs	r4, [pc], #623	; 8a4 <__Stack_Size+0x4a4>
     8a0:	69654879 	stmdbvs	r5!, {r0, r3, r4, r5, r6, fp, lr}^
     8a4:	00746867 	rsbseq	r6, r4, r7, ror #16
     8a8:	00000d1d 	andeq	r0, r0, sp, lsl sp
     8ac:	63656843 	cmnvs	r5, #4390912	; 0x430000
	}

	//Add negative sign
	if (NegativeValue)
		AngleRad4 = 31416 - AngleRad4;
     8b0:	6c6f566b 	stclvs	6, cr5, [pc], #-428
     8b4:	65676174 	strbvs	r6, [r7, #-372]!
     8b8:	000d3700 	andeq	r3, sp, r0, lsl #14
     8bc:	63614200 	cmnvs	r1, #0	; 0x0
     8c0:	6f72676b 	svcvs	0x0072676b

	return AngleRad4;
}
     8c4:	50646e75 	rsbpl	r6, r4, r5, ror lr
     8c8:	65636f72 	strbvs	r6, [r3, #-3954]!
     8cc:	4d007373 	stcmi	3, cr7, [r0, #-460]
     8d0:	4900000d 	stmdbmi	r0, {r0, r2, r3}
     8d4:	54656c64 	strbtpl	r6, [r5], #-3172
     8d8:	00656d69 	rsbeq	r6, r5, r9, ror #26

unsigned long isqrt32(unsigned long n) //
{
     8dc:	00000d63 	andeq	r0, r0, r3, ror #26
     8e0:	52746553 	rsbspl	r6, r4, #348127232	; 0x14c00000

	root = 0;
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
     8e4:	6e4f6765 	cdpvs	7, 4, cr6, cr15, cr5, {3}
     8e8:	536c6c41 	cmnpl	ip, #16640	; 0x4100
     8ec:	6f767265 	svcvs	0x00767265
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
     8f0:	0dcb0073 	stcleq	0, cr0, [fp, #460]
			remainder = remainder - root - place;
     8f4:	614d0000 	cmpvs	sp, r0
     8f8:	7553656b 	ldrbvc	r6, [r3, #-1387]
			root = root + (place << 1);
     8fc:	65536572 	ldrbvs	r6, [r3, #-1394]

	while (place > remainder)
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
			remainder = remainder - root - place;
     900:	736f7672 	cmnvc	pc, #119537664	; 0x7200000
			root = root + (place << 1);
		}
		root = root >> 1;
		place = place >> 2;
     904:	4f657241 	svcmi	0x00657241
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
		place = place >> 2;
	while (place) {
     908:	0dfa006e 	ldcleq	0, cr0, [sl, #440]!
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
	XYhyp2 = isqrt32(
     90c:	65420000 	strbvs	r0, [r2]
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     910:	536e6967 	cmnpl	lr, #1687552	; 0x19c000
	XYhyp2 = isqrt32(
     914:	6f767265 	svcvs	0x00767265
     918:	61647055 	qdsubvs	r7, r5, r4
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     91c:	23006574 	movwcs	r6, #1396	; 0x574
	XYhyp2 = isqrt32(
     920:	4600000e 	strmi	r0, [r0], -lr
     924:	53656572 	cmnpl	r5, #478150656	; 0x1c800000
     928:	6f767265 	svcvs	0x00767265
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);
     92c:	0e520073 	mrceq	0, 2, r0, cr2, cr3, {3}
     930:	65530000 	ldrbvs	r0, [r3]
     934:	5f6f7672 	svcpl	0x006f7672
     938:	74696e49 	strbtvc	r6, [r9], #-3657
     93c:	000e6700 	andeq	r6, lr, r0, lsl #14
     940:	74657300 	strbtvc	r7, [r5], #-768
     944:	68507075 	ldmdavs	r0, {r0, r2, r4, r5, r6, ip, sp, lr}^

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
     948:	696e656f 	stmdbvs	lr!, {r0, r1, r2, r3, r5, r6, r8, sl, sp, lr}^
		Atan4 = -AngleRad4;
     94c:	0e9a0078 	mrceq	0, 4, r0, cr10, cr8, {3}
	else
		Atan4 = AngleRad4;
     950:	6f430000 	svcvs	0x00430000
	XYhyp2 = isqrt32(
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
		Atan4 = -AngleRad4;
     954:	74696d6d 	strbtvc	r6, [r9], #-3437
	else
		Atan4 = AngleRad4;
     958:	76726553 	undefined
     95c:	6972446f 	ldmdbvs	r2!, {r0, r1, r2, r3, r5, r6, sl, lr}^
	return Atan4;
}
     960:	00726576 	rsbseq	r6, r2, r6, ror r5
     964:	00000f0e 	andeq	r0, r0, lr, lsl #30
     968:	7074754f 	rsbsvc	r7, r4, pc, asr #10
     96c:	65537475 	ldrbvs	r7, [r3, #-1141]

}

//--------------------------------------------------------------------
//[BalCalcOneLeg]
void BalCalcOneLeg(long PosX, long PosZ, long PosY, byte BalLegNr) {
     970:	496f7672 	stmdbmi	pc!, {r1, r4, r5, r6, r9, sl, ip, sp, lr}^
	long CPR_Y;            //Final Y value for centerpoint of rotation
	long CPR_Z;            //Final Z value for centerpoint of rotation

	long lAtan;
	//Calculating totals from center of the body to the feet
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BalLegNr]) + PosZ;
     974:	466f666e 	strbtmi	r6, [pc], -lr, ror #12
     978:	654c726f 	strbvs	r7, [ip, #-623]
	CPR_X = (short) pgm_read_word(&cOffsetX[BalLegNr]) + PosX;
     97c:	0f850067 	svceq	0x00850067
     980:	74530000 	ldrbvc	r0, [r3]
	CPR_Y = 150 + PosY; // using the value 150 to lower the centerpoint of rotation 'g_InControlState.BodyPos.y +

	TotalTransY += (long) PosY;
     984:	55747261 	ldrbpl	r7, [r4, #-609]!
     988:	74616470 	strbtvc	r6, [r1], #-1136
     98c:	72655365 	rsbvc	r5, r5, #-1811939327	; 0x94000001
	TotalTransZ += (long) CPR_Z;
     990:	00736f76 	rsbseq	r6, r3, r6, ror pc
     994:	00000fb0 	strheq	r0, [r0], -r0
     998:	42746547 	rsbsmi	r6, r4, #297795584	; 0x11c00000
	TotalTransX += (long) CPR_X;
     99c:	65747461 	ldrbvs	r7, [r4, #-1121]!
     9a0:	6f567972 	svcvs	0x00567972
     9a4:	6761746c 	strbvs	r7, [r1, -ip, ror #8]!
     9a8:	0fee0065 	svceq	0x00ee0065

	lAtan = GetATan2(CPR_X, CPR_Z);
     9ac:	6f430000 	svcvs	0x00430000
	TotalYBal1 += (lAtan * 1800) / 31415;
     9b0:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
     9b4:	5f726564 	svcpl	0x00726564
     9b8:	64616552 	strbtvs	r6, [r1], #-1362
     9bc:	7367734d 	cmnvc	r7, #872415233	; 0x34000001
     9c0:	00100700 	andseq	r0, r0, r0, lsl #14
     9c4:	6d6f4300 	stclvs	3, cr4, [pc]
     9c8:	646e616d 	strbtvs	r6, [lr], #-365
     9cc:	6e497265 	cdpvs	2, 4, cr7, cr9, cr5, {3}

	lAtan = GetATan2(CPR_X, CPR_Y);
     9d0:	43747570 	cmnmi	r4, #469762048	; 0x1c000000
     9d4:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
	TotalZBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     9d8:	656c6c6f 	strbvs	r6, [ip, #-3183]!
     9dc:	6f435f72 	svcvs	0x00435f72
     9e0:	6f72746e 	svcvs	0x0072746e
     9e4:	706e496c 	rsbvc	r4, lr, ip, ror #18
     9e8:	a4007475 	strge	r7, [r0], #-1141
     9ec:	42000010 	andmi	r0, r0, #16	; 0x10
     9f0:	6d5f6769 	ldclvs	7, cr6, [pc, #-420]
     9f4:	006e6961 	rsbeq	r6, lr, r1, ror #18
     9f8:	000012b9 	strheq	r1, [r0], -r9
     9fc:	5f4d554e 	svcpl	0x004d554e

	lAtan = GetATan2(CPR_Z, CPR_Y);
     a00:	54494147 	strbpl	r4, [r9], #-327
     a04:	12cc0053 	sbcne	r0, ip, #83	; 0x53
	TotalXBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     a08:	5f670000 	svcpl	0x00670000
     a0c:	62654466 	rsbvs	r4, r5, #1711276032	; 0x66000000
     a10:	754f6775 	strbvc	r6, [pc, #-1909]	; 2a3 <_Minimum_Stack_Size+0x1a3>
     a14:	74757074 	ldrbtvc	r7, [r5], #-116
     a18:	0012df00 	andseq	sp, r2, r0, lsl #30
     a1c:	665f6700 	ldrbvs	r6, [pc], -r0, lsl #14
     a20:	62616e45 	rsbvs	r6, r1, #1104	; 0x450
     a24:	6553656c 	ldrbvs	r6, [r3, #-1388]

}
     a28:	736f7672 	cmnvc	pc, #119537664	; 0x7200000
     a2c:	0012f200 	andseq	pc, r2, r0, lsl #4
     a30:	665f6700 	ldrbvs	r6, [pc], -r0, lsl #14
     a34:	6f626f52 	svcvs	0x00626f52
     a38:	73705574 	cmnvc	r0, #486539264	; 0x1d000000
     a3c:	44656469 	strbtmi	r6, [r5], #-1129
     a40:	006e776f 	rsbeq	r7, lr, pc, ror #14
     a44:	00001305 	andeq	r1, r0, r5, lsl #6
     a48:	6e495f67 	cdpvs	15, 4, cr5, cr9, cr7, {3}
     a4c:	746e6f43 	strbtvc	r6, [lr], #-3907
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a50:	536c6f72 	cmnpl	ip, #456	; 0x1c8
     a54:	65746174 	ldrbvs	r6, [r4, #-372]!
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a58:	00132700 	andseq	r2, r3, r0, lsl #14
     a5c:	615f6700 	cmpvs	pc, r0, lsl #14
     a60:	78654862 	stmdavc	r5!, {r1, r5, r6, fp, lr}^
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a64:	58746e49 	ldmdapl	r4!, {r0, r3, r6, r9, sl, fp, sp, lr}^
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a68:	133e005a 	teqne	lr, #90	; 0x5a
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
     a6c:	5f670000 	svcpl	0x00670000
     a70:	65486261 	strbvs	r6, [r8, #-609]
     a74:	78614d78 	stmdavc	r1!, {r3, r4, r5, r6, r8, sl, fp, lr}^

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     a78:	79646f42 	stmdbvc	r4!, {r1, r6, r8, r9, sl, fp, sp, lr}^

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a7c:	13550059 	cmpne	r5, #89	; 0x59
     a80:	69720000 	ldmdbvs	r2!, {}^
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a84:	56746867 	ldrbtpl	r6, [r4], -r7, ror #16
     a88:	00136700 	andseq	r6, r3, r0, lsl #14

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a8c:	67697200 	strbvs	r7, [r9, -r0, lsl #4]!
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a90:	00487468 	subeq	r7, r8, r8, ror #8
     a94:	00001379 	andeq	r1, r0, r9, ror r3
	SinG4 = sin4;
     a98:	7466656c 	strbtvc	r6, [r6], #-1388
	CosG4 = cos4;
     a9c:	138b0056 	orrne	r0, fp, #86	; 0x56
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa0:	656c0000 	strbvs	r0, [ip]!
	CosG4 = cos4;
     aa4:	00487466 	subeq	r7, r8, r6, ror #8
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa8:	0000139d 	muleq	r0, sp, r3
	CosG4 = cos4;

	GetSinCos(g_InControlState.BodyRot1.z + TotalZBal1);
     aac:	00747865 	rsbseq	r7, r4, r5, ror #16
	SinB4 = sin4;
     ab0:	000013bf 	strheq	r1, [r0], -pc
     ab4:	736c6176 	cmnvc	ip, #-2147483619	; 0x8000001d
	CosB4 = cos4;
     ab8:	0013d100 	andseq	sp, r3, r0, lsl #2

	GetSinCos(g_InControlState.BodyRot1.y + (RotationY * c1DEC) + TotalYBal1);
     abc:	65686300 	strbvs	r6, [r8, #-768]!
     ac0:	75736b63 	ldrbvc	r6, [r3, #-2915]!
     ac4:	13e3006d 	mvnne	r0, #109	; 0x6d
     ac8:	5f670000 	svcpl	0x00670000
     acc:	614c6c75 	cmpvs	ip, r5, ror ip

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     ad0:	734d7473 	movtvc	r7, #54387	; 0xd473
     ad4:	6d695467 	cfstrdvs	mvd5, [r9, #-412]!
     ad8:	13f50065 	mvnsne	r0, #101	; 0x65
     adc:	5f670000 	svcpl	0x00670000
     ae0:	53504773 	cmppl	r0, #30146560	; 0x1cc0000
     ae4:	6e6f434d 	cdpvs	3, 6, cr4, cr15, cr13, {2}
     ae8:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
     aec:	0072656c 	rsbseq	r6, r2, ip, ror #10
     af0:	00001407 	andeq	r1, r0, r7, lsl #8
     af4:	44665f67 	strbtmi	r5, [r6], #-3943
     af8:	6d616e79 	stclvs	14, cr6, [r1, #-484]!
     afc:	654c6369 	strbvs	r6, [ip, #-873]
     b00:	4c5a5867 	mrrcmi	8, 6, r5, sl, cr7
     b04:	74676e65 	strbtvc	r6, [r7], #-3685
     b08:	14190068 	ldrne	r0, [r9], #-104
     b0c:	50470000 	subpl	r0, r7, r0
     b10:	00716553 	rsbseq	r6, r1, r3, asr r5
     b14:	0000142b 	andeq	r1, r0, fp, lsr #8
     b18:	41665f67 	cmnmi	r6, r7, ror #30
     b1c:	65705358 	ldrbvs	r5, [r0, #-856]!
     b20:	6f436465 	svcvs	0x00436465
     b24:	6f72746e 	svcvs	0x0072746e
     b28:	1467006c 	strbtne	r0, [r7], #-108
     b2c:	5f670000 	svcpl	0x00670000
     b30:	75437761 	strbvc	r7, [r3, #-1889]
     b34:	50584172 	subspl	r4, r8, r2, ror r1
     b38:	7900736f 	stmdbvc	r0, {r0, r1, r2, r3, r5, r6, r8, r9, ip, sp, lr}
     b3c:	67000014 	smladvs	r0, r4, r0, r0
     b40:	4777615f 	undefined
     b44:	416c616f 	cmnmi	ip, pc, ror #2
     b48:	736f5058 	cmnvc	pc, #88	; 0x58
     b4c:	00148b00 	andseq	r8, r4, r0, lsl #22
     b50:	665f6700 	ldrbvs	r6, [pc], -r0, lsl #14
     b54:	76726553 	undefined
     b58:	7246736f 	subvc	r7, r6, #-1140850687	; 0xbc000001
     b5c:	9d006565 	cfstr32ls	mvfx6, [r0, #-404]
     b60:	67000014 	smladvs	r0, r4, r0, r0
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b64:	614c775f 	cmpvs	ip, pc, asr r7
     b68:	6f567473 	svcvs	0x00567473

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     b6c:	6761746c 	strbvs	r7, [r1, -ip, ror #8]!
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b70:	14af0065 	strtne	r0, [pc], #101	; b78 <__Stack_Size+0x778>
     b74:	5f670000 	svcpl	0x00670000
     b78:	67654c62 	strbvs	r4, [r5, -r2, ror #24]!
     b7c:	746c6f56 	strbtvc	r6, [ip], #-3926
     b80:	00656761 	rsbeq	r6, r5, r1, ror #14
     b84:	000014c1 	andeq	r1, r0, r1, asr #9
     b88:	6c755f67 	ldclvs	15, cr5, [r5], #-412
     b8c:	656d6954 	strbvs	r6, [sp, #-2388]!
     b90:	7473614c 	ldrbtvc	r6, [r3], #-332
     b94:	74746142 	ldrbtvc	r6, [r4], #-322
     b98:	56797265 	ldrbtpl	r7, [r9], -r5, ror #4
     b9c:	61746c6f 	cmnvs	r4, pc, ror #24
     ba0:	e3006567 	movw	r6, #1383	; 0x567
     ba4:	63000014 	movwvs	r0, #20	; 0x14
     ba8:	61786f43 	cmnvs	r8, r3, asr #30
     bac:	316e694d 	cmncc	lr, sp, asr #18
     bb0:	0014fa00 	andseq	pc, r4, r0, lsl #20
     bb4:	6f436300 	svcvs	0x00436300
     bb8:	614d6178 	cmpvs	sp, r8, ror r1
     bbc:	11003178 	tstne	r0, r8, ror r1
     bc0:	63000015 	movwvs	r0, #21	; 0x15
     bc4:	756d6546 	strbvc	r6, [sp, #-1350]!
     bc8:	6e694d72 	mcrvs	13, 3, r4, cr9, cr2, {3}
     bcc:	15280031 	strne	r0, [r8, #-49]!
     bd0:	46630000 	strbtmi	r0, [r3], -r0
     bd4:	72756d65 	rsbsvc	r6, r5, #6464	; 0x1940
     bd8:	3178614d 	cmncc	r8, sp, asr #2
     bdc:	00153f00 	andseq	r3, r5, r0, lsl #30
     be0:	69546300 	ldmdbvs	r4, {r8, r9, sp, lr}^
     be4:	4d616962 	stclmi	9, cr6, [r1, #-392]!
     be8:	00316e69 	eorseq	r6, r1, r9, ror #28
     bec:	00001556 	andeq	r1, r0, r6, asr r5
     bf0:	62695463 	rsbvs	r5, r9, #1660944384	; 0x63000000
     bf4:	614d6169 	cmpvs	sp, r9, ror #2
     bf8:	7d003178 	stfvcs	f3, [r0, #-480]
     bfc:	63000015 	movwvs	r0, #21	; 0x15
     c00:	61786f43 	cmnvs	r8, r3, asr #30
     c04:	00766e49 	rsbseq	r6, r6, r9, asr #28
     c08:	00001594 	muleq	r0, r4, r5
     c0c:	6d654663 	stclvs	6, cr4, [r5, #-396]!
     c10:	6e497275 	mcrvs	2, 2, r7, cr9, cr5, {3}
     c14:	15a60076 	strne	r0, [r6, #118]!
     c18:	54630000 	strbtpl	r0, [r3]
     c1c:	61696269 	cmnvs	r9, r9, ror #4
     c20:	00766e49 	rsbseq	r6, r6, r9, asr #28
     c24:	000015bd 	strheq	r1, [r0], -sp
     c28:	786f4363 	stmdavc	pc!, {r0, r1, r5, r6, r8, r9, lr}^
     c2c:	6e654c61 	cdpvs	12, 6, cr4, cr5, cr1, {3}
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c30:	00687467 	rsbeq	r7, r8, r7, ror #8
	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     c34:	000015d4 	ldrdeq	r1, [r0], -r4
     c38:	6d654663 	stclvs	6, cr4, [r5, #-396]!
     c3c:	654c7275 	strbvs	r7, [ip, #-629]
     c40:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c44:	0015eb00 	andseq	lr, r5, r0, lsl #22
     c48:	69546300 	ldmdbvs	r4, {r8, r9, sp, lr}^
     c4c:	4c616962 	stclmi	9, cr6, [r1], #-392
     c50:	74676e65 	strbtvc	r6, [r7], #-3685
     c54:	16020068 	strne	r0, [r2], -r8, rrx
     c58:	4f630000 	svcmi	0x00630000
     c5c:	65736666 	ldrbvs	r6, [r3, #-1638]!
     c60:	19005874 	stmdbne	r0, {r2, r4, r5, r6, fp, ip, lr}
     c64:	63000016 	movwvs	r0, #22	; 0x16
     c68:	7366664f 	cmnvc	r6, #82837504	; 0x4f00000
     c6c:	005a7465 	subseq	r7, sl, r5, ror #8
     c70:	00001630 	andeq	r1, r0, r0, lsr r6
     c74:	786f4363 	stmdavc	pc!, {r0, r1, r5, r6, r8, r9, lr}^
     c78:	676e4161 	strbvs	r4, [lr, -r1, ror #2]!
     c7c:	0031656c 	eorseq	r6, r1, ip, ror #10
     c80:	00001647 	andeq	r1, r0, r7, asr #12
     c84:	696e4963 	stmdbvs	lr!, {r0, r1, r5, r6, r8, fp, lr}^
     c88:	736f5074 	cmnvc	pc, #116	; 0x74
     c8c:	165f0058 	undefined
     c90:	49630000 	stmdbmi	r3!, {}^
     c94:	5074696e 	rsbspl	r6, r4, lr, ror #18
     c98:	0059736f 	subseq	r7, r9, pc, ror #6
     c9c:	00001677 	andeq	r1, r0, r7, ror r6
     ca0:	696e4963 	stmdbvs	lr!, {r0, r1, r5, r6, r8, fp, lr}^
     ca4:	736f5074 	cmnvc	pc, #116	; 0x74
     ca8:	168f005a 	pkhtbne	r0, pc, sl, asr #32
     cac:	5f670000 	svcpl	0x00670000
     cb0:	6f685366 	svcvs	0x00685366
     cb4:	62654477 	rsbvs	r4, r5, #1996488704	; 0x77000000
     cb8:	72506775 	subsvc	r6, r0, #30670848	; 0x1d40000
     cbc:	74706d6f 	ldrbtvc	r6, [r0], #-3439
     cc0:	0016a200 	andseq	sl, r6, r0, lsl #4
     cc4:	786f4300 	stmdavc	pc!, {r8, r9, lr}^
     cc8:	676e4161 	strbvs	r4, [lr, -r1, ror #2]!
     ccc:	0031656c 	eorseq	r6, r1, ip, ror #10
     cd0:	000016b5 	strheq	r1, [r0], -r5
     cd4:	756d6546 	strbvc	r6, [sp, #-1350]!
     cd8:	676e4172 	undefined
     cdc:	0031656c 	eorseq	r6, r1, ip, ror #10
     ce0:	000016c8 	andeq	r1, r0, r8, asr #13
     ce4:	69626954 	stmdbvs	r2!, {r2, r4, r6, r8, fp, sp, lr}^
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * SinG4 / c4DEC
					+ (long) CPR_Z * c2DEC * CosG4 / c4DEC * SinA4 / c4DEC
							* SinB4 / c4DEC
					+ (long) CPR_Y * c2DEC * CosB4 / c4DEC * CosG4 / c4DEC))
			/ c2DEC;
}
     ce8:	676e4161 	strbvs	r4, [lr, -r1, ror #2]!
     cec:	0031656c 	eorseq	r6, r1, ip, ror #10
     cf0:	000016db 	ldrdeq	r1, [r0], -fp
     cf4:	5067654c 	rsbpl	r6, r7, ip, asr #10
     cf8:	0058736f 	subseq	r7, r8, pc, ror #6
     cfc:	000016ee 	andeq	r1, r0, lr, ror #13
     d00:	5067654c 	rsbpl	r6, r7, ip, asr #10
     d04:	0059736f 	subseq	r7, r9, pc, ror #6
     d08:	00001701 	andeq	r1, r0, r1, lsl #14
     d0c:	5067654c 	rsbpl	r6, r7, ip, asr #10
     d10:	005a736f 	subseq	r7, sl, pc, ror #6
     d14:	00001714 	andeq	r1, r0, r4, lsl r7
     d18:	65646e49 	strbvs	r6, [r4, #-3657]!
     d1c:	17270078 	undefined
//FemurAngle1           - Output Angle of Femur in degrees
//TibiaAngle1           - Output Angle of Tibia in degrees
//CoxaAngle1            - Output Angle of Coxa in degrees
//--------------------------------------------------------------------
void LegIK(short IKFeetPosX, short IKFeetPosY, short IKFeetPosZ,
		byte LegIKLegNr) {
     d20:	654c0000 	strbvs	r0, [ip]
     d24:	646e4967 	strbtvs	r4, [lr], #-2407
     d28:	3a007865 	bcc	1eec4 <__Stack_Size+0x1eac4>
	long Temp1;
	long Temp2;
	long T3;

	//Calculate IKCoxaAngle and IKFeetPosXZ
	GetATan2(IKFeetPosX, IKFeetPosZ);
     d2c:	41000017 	tstmi	r0, r7, lsl r0
	CoxaAngle1[LegIKLegNr] = (((long) Atan4 * 180) / 3141)
     d30:	656c676e 	strbvs	r6, [ip, #-1902]!
     d34:	31676544 	cmncc	r7, r4, asr #10
     d38:	00174d00 	andseq	r4, r7, r0, lsl #26
     d3c:	6e697300 	cdpvs	3, 6, cr7, cr9, cr0, {0}
     d40:	17600034 	undefined
     d44:	6f630000 	svcvs	0x00630000
     d48:	73003473 	movwvc	r3, #1139	; 0x473
     d4c:	41000017 	tstmi	r0, r7, lsl r0
     d50:	656c676e 	strbvs	r6, [ip, #-1902]!
     d54:	34646152 	strbtcc	r6, [r4], #-338
	//Length between the Coxa and tars [foot]
	IKFeetPosXZ = XYhyp2 / c2DEC;

	//Using GetAtan2 for solving IKA1 and IKSW
	//IKA14 - Angle between SW line and the ground in radians
	IKA14 = GetATan2(IKFeetPosY - TarsOffsetY,
     d58:	00178600 	andseq	r8, r7, r0, lsl #12
     d5c:	61744100 	cmnvs	r4, r0, lsl #2
     d60:	9900586e 	stmdbls	r0, {r1, r2, r3, r5, r6, fp, ip, lr}
     d64:	41000017 	tstmi	r0, r7, lsl r0
     d68:	596e6174 	stmdbpl	lr!, {r2, r4, r5, r6, r8, sp, lr}^
     d6c:	0017ac00 	andseq	sl, r7, r0, lsl #24
     d70:	61744100 	cmnvs	r4, r0, lsl #2

	//IKSW2 - Length between femur axis and tars
	IKSW2 = XYhyp2;

	//IKA2 - Angle of the line S>W with respect to the femur in radians
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     d74:	bf00346e 	svclt	0x0000346e
     d78:	58000017 	stmdapl	r0, {r0, r1, r2, r4}
     d7c:	70796859 	rsbsvc	r6, r9, r9, asr r8
     d80:	17d20032 	undefined
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			+ ((long) IKSW2 * IKSW2));
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);
     d84:	6f500000 	svcvs	0x00500000
     d88:	e5005873 	str	r5, [r0, #-2163]
     d8c:	50000017 	andpl	r0, r0, r7, lsl r0
     d90:	005a736f 	subseq	r7, sl, pc, ror #6
     d94:	000017f8 	strdeq	r1, [r0], -r8
     d98:	59736f50 	ldmdbpl	r3!, {r4, r6, r8, r9, sl, fp, sp, lr}^
     d9c:	00180b00 	andseq	r0, r8, r0, lsl #22
     da0:	646f4200 	strbtvs	r4, [pc], #512	; da8 <__Stack_Size+0x9a8>
     da4:	504b4679 	subpl	r4, fp, r9, ror r6
     da8:	0058736f 	subseq	r7, r8, pc, ror #6
     dac:	0000181e 	andeq	r1, r0, lr, lsl r8
     db0:	79646f42 	stmdbvc	r4!, {r1, r6, r8, r9, sl, fp, sp, lr}^
     db4:	6f504b46 	svcvs	0x00504b46

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     db8:	31005973 	tstcc	r0, r3, ror r9
     dbc:	42000018 	andmi	r0, r0, #24	; 0x18
     dc0:	4679646f 	ldrbtmi	r6, [r9], -pc, ror #8
     dc4:	736f504b 	cmnvc	pc, #75	; 0x4b
     dc8:	1844005a 	stmdane	r4, {r1, r3, r4, r6}^
     dcc:	4b490000 	blmi	1240dd4 <__Stack_Size+0x12409d4>
     dd0:	74656546 	strbtvc	r6, [r5], #-1350
     dd4:	58736f50 	ldmdapl	r3!, {r4, r6, r8, r9, sl, fp, sp, lr}^
     dd8:	00185700 	andseq	r5, r8, r0, lsl #14
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     ddc:	464b4900 	strbmi	r4, [fp], -r0, lsl #18
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     de0:	50746565 	rsbspl	r6, r4, r5, ror #10
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     de4:	0059736f 	subseq	r7, r9, pc, ror #6
     de8:	0000186a 	andeq	r1, r0, sl, ror #16
			+ ((long) (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr])
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);
     dec:	65464b49 	strbvs	r4, [r6, #-2889]
     df0:	6f507465 	svcvs	0x00507465
     df4:	7d005a73 	fstsvc	s10, [r0, #-460]
     df8:	49000018 	stmdbmi	r0, {r3, r4}
     dfc:	6c6f534b 	stclvs	3, cr5, [pc], #-300
     e00:	6f697475 	svcvs	0x00697475
     e04:	1890006e 	ldmne	r0, {r1, r2, r3, r5, r6}
     e08:	4b490000 	blmi	1240e10 <__Stack_Size+0x1240a10>

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e0c:	756c6f53 	strbvc	r6, [ip, #-3923]!
     e10:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     e14:	6e726157 	mrcvs	1, 3, r6, cr2, cr7, {2}
     e18:	00676e69 	rsbeq	r6, r7, r9, ror #28
     e1c:	000018a3 	andeq	r1, r0, r3, lsr #17
     e20:	6f534b49 	svcvs	0x00534b49
     e24:	6974756c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sl, ip, sp, lr}^
     e28:	72456e6f 	subvc	r6, r5, #1776	; 0x6f0
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e2c:	00726f72 	rsbseq	r6, r2, r2, ror pc
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e30:	000018b6 	strheq	r1, [r0], -r6
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e34:	6d69546c 	cfstrdvs	mvd5, [r9, #-432]!
     e38:	74537265 	ldrbvc	r7, [r3], #-613
     e3c:	00747261 	rsbseq	r7, r4, r1, ror #4
     e40:	000018c9 	andeq	r1, r0, r9, asr #17
     e44:	6d69546c 	cfstrdvs	mvd5, [r9, #-432]!
			< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
					+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]) - 30)
					* c2DEC))
		IKSolution = 1;
     e48:	6e457265 	cdpvs	2, 4, cr7, cr5, cr5, {3}
	else {
		if (IKSW2
     e4c:	18dc0064 	ldmne	ip, {r2, r5, r6}^
     e50:	79430000 	stmdbvc	r3, {}^
				< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
						+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))
						* c2DEC))
			IKSolutionWarning = 1;
     e54:	54656c63 	strbtpl	r6, [r5], #-3171
     e58:	00656d69 	rsbeq	r6, r5, r9, ror #26
		else
			IKSolutionError = 1;
     e5c:	000018ef 	andeq	r1, r0, pc, ror #17
	}

}
     e60:	76726553 	undefined
     e64:	766f4d6f 	strbtvc	r4, [pc], -pc, ror #26
     e68:	6d695465 	cfstrdvs	mvd5, [r9, #-404]!
     e6c:	19020065 	stmdbne	r2, {r0, r2, r5, r6}
     e70:	72500000 	subsvc	r0, r0, #0	; 0x0
     e74:	65537665 	ldrbvs	r7, [r3, #-1637]
     e78:	4d6f7672 	stclmi	6, cr7, [pc, #-456]!
     e7c:	5465766f 	strbtpl	r7, [r5], #-1647
     e80:	00656d69 	rsbeq	r6, r5, r9, ror #26
     e84:	00001915 	andeq	r1, r0, r5, lsl r9
     e88:	4c665f67 	stclmi	15, cr5, [r6], #-412
     e8c:	6f56776f 	svcvs	0x0056776f
     e90:	6761746c 	strbvs	r7, [r1, -ip, ror #8]!
     e94:	75685365 	strbvc	r5, [r8, #-869]!
     e98:	776f6474 	undefined
     e9c:	1928006e 	stmdbne	r8!, {r1, r2, r3, r5, r6}
     ea0:	6f560000 	svcvs	0x00560000
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ea4:	6761746c 	strbvs	r7, [r1, -ip, ror #8]!
	if (sVal < s) {
     ea8:	193b0065 	ldmdbne	fp!, {r0, r2, r5, r6}
     eac:	6f540000 	svcvs	0x00540000
		return s;
	}

	s = (short) pgm_read_word(sMax);
     eb0:	546c6174 	strbtpl	r6, [ip], #-372
     eb4:	736e6172 	cmnvc	lr, #-2147483620	; 0x8000001c
     eb8:	194e0058 	stmdbne	lr, {r3, r4, r6}^

		return s;
	}
	return sVal;

}
     ebc:	6f540000 	svcvs	0x00540000
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec0:	546c6174 	strbtpl	r6, [ip], #-372
}

//--------------------------------------------------------------------
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
     ec4:	736e6172 	cmnvc	lr, #-2147483620	; 0x8000001c
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec8:	1961005a 	stmdbne	r1!, {r1, r3, r4, r6}^
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ecc:	6f540000 	svcvs	0x00540000
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     ed0:	546c6174 	strbtpl	r6, [ip], #-372
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ed4:	736e6172 	cmnvc	lr, #-2147483620	; 0x8000001c
	if (sVal < s) {
     ed8:	19740059 	ldmdbne	r4!, {r0, r3, r4, r6}^
     edc:	6f540000 	svcvs	0x00540000
     ee0:	596c6174 	stmdbpl	ip!, {r2, r4, r5, r6, r8, sp, lr}^
		return s;
	}

	s = (short) pgm_read_word(sMax);
     ee4:	316c6142 	cmncc	ip, r2, asr #2
     ee8:	00198700 	andseq	r8, r9, r0, lsl #14
     eec:	746f5400 	strbtvc	r5, [pc], #1024	; ef4 <__Stack_Size+0xaf4>
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
     ef0:	42586c61 	subsmi	r6, r8, #24832	; 0x6100
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ef4:	00316c61 	eorseq	r6, r1, r1, ror #24
	if (sVal < s) {
     ef8:	0000199a 	muleq	r0, sl, r9
     efc:	61746f54 	cmnvs	r4, r4, asr pc
     f00:	61425a6c 	cmpvs	r2, ip, ror #20
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f04:	ad00316c 	stfges	f3, [r0, #-432]
     f08:	41000019 	tstmi	r0, r9, lsl r0
     f0c:	6f446c6c 	svcvs	0x00446c6c
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f10:	c0006e77 	andgt	r6, r0, r7, ror lr
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f14:	54000019 	strpl	r0, [r0], #-25
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f18:	65766172 	ldrbvs	r6, [r6, #-370]!
	if (sVal < s) {
     f1c:	7165526c 	cmnvc	r5, ip, ror #4
     f20:	74736575 	ldrbtvc	r6, [r3], #-1397
     f24:	0019e300 	andseq	lr, r9, r0, lsl #6
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f28:	69614700 	stmdbvs	r1!, {r8, r9, sl, lr}^
     f2c:	736f5074 	cmnvc	pc, #116	; 0x74
     f30:	19f60058 	ldmibne	r6!, {r3, r4, r6}^
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
				FemurAngle1[LegIndex], &cFemurMin1[LegIndex],
				&cFemurMax1[LegIndex]);
		TibiaAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f34:	61470000 	cmpvs	r7, r0
     f38:	6f507469 	svcvs	0x00507469
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     f3c:	09005973 	stmdbeq	r0, {r0, r1, r4, r5, r6, r8, fp, ip, lr}
     f40:	4700001a 	smladmi	r0, sl, r0, r0
				TibiaAngle1[LegIndex], &cTibiaMin1[LegIndex],
				&cTibiaMax1[LegIndex]);

	}
#endif
}
     f44:	50746961 	rsbspl	r6, r4, r1, ror #18
     f48:	005a736f 	subseq	r7, sl, pc, ror #6
     f4c:	00001a1c 	andeq	r1, r0, ip, lsl sl
     f50:	74696147 	strbtvc	r6, [r9], #-327
     f54:	59746f52 	ldmdbpl	r4!, {r1, r4, r6, r8, r9, sl, fp, sp, lr}^
     f58:	001a2f00 	andseq	r2, sl, r0, lsl #30
     f5c:	61576600 	cmpvs	r7, r0, lsl #12
     f60:	6e696b6c 	fnmuldvs	d22, d9, d28
     f64:	1a420067 	bne	1081108 <__Stack_Size+0x1080d08>
     f68:	45620000 	strbmi	r0, [r2]!
     f6c:	61727478 	cmnvs	r2, r8, ror r4
// SmoothControl (From Zenta) -  This function makes the body
//            rotation and translation much smoother
//--------------------------------------------------------------------
short SmoothControl(short CtrlMoveInp, short CtrlMoveOut, byte CtrlDivider) {

	if (CtrlMoveOut < (CtrlMoveInp - 4))
     f70:	6c637943 	stclvs	9, cr7, [r3], #-268
     f74:	1a550065 	bne	1541110 <__Stack_Size+0x1540d10>
		return CtrlMoveOut + abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f78:	52660000 	rsbpl	r0, r6, #0	; 0x0
     f7c:	746f626f 	strbtvc	r6, [pc], #623	; f84 <__Stack_Size+0xb84>
     f80:	69737055 	ldmdbvs	r3!, {r0, r2, r4, r6, ip, sp, lr}^
     f84:	6f446564 	svcvs	0x00446564
     f88:	72506e77 	subsvc	r6, r0, #1904	; 0x770
     f8c:	78007665 	stmdavc	r0, {r0, r2, r5, r6, r9, sl, ip, sp, lr}
     f90:	4100001a 	tstmi	r0, sl, lsl r0
	else if (CtrlMoveOut > (CtrlMoveInp + 4))
     f94:	8b004750 	blhi	12cdc <__Stack_Size+0x128dc>
		return CtrlMoveOut - abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f98:	7300001a 	movwvc	r0, #26	; 0x1a
     f9c:	564c625f 	undefined
     fa0:	70656542 	rsbvc	r6, r5, r2, asr #10
     fa4:	00746e43 	rsbseq	r6, r4, r3, asr #28
     fa8:	00001a9e 	muleq	r0, lr, sl
     fac:	4c775f67 	ldclmi	15, cr5, [r7], #-412
     fb0:	58736765 	ldmdapl	r3!, {r0, r2, r5, r6, r8, r9, sl, sp, lr}^

	return CtrlMoveInp;
}
     fb4:	6e654c5a 	mcrvs	12, 3, r4, cr5, cr10, {2}
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
     fb8:	00687467 	rsbeq	r7, r8, r7, ror #8
     fbc:	00001ab1 	strheq	r1, [r0], -r1
     fc0:	4c695f67 	stclmi	15, cr5, [r9], #-412

//--------------------------------------------------------------------
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
     fc4:	6e496765 	cdpvs	7, 4, cr6, cr9, cr5, {3}
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
		return g_wLegsXZLength;

	return isqrt32((LegPosX[0] * LegPosX[0]) + (LegPosZ[0] * LegPosZ[0]));
     fc8:	6e497469 	cdpvs	4, 4, cr7, cr9, cr9, {3}
     fcc:	00786564 	rsbseq	r6, r8, r4, ror #10
     fd0:	00000000 	andeq	r0, r0, r0
     fd4:	00000254 	andeq	r0, r0, r4, asr r2
     fd8:	27140002 	ldrcs	r0, [r4, -r2]
     fdc:	07800000 	streq	r0, [r0, r0]
}
     fe0:	03040000 	movweq	r0, #16384	; 0x4000
     fe4:	69420000 	stmdbvs	r2, {}^
     fe8:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
     fec:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}

#ifndef MAX_XZ_LEG_ADJUST
#define MAX_XZ_LEG_ADJUST   (word)(cCoxaLength[0]+cTibiaLength[0] + cFemurLength[0]/4)
#endif

void AdjustLegPositions(word XZLength1) {
     ff0:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
     ff4:	4572656c 	ldrbmi	r6, [r2, #-1388]!
     ff8:	65735f78 	ldrbvs	r5, [r3, #-3960]!
     ffc:	00644974 	rsbeq	r4, r4, r4, ror r9
    1000:	00000335 	andeq	r0, r0, r5, lsr r3
		XZLength1 = MAX_XZ_LEG_ADJUST;
	if (XZLength1 < MIN_XZ_LEG_ADJUST)
		XZLength1 = MIN_XZ_LEG_ADJUST;

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
    1004:	6c6f6942 	stclvs	9, cr6, [pc], #-264
    1008:	4364696f 	cmnmi	r4, #1818624	; 0x1bc000
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    100c:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
		return;

	g_wLegsXZLength = XZLength1;
    1010:	656c6c6f 	strbvs	r6, [ip, #-3183]!

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));
    1014:	5f784572 	svcpl	0x00784572
    1018:	49746567 	ldmdbmi	r4!, {r0, r1, r2, r5, r6, r8, sl, sp, lr}^

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
    101c:	03600064 	cmneq	r0, #100	; 0x64
    1020:	69420000 	stmdbvs	r2, {}^
    1024:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
    1028:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    102c:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
    1030:	4572656c 	ldrbmi	r6, [r2, #-1388]!
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    1034:	6f6c5f78 	svcvs	0x006c5f78
    1038:	6f506461 	svcvs	0x00506461
    103c:	99006573 	stmdbls	r0, {r0, r1, r4, r5, r6, r8, sl, sp, lr}
    1040:	42000003 	andmi	r0, r0, #3	; 0x3
    1044:	6f6c6f69 	svcvs	0x006c6f69
    1048:	6f436469 	svcvs	0x00436469
		return;

	g_wLegsXZLength = XZLength1;

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    104c:	6f72746e 	svcvs	0x0072746e
		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
	}

	// Make sure we cycle through one gait to have the legs all move into their new locations...
	g_InControlState.ForceGaitStepCnt = g_InControlState.gaitCur.StepsInGait;
    1050:	72656c6c 	rsbvc	r6, r5, #27648	; 0x6c00
    1054:	675f7845 	ldrbvs	r7, [pc, -r5, asr #16]
}
    1058:	75437465 	strbvc	r7, [r3, #-1125]
    105c:	736f5072 	cmnvc	pc, #114	; 0x72
    1060:	03d00065 	bicseq	r0, r0, #101	; 0x65
    1064:	69420000 	stmdbvs	r2, {}^
    1068:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
    106c:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    1070:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
    1074:	4572656c 	ldrbmi	r6, [r2, #-1388]!
    1078:	65675f78 	strbvs	r5, [r7, #-3960]!
		g_InControlState.aCoxaInitAngle1[LegIndex] = (short)pgm_read_word(&cCoxaAngle1[LegIndex]);
#endif
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    107c:	78654e74 	stmdavc	r5!, {r2, r4, r5, r6, r9, sl, fp, lr}^
		else if (g_InControlState.aCoxaInitAngle1[LegIndex] < -700)
		g_InControlState.aCoxaInitAngle1[LegIndex] = -700;
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    1080:	736f5074 	cmnvc	pc, #116	; 0x74
//     to be appropriate for the current y location of the body...
//--------------------------------------------------------------------

u8 g_iLegInitIndex = 0x00; // remember which index we are currently using...

void AdjustLegPositionsToBodyHeight() {
    1084:	04070065 	streq	r0, [r7], #-101
    1088:	69420000 	stmdbvs	r2, {}^
#ifdef CNT_HEX_INITS
	// Lets see which of our units we should use...
	// Note: We will also limit our body height here...
	if (g_InControlState.BodyPos.y
    108c:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
			> (short) pgm_read_byte(&g_abHexMaxBodyY[CNT_HEX_INITS-1]))
		g_InControlState.BodyPos.y = (short) pgm_read_byte(
    1090:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    1094:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
    1098:	4572656c 	ldrbmi	r6, [r2, #-1388]!
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    109c:	65735f78 	ldrbvs	r5, [r3, #-3960]!
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    10a0:	78654e74 	stmdavc	r5!, {r2, r4, r5, r6, r9, sl, fp, lr}^
    10a4:	736f5074 	cmnvc	pc, #116	; 0x74
    10a8:	04490065 	strbeq	r0, [r9], #-101
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    10ac:	69420000 	stmdbvs	r2, {}^
		g_iLegInitIndex = i;  // remember the current index...
		AdjustLegPositions(XZLength1);
    10b0:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
	}
#endif // CNT_HEX_INITS
}
    10b4:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    10b8:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
    10bc:	4572656c 	ldrbmi	r6, [r2, #-1388]!
}
//--------------------------------------------------------------------
//[CHECK VOLTAGE]
//Reads the input voltage and shuts down the bot when the power drops
byte s_bLVBeepCnt;
boolean CheckVoltage() {
    10c0:	65735f78 	ldrbvs	r5, [r3, #-3960]!
    10c4:	78654e74 	stmdavc	r5!, {r2, r4, r5, r6, r9, sl, fp, lr}^
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10c8:	736f5074 	cmnvc	pc, #116	; 0x74

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10cc:	49794265 	ldmdbmi	r9!, {r0, r2, r5, r6, r9, lr}^
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d0:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10d4:	00047e00 	andeq	r7, r4, r0, lsl #28
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d8:	6f694200 	svcvs	0x00694200

	if (!g_fLowVoltageShutdown) {
		/**PrintString("Voltage : ");
		Printu32d(Voltage);
		PrintString("\n");*/
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {
    10dc:	64696f6c 	strbtvs	r6, [r9], #-3948
    10e0:	746e6f43 	strbtvc	r6, [lr], #-3907
    10e4:	6c6c6f72 	stclvs	15, cr6, [ip], #-456


			//Turn off
			g_InControlState.BodyPos.x = 0;
    10e8:	78457265 	stmdavc	r5, {r0, r2, r5, r6, r9, ip, sp, lr}^
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;

#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
    10ec:	746e695f 	strbtvc	r6, [lr], #-2399
    10f0:	6f707265 	svcvs	0x00707265
#endif
			g_fLowVoltageShutdown = 1;
    10f4:	6574616c 	ldrbvs	r6, [r4, #-364]!
			s_bLVBeepCnt = 0;    // how many times we beeped...
    10f8:	75746553 	ldrbvc	r6, [r4, #-1363]!
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {


			//Turn off
			g_InControlState.BodyPos.x = 0;
			g_InControlState.BodyPos.y = 0;
    10fc:	04bf0070 	ldrteq	r0, [pc], #112	; 1104 <__Stack_Size+0xd04>
			g_InControlState.BodyPos.z = 0;
			g_InControlState.BodyRot1.x = 0;
    1100:	69420000 	stmdbvs	r2, {}^
			g_InControlState.BodyRot1.y = 0;
			g_InControlState.BodyRot1.z = 0;
    1104:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;
    1108:	65535f64 	ldrbvs	r5, [r3, #-3940]
#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
#endif
			g_fLowVoltageShutdown = 1;
			s_bLVBeepCnt = 0;    // how many times we beeped...
    110c:	00707574 	rsbseq	r7, r0, r4, ror r5
			g_InControlState.fRobotOn = false;
    1110:	000004f5 	strdeq	r0, [r0], -r5
		}
#ifdef cTurnOnVol
	} else if ((Voltage > cTurnOnVol) && (Voltage < 1999)) {
    1114:	6c6f6942 	stclvs	9, cr6, [pc], #-264
    1118:	4364696f 	cmnmi	r4, #1818624	; 0x1bc000

		g_fLowVoltageShutdown = 0;
    111c:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    1120:	656c6c6f 	strbvs	r6, [ip, #-3183]!

#endif
	} else {
		if (s_bLVBeepCnt < 5) {
    1124:	00784572 	rsbseq	r4, r8, r2, ror r5
    1128:	00000517 	andeq	r0, r0, r7, lsl r5
			s_bLVBeepCnt++;
    112c:	6c6f6942 	stclvs	9, cr6, [pc], #-264

			//MSound( 1, 45, 2000);
			Buzzed(45, 2000);
    1130:	4364696f 	cmnmi	r4, #1818624	; 0x1bc000
    1134:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    1138:	656c6c6f 	strbvs	r6, [ip, #-3183]!
		}
		mDelay(2000);
    113c:	5f784572 	svcpl	0x00784572
    1140:	74697277 	strbtvc	r7, [r9], #-631
    1144:	736f5065 	cmnvc	pc, #101	; 0x65
	}
#endif

	return g_fLowVoltageShutdown;
}
    1148:	05550065 	ldrbeq	r0, [r5, #-101]
    114c:	69420000 	stmdbvs	r2, {}^
    1150:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
    1154:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    1158:	6c6f7274 	sfmvs	f7, 2, [pc], #-464

//==============================================================================
// BackgroundProcess - Allows us to have some background processing for those
//    servo drivers that need us to do things like polling...
//==============================================================================
void BackgroundProcess(void) {
    115c:	4572656c 	ldrbmi	r6, [r2, #-1388]!
    1160:	6e695f78 	mcrvs	15, 3, r5, cr9, cr8, {3}
	if (g_fAXSpeedControl)
    1164:	70726574 	rsbsvc	r6, r2, r4, ror r5
		return;  // nothing to do in this mode...

	if (ServosEnabled) {
		//DebugToggle(A3);
		BioloidControllerEx_interpolateStep(false); // Do our background stuff...
    1168:	74616c6f 	strbtvc	r6, [r1], #-3183
		Battery_Monitor_Alarm();
    116c:	65745365 	ldrbvs	r5, [r4, #-869]!
	}
}
    1170:	05b30070 	ldreq	r0, [r3, #112]!
    1174:	69420000 	stmdbvs	r2, {}^
//Function that gets called from the main loop if the robot is not logically
//     on.  Gives us a chance to play some...
//--------------------------------------------------------------------
static u8 g_iIdleServoNum = (u8) - 1;
static u8 g_iIdleLedState = 1;  // what state to we wish to set...
void IdleTime(void) {
    1178:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
    117c:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
	// Each time we call this set servos LED on or off...
	g_iIdleServoNum++;
    1180:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
	if (g_iIdleServoNum >= NUMSERVOS) {
    1184:	4572656c 	ldrbmi	r6, [r2, #-1388]!
    1188:	65725f78 	ldrbvs	r5, [r2, #-3960]!
		g_iIdleServoNum = 0;
    118c:	6f506461 	svcvs	0x00506461
		g_iIdleLedState = 1 - g_iIdleLedState;
    1190:	83006573 	movwhi	r6, #1395	; 0x573
    1194:	69000006 	stmdbvs	r0, {r1, r2}
	}
	dxl_write_byte(pgm_read_byte(&cPinTable[g_iIdleServoNum]), AXM_LED,
    1198:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    119c:	616c6f70 	smcvs	50928
    11a0:	676e6974 	undefined
    11a4:	00069500 	andeq	r9, r6, r0, lsl #10
    11a8:	6e757200 	cdpvs	2, 7, cr7, cr5, cr0, {0}
			g_iIdleLedState);
	//ax12ReadPacket(6);  // get the response...


}
    11ac:	676e696e 	strbvs	r6, [lr, -lr, ror #18]!
    11b0:	00716553 	rsbseq	r6, r1, r3, asr r5
    11b4:	000006a7 	andeq	r0, r0, r7, lsr #13
    11b8:	65736f70 	ldrbvs	r6, [r3, #-3952]!

//--------------------------------------------------------------------
//[SetRegOnAllServos] Function that is called to set the state of one
//  register in all of the servos, like Torque on...
//--------------------------------------------------------------------
void SetRegOnAllServos(u8 bReg, u8 bVal) {
    11bc:	657a6953 	ldrbvs	r6, [sl, #-2387]!
    11c0:	0006b900 	andeq	fp, r6, r0, lsl #18
    11c4:	61726600 	cmnvs	r2, r0, lsl #12
	 ax12write(bVal);

  }
  ax12write(0xff - (checksum % 256));
  setRX(0);*/
	 dxl_set_txpacket_id (BROADCAST_ID);
    11c8:	654c656d 	strbvs	r6, [ip, #-1389]
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    11cc:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
	dxl_set_txpacket_parameter(0,bReg);
    11d0:	0006db00 	andeq	sp, r6, r0, lsl #22
    11d4:	736f7000 	cmnvc	pc, #0	; 0x0
	dxl_set_txpacket_parameter(1,2);
    11d8:	ed005f65 	stc	15, cr5, [r0, #-404]
    11dc:	6e000006 	cdpvs	0, 0, cr0, cr0, cr6, {0}
    11e0:	70747865 	rsbsvc	r7, r4, r5, ror #16
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
    11e4:	5f65736f 	svcpl	0x0065736f
    11e8:	00070f00 	andeq	r0, r7, r0, lsl #30
    11ec:	65707300 	ldrbvs	r7, [r0, #-768]!
    11f0:	005f6465 	subseq	r6, pc, r5, ror #8
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    11f4:	00000731 	andeq	r0, r0, r1, lsr r7
    11f8:	005f6469 	subseq	r6, pc, r9, ror #8
    11fc:	00000743 	andeq	r0, r0, r3, asr #14
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1200:	7478656e 	ldrbtvc	r6, [r8], #-1390
    1204:	6d617266 	sfmvs	f7, 2, [r1, #-408]!
    1208:	55005f65 	strpl	r5, [r0, #-3941]
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    120c:	73000007 	movwvc	r0, #7	; 0x7
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1210:	65757165 	ldrbvs	r7, [r5, #-357]!
	 dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0,bReg);
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
    1214:	0065636e 	rsbeq	r6, r5, lr, ror #6
    1218:	0000076d 	andeq	r0, r0, sp, ror #14
    121c:	6e617274 	mcrvs	2, 3, r7, cr1, cr4, {3}
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
	}

	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
    1220:	69746973 	ldmdbvs	r4!, {r0, r1, r4, r5, r6, r8, fp, sp, lr}^
    1224:	00736e6f 	rsbseq	r6, r3, pc, ror #28
    1228:	00000000 	andeq	r0, r0, r0
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- SetRegOnAllServos ---\n");
#endif
	dxl_txrx_packet();
    122c:	00000185 	andeq	r0, r0, r5, lsl #3

	u16 CommStatus = dxl_get_result();
    1230:	2e940002 	cdpcs	0, 9, cr0, cr4, cr2, {0}
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
    1234:	083b0000 	ldmdaeq	fp!, {}
		PrintErrorCode();
    1238:	014b0000 	cmpeq	fp, r0
	else
		PrintCommStatus(CommStatus);
    123c:	68430000 	stmdavs	r3, {}^
#endif
}
    1240:	506b6365 	rsbpl	r6, fp, r5, ror #6
    1244:	77654e43 	strbvc	r4, [r5, -r3, asr #28]!
    1248:	69727241 	ldmdbvs	r2!, {r0, r6, r9, ip, sp, lr}^
//--------------------------------------------------------------------
//[MakeSureServosAreOn] Function that is called to handle when you are
//  transistioning from servos all off to being on.  May need to read
//  in the current pose...
//--------------------------------------------------------------------
void MakeSureServosAreOn(void) {
    124c:	62006576 	andvs	r6, r0, #494927872	; 0x1d800000

	if (ServosEnabled) {

		if (!g_fServosFree)
    1250:	52000001 	andpl	r0, r0, #1	; 0x1
			return;    // we are not free

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {
    1254:	79424478 	stmdbvc	r2, {r3, r4, r5, r6, sl, lr}^
    1258:	505f6574 	subspl	r6, pc, r4, ror r5

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
    125c:	018b0043 	orreq	r0, fp, r3, asr #32
    1260:	78540000 	ldmdavc	r4, {}^
    1264:	65445f44 	strbvs	r5, [r4, #-3908]
    1268:	33535f63 	cmpcc	r3, #396	; 0x18c
						AXM_PRESENT_POSITION_L);
				mDelay(25);
    126c:	01f00032 	mvnseq	r0, r2, lsr r0
    1270:	78540000 	ldmdavc	r4, {}^

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
    1274:	65445f44 	strbvs	r5, [r4, #-3908]
    1278:	31535f63 	cmpcc	r3, r3, ror #30
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
						AXM_PRESENT_POSITION_L);
				mDelay(25);
			}
		} else {
			BioloidControllerEx_readPose();
    127c:	02650036 	rsbeq	r0, r5, #54	; 0x36
		}

		SetRegOnAllServos(AXM_TORQUE_ENABLE, 1);  // Use sync write to do it.
    1280:	78540000 	ldmdavc	r4, {}^
    1284:	65445f44 	strbvs	r5, [r4, #-3908]

		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = false;
    1288:	38535f63 	ldmdacc	r3, {r0, r1, r5, r6, r8, r9, sl, fp, ip, lr}^
	}

}
    128c:	0002d900 	andeq	sp, r2, r0, lsl #18
    1290:	44785400 	ldrbtmi	r5, [r8], #-1024
    1294:	6365445f 	cmnvs	r5, #1593835520	; 0x5f000000
    1298:	3233555f 	eorscc	r5, r3, #398458880	; 0x17c00000
    129c:	00033e00 	andeq	r3, r3, r0, lsl #28

//------------------------------------------------------------------------------------------
//[BeginServoUpdate] Does whatever preperation that is needed to starrt a move of our servos
//------------------------------------------------------------------------------------------
void BeginServoUpdate(void)    // Start the update
		{
    12a0:	44785400 	ldrbtmi	r5, [r8], #-1024

	MakeSureServosAreOn();
    12a4:	6365445f 	cmnvs	r5, #1593835520	; 0x5f000000
	if (ServosEnabled) {

		if (g_fAXSpeedControl) {
    12a8:	3631555f 	undefined
    12ac:	0003a300 	andeq	sl, r3, r0, lsl #6

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awCurAXPos[i] = g_awGoalAXPos[i];
    12b0:	44785400 	ldrbtmi	r5, [r8], #-1024
    12b4:	6365445f 	cmnvs	r5, #1593835520	; 0x5f000000
    12b8:	0038555f 	eorseq	r5, r8, pc, asr r5
		if (g_fAXSpeedControl) {

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
    12bc:	000003de 	ldrdeq	r0, [r0], -lr
				g_awCurAXPos[i] = g_awGoalAXPos[i];
			}
#endif
		} else
			BioloidControllerEx_interpolateStep(true); // Make sure we call at least once
    12c0:	5f647473 	svcpl	0x00647473
    12c4:	63747570 	cmnvs	r4, #469762048	; 0x1c000000

	}
}
    12c8:	00726168 	rsbseq	r6, r2, r8, ror #2
    12cc:	00000410 	andeq	r0, r0, r0, lsl r4
    12d0:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}
    12d4:	61684374 	smcvs	33844
}

//--------------------------------------------------------------------
//[FREE SERVOS] Frees all the servos
//--------------------------------------------------------------------
void FreeServos(void) {
    12d8:	043b0072 	ldrteq	r0, [fp], #-114
    12dc:	74730000 	ldrbtvc	r0, [r3]

	if (!g_fServosFree) {
    12e0:	75705f64 	ldrbvc	r5, [r0, #-3940]!
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
    12e4:	7e007374 	mcrvc	3, 0, r7, cr0, cr4, {3}
    12e8:	50000004 	andpl	r0, r0, r4
    12ec:	746e6972 	strbtvc	r6, [lr], #-2418
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
			Relax(pgm_read_byte(&cPinTable[i]));
    12f0:	00683875 	rsbeq	r3, r8, r5, ror r8
    12f4:	000004c8 	andeq	r0, r0, r8, asr #9
    12f8:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}

	if (!g_fServosFree) {
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
    12fc:	36317574 	undefined
			Relax(pgm_read_byte(&cPinTable[i]));
		}
		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = true;
    1300:	05120068 	ldreq	r0, [r2, #-104]
	}
}
    1304:	72500000 	subsvc	r0, r0, #0	; 0x0
    1308:	73746e69 	cmnvc	r4, #1680	; 0x690
    130c:	00643233 	rsbeq	r3, r4, r3, lsr r2
extern void SetRegOnAllServos(u8 bReg, u8 bVal);

//--------------------------------------------------------------------
//Init
//--------------------------------------------------------------------
void Servo_Init(void) {
    1310:	000005a4 	andeq	r0, r0, r4, lsr #11
	// First lets get the actual servo positions for all of our servos...
	//pinMode(0, OUTPUT);
	g_fServosFree = true;
    1314:	6e697250 	mcrvs	2, 3, r7, cr9, cr0, {2}

  poseSize = NUMSERVOS;
    1318:	32337574 	eorscc	r7, r3, #486539264	; 0x1d000000
    131c:	061b0064 	ldreq	r0, [fp], -r4, rrx
  BioloidControllerEx_readPose();
    1320:	72500000 	subsvc	r0, r0, #0	; 0x0
#ifdef cVoltagePin
	for (byte i=0; i < 8; i++)
	GetBatteryVoltage();  // init the voltage pin
#endif

	g_fAXSpeedControl = false;
    1324:	53746e69 	cmnpl	r4, #1680	; 0x690
    1328:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}



	// Added - try to speed things up later if we do a query...
	SetRegOnAllServos(AXM_RETURN_DELAY_TIME, 0); // tell servos to give us back their info as quick as they can...
    132c:	06460067 	strbeq	r0, [r6], -r7, rrx
    1330:	72500000 	subsvc	r0, r0, #0	; 0x0

}
    1334:	43746e69 	cmnmi	r4, #1680	; 0x690
    1338:	536d6d6f 	cmnpl	sp, #7104	; 0x1bc0
    133c:	75746174 	ldrbvc	r6, [r4, #-372]!
    1340:	066f0073 	undefined

}

void setupPhoenix() {

	g_fShowDebugPrompt = true;
    1344:	72500000 	subsvc	r0, r0, #0	; 0x0
void readSensors(){


}

void setupPhoenix() {
    1348:	45746e69 	ldrbmi	r6, [r4, #-3689]!

	g_fShowDebugPrompt = true;
	g_fDebugOutput = false;
    134c:	726f7272 	rsbvc	r7, pc, #536870919	; 0x20000007
    1350:	65646f43 	strbvs	r6, [r4, #-3907]!
	//init BioloidEx
	BioloidControllerEx();
    1354:	00068400 	andeq	r8, r6, r0, lsl #8

	// Init our ServoDriver
	Servo_Init();
    1358:	64747300 	ldrbtvs	r7, [r4], #-768

	mDelay(10);
    135c:	7465675f 	strbtvc	r6, [r5], #-1887

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1360:	06cd0073 	uxtab16eq	r0, sp, r3
    1364:	65470000 	strbvs	r0, [r7]
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    1368:	72745374 	rsbsvc	r5, r4, #-805306367	; 0xd0000001
    136c:	00676e69 	rsbeq	r6, r7, r9, ror #28
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1370:	000006f8 	strdeq	r0, [r0], -r8

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1374:	5f647473 	svcpl	0x00647473
    1378:	63746567 	cmnvs	r4, #432013312	; 0x19c00000
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    137c:	00726168 	rsbseq	r6, r2, r8, ror #2
    1380:	00000721 	andeq	r0, r0, r1, lsr #14
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1384:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    1388:	00726168 	rsbseq	r6, r2, r8, ror #2
    138c:	0000073a 	andeq	r0, r0, sl, lsr r7
	Servo_Init();

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1390:	5f756370 	svcpl	0x00756370
    1394:	6d726574 	cfldr64vs	mvdx6, [r2, #-464]!
    1398:	74616e69 	strbtvc	r6, [r1], #-3689

	ResetLegInitAngles();

	//Single leg control. Make sure no leg is selected
#ifdef OPT_SINGLELEG
	g_InControlState.SelectedLeg = 255; // No Leg selected
    139c:	074f0065 	strbeq	r0, [pc, -r5, rrx]
    13a0:	63700000 	cmnvs	r0, #0	; 0x0
	g_InControlState.PrevSelectedLeg = 255;
    13a4:	6e695f75 	mcrvs	15, 3, r5, cr9, cr5, {3}
#endif
	//Body Positions
	g_InControlState.BodyPos.x = 0;
    13a8:	61697469 	cmnvs	r9, r9, ror #8
	g_InControlState.BodyPos.y = 0;
	g_InControlState.BodyPos.z = 0;
    13ac:	657a696c 	ldrbvs	r6, [sl, #-2412]!

//Body Rotations
	g_InControlState.BodyRot1.x = 0;
	g_InControlState.BodyRot1.y = 0;
    13b0:	00000000 	andeq	r0, r0, r0
	g_InControlState.BodyRot1.z = 0;
	g_InControlState.BodyRotOffset.x = 0;
    13b4:	00028800 	andeq	r8, r2, r0, lsl #16
	g_InControlState.BodyRotOffset.y = 0; //Input Y offset value to adjust centerpoint of rotation
	g_InControlState.BodyRotOffset.z = 0;
    13b8:	cf000200 	svcgt	0x00000200

	//Gait
	g_InControlState.GaitType = 0;
    13bc:	1f000036 	svcne	0x00000036
	g_InControlState.BalanceMode = 0;
    13c0:	fe00000a 	cdp2	0, 0, cr0, cr0, cr10, {0}
	g_InControlState.LegLiftHeight = 50;
	g_InControlState.ForceGaitStepCnt = 0; // added to try to adjust starting positions depending on height...
    13c4:	64000002 	strvs	r0, [r0], #-2
	g_InControlState.GaitStep = 1;
    13c8:	675f6c78 	undefined
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    13cc:	725f7465 	subsvc	r7, pc, #1694498816	; 0x65000000
	g_InControlState.BodyRotOffset.z = 0;

	//Gait
	g_InControlState.GaitType = 0;
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
    13d0:	6c757365 	ldclvs	3, cr7, [r5], #-404
    13d4:	03150074 	tsteq	r5, #116	; 0x74
void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    13d8:	78640000 	stmdavc	r4!, {}^
    13dc:	65735f6c 	ldrbvs	r5, [r3, #-3948]!
    13e0:	78745f74 	ldmdavc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
//==============================================================================

// If both PS2 and XBee are defined then we will become secondary to the xbee
void CommanderInputController_Init(void) {

	g_BodyYOffset = 0;
    13e4:	6b636170 	blvs	18d99ac <__Stack_Size+0x18d95ac>
    13e8:	695f7465 	ldmdbvs	pc, {r0, r2, r5, r6, sl, ip, sp, lr}^
    13ec:	03300064 	teqeq	r0, #100	; 0x64
	g_BodyYShift = 0;
	//begin(XBEE_BAUD);
	GPSeq = 0;  // init to something...
    13f0:	78640000 	stmdavc	r4!, {}^
    13f4:	65735f6c 	ldrbvs	r5, [r3, #-3948]!

	ControlMode = WALKMODE;
    13f8:	78745f74 	ldmdavc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
	HeightSpeedMode = NORM_NORM;
    13fc:	6b636170 	blvs	18d99c4 <__Stack_Size+0x18d95c4>
	//    DoubleHeightOn = false;
	DoubleTravelOn = false;
    1400:	695f7465 	ldmdbvs	pc, {r0, r2, r5, r6, sl, ip, sp, lr}^
	bJoystickWalkMode = 0;
    1404:	7274736e 	rsbsvc	r7, r4, #-1207959551	; 0xb8000001
	GaitSelect();

	CommanderInputController_Init();

	// Servo Driver
	ServoMoveTime = 150;
    1408:	69746375 	ldmdbvs	r4!, {r0, r2, r4, r5, r6, r8, r9, sp, lr}^
	g_InControlState.fRobotOn = 0;
    140c:	4b006e6f 	blmi	1cdd0 <__Stack_Size+0x1c9d0>
	g_fLowVoltageShutdown = false;
    1410:	64000003 	strvs	r0, [r0], #-3

}
    1414:	735f6c78 	cmpvc	pc, #30720	; 0x7800
    1418:	745f7465 	ldrbvc	r7, [pc], #1125	; 1420 <__Stack_Size+0x1020>
    141c:	63617078 	cmnvs	r1, #120	; 0x78
    1420:	5f74656b 	svcpl	0x0074656b
    1424:	61726170 	cmnvs	r2, r0, ror r1
    1428:	6574656d 	ldrbvs	r6, [r4, #-1389]!
    142c:	036d0072 	cmneq	sp, #114	; 0x72
    1430:	78640000 	stmdavc	r4!, {}^
    1434:	65735f6c 	ldrbvs	r5, [r3, #-3948]!
    1438:	78745f74 	ldmdavc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    143c:	6b636170 	blvs	18d9a04 <__Stack_Size+0x18d9604>
    1440:	6c5f7465 	cfldrdvs	mvd7, [pc], {101}
    1444:	74676e65 	strbtvc	r6, [r7], #-3685
    1448:	03880068 	orreq	r0, r8, #104	; 0x68
    144c:	78640000 	stmdavc	r4!, {}^
    1450:	65675f6c 	strbvs	r5, [r7, #-3948]!
    1454:	78725f74 	ldmdavc	r2!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1458:	6b636170 	blvs	18d9a20 <__Stack_Size+0x18d9620>
    145c:	655f7465 	ldrbvs	r7, [pc, #-1125]	; fff <__Stack_Size+0xbff>
    1460:	726f7272 	rsbvc	r7, pc, #536870919	; 0x20000007
    1464:	0003b300 	andeq	fp, r3, r0, lsl #6
//[CommitServoDriver Updates the positions of the servos - This outputs
//         as much of the command as we can without committing it.  This
//         allows us to once the previous update was completed to quickly
//        get the next command to start
//--------------------------------------------------------------------
void CommitServoDriver(word wMoveTime) {
    1468:	6c786400 	cfldrdvs	mvd6, [r8]
    146c:	7465675f 	strbtvc	r6, [r5], #-1887
    1470:	7078725f 	rsbsvc	r7, r8, pc, asr r2


	CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1474:	656b6361 	strbvs	r6, [fp, #-865]!

      }
      ax12write(0xff - (checksum % 256));
      setRX(0);
*/
  	    dxl_set_txpacket_id (BROADCAST_ID);
    1478:	656c5f74 	strbvs	r5, [ip, #-3956]!
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    147c:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    1480:	0003cb00 	andeq	ip, r3, r0, lsl #22
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
    1484:	6c786400 	cfldrdvs	mvd6, [r8]
    1488:	7465675f 	strbtvc	r6, [r5], #-1887
		dxl_set_txpacket_parameter(1, 2);
    148c:	7078725f 	rsbsvc	r7, r8, pc, asr r2
    1490:	656b6361 	strbvs	r6, [fp, #-865]!
    1494:	61705f74 	cmnvs	r0, r4, ror pc
    1498:	656d6172 	strbvs	r6, [sp, #-370]!
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
			wSpeed = CalculateAX12MoveSpeed(g_awCurAXPos[i], g_awGoalAXPos[i], wMoveTime);    // What order should we store these values?
    149c:	00726574 	rsbseq	r6, r2, r4, ror r5
    14a0:	000003f8 	strdeq	r0, [r0], -r8
    14a4:	5f6c7864 	svcpl	0x006c7864
    14a8:	656b616d 	strbvs	r6, [fp, #-365]!
			//dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
			byte id = pgm_read_byte(&cPinTable[i]);
			dxl_set_txpacket_parameter(2 + 3 * i, id);
    14ac:	64726f77 	ldrbtvs	r6, [r2], #-3959
    14b0:	00042100 	andeq	r2, r4, r0, lsl #2
    14b4:	6c786400 	cfldrdvs	mvd6, [r8]
    14b8:	7465675f 	strbtvc	r6, [r5], #-1887
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(g_awGoalAXPos[i]));
    14bc:	776f6c5f 	undefined
    14c0:	65747962 	ldrbvs	r7, [r4, #-2402]!
    14c4:	00044300 	andeq	r4, r4, r0, lsl #6
    14c8:	6c786400 	cfldrdvs	mvd6, [r8]
    14cc:	7465675f 	strbtvc	r6, [r5], #-1887
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
    14d0:	6769685f 	undefined
    14d4:	74796268 	ldrbtvc	r6, [r9], #-616
    14d8:	04650065 	strbteq	r0, [r5], #-101
    14dc:	78640000 	stmdavc	r4!, {}^
    14e0:	6c635f6c 	stclvs	15, cr5, [r3], #-432
    14e4:	5f726165 	svcpl	0x00726165
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
    14e8:	74617473 	strbtvc	r7, [r1], #-1139
    14ec:	00746b70 	rsbseq	r6, r4, r0, ror fp
    14f0:	0000048b 	andeq	r0, r0, fp, lsl #9
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
    14f4:	5f6c7864 	svcpl	0x006c7864
    14f8:	705f7872 	subsvc	r7, pc, r2, ror r8
    14fc:	656b6361 	strbvs	r6, [fp, #-865]!
    1500:	04d90074 	ldrbeq	r0, [r9], #116
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
		dxl_set_txpacket_parameter(1, 2);
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
    1504:	78640000 	stmdavc	r4!, {}^
    1508:	78745f6c 	ldmdavc	r4!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    150c:	6361705f 	cmnvs	r1, #95	; 0x5f
    1510:	0074656b 	rsbseq	r6, r4, fp, ror #10
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
		}

		dxl_set_txpacket_length((4 + 1) * poseSize + 4);
    1514:	00000527 	andeq	r0, r0, r7, lsr #10
    1518:	5f6c7864 	svcpl	0x006c7864
    151c:	78727874 	ldmdavc	r2!, {r2, r4, r5, r6, fp, ip, sp, lr}^
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- CommitServoDriver ---\n");
#endif
		dxl_txrx_packet();
    1520:	6361705f 	cmnvs	r1, #95	; 0x5f

			u16 CommStatus = dxl_get_result();
    1524:	0074656b 	rsbseq	r6, r4, fp, ror #10
#ifdef USING_PC_UART
			if (CommStatus == DXL_RXSUCCESS)
    1528:	0000056d 	andeq	r0, r0, sp, ror #10
				PrintErrorCode();
    152c:	5f6c7864 	svcpl	0x006c7864
			else
				PrintCommStatus(CommStatus);
    1530:	5f746573 	svcpl	0x00746573
    1534:	6c616f67 	stclvs	15, cr6, [r1], #-412
#endif
#endif
		} else {
			BioloidControllerEx_interpolateSetup(wMoveTime);
    1538:	6570735f 	ldrbvs	r7, [r0, #-863]!

	}

	CommanderInputController_AllowControllerInterrupts(true);

}
    153c:	06006465 	streq	r6, [r0], -r5, ror #8
    1540:	64000007 	strvs	r0, [r0], #-7
    1544:	775f6c78 	undefined
    1548:	65746972 	ldrbvs	r6, [r4, #-2418]!
    154c:	726f775f 	rsbvc	r7, pc, #24903680	; 0x17c0000
    1550:	07540064 	ldrbeq	r0, [r4, -r4, rrx]
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    1554:	78640000 	stmdavc	r4!, {}^
    1558:	65725f6c 	ldrbvs	r5, [r2, #-3948]!
    155c:	775f6461 	ldrbvc	r6, [pc, -r1, ror #8]
    1560:	0064726f 	rsbeq	r7, r4, pc, ror #4
    1564:	000007c0 	andeq	r0, r0, r0, asr #15


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1568:	5f6c7864 	svcpl	0x006c7864
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    156c:	74697277 	strbtvc	r7, [r9], #-631
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1570:	79625f65 	stmdbvc	r2!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
    1574:	0e006574 	cfrshl64eq	mvdx0, mvdx4, r6
    1578:	64000008 	strvs	r0, [r0], #-8
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    157c:	635f6c78 	cmpvs	pc, #30720	; 0x7800
    1580:	75747061 	ldrbvc	r7, [r4, #-97]!
    1584:	38006572 	stmdacc	r0, {r1, r4, r5, r6, r8, sl, sp, lr}


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1588:	64000008 	strvs	r0, [r0], #-8
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    158c:	725f6c78 	subsvc	r6, pc, #30720	; 0x7800
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1590:	5f646165 	svcpl	0x00646165
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1594:	65747962 	ldrbvs	r7, [r4, #-2402]!
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    1598:	00087600 	andeq	r7, r8, r0, lsl #12

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
    159c:	6c786400 	cfldrdvs	mvd6, [r8]
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    15a0:	6e69705f 	mcrvs	0, 3, r7, cr9, cr15, {2}
			g_awGoalAXPos[FIRSTTIBIAPIN + LegIndex] = wTibiaSDV;
    15a4:	08a40067 	stmiaeq	r4!, {r0, r1, r2, r5, r6}
    15a8:	78640000 	stmdavc	r4!, {}^
    15ac:	65745f6c 	ldrbvs	r5, [r4, #-3948]!

#endif
		} else {
			BioloidControllerEx_setNextPose(
    15b0:	6e696d72 	mcrvs	13, 3, r6, cr9, cr2, {3}
    15b4:	00657461 	rsbeq	r7, r5, r1, ror #8
					pgm_read_byte(&cPinTable[FIRSTCOXAPIN + LegIndex]),
					wCoxaSDV);
			BioloidControllerEx_setNextPose(
    15b8:	000008b9 	strheq	r0, [r0], -r9
    15bc:	5f6c7864 	svcpl	0x006c7864
    15c0:	74696e69 	strbtvc	r6, [r9], #-3689
					pgm_read_byte(&cPinTable[FIRSTFEMURPIN + LegIndex]),
					wFemurSDV);
			BioloidControllerEx_setNextPose(
    15c4:	696c6169 	stmdbvs	ip!, {r0, r3, r5, r6, r8, sp, lr}^
    15c8:	a200657a 	andge	r6, r0, #511705088	; 0x1e800000
					wTibiaSDV);

		}
	}
	CommanderInputController_AllowControllerInterrupts(true); // Ok for hserial again...
}
    15cc:	67000009 	strvs	r0, [r0, -r9]
    15d0:	736e4962 	cmnvc	lr, #1605632	; 0x188000
    15d4:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    15d8:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    15dc:	6b636150 	blvs	18d9b24 <__Stack_Size+0x18d9724>

void StartUpdateServos() {
    15e0:	c4007465 	strgt	r7, [r0], #-1125
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update
    15e4:	67000009 	strvs	r0, [r0, -r9]
    15e8:	61745362 	cmnvs	r4, r2, ror #6
    15ec:	50737574 	rsbspl	r7, r3, r4, ror r5

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		OutputServoInfoForLeg(LegIndex,
    15f0:	656b6361 	strbvs	r6, [fp, #-865]!
    15f4:	09d60074 	ldmibeq	r6, {r2, r4, r5, r6}^
    15f8:	62670000 	rsbvs	r0, r7, #0	; 0x0
    15fc:	61507852 	cmpvs	r0, r2, asr r8
    1600:	74656b63 	strbtvc	r6, [r5], #-2915
    1604:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
    1608:	e8006874 	stmda	r0, {r2, r4, r5, r6, fp, sp, lr}
    160c:	67000009 	strvs	r0, [r0, -r9]
    1610:	47785262 	ldrbmi	r5, [r8, -r2, ror #4]!
    1614:	654c7465 	strbvs	r7, [ip, #-1125]
    1618:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    161c:	0009fa00 	andeq	pc, r9, r0, lsl #20
    1620:	43626700 	cmnmi	r2, #0	; 0x0
    1624:	536d6d6f 	cmnpl	sp, #7104	; 0x1bc0
    1628:	75746174 	ldrbvc	r6, [r4, #-372]!
    162c:	0a0c0073 	beq	301800 <__Stack_Size+0x301400>
    1630:	69670000 	stmdbvs	r7!, {}^
    1634:	55737542 	ldrbpl	r7, [r3, #-1346]!
    1638:	676e6973 	undefined
    163c:	00000000 	andeq	r0, r0, r0
    1640:	00021b00 	andeq	r1, r2, r0, lsl #22
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1644:	ee000200 	cdp	2, 0, cr0, cr0, cr0, {0}
				cTibiaInv[LegIndex] ?
						-TibiaAngle1[LegIndex] : TibiaAngle1[LegIndex]);

	}

}
    1648:	77000040 	strvc	r0, [r0, -r0, asr #32]
    164c:	7d000004 	stcvc	0, cr0, [r0, #-16]
    1650:	7a000000 	bvc	1658 <__Stack_Size+0x1258>
    1654:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
    1658:	61645f78 	smcvs	17912
    165c:	94006174 	strls	r6, [r0], #-372
    1660:	7a000000 	bvc	1668 <__Stack_Size+0x1268>
#else
word g_wLastVoltage = 0xffff;    // save the last voltage we retrieved...
byte g_bLegVoltage = 0;		// what leg did we last check?
unsigned long g_ulTimeLastBatteryVoltage;
#define VOLTAGE_REPEAT_MAX  3
word GetBatteryVoltage(void) {
    1664:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
	if (interpolating && (g_wLastVoltage != 0xffff)
    1668:	61645f78 	smcvs	17912
    166c:	725f6174 	subsvc	r6, pc, #29	; 0x1d
    1670:	74686769 	strbtvc	r6, [r8], #-1897
    1674:	ac00565f 	stcge	6, cr5, [r0], {95}
    1678:	7a000000 	bvc	1680 <__Stack_Size+0x1280>
    167c:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
    1680:	61645f78 	smcvs	17912
    1684:	725f6174 	subsvc	r6, pc, #29	; 0x1d
			&& ((getMillis() - g_ulTimeLastBatteryVoltage)
					< VOLTAGE_MAX_TIME_BETWEEN_CALLS))
		return g_wLastVoltage;
    1688:	74686769 	strbtvc	r6, [r8], #-1897

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
    168c:	c400485f 	strgt	r4, [r0], #-2143
    1690:	7a000000 	bvc	1698 <__Stack_Size+0x1298>
    1694:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    1698:	61645f78 	smcvs	17912
			g_wLastVoltage = wVoltage * 10;
    169c:	6c5f6174 	ldfvse	f6, [pc], {116}

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    16a0:	5f746665 	svcpl	0x00746665
			g_wLastVoltage = wVoltage * 10;
    16a4:	00dc0056 	sbcseq	r0, ip, r6, asr r0
		}
	} while (--bLoopCnt);

	return 0;

}
    16a8:	677a0000 	ldrbvs	r0, [sl, -r0]!
    16ac:	78725f62 	ldmdavc	r2!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    16b0:	7461645f 	strbtvc	r6, [r1], #-1119
    16b4:	656c5f61 	strbvs	r5, [ip, #-3937]!
// ReadMsgs
//==============================================================================

/* process messages coming from Commander
 *  format = 0xFF RIGHT_H RIGHT_V LEFT_H LEFT_V BUTTONS EXT CHECKSUM */
int Commander_ReadMsgs() {
    16b8:	485f7466 	ldmdami	pc, {r1, r2, r5, r6, sl, ip, sp, lr}^
	 }
	 #endif
	 */
	//while (CheckZBNewArrive() > 0) {
	while (1) {
		if (zgb_rx_check_arduino() == 1) {
    16bc:	0000f400 	andeq	pc, r0, r0, lsl #8
    16c0:	62677a00 	rsbvs	r7, r7, #0	; 0x0

			leftV = (signed char) (zgb_rx_data_right_V_());
    16c4:	5f78725f 	svcpl	0x0078725f
    16c8:	61746164 	cmnvs	r4, r4, ror #2
			leftH = (signed char) (zgb_rx_data_right_H_());
    16cc:	7475625f 	ldrbtvc	r6, [r5], #-607
    16d0:	736e6f74 	cmnvc	lr, #464	; 0x1d0
			rightV = (signed char) (zgb_rx_data_left_V_());
    16d4:	00010c00 	andeq	r0, r1, r0, lsl #24
    16d8:	62677a00 	rsbvs	r7, r7, #0	; 0x0
			rightH = (signed char) (zgb_rx_data_left_H_());
    16dc:	5f78725f 	svcpl	0x0078725f
    16e0:	61746164 	cmnvs	r4, r4, ror #2
			buttons = zgb_rx_data_buttons();
    16e4:	7478655f 	ldrbtvc	r6, [r8], #-1375
    16e8:	24006172 	strcs	r6, [r0], #-370
			ext = zgb_rx_data_extra();
    16ec:	7a000001 	bvc	16f8 <__Stack_Size+0x12f8>
    16f0:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006

	}

	return 0;

}
    16f4:	61645f78 	smcvs	17912
    16f8:	725f6174 	subsvc	r6, pc, #29	; 0x1d
    16fc:	74686769 	strbtvc	r6, [r8], #-1897
    1700:	005f565f 	subseq	r5, pc, pc, asr r6
    1704:	00000143 	andeq	r0, r0, r3, asr #2
    1708:	5f62677a 	svcpl	0x0062677a
    170c:	645f7872 	ldrbvs	r7, [pc], #2162	; 1714 <__Stack_Size+0x1314>
    1710:	5f617461 	svcpl	0x00617461

//==============================================================================
// This is The main code to input function to read inputs from the Commander and then
//process any commands.
//==============================================================================
void CommanderInputController_ControlInput(void) {
    1714:	68676972 	stmdavs	r7!, {r1, r4, r5, r6, r8, fp, sp, lr}^

	// See if we have a new command available...
	if (Commander_ReadMsgs() > 0) {
    1718:	5f485f74 	svcpl	0x00485f74
    171c:	00015b00 	andeq	r5, r1, r0, lsl #22
    1720:	62677a00 	rsbvs	r7, r7, #0	; 0x0
    1724:	5f78725f 	svcpl	0x0078725f
		// If we receive a valid message than turn robot on...
		boolean fAdjustLegPositions = false;
		short sLegInitXZAdjust = 0;
		short sLegInitAngleAdjust = 0;

		if (!g_InControlState.fRobotOn) {
    1728:	61746164 	cmnvs	r4, r4, ror #2
    172c:	66656c5f 	undefined
			g_InControlState.fRobotOn = true;
    1730:	5f565f74 	svcpl	0x00565f74
    1734:	00017300 	andeq	r7, r1, r0, lsl #6
		}

		// [SWITCH MODES]

		// Cycle through modes...
		if ((buttons & BUT_LT) && !(buttonsPrev & BUT_LT)) {
    1738:	62677a00 	rsbvs	r7, r7, #0	; 0x0
    173c:	5f78725f 	svcpl	0x0078725f
    1740:	61746164 	cmnvs	r4, r4, ror #2
    1744:	66656c5f 	undefined
    1748:	5f485f74 	svcpl	0x00485f74
    174c:	00018b00 	andeq	r8, r1, r0, lsl #22

			if (++ControlMode >= MODECNT) {
    1750:	65684300 	strbvs	r4, [r8, #-768]!
    1754:	425a6b63 	subsmi	r6, sl, #101376	; 0x18c00
    1758:	4177654e 	cmnmi	r7, lr, asr #10
    175c:	76697272 	undefined
				ControlMode = WALKMODE;    // cycled back around...
				Buzzed(50, 2000);
    1760:	01a30065 	undefined instruction 0x01a30065
    1764:	677a0000 	ldrbvs	r0, [sl, -r0]!
    1768:	78725f62 	ldmdavc	r2!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
				Buzzed(50, 3000);
    176c:	6568635f 	strbvs	r6, [r8, #-863]!
    1770:	615f6b63 	cmpvs	pc, r3, ror #22

			} else {
				Buzzed(50, 2000);
    1774:	69756472 	ldmdbvs	r5!, {r1, r4, r5, r6, sl, sp, lr}^
    1778:	f1006f6e 	undefined instruction 0xf1006f6e
    177c:	7a000001 	bvc	1788 <__Stack_Size+0x1388>
			}
			if (ControlMode != SINGLELEGMODE)
    1780:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
    1784:	68635f78 	stmdavs	r3!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
				g_InControlState.SelectedLeg = 255;
    1788:	006b6365 	rsbeq	r6, fp, r5, ror #6
    178c:	0000023f 	andeq	r0, r0, pc, lsr r2
    1790:	5f62677a 	svcpl	0x0062677a

		}

		//[Common functions]
		//Switch Balance mode on/off
		if ((buttons & BUT_L4) && !(buttonsPrev & BUT_L4)) {
    1794:	645f7874 	ldrbvs	r7, [pc], #2164	; 179c <__Stack_Size+0x139c>
    1798:	00617461 	rsbeq	r7, r1, r1, ror #8
    179c:	000002a8 	andeq	r0, r0, r8, lsr #5
    17a0:	5f62677a 	svcpl	0x0062677a
    17a4:	6d726574 	cfldr64vs	mvdx6, [r2, #-464]!
    17a8:	74616e69 	strbtvc	r6, [r1], #-3689

			g_InControlState.BalanceMode = !g_InControlState.BalanceMode;
    17ac:	02bd0065 	adcseq	r0, sp, #101	; 0x65
    17b0:	677a0000 	ldrbvs	r0, [sl, -r0]!
    17b4:	6e695f62 	cdpvs	15, 6, cr5, cr9, cr2, {3}
    17b8:	61697469 	cmnvs	r9, r9, ror #8
    17bc:	657a696c 	ldrbvs	r6, [sl, #-2412]!
			if (g_InControlState.BalanceMode) {
    17c0:	0003a000 	andeq	sl, r3, r0
				Buzzed(250, 1500);
    17c4:	52626700 	rsbpl	r6, r2, #0	; 0x0
    17c8:	61507663 	cmpvs	r0, r3, ror #12
			} else {
				Buzzed(100, 2000);
    17cc:	74656b63 	strbtvc	r6, [r5], #-2915
    17d0:	0003c200 	andeq	ip, r3, r0, lsl #4
				Buzzed(50, 4000);
    17d4:	52626700 	rsbpl	r6, r2, #0	; 0x0
    17d8:	61507663 	cmpvs	r0, r3, ror #12
    17dc:	74656b63 	strbtvc	r6, [r5], #-2915
			}
		}

		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
    17e0:	75647241 	strbvc	r7, [r4, #-577]!
    17e4:	006f6e69 	rsbeq	r6, pc, r9, ror #28
    17e8:	000003d4 	ldrdeq	r0, [r0], -r4
    17ec:	63526267 	cmpvs	r2, #1879048198	; 0x70000006
    17f0:	63615076 	cmnvs	r1, #118	; 0x76
    17f4:	4e74656b 	cdpmi	5, 7, cr6, cr4, cr11, {3}
			if (g_BodyYOffset > 0)
    17f8:	e6006d75 	undefined
    17fc:	67000003 	strvs	r0, [r0, -r3]
				g_BodyYOffset = 0;
    1800:	76635277 	undefined
    1804:	61746144 	cmnvs	r4, r4, asr #2
			else
				g_BodyYOffset = 35;
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1808:	0003f800 	andeq	pc, r3, r0, lsl #16
		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
			if (g_BodyYOffset > 0)
				g_BodyYOffset = 0;
			else
				g_BodyYOffset = 35;
    180c:	52626700 	rsbpl	r6, r2, #0	; 0x0
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1810:	6c467663 	mcrrvs	6, 6, r7, r6, cr3
    1814:	0a006761 	beq	1b5a0 <__Stack_Size+0x1b1a0>

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1818:	72000004 	andvc	r0, r0, #4	; 0x4
		int ly = leftV;
		if (buttons & BUT_L6) {
    181c:	74686769 	strbtvc	r6, [r8], #-1897

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1820:	1c00565f 	stcne	6, cr5, [r0], {95}
    1824:	72000004 	andvc	r0, r0, #4	; 0x4
		int ly = leftV;
    1828:	74686769 	strbtvc	r6, [r8], #-1897
    182c:	2e00485f 	mcrcs	8, 0, r4, cr0, cr15, {2}
		if (buttons & BUT_L6) {
    1830:	6c000004 	stcvs	0, cr0, [r0], {4}
    1834:	5f746665 	svcpl	0x00746665
			// raise or lower the robot on the joystick up /down
			// Maybe should have Min/Max
			int delta = rightV / 25;
    1838:	04400056 	strbeq	r0, [r0], #-86
    183c:	656c0000 	strbvs	r0, [ip]!
    1840:	485f7466 	ldmdami	pc, {r1, r2, r5, r6, sl, ip, sp, lr}^
    1844:	00045200 	andeq	r5, r4, r0, lsl #4
    1848:	74756200 	ldrbtvc	r6, [r5], #-512
    184c:	736e6f74 	cmnvc	lr, #464	; 0x1d0
			if (delta) {
    1850:	0464005f 	strbteq	r0, [r4], #-95
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
    1854:	78650000 	stmdavc	r5!, {}^
    1858:	00617274 	rsbeq	r7, r1, r4, ror r2
    185c:	00000000 	andeq	r0, r0, r0
    1860:	00000260 	andeq	r0, r0, r0, ror #4
    1864:	45650002 	strbmi	r0, [r5, #-2]!
    1868:	09a60000 	stmibeq	r6!, {}
    186c:	03c60000 	biceq	r0, r6, #0	; 0x0
    1870:	68630000 	stmdavs	r3!, {}^
    1874:	4d6b6365 	stclmi	3, cr6, [fp, #-404]!
			sLegInitAngleAdjust = ly / 8;
			lx = 0;
			ly = 0;

			// Likewise for Speed control
			delta = rightH / 16;   //
    1878:	6f69746f 	svcvs	0x0069746f
    187c:	6e69466e 	cdpvs	6, 6, cr4, cr9, cr14, {3}
    1880:	65687369 	strbvs	r7, [r8, #-873]!
    1884:	03dd0064 	bicseq	r0, sp, #100	; 0x64
    1888:	65730000 	ldrbvs	r0, [r3]!
			if ((delta < 0) && g_InControlState.SpeedControl) {
    188c:	77654e74 	undefined
    1890:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    1894:	6f436e6f 	svcvs	0x00436e6f
				if ((word)(-delta) < g_InControlState.SpeedControl)
    1898:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
					g_InControlState.SpeedControl += delta;
    189c:	04060064 	streq	r0, [r6], #-100
				else
					g_InControlState.SpeedControl = 0;
    18a0:	65670000 	strbvs	r0, [r7]!
    18a4:	72754374 	rsbsvc	r4, r5, #-805306367	; 0xd0000001

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
    18a8:	746e6572 	strbtvc	r6, [lr], #-1394
    18ac:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    18b0:	74536e6f 	ldrbvc	r6, [r3], #-3695
				g_InControlState.SpeedControl += delta;
				if (g_InControlState.SpeedControl > 2000)
    18b4:	54747261 	ldrbtpl	r7, [r4], #-609
					g_InControlState.SpeedControl = 0;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
				g_InControlState.SpeedControl += delta;
    18b8:	00656d69 	rsbeq	r6, r5, r9, ror #26
				if (g_InControlState.SpeedControl > 2000)
					g_InControlState.SpeedControl = 2000;
    18bc:	0000041d 	andeq	r0, r0, sp, lsl r4
    18c0:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
    18c4:	72754374 	rsbsvc	r4, r5, #-805306367	; 0xd0000001
    18c8:	746e6572 	strbtvc	r6, [lr], #-1394
    18cc:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18d0:	61506e6f 	cmpvs	r0, pc, ror #28
    18d4:	7d006567 	cfstr32vc	mvfx6, [r0, #-412]
    18d8:	63000004 	movwvs	r0, #4	; 0x4
    18dc:	6b636568 	blvs	18dae84 <__Stack_Size+0x18daa84>
			sLegInitAngleAdjust = ly / 8;
    18e0:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    18e4:	74536e6f 	ldrbvc	r6, [r3], #-3695
    18e8:	69467065 	stmdbvs	r6, {r0, r2, r5, r6, ip, sp, lr}^
    18ec:	6873696e 	ldmdavs	r3!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f0:	96006465 	strls	r6, [r0], -r5, ror #8
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18f4:	65000004 	strvs	r0, [r0, #-4]
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f8:	75636578 	strbvc	r6, [r3, #-1400]!
		}

		//[Walk functions]
		if (ControlMode == WALKMODE) {
    18fc:	6f4d6574 	svcvs	0x004d6574
    1900:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    1904:	70657453 	rsbvc	r7, r5, r3, asr r4

			//Switch gates
			if (((buttons & BUT_R1) && !(buttonsPrev & BUT_R1))
    1908:	0004d500 	andeq	sp, r4, r0, lsl #10
    190c:	74657300 	strbtvc	r7, [r5], #-768
    1910:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    1914:	61506e6f 	cmpvs	r0, pc, ror #28
    1918:	6f4a6567 	svcvs	0x004a6567
    191c:	46746e69 	ldrbtmi	r6, [r4], -r9, ror #28
    1920:	6978656c 	ldmdbvs	r8!, {r2, r3, r5, r6, r8, sl, sp, lr}^
    1924:	696c6962 	stmdbvs	ip!, {r1, r5, r6, r8, fp, sp, lr}^
    1928:	21007974 	tstcs	r0, r4, ror r9
    192c:	75000005 	strvc	r0, [r0, #-5]
    1930:	6361706e 	cmnvs	r1, #110	; 0x6e
    1934:	746f4d6b 	strbtvc	r4, [pc], #3435	; 193c <__Stack_Size+0x153c>
    1938:	326e6f69 	rsbcc	r6, lr, #420	; 0x1a4
    193c:	00058d00 	andeq	r8, r5, r0, lsl #26
    1940:	65786500 	ldrbvs	r6, [r8, #-1280]!
    1944:	65747563 	ldrbvs	r7, [r4, #-1379]!
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1948:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    194c:	71006e6f 	tstvc	r0, pc, ror #28
    1950:	65000006 	strvs	r0, [r0, #-6]
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1954:	75636578 	strbvc	r6, [r3, #-1400]!
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    1958:	6f4d6574 	svcvs	0x004d6574
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
					Buzzed(50, 2000);
    195c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    1960:	74697845 	strbtvc	r7, [r9], #-2117
    1964:	65676150 	strbvs	r6, [r7, #-336]!
				} else {
					Buzzed(50, 2000);
    1968:	00069b00 	andeq	r9, r6, r0, lsl #22
    196c:	746f6d00 	strbtvc	r6, [pc], #3328	; 1974 <__Stack_Size+0x1574>
    1970:	506e6f69 	rsbpl	r6, lr, r9, ror #30
					Buzzed(50, 2250);
    1974:	49656761 	stmdbmi	r5!, {r0, r5, r6, r8, r9, sl, sp, lr}^
    1978:	0074696e 	rsbseq	r6, r4, lr, ror #18
					g_InControlState.GaitType = 0;
    197c:	000006c7 	andeq	r0, r0, r7, asr #13
    1980:	63657865 	cmnvs	r5, #6619136	; 0x650000
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    1984:	4d657475 	cfstrdmi	mvd7, [r5, #-468]!
    1988:	6f69746f 	svcvs	0x0069746f
    198c:	7165536e 	cmnvc	r5, lr, ror #6

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    1990:	636e6575 	cmnvs	lr, #490733568	; 0x1d400000
    1994:	08190065 	ldmdaeq	r9, {r0, r2, r5, r6}
    1998:	58410000 	stmdapl	r1, {}^
    199c:	455f3231 	ldrbmi	r3, [pc, #-561]	; 1773 <__Stack_Size+0x1373>
    19a0:	4c42414e 	stfmie	f4, [r2], {78}
				}
				GaitSelect();
			}

			//Double leg lift height
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    19a4:	30004445 	andcc	r4, r0, r5, asr #8
    19a8:	53000008 	movwpl	r0, #8	; 0x8
    19ac:	4f565245 	svcmi	0x00565245
    19b0:	58414d5f 	stmdapl	r1, {r0, r1, r2, r3, r4, r6, r8, sl, fp, lr}^
    19b4:	4c41565f 	mcrrmi	6, 5, r5, r1, cr15
				Buzzed(50, 2000);
    19b8:	00534555 	subseq	r4, r3, r5, asr r5
    19bc:	00000847 	andeq	r0, r0, r7, asr #16
				HeightSpeedMode = (HeightSpeedMode + 1) & 0x3; // wrap around mode
    19c0:	56524553 	undefined
    19c4:	494d5f4f 	stmdbmi	sp, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    19c8:	41565f4e 	cmpmi	r6, lr, asr #30
    19cc:	5345554c 	movtpl	r5, #21836	; 0x554c
				DoubleTravelOn = HeightSpeedMode & 0x1;
    19d0:	00085e00 	andeq	r5, r8, r0, lsl #28
    19d4:	746f6d00 	strbtvc	r6, [pc], #3328	; 19dc <__Stack_Size+0x15dc>
				if (HeightSpeedMode & 0x2)
    19d8:	5f6e6f69 	svcpl	0x006e6f69
    19dc:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
					g_InControlState.LegLiftHeight = 80;
    19e0:	5f726574 	svcpl	0x00726574
    19e4:	65676170 	strbvs	r6, [r7, #-368]!
				else
					g_InControlState.LegLiftHeight = 50;
			}

			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {
    19e8:	08750073 	ldmdaeq	r5!, {r0, r1, r4, r5, r6}^
    19ec:	6f6d0000 	svcvs	0x006d0000
    19f0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    19f4:	6174735f 	cmnvs	r4, pc, asr r3
    19f8:	87006574 	smlsdxhi	r0, r4, r5, r6

				if ((++bJoystickWalkMode) > 1)
    19fc:	70000008 	andvc	r0, r0, r8
    1a00:	65737561 	ldrbvs	r7, [r3, #-1377]!
    1a04:	6174735f 	cmnvs	r4, pc, asr r3

					bJoystickWalkMode = 0;
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a08:	745f7472 	ldrbvc	r7, [pc], #1138	; 1a10 <__Stack_Size+0x1610>
			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {

				if ((++bJoystickWalkMode) > 1)

					bJoystickWalkMode = 0;
    1a0c:	00656d69 	rsbeq	r6, r5, r9, ror #26
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a10:	00000899 	muleq	r0, r9, r8
    1a14:	65706572 	ldrbvs	r6, [r0, #-1394]!
    1a18:	635f7461 	cmpvs	pc, #1627389952	; 0x61000000
    1a1c:	746e756f 	strbtvc	r7, [lr], #-1391
			}

			//Walking
			switch (bJoystickWalkMode) {
    1a20:	ab007265 	blge	1e3bc <__Stack_Size+0x1dfbc>
    1a24:	65000008 	strvs	r0, [r0, #-8]
    1a28:	5f746978 	svcpl	0x00746978
			case 0:
				g_InControlState.TravelLength.x = -lx;
    1a2c:	67616c66 	strbvs	r6, [r1, -r6, ror #24]!
    1a30:	0008bd00 	andeq	fp, r8, r0, lsl #26
    1a34:	73616c00 	cmnvc	r1, #0	; 0x0
				g_InControlState.TravelLength.z = -ly;
    1a38:	6f6a5f74 	svcvs	0x006a5f74
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
				break;
			case 1:
				g_InControlState.TravelLength.z = (rightV); //Right Stick Up/Down
    1a3c:	5f746e69 	svcpl	0x00746e69
    1a40:	78656c66 	stmdavc	r5!, {r1, r2, r5, r6, sl, fp, sp, lr}^
    1a44:	0008cf00 	andeq	ip, r8, r0, lsl #30
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
    1a48:	65747300 	ldrbvs	r7, [r4, #-768]!
    1a4c:	74735f70 	ldrbtvc	r5, [r3], #-3952
    1a50:	5f747261 	svcpl	0x00747261
    1a54:	656d6974 	strbvs	r6, [sp, #-2420]!
    1a58:	0008e100 	andeq	lr, r8, r0, lsl #2
    1a5c:	65747300 	ldrbvs	r7, [r4, #-768]!
				break;

			}

			if (!DoubleTravelOn) {  //(Double travel length)
    1a60:	69665f70 	stmdbvs	r6!, {r4, r5, r6, r8, r9, sl, fp, ip, lr}^
				g_InControlState.TravelLength.x =
    1a64:	6873696e 	ldmdavs	r3!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    1a68:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!
    1a6c:	08f30065 	ldmeq	r3!, {r0, r2, r5, r6}^
						g_InControlState.TravelLength.x / 2;
				g_InControlState.TravelLength.z =
    1a70:	6c620000 	stclvs	0, cr0, [r2]
    1a74:	5f6b636f 	svcpl	0x006b636f
    1a78:	656d6974 	strbvs	r6, [sp, #-2420]!
			}

		}

		//[Translate functions]
		g_BodyYShift = 0;
    1a7c:	00090500 	andeq	r0, r9, r0, lsl #10
    1a80:	72756300 	rsbsvc	r6, r5, #0	; 0x0
		if (ControlMode == TRANSLATEMODE) {
    1a84:	746e6572 	strbtvc	r6, [lr], #-1394
    1a88:	746f6d5f 	strbtvc	r6, [pc], #3423	; 1a90 <__Stack_Size+0x1690>

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
    1a8c:	5f6e6f69 	svcpl	0x006e6f69
    1a90:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    1a94:	69745f74 	ldmdbvs	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1a98:	8100656d 	tsthi	r0, sp, ror #10
    1a9c:	6d000009 	stcvs	0, cr0, [r0, #-36]
    1aa0:	6f69746f 	svcvs	0x0069746f
    1aa4:	6f705f6e 	svcvs	0x00705f6e
    1aa8:	65746e69 	ldrbvs	r6, [r4, #-3689]!
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1aac:	09930072 	ldmibeq	r3, {r1, r4, r5, r6}
    1ab0:	75430000 	strbvc	r0, [r3]
    1ab4:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
    1ab8:	746f4d74 	strbtvc	r4, [pc], #3444	; 1ac0 <__Stack_Size+0x16c0>
    1abc:	006e6f69 	rsbeq	r6, lr, r9, ror #30
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac0:	00000000 	andeq	r0, r0, r0
		//[Translate functions]
		g_BodyYShift = 0;
		if (ControlMode == TRANSLATEMODE) {

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1ac4:	00000262 	andeq	r0, r0, r2, ror #4
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac8:	4f0b0002 	svcmi	0x000b0002
    1acc:	03c50000 	biceq	r0, r5, #0	; 0x0
    1ad0:	00e50000 	rsceq	r0, r5, r0
    1ad4:	58410000 	stmdapl	r1, {}^


			//      g_InControlState.BodyPos.x = (lx)/2;
			//      g_InControlState.BodyPos.z = -(ly)/3;
			//      g_InControlState.BodyRot1.y = (rightH)*2;
			g_BodyYShift = (-(rightV) / 2);
    1ad8:	65533231 	ldrbvs	r3, [r3, #-561]
    1adc:	736f7672 	cmnvc	pc, #119537664	; 0x7200000
    1ae0:	00010c00 	andeq	r0, r1, r0, lsl #24
    1ae4:	31584100 	cmpcc	r8, r0, lsl #2
    1ae8:	44495f32 	strbmi	r5, [r9], #-3890
    1aec:	01230053 	qsubeq	r0, r3, r3
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
    1af0:	75620000 	strbvc	r0, [r2]!
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1af4:	72657a7a 	rsbvc	r7, r5, #499712	; 0x7a000
    1af8:	696e6946 	stmdbvs	lr!, {r1, r2, r6, r8, fp, sp, lr}^
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1afc:	64656873 	strbtvs	r6, [r5], #-2163
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1b00:	00013500 	andeq	r3, r1, r0, lsl #10
			g_BodyYShift = (-(rightV) / 2);
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
    1b04:	7a756200 	bvc	1d5a30c <__Stack_Size+0x1d59f0c>
			g_InControlState.BodyRot1.y = (rightH) * 2;
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1b08:	5372657a 	cmnpl	r2, #511705088	; 0x1e800000
    1b0c:	65757165 	ldrbvs	r7, [r5, #-357]!
    1b10:	0065636e 	rsbeq	r6, r5, lr, ror #6
    1b14:	00000169 	andeq	r0, r0, r9, ror #2
    1b18:	5f636461 	svcpl	0x00636461
		}

		//[Single leg functions]
#ifdef OPT_SINGLELEG
		if (ControlMode == SINGLELEGMODE) {
    1b1c:	736e6573 	cmnvc	lr, #482344960	; 0x1cc00000

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
    1b20:	655f726f 	ldrbvs	r7, [pc, #-623]	; 18b9 <__Stack_Size+0x14b9>
    1b24:	6c62616e 	stfvse	f6, [r2], #-440
    1b28:	01900065 	orrseq	r0, r0, r5, rrx
    1b2c:	64610000 	strbtvs	r0, [r1]
    1b30:	65735f63 	ldrbvs	r5, [r3, #-3939]!
				Buzzed(50,2000);
    1b34:	726f736e 	rsbvc	r7, pc, #-1207959551	; 0xb8000001
    1b38:	6c61765f 	stclvs	6, cr7, [r1], #-380
    1b3c:	0001a700 	andeq	sl, r1, r0, lsl #14
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b40:	63646100 	cmnvs	r4, #0	; 0x0
    1b44:	7461625f 	strbtvc	r6, [r1], #-607
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
				} else {
					g_InControlState.SelectedLeg = 0;
    1b48:	79726574 	ldmdbvc	r2!, {r2, r4, r5, r6, r8, sl, sp, lr}^
		if (ControlMode == SINGLELEGMODE) {

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
				Buzzed(50,2000);
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b4c:	6c61765f 	stclvs	6, cr7, [r1], #-380
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
    1b50:	0001be00 	andeq	fp, r1, r0, lsl #28
			   g_InControlState.SLLeg.x= (signed char)((int)((int)lx+128)/2); //Left Stick Right/Left
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
    1b54:	63646100 	cmnvs	r4, #0	; 0x0
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b58:	7279675f 	rsbsvc	r6, r9, #24903680	; 0x17c0000
    1b5c:	635f786f 	cmpvs	pc, #7274496	; 0x6f0000
    1b60:	65746e65 	ldrbvs	r6, [r4, #-3685]!
    1b64:	01d00072 	bicseq	r0, r0, r2, ror r0
    1b68:	64610000 	strbtvs	r0, [r1]
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b6c:	79675f63 	stmdbvc	r7!, {r0, r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    1b70:	5f796f72 	svcpl	0x00796f72
    1b74:	746e6563 	strbtvc	r6, [lr], #-1379
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b78:	e2007265 	and	r7, r0, #1342177286	; 0x50000006
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b7c:	61000001 	tstvs	r0, r1
    1b80:	615f6364 	cmpvs	pc, r4, ror #6
    1b84:	6c656363 	stclvs	3, cr6, [r5], #-396
				Buzzed(50,2000);
    1b88:	01f90078 	mvnseq	r0, r8, ror r0
    1b8c:	64610000 	strbtvs	r0, [r1]
				g_InControlState.fSLHold = !g_InControlState.fSLHold;
    1b90:	63615f63 	cmnvs	r1, #396	; 0x18c
    1b94:	796c6563 	stmdbvc	ip!, {r0, r1, r5, r6, r8, sl, sp, lr}^
    1b98:	00020b00 	andeq	r0, r2, r0, lsl #22
    1b9c:	63646100 	cmnvs	r4, #0	; 0x0
			}
		}
#endif

		//Calculate walking time delay
		g_InControlState.InputTimeDelay = 128- max(max(abs(lx), abs(ly)), abs(rightH));
    1ba0:	6363615f 	cmnvs	r3, #-1073741801	; 0xc0000017
    1ba4:	5f786c65 	svcpl	0x00786c65
    1ba8:	746e6563 	strbtvc	r6, [lr], #-1379
    1bac:	1d007265 	sfmne	f7, 4, [r0, #-404]
    1bb0:	61000002 	tstvs	r0, r2
    1bb4:	615f6364 	cmpvs	pc, r4, ror #6
    1bb8:	6c656363 	stclvs	3, cr6, [r5], #-396
    1bbc:	65635f79 	strbvs	r5, [r3, #-3961]!
    1bc0:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    1bc4:	00022f00 	andeq	r2, r2, r0, lsl #30
    1bc8:	63646100 	cmnvs	r4, #0	; 0x0
    1bcc:	746c755f 	strbtvc	r7, [ip], #-1375
    1bd0:	6f736172 	svcvs	0x00736172

		//Calculate g_InControlState.BodyPos.y
		g_InControlState.BodyPos.y = max(g_BodyYOffset + g_BodyYShift, 0);
    1bd4:	5f63696e 	svcpl	0x0063696e
    1bd8:	74736964 	ldrbtvc	r6, [r3], #-2404
    1bdc:	65636e61 	strbvs	r6, [r3, #-3681]!
    1be0:	00024100 	andeq	r4, r2, r0, lsl #2
    1be4:	63646100 	cmnvs	r4, #0	; 0x0
    1be8:	736d645f 	cmnvc	sp, #1593835520	; 0x5f000000

		if (sLegInitXZAdjust || sLegInitAngleAdjust) {
    1bec:	7369645f 	cmnvc	r9, #1593835520	; 0x5f000000
    1bf0:	636e6174 	cmnvs	lr, #29	; 0x1d
			// User asked for manual leg adjustment - only do when we have finished any previous adjustment

			if (!g_InControlState.ForceGaitStepCnt) {
    1bf4:	02530065 	subseq	r0, r3, #101	; 0x65
				if (sLegInitXZAdjust)
    1bf8:	69620000 	stmdbvs	r2!, {}^
					g_fDynamicLegXZLength = true;
    1bfc:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
    1c00:	6f635f64 	svcvs	0x00635f64

				sLegInitXZAdjust += GetLegsXZLength(); // Add on current length to our adjustment...
    1c04:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
    1c08:	026a0064 	rsbeq	r0, sl, #100	; 0x64
				// Handle maybe change angles...
				if (sLegInitAngleAdjust)
					RotateLegInitAngles(sLegInitAngleAdjust);

				// Give system time to process previous calls
				AdjustLegPositions(sLegInitXZAdjust);
    1c0c:	616c0000 	cmnvs	ip, r0
			}
		}

		if (fAdjustLegPositions && !g_fDynamicLegXZLength)
    1c10:	625f7473 	subsvs	r7, pc, #1929379840	; 0x73000000
    1c14:	6f6c6f69 	svcvs	0x006c6f69
    1c18:	635f6469 	cmpvs	pc, #1761607680	; 0x69000000
			AdjustLegPositionsToBodyHeight(); // Put main workings into main program file
    1c1c:	616d6d6f 	cmnvs	sp, pc, ror #26
		// Save away the buttons state as to not process the same press twice.
		buttonsPrev = buttons;
    1c20:	7c00646e 	cfstrsvc	mvf6, [r0], {110}
    1c24:	6e000002 	cdpvs	0, 0, cr0, cr0, cr2, {0}
		extPrev = ext;
    1c28:	635f7765 	cmpvs	pc, #26476544	; 0x1940000
    1c2c:	616d6d6f 	cmnvs	sp, pc, ror #26
		g_ulLastMsgTime = getMillis();
    1c30:	9300646e 	movwls	r6, #1134	; 0x46e
    1c34:	66000002 	strvs	r0, [r0], -r2
	} else {
		// We did not receive a valid packet.  check for a timeout to see if we should turn robot off...
		if (g_InControlState.fRobotOn) {
    1c38:	5f67616c 	svcpl	0x0067616c
			if ((getMillis() - g_ulLastMsgTime) > ARBOTIX_TO)
    1c3c:	65636572 	strbvs	r6, [r3, #-1394]!
    1c40:	5f657669 	svcpl	0x00657669
    1c44:	64616572 	strbtvs	r6, [r1], #-1394
    1c48:	02a50079 	adceq	r0, r5, #121	; 0x79
    1c4c:	616d0000 	cmnvs	sp, r0
				CommanderTurnRobotOff();
    1c50:	5f726f6a 	svcpl	0x00726f6a
		}
	}

}
    1c54:	72616c61 	rsbvc	r6, r1, #24832	; 0x6100
    1c58:	02c7006d 	sbceq	r0, r7, #109	; 0x6d
    1c5c:	75630000 	strbvc	r0, [r3]!
    1c60:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
    1c64:	6f705f74 	svcvs	0x00705f74
    1c68:	f4006573 	vst3.16	{d6,d8,d10}, [r0, :256], r3
    1c6c:	6d000002 	stcvs	0, cr0, [r0, #-8]
    1c70:	6f69746f 	svcvs	0x0069746f
    1c74:	74735f6e 	ldrbtvc	r5, [r3], #-3950
    1c78:	735f7065 	cmpvc	pc, #101	; 0x65
    1c7c:	6f767265 	svcvs	0x00767265
    1c80:	6f6d5f73 	svcvs	0x006d5f73
    1c84:	676e6976 	undefined
    1c88:	00030b00 	andeq	r0, r3, r0, lsl #22
    1c8c:	746f6d00 	strbtvc	r6, [pc], #3328	; 1c94 <__Stack_Size+0x1894>
    1c90:	5f6e6f69 	svcpl	0x006e6f69
    1c94:	76726573 	undefined
    1c98:	6d5f736f 	ldclvs	3, cr7, [pc, #-444]
    1c9c:	6e69766f 	cdpvs	6, 6, cr7, cr9, cr15, {3}
    1ca0:	03220067 	teqeq	r2, #103	; 0x67
    1ca4:	75630000 	strbvc	r0, [r3]!
    1ca8:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
    1cac:	6f6d5f74 	svcvs	0x006d5f74

extern void setupPhoenix(void);
extern void readSensors(void);


int Big_main(void) {
    1cb0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
    1cb4:	6761705f 	undefined
	setupPhoenix();
    1cb8:	03340065 	teqeq	r4, #101	; 0x65
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1cbc:	656e0000 	strbvs	r0, [lr]!

	while (1){
		while (1) {
			//Start time
			unsigned long lTimeWaitEnd;
			lTimerStart = getMillis();
    1cc0:	6d5f7478 	cfldrdvs	mvd7, [pc, #-480]
    1cc4:	6f69746f 	svcvs	0x0069746f
    1cc8:	61705f6e 	cmnvs	r0, lr, ror #30
#ifdef MILLIS
			PrintString("Barebones lTimerStart ");
			Printu32d(lTimerStart);
			PrintString("\n");
#endif
			DoBackgroundProcess();
    1ccc:	46006567 	strmi	r6, [r0], -r7, ror #10
			//Read input
			CheckVoltage();        // check our voltages...
    1cd0:	63000003 	movwvs	r0, #3	; 0x3
			if (!g_fLowVoltageShutdown) {
    1cd4:	65727275 	ldrbvs	r7, [r2, #-629]!
    1cd8:	735f746e 	cmpvc	pc, #1845493760	; 0x6e000000
				CommanderInputController_ControlInput();
    1cdc:	00706574 	rsbseq	r6, r0, r4, ror r5
			}
			WriteOutputs();        // Write Outputs
			//Single leg control
			SingleLegControl();
    1ce0:	00000368 	andeq	r0, r0, r8, ror #6
			DoBackgroundProcess();
    1ce4:	5f646970 	svcpl	0x00646970

			//Gait
			GaitSeq();
    1ce8:	75706e69 	ldrbvc	r6, [r0, #-3689]!

			DoBackgroundProcess();
    1cec:	037f0074 	cmneq	pc, #116	; 0x74

			//Balance calculations
			TotalTransX = 0;     //reset values used for calculation of balance
    1cf0:	69700000 	ldmdbvs	r0!, {}^
    1cf4:	756f5f64 	strbvc	r5, [pc, #-3940]!	; d98 <__Stack_Size+0x998>
			TotalTransZ = 0;
    1cf8:	74757074 	ldrbtvc	r7, [r5], #-116
			TotalTransY = 0;
    1cfc:	00039600 	andeq	r9, r3, r0, lsl #12
    1d00:	64697000 	strbtvs	r7, [r9]
			TotalXBal1 = 0;
    1d04:	7465735f 	strbtvc	r7, [r5], #-863
			TotalYBal1 = 0;
    1d08:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    1d0c:	03ad0074 	undefined instruction 0x03ad0074
			TotalZBal1 = 0;
    1d10:	69700000 	ldmdbvs	r0!, {}^

			if (g_InControlState.BalanceMode) {
    1d14:	6e755f64 	cdpvs	15, 7, cr5, cr5, cr4, {3}
    1d18:	6c616373 	stclvs	3, cr6, [r1], #-460
    1d1c:	6f5f6465 	svcvs	0x005f6465

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d20:	75707475 	ldrbvc	r7, [r0, #-1141]!

					DoBackgroundProcess();
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d24:	00000074 	andeq	r0, r0, r4, ror r0
    1d28:	02380000 	eorseq	r0, r8, #0	; 0x0
    1d2c:	00020000 	andeq	r0, r2, r0

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs

					DoBackgroundProcess();
    1d30:	000052d0 	ldrdeq	r5, [r0], -r0
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d34:	000007c5 	andeq	r0, r0, r5, asr #15
    1d38:	00000138 	andeq	r0, r0, r8, lsr r1
    1d3c:	636c6163 	cmnvs	ip, #-1073741800	; 0xc0000018
    1d40:	74616c75 	strbtvc	r6, [r1], #-3189
    1d44:	70735f65 	rsbsvc	r5, r3, r5, ror #30
    1d48:	00646565 	rsbeq	r6, r4, r5, ror #10
    1d4c:	00000197 	muleq	r0, r7, r1
    1d50:	6c707061 	ldclvs	0, cr7, [r0], #-388
    1d54:	66664f79 	uqsub16vs	r4, r6, r9
    1d58:	73746573 	cmnvc	r4, #482344960	; 0x1cc00000
    1d5c:	6e756f42 	cdpvs	15, 7, cr6, cr5, cr2, {2}
    1d60:	dc007364 	stcle	3, cr7, [r0], {100}
    1d64:	72000001 	andvc	r0, r0, #1	; 0x1
    1d68:	74657365 	strbtvc	r7, [r5], #-869
    1d6c:	6e696f4a 	cdpvs	15, 6, cr6, cr9, cr10, {2}
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d70:	66664f74 	uqsub16vs	r4, r6, r4
    1d74:	73746573 	cmnvc	r4, #482344960	; 0x1cc00000
    1d78:	00020500 	andeq	r0, r2, r0, lsl #10
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1d7c:	74656700 	strbtvc	r6, [r5], #-1792
    1d80:	66666f5f 	uqsubaddxvs	r6, r6, pc
					DoBackgroundProcess();
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d84:	5f746573 	svcpl	0x00746573
    1d88:	756a6461 	strbvc	r6, [sl, #-1121]!
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
					DoBackgroundProcess();
    1d8c:	656d7473 	strbvs	r7, [sp, #-1139]!
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d90:	745f746e 	ldrbvc	r7, [pc], #1134	; 1d98 <__Stack_Size+0x1998>
    1d94:	00656d69 	rsbeq	r6, r5, r9, ror #26
    1d98:	00000231 	andeq	r0, r0, r1, lsr r2
    1d9c:	5f746567 	svcpl	0x00746567
    1da0:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    1da4:	5d007465 	cfstrspl	mvf7, [r0, #-404]
    1da8:	73000002 	movwvc	r0, #2	; 0x2
    1dac:	705f7465 	subsvc	r7, pc, r5, ror #8
    1db0:	5f65736f 	svcpl	0x0065736f
    1db4:	65646f6d 	strbvs	r6, [r4, #-3949]!
    1db8:	00028400 	andeq	r8, r2, r0, lsl #8
    1dbc:	74656700 	strbtvc	r6, [r5], #-1792
    1dc0:	72727543 	rsbsvc	r7, r2, #281018368	; 0x10c00000
    1dc4:	47746e65 	ldrbmi	r6, [r4, -r5, ror #28]!
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1dc8:	506c616f 	rsbpl	r6, ip, pc, ror #2
    1dcc:	0065736f 	rsbeq	r7, r5, pc, ror #6
    1dd0:	0000029b 	muleq	r0, fp, r2
							LegPosZ[LegIndex] + GaitPosZ[LegIndex],
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}
				BalanceBody();
    1dd4:	6c707061 	ldclvs	0, cr7, [r0], #-388
			}

			//Reset IKsolution indicators
			IKSolution = 0;
    1dd8:	656e5f79 	strbvs	r5, [lr, #-3961]!
    1ddc:	6f705f77 	svcvs	0x00705f77
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1de0:	615f6573 	cmpvs	pc, r3, ror r5
			}

			//Reset IKsolution indicators
			IKSolution = 0;
			IKSolutionWarning = 0;
			IKSolutionError = 0;
    1de4:	6f5f646e 	svcvs	0x005f646e
    1de8:	65736666 	ldrbvs	r6, [r3, #-1638]!

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
				DoBackgroundProcess();
    1dec:	b9007374 	stmdblt	r0, {r2, r4, r5, r6, r8, r9, ip, sp, lr}
				BodyFK(
    1df0:	73000003 	movwvc	r0, #3	; 0x3
    1df4:	6f4a7465 	svcvs	0x004a7465
    1df8:	4f746e69 	svcmi	0x00746e69
    1dfc:	65736666 	ldrbvs	r6, [r3, #-1638]!
    1e00:	65705374 	ldrbvs	r5, [r0, #-884]!
    1e04:	79426465 	stmdbvc	r2, {r0, r2, r5, r6, sl, sp, lr}^
    1e08:	03006449 	movweq	r6, #1097	; 0x449
    1e0c:	73000004 	movwvc	r0, #4	; 0x4
    1e10:	6f4a7465 	svcvs	0x004a7465
    1e14:	4f746e69 	svcmi	0x00746e69
    1e18:	65736666 	ldrbvs	r6, [r3, #-1638]!
    1e1c:	49794274 	ldmdbmi	r9!, {r2, r4, r5, r6, r9, lr}^
    1e20:	043d0064 	ldrteq	r0, [sp], #-100
    1e24:	61770000 	cmnvs	r7, r0
    1e28:	6f467469 	svcvs	0x00467469
    1e2c:	736f5072 	cmnvc	pc, #114	; 0x72
    1e30:	6e694665 	cdpvs	6, 6, cr4, cr9, cr5, {3}
    1e34:	00687369 	rsbeq	r7, r8, r9, ror #6
    1e38:	00000499 	muleq	r0, r9, r4
    1e3c:	64616572 	strbtvs	r6, [r1], #-1394
    1e40:	72727543 	rsbsvc	r7, r2, #281018368	; 0x10c00000
    1e44:	50746e65 	rsbspl	r6, r4, r5, ror #28
    1e48:	0065736f 	rsbeq	r7, r5, pc, ror #6
    1e4c:	000004bd 	strheq	r0, [r0], -sp
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);

				LegIK(
    1e50:	636c6163 	cmnvs	ip, #-1073741800	; 0xc0000018
    1e54:	74616c75 	strbtvc	r6, [r1], #-3189
    1e58:	736f5065 	cmnvc	pc, #101	; 0x65
    1e5c:	72655365 	rsbvc	r5, r5, #-1811939327	; 0x94000001
    1e60:	70536f76 	subsvc	r6, r3, r6, ror pc
    1e64:	73646565 	cmnvc	r4, #423624704	; 0x19400000
    1e68:	00052b00 	andeq	r2, r5, r0, lsl #22
    1e6c:	766f6d00 	strbtvc	r6, [pc], -r0, lsl #26
    1e70:	476f5465 	strbmi	r5, [pc, -r5, ror #8]!
    1e74:	506c616f 	rsbpl	r6, ip, pc, ror #2
    1e78:	0065736f 	rsbeq	r7, r5, pc, ror #6
    1e7c:	000005c1 	andeq	r0, r0, r1, asr #11
    1e80:	65766f6d 	ldrbvs	r6, [r6, #-3949]!
    1e84:	65446f54 	strbvs	r6, [r4, #-3924]
    1e88:	6c756166 	ldfvse	f6, [r5], #-408
    1e8c:	736f5074 	cmnvc	pc, #116	; 0x74
    1e90:	06c70065 	strbeq	r0, [r7], r5, rrx
    1e94:	6e490000 	cdpvs	0, 4, cr0, cr9, cr0, {0}
    1e98:	61697469 	cmnvs	r9, r9, ror #8
    1e9c:	6c61566c 	stclvs	6, cr5, [r1], #-432
    1ea0:	00736575 	rsbseq	r6, r3, r5, ror r5
    1ea4:	000006de 	ldrdeq	r0, [r0], -lr
    1ea8:	74696e49 	strbtvc	r6, [r9], #-3657
    1eac:	506c6169 	rsbpl	r6, ip, r9, ror #2
    1eb0:	5479616c 	ldrbtpl	r6, [r9], #-364
    1eb4:	00656d69 	rsbeq	r6, r5, r9, ror #26
    1eb8:	000006f0 	strdeq	r0, [r0], -r0
    1ebc:	6c616f67 	stclvs	15, cr6, [r1], #-412
    1ec0:	736f705f 	cmnvc	pc, #95	; 0x5f
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1ec4:	07020065 	streq	r0, [r2, -r5, rrx]
    1ec8:	6f670000 	svcvs	0x00670000
    1ecc:	705f6c61 	subsvc	r6, pc, r1, ror #24
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1ed0:	5f65736f 	svcpl	0x0065736f
    1ed4:	64616873 	strbtvs	r6, [r1], #-2163
				DoBackgroundProcess();
    1ed8:	1400776f 	strne	r7, [r0], #-1903
				BodyFK(
    1edc:	67000007 	strvs	r0, [r0, -r7]
    1ee0:	5f6c616f 	svcpl	0x006c616f
    1ee4:	65657073 	strbvs	r7, [r5, #-115]!
    1ee8:	07260064 	streq	r0, [r6, -r4, rrx]!
    1eec:	6f670000 	svcvs	0x00670000
    1ef0:	705f6c61 	subsvc	r6, pc, r1, ror #24
    1ef4:	5f65736f 	svcpl	0x0065736f
    1ef8:	756a6461 	strbvc	r6, [sl, #-1121]!
    1efc:	64657473 	strbtvs	r7, [r5], #-1139
    1f00:	00074800 	andeq	r4, r7, r0, lsl #16
    1f04:	66666f00 	strbtvs	r6, [r6], -r0, lsl #30
    1f08:	5f746573 	svcpl	0x00746573
    1f0c:	696d6974 	stmdbvs	sp!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    1f10:	0073676e 	rsbseq	r6, r3, lr, ror #14
    1f14:	0000076a 	andeq	r0, r0, sl, ror #14
    1f18:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    1f1c:	00737465 	rsbseq	r7, r3, r5, ror #8
    1f20:	0000077c 	andeq	r0, r0, ip, ror r7
    1f24:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    1f28:	5f737465 	svcpl	0x00737465
    1f2c:	64616873 	strbtvs	r6, [r1], #-2163
    1f30:	8e00776f 	cdphi	7, 0, cr7, cr0, cr15, {3}
    1f34:	6f000007 	svcvs	0x00000007
    1f38:	65736666 	ldrbvs	r6, [r3, #-1638]!
    1f3c:	735f7374 	cmpvc	pc, #-805306367	; 0xd0000001
    1f40:	64656570 	strbtvs	r6, [r5], #-1392
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);
				LegIK(
    1f44:	07a00073 	undefined
    1f48:	6f670000 	svcvs	0x00670000
    1f4c:	745f6c61 	ldrbvc	r6, [pc], #3169	; 1f54 <__Stack_Size+0x1b54>
    1f50:	00656d69 	rsbeq	r6, r5, r9, ror #26
    1f54:	000007b2 	strheq	r0, [r0], -r2
    1f58:	65736f70 	ldrbvs	r6, [r3, #-3952]!
    1f5c:	646f6d5f 	strbtvs	r6, [pc], #3423	; 1f64 <__Stack_Size+0x1b64>
    1f60:	00000065 	andeq	r0, r0, r5, rrx
    1f64:	006e0000 	rsbeq	r0, lr, r0
    1f68:	00020000 	andeq	r0, r2, r0
    1f6c:	00005a95 	muleq	r0, r5, sl
    1f70:	0000025c 	andeq	r0, r0, ip, asr r2
    1f74:	000000af 	andeq	r0, r0, pc, lsr #1
    1f78:	6b6c6177 	blvs	1b1a55c <__Stack_Size+0x1b1a15c>
    1f7c:	7465735f 	strbtvc	r7, [r5], #-863
    1f80:	6b6c6157 	blvs	1b1a4e4 <__Stack_Size+0x1b1a0e4>
    1f84:	74617453 	strbtvc	r7, [r1], #-1107
    1f88:	00d40065 	sbcseq	r0, r4, r5, rrx
    1f8c:	61770000 	cmnvs	r7, r0
    1f90:	675f6b6c 	ldrbvs	r6, [pc, -ip, ror #22]
    1f94:	61577465 	cmpvs	r7, r5, ror #8
    1f98:	74536b6c 	ldrbvc	r6, [r3], #-2924
    1f9c:	00657461 	rsbeq	r7, r5, r1, ror #8
    1fa0:	000000ea 	andeq	r0, r0, sl, ror #1
    1fa4:	6b6c6177 	blvs	1b1a588 <__Stack_Size+0x1b1a188>
    1fa8:	6968735f 	stmdbvs	r8!, {r0, r1, r2, r3, r4, r6, r8, r9, ip, sp, lr}^
    1fac:	00007466 	andeq	r7, r0, r6, ror #8
    1fb0:	77000001 	strvc	r0, [r0, -r1]
    1fb4:	5f6b6c61 	svcpl	0x006b6c61
    1fb8:	696f7661 	stmdbvs	pc!, {r0, r5, r6, r9, sl, ip, sp, lr}^
    1fbc:	73624f64 	cmnvc	r2, #400	; 0x190
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1fc0:	6c636174 	stfvse	f6, [r3], #-464
    1fc4:	012b0065 	teqeq	fp, r5, rrx
    1fc8:	61770000 	cmnvs	r7, r0
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Check mechanical limits
			CheckAngles();
    1fcc:	695f6b6c 	ldmdbvs	pc, {r2, r3, r5, r6, r8, r9, fp, sp, lr}^

			//Drive Servos
			if (g_InControlState.fRobotOn) {
    1fd0:	0074696e 	rsbseq	r6, r4, lr, ror #18
    1fd4:	00000000 	andeq	r0, r0, r0
    1fd8:	0000005d 	andeq	r0, r0, sp, asr r0
				if (g_InControlState.fRobotOn && !g_InControlState.fPrev_RobotOn) {
					// MSound(3, 60, 2000, 80, 2250, 100, 2500);
					Buzzed(30, 2000);
    1fdc:	5cf10002 	ldclpl	0, cr0, [r1], #8
    1fe0:	03f90000 	mvnseq	r0, #0	; 0x0
    1fe4:	02fb0000 	rscseq	r0, fp, #0	; 0x0
					Buzzed(80, 2250);
    1fe8:	65530000 	ldrbvs	r0, [r3]
    1fec:	6f504574 	svcvs	0x00504574
					Buzzed(100, 2500);
    1ff0:	33007472 	movwcc	r7, #1138	; 0x472
    1ff4:	52000003 	andpl	r0, r0, #3	; 0x3
    1ff8:	41646165 	cmnmi	r4, r5, ror #2

				}

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
    1ffc:	6f6c616e 	svcvs	0x006c616e
    2000:	03790067 	cmneq	r9, #103	; 0x67
    2004:	61420000 	cmpvs	r2, r0
    2008:	72657474 	rsbvc	r7, r5, #1946157056	; 0x74000000
    200c:	6f4d5f79 	svcvs	0x004d5f79
    2010:	6f74696e 	svcvs	0x0074696e
    2014:	6c415f72 	mcrrvs	15, 7, r5, r1, cr2
    2018:	006d7261 	rsbeq	r7, sp, r1, ror #4
    201c:	0000039e 	muleq	r0, lr, r3
    2020:	64616552 	strbtvs	r6, [r1], #-1362
    2024:	e6005249 	str	r5, [r0], -r9, asr #4
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2028:	45000003 	strmi	r0, [r0, #-3]
    202c:	45797361 	ldrbmi	r7, [r9, #-865]!
    2030:	74726f50 	ldrbtvc	r6, [r2], #-3920
    2034:	00000000 	andeq	r0, r0, r0
    2038:	00002c00 	andeq	r2, r0, r0, lsl #24
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
    203c:	ea000200 	b	2844 <__Stack_Size+0x2444>

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2040:	c5000060 	strgt	r0, [r0, #-96]
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
						ServoMoveTime = ServoMoveTime + BALANCE_DELAY;
    2044:	75000001 	strvc	r0, [r0, #-1]
    2048:	52000001 	andpl	r0, r0, #1	; 0x1
				} else
					//Movement speed excl. Walking
					ServoMoveTime = 200 + g_InControlState.SpeedControl;
    204c:	42646165 	rsbmi	r6, r4, #1073741849	; 0x40000019
    2050:	6f747475 	svcvs	0x00747475
    2054:	01b2006e 	undefined instruction 0x01b2006e

				// note we broke up the servo driver into start/commit that way we can output all of the servo information
				// before we wait and only have the termination information to output after the wait.  That way we hopefully
				// be more accurate with our timings...
				DoBackgroundProcess();
    2058:	61450000 	cmpvs	r5, r0
				StartUpdateServos();
    205c:	75427973 	strbvc	r7, [r2, #-2419]

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    2060:	6e6f7474 	mcrvs	4, 3, r7, cr15, cr4, {3}
					if ((GaitPosX[LegIndex] > cGPlimit)
    2064:	00000000 	andeq	r0, r0, r0
    2068:	00002500 	andeq	r2, r0, r0, lsl #10
    206c:	af000200 	svcge	0x00000200
    2070:	c2000062 	andgt	r0, r0, #98	; 0x62
    2074:	67000001 	strvs	r0, [r0, -r1]
    2078:	53000001 	movwpl	r0, #1	; 0x1
    207c:	454c7465 	strbmi	r7, [ip, #-1125]
    2080:	01af0044 	undefined instruction 0x01af0044
    2084:	61450000 	cmpvs	r5, r0
    2088:	454c7973 	strbmi	r7, [ip, #-2419]
    208c:	00000044 	andeq	r0, r0, r4, asr #32
    2090:	00260000 	eoreq	r0, r6, r0
    2094:	00020000 	andeq	r0, r2, r0
    2098:	00006471 	andeq	r6, r0, r1, ror r4
    209c:	00000211 	andeq	r0, r0, r1, lsl r2
							|| (GaitPosZ[LegIndex] > cGPlimit)
							|| (GaitPosZ[LegIndex] < -cGPlimit)
							|| (GaitRotY[LegIndex] > cGPlimit)
							|| (GaitRotY[LegIndex] < -cGPlimit)) {

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
    20a0:	0000017f 	andeq	r0, r0, pc, ror r1
    20a4:	7a7a7542 	bvc	1e9f5b4 <__Stack_Size+0x1e9f1b4>
    20a8:	b7006465 	strlt	r6, [r0, -r5, ror #8]

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    20ac:	50000001 	andpl	r0, r0, r1
    20b0:	4e79616c 	rpwmiez	f6, f1, #4.0

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
						break;
					}
				}
				if (bExtraCycle > 0) {
    20b4:	0065746f 	rsbeq	r7, r5, pc, ror #8
					bExtraCycle--;
    20b8:	00000000 	andeq	r0, r0, r0
    20bc:	0000016a 	andeq	r0, r0, sl, ror #2
					fWalking = !(bExtraCycle == 0);
    20c0:	66820002 	strvs	r0, [r2], r2
    20c4:	02b40000 	adcseq	r0, r4, #0	; 0x0

					//Get endtime and calculate wait time
					lTimeWaitEnd = lTimerStart + PrevServoMoveTime;
    20c8:	009e0000 	addseq	r0, lr, r0
    20cc:	44750000 	ldrbtmi	r0, [r5]
    20d0:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
					PrintString("\n");
#endif
					//DebugWrite(A1, HIGH);
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    20d4:	0000c300 	andeq	ip, r0, r0, lsl #6
					} while (getMillis() < lTimeWaitEnd);
    20d8:	65446d00 	strbvs	r6, [r4, #-3328]
    20dc:	0079616c 	rsbseq	r6, r9, ip, ror #2
					PrintString("\n");
#endif

				}
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
    20e0:	000000ec 	andeq	r0, r0, ip, ror #1
    20e4:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    20e8:	6f635f74 	svcvs	0x00635f74
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
    20ec:	64746e75 	ldrbtvs	r6, [r4], #-3701
					PrintString("Barebones lTimeWaitEnd-Millis  ");
					Printu32d(getMillis);
					PrintString("\n");
#endif
				} else {
					FreeServos();
    20f0:	5f6e776f 	svcpl	0x006e776f
    20f4:	7a7a7562 	bvc	1e9f684 <__Stack_Size+0x1e9f284>
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
					ServoMoveTime = 600;
    20f8:	11007265 	tstne	r0, r5, ror #4
    20fc:	73000001 	movwvc	r0, #1	; 0x1
					StartUpdateServos();
    2100:	74726174 	ldrbtvc	r6, [r2], #-372
					CommitServoDriver(ServoMoveTime);
    2104:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!
					//MSound(3, 100, 2500, 80, 2250, 60, 2000);
					Buzzed(100, 2500);
    2108:	74756f65 	ldrbtvc	r6, [r5], #-3941
    210c:	6c78645f 	cfldrdvs	mvd6, [r8], #-380
    2110:	00013600 	andeq	r3, r1, r0, lsl #12
					Buzzed(80, 2250);
    2114:	61747300 	cmnvs	r4, r0, lsl #6
    2118:	745f7472 	ldrbvc	r7, [pc], #1138	; 2120 <__Stack_Size+0x1d20>
					Buzzed(60, 2000);
    211c:	6f656d69 	svcvs	0x00656d69
    2120:	705f7475 	subsvc	r7, pc, r5, ror r4
    2124:	5b007563 	blpl	1f6b8 <__Stack_Size+0x1f2b8>

					//lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
					lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
    2128:	67000001 	strvs	r0, [r0, -r1]
    212c:	694d7465 	stmdbvs	sp, {r0, r2, r5, r6, sl, ip, sp, lr}^
					Printu32d(lTimeWaitEnd);
					PrintString("\n");
#endif
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    2130:	73696c6c 	cmnvc	r9, #27648	; 0x6c00
					} while (getMillis() < lTimeWaitEnd);
    2134:	00017200 	andeq	r7, r1, r0, lsl #4
    2138:	495f5f00 	ldmdbmi	pc, {r8, r9, sl, fp, ip, lr}^
				} else {
					FreeServos();
				}

				// Allow the Servo driver to do stuff durint our idle time
				IdleTime();
    213c:	535f5253 	cmppl	pc, #805306373	; 0x30000005
				mDelay(20); // give a pause between times we call if nothing is happening
    2140:	49545359 	ldmdbmi	r4, {r0, r3, r4, r6, r8, r9, ip, lr}^
			}
			PrevServoMoveTime = ServoMoveTime;
    2144:	85004b43 	strhi	r4, [r0, #-2883]
    2148:	49000001 	stmdbmi	r0, {r0}

			//Store previous g_InControlState.fRobotOn State
			if (g_InControlState.fRobotOn)
    214c:	445f5253 	ldrbmi	r5, [pc], #595	; 2154 <__Stack_Size+0x1d54>
    2150:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
				g_InControlState.fPrev_RobotOn = 1;
			else
				g_InControlState.fPrev_RobotOn = 0;
    2154:	7361425f 	cmnvc	r1, #-268435451	; 0xf0000005
    2158:	019a0065 	orrseq	r0, sl, r5, rrx
    215c:	74530000 	ldrbvc	r0, [r3]
    2160:	43747261 	cmnmi	r4, #268435462	; 0x10000006
    2164:	746e756f 	strbtvc	r7, [lr], #-1391
    2168:	6e776f64 	cdpvs	15, 7, cr6, cr7, cr4, {3}
    216c:	0001c300 	andeq	ip, r1, r0, lsl #6
    2170:	63696d00 	cmnvs	r9, #0	; 0x0
    2174:	00736f72 	rsbseq	r6, r3, r2, ror pc
    2178:	00000207 	andeq	r0, r0, r7, lsl #4
    217c:	65446c67 	strbvs	r6, [r4, #-3175]
    2180:	4379616c 	cmnmi	r9, #27	; 0x1b
    2184:	746e756f 	strbtvc	r7, [lr], #-1391
    2188:	1e007265 	cdpne	2, 0, cr7, cr0, cr5, {3}
    218c:	67000002 	strvs	r0, [r0, -r2]
    2190:	756f436c 	strbvc	r4, [pc, #-876]!	; 1e2c <__Stack_Size+0x1a2c>
    2194:	6f64746e 	svcvs	0x0064746e
    2198:	6f436e77 	svcvs	0x00436e77
    219c:	65746e75 	ldrbvs	r6, [r4, #-3701]!
    21a0:	02300072 	eorseq	r0, r0, #114	; 0x72
    21a4:	6c670000 	stclvs	0, cr0, [r7]
    21a8:	546c7844 	strbtpl	r7, [ip], #-2116
    21ac:	6f656d69 	svcvs	0x00656d69
    21b0:	6f437475 	svcvs	0x00437475
    21b4:	65746e75 	ldrbvs	r6, [r4, #-3701]!
    21b8:	02420072 	subeq	r0, r2, #114	; 0x72
    21bc:	6c670000 	stclvs	0, cr0, [r7]
    21c0:	54756350 	ldrbtpl	r6, [r5], #-848
    21c4:	6f656d69 	svcvs	0x00656d69
    21c8:	6f437475 	svcvs	0x00437475
    21cc:	65746e75 	ldrbvs	r6, [r4, #-3701]!
    21d0:	02540072 	subseq	r0, r4, #114	; 0x72
    21d4:	6c670000 	stclvs	0, cr0, [r7]
    21d8:	7a7a7542 	bvc	1e9f6e8 <__Stack_Size+0x1e9f2e8>
    21dc:	6f437265 	svcvs	0x00437265
    21e0:	65746e75 	ldrbvs	r6, [r4, #-3701]!
    21e4:	02660072 	rsbeq	r0, r6, #114	; 0x72
    21e8:	62670000 	rsbvs	r0, r7, #0	; 0x0
    21ec:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    21f0:	43726574 	cmnmi	r2, #486539264	; 0x1d000000
    21f4:	746e756f 	strbtvc	r7, [lr], #-1391
    21f8:	00027d00 	andeq	r7, r2, r0, lsl #26
    21fc:	6c694d00 	stclvs	13, cr4, [r9]
    2200:	0073696c 	rsbseq	r6, r3, ip, ror #18
    2204:	0000028f 	andeq	r0, r0, pc, lsl #5
    2208:	694d736d 	stmdbvs	sp, {r0, r2, r3, r5, r6, r8, r9, ip, sp, lr}^
    220c:	73696c6c 	cmnvc	r9, #27648	; 0x6c00
    2210:	0002a100 	andeq	sl, r2, r0, lsl #2
    2214:	53736d00 	cmnpl	r3, #0	; 0x0
    2218:	69747379 	ldmdbvs	r4!, {r0, r3, r4, r5, r6, r8, r9, ip, sp, lr}^
    221c:	6f436b63 	svcvs	0x00436b63
    2220:	65746e75 	ldrbvs	r6, [r4, #-3701]!
    2224:	00000072 	andeq	r0, r0, r2, ror r0
    2228:	00a60000 	adceq	r0, r6, r0
    222c:	00020000 	andeq	r0, r2, r0
    2230:	00006936 	andeq	r6, r0, r6, lsr r9
    2234:	000005ab 	andeq	r0, r0, fp, lsr #11
    2238:	000003d7 	ldrdeq	r0, [r0], -r7
    223c:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    2240:	6f435f54 	svcvs	0x00435f54
    2244:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2248:	74617275 	strbtvc	r7, [r1], #-629
    224c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2250:	000003fd 	strdeq	r0, [r0], -sp
    2254:	54737953 	ldrbtpl	r7, [r3], #-2387
    2258:	5f6b6369 	svcpl	0x006b6369
    225c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2260:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
    2264:	6f697461 	svcvs	0x00697461
    2268:	0413006e 	ldreq	r0, [r3], #-110
    226c:	44410000 	strbmi	r0, [r1]
    2270:	6f435f43 	svcvs	0x00435f43
    2274:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2278:	74617275 	strbtvc	r7, [r1], #-629
    227c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2280:	0000043b 	andeq	r0, r0, fp, lsr r4
    2284:	4f495047 	svcmi	0x00495047
    2288:	6e6f435f 	mcrvs	3, 3, r4, cr15, cr15, {2}
    228c:	75676966 	strbvc	r6, [r7, #-2406]!
    2290:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
    2294:	63006e6f 	movwvs	r6, #3695	; 0xe6f
    2298:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
    229c:	5f434956 	svcpl	0x00434956
    22a0:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    22a4:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
    22a8:	6f697461 	svcvs	0x00697461
    22ac:	048b006e 	streq	r0, [fp], #110
    22b0:	43520000 	cmpmi	r2, #0	; 0x0
    22b4:	6f435f43 	svcvs	0x00435f43
    22b8:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    22bc:	74617275 	strbtvc	r7, [r1], #-629
    22c0:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    22c4:	000004b0 	strheq	r0, [r0], -r0
    22c8:	49737953 	ldmdbmi	r3!, {r0, r1, r4, r6, r8, fp, ip, sp, lr}^
    22cc:	0074696e 	rsbseq	r6, r4, lr, ror #18
    22d0:	00000000 	andeq	r0, r0, r0
    22d4:	00000201 	andeq	r0, r0, r1, lsl #4
    22d8:	6ee10002 	cdpvs	0, 14, cr0, cr1, cr2, {0}
    22dc:	07ed0000 	strbeq	r0, [sp, r0]!
    22e0:	029c0000 	addseq	r0, ip, #0	; 0x0
    22e4:	63700000 	cmnvs	r0, #0	; 0x0
    22e8:	61685f75 	smcvs	34293
    22ec:	69745f6c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    22f0:	756f656d 	strbvc	r6, [pc, #-1389]!	; 1d8b <__Stack_Size+0x198b>
    22f4:	02b30074 	adcseq	r0, r3, #116	; 0x74
    22f8:	63700000 	cmnvs	r0, #0	; 0x0
    22fc:	65675f75 	strbvs	r5, [r7, #-3957]!
    2300:	75715f74 	ldrbvc	r5, [r1, #-3956]!
    2304:	00657565 	rsbeq	r7, r5, r5, ror #10
    2308:	000002de 	ldrdeq	r0, [r0], -lr
    230c:	5f756370 	svcpl	0x00756370
    2310:	6b656570 	blvs	195b8d8 <__Stack_Size+0x195b4d8>
    2314:	6575715f 	ldrbvs	r7, [r5, #-351]!
    2318:	09006575 	stmdbeq	r0, {r0, r2, r4, r5, r6, r8, sl, sp, lr}
    231c:	70000003 	andvc	r0, r0, r3
    2320:	635f7563 	cmpvs	pc, #415236096	; 0x18c00000
    2324:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    2328:	6575715f 	ldrbvs	r7, [r5, #-351]!
    232c:	18006575 	stmdane	r0, {r0, r2, r4, r5, r6, r8, sl, sp, lr}
    2330:	70000003 	andvc	r0, r0, r3
    2334:	675f7563 	ldrbvs	r7, [pc, -r3, ror #10]
    2338:	715f7465 	cmpvc	pc, r5, ror #8
    233c:	74617473 	strbtvc	r7, [r1], #-1139
    2340:	03430065 	movteq	r0, #12389	; 0x3065
    2344:	677a0000 	ldrbvs	r0, [sl, -r0]!
    2348:	61685f62 	cmnvs	r8, r2, ror #30
    234c:	78725f6c 	ldmdavc	r2!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2350:	00039600 	andeq	r9, r3, r0, lsl #12
    2354:	6c786400 	cfldrdvs	mvd6, [r8]
    2358:	6c61685f 	stclvs	8, cr6, [r1], #-380
    235c:	656c635f 	strbvs	r6, [ip, #-863]!
    2360:	b9007261 	stmdblt	r0, {r0, r5, r6, r9, ip, sp, lr}
    2364:	64000003 	strvs	r0, [r0], #-3
    2368:	685f6c78 	ldmdavs	pc, {r3, r4, r5, r6, sl, fp, sp, lr}^
    236c:	725f6c61 	subsvc	r6, pc, #24832	; 0x6100
    2370:	04060078 	streq	r0, [r6], #-120
    2374:	78640000 	stmdavc	r4!, {}^
    2378:	61685f6c 	cmnvs	r8, ip, ror #30
    237c:	69745f6c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2380:	756f656d 	strbvc	r6, [pc, #-1389]!	; 1e1b <__Stack_Size+0x1a1b>
    2384:	041e0074 	ldreq	r0, [lr], #-116
    2388:	78520000 	ldmdavc	r2, {}^
    238c:	58445f44 	stmdapl	r4, {r2, r6, r8, r9, sl, fp, ip, lr}^
    2390:	6e495f4c 	cdpvs	15, 4, cr5, cr9, cr12, {2}
    2394:	72726574 	rsbsvc	r6, r2, #486539264	; 0x1d000000
    2398:	00747075 	rsbseq	r7, r4, r5, ror r0
    239c:	00000447 	andeq	r0, r0, r7, asr #8
    23a0:	5f6c7864 	svcpl	0x006c7864
    23a4:	5f6c6168 	svcpl	0x006c6168
    23a8:	5f746573 	svcpl	0x00746573
    23ac:	656d6974 	strbvs	r6, [sp, #-2420]!
    23b0:	0074756f 	rsbseq	r7, r4, pc, ror #10
    23b4:	00000472 	andeq	r0, r0, r2, ror r4
    23b8:	5f6c7864 	svcpl	0x006c7864
    23bc:	5f6c6168 	svcpl	0x006c6168
    23c0:	bb007874 	bllt	20598 <__Stack_Size+0x20198>
    23c4:	64000004 	strvs	r0, [r0], #-4
    23c8:	685f6c78 	ldmdavs	pc, {r3, r4, r5, r6, sl, fp, sp, lr}^
    23cc:	635f6c61 	cmpvs	pc, #24832	; 0x6100
    23d0:	65736f6c 	ldrbvs	r6, [r3, #-3948]!
    23d4:	0004d100 	andeq	sp, r4, r0, lsl #2
    23d8:	62677a00 	rsbvs	r7, r7, #0	; 0x0
    23dc:	6c61685f 	stclvs	8, cr6, [r1], #-380
    23e0:	6f6c635f 	svcvs	0x006c635f
    23e4:	e7006573 	smlsdx	r0, r3, r5, r6
    23e8:	70000004 	andvc	r0, r0, r4
    23ec:	685f7563 	ldmdavs	pc, {r0, r1, r5, r6, r8, sl, ip, sp, lr}^
    23f0:	635f6c61 	cmpvs	pc, #24832	; 0x6100
    23f4:	65736f6c 	ldrbvs	r6, [r3, #-3948]!
    23f8:	0004fc00 	andeq	pc, r4, r0, lsl #24
    23fc:	6c786400 	cfldrdvs	mvd6, [r8]
    2400:	6c61685f 	stclvs	8, cr6, [r1], #-380
    2404:	65706f5f 	ldrbvs	r6, [r0, #-3935]!
    2408:	053a006e 	ldreq	r0, [sl, #-110]!
    240c:	677a0000 	ldrbvs	r0, [sl, -r0]!
    2410:	61685f62 	cmnvs	r8, r2, ror #30
    2414:	706f5f6c 	rsbvc	r5, pc, ip, ror #30
    2418:	78006e65 	stmdavc	r0, {r0, r2, r5, r6, r9, sl, fp, sp, lr}
    241c:	70000005 	andvc	r0, r0, r5
    2420:	685f7563 	ldmdavs	pc, {r0, r1, r5, r6, r8, sl, ip, sp, lr}^
    2424:	6f5f6c61 	svcvs	0x005f6c61
    2428:	006e6570 	rsbeq	r6, lr, r0, ror r5
    242c:	000005b3 	strheq	r0, [r0], -r3
    2430:	5f447852 	svcpl	0x00447852
    2434:	5f47495a 	svcpl	0x0047495a
    2438:	65746e49 	ldrbvs	r6, [r4, #-3657]!
    243c:	70757272 	rsbsvc	r7, r5, r2, ror r2
    2440:	05dc0074 	ldrbeq	r0, [ip, #116]
    2444:	677a0000 	ldrbvs	r0, [sl, -r0]!
    2448:	61685f62 	cmnvs	r8, r2, ror #30
    244c:	78745f6c 	ldmdavc	r4!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2450:	00062500 	andeq	r2, r6, r0, lsl #10
    2454:	75637000 	strbvc	r7, [r3]!
    2458:	7475705f 	ldrbtvc	r7, [r5], #-95
    245c:	6575715f 	ldrbvs	r7, [r5, #-351]!
    2460:	4c006575 	cfstr32mi	mvfx6, [r0], {117}
    2464:	52000006 	andpl	r0, r0, #6	; 0x6
    2468:	505f4478 	subspl	r4, pc, r8, ror r4
    246c:	495f5543 	ldmdbmi	pc, {r0, r1, r6, r8, sl, ip, lr}^
    2470:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    2474:	74707572 	ldrbtvc	r7, [r0], #-1394
    2478:	00066100 	andeq	r6, r6, r0, lsl #2
    247c:	75637000 	strbvc	r7, [r3]!
    2480:	7475705f 	ldrbtvc	r7, [r5], #-95
    2484:	7479625f 	ldrbtvc	r6, [r9], #-607
    2488:	068a0065 	streq	r0, [sl], r5, rrx
    248c:	63700000 	cmnvs	r0, #0	; 0x0
    2490:	61685f75 	smcvs	34293
    2494:	65735f6c 	ldrbvs	r5, [r3, #-3948]!
    2498:	69745f74 	ldmdbvs	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    249c:	756f656d 	strbvc	r6, [pc, #-1389]!	; 1f37 <__Stack_Size+0x1b37>
    24a0:	07970074 	undefined
    24a4:	61420000 	cmpvs	r2, r0
    24a8:	61726475 	cmnvs	r2, r5, ror r4
    24ac:	445f6574 	ldrbmi	r6, [pc], #1396	; 24b4 <__Stack_Size+0x20b4>
    24b0:	a9004c58 	stmdbge	r0, {r3, r4, r6, sl, fp, lr}
    24b4:	42000007 	andmi	r0, r0, #7	; 0x7
    24b8:	72647561 	rsbvc	r7, r4, #406847488	; 0x18400000
    24bc:	5f657461 	svcpl	0x00657461
    24c0:	0047495a 	subeq	r4, r7, sl, asr r9
    24c4:	000007bb 	strheq	r0, [r0], -fp
    24c8:	64756142 	ldrbtvs	r6, [r5], #-322
    24cc:	65746172 	ldrbvs	r6, [r4, #-370]!
    24d0:	5543505f 	strbpl	r5, [r3, #-95]
    24d4:	00000000 	andeq	r0, r0, r0
    24d8:	0003fd00 	andeq	pc, r3, r0, lsl #26
    24dc:	ce000200 	cdpgt	2, 0, cr0, cr0, cr0, {0}
    24e0:	1f000076 	svcne	0x00000076
    24e4:	5400000b 	strpl	r0, [r0], #-11
    24e8:	41000002 	tstmi	r0, r2
    24ec:	495f4344 	ldmdbmi	pc, {r2, r6, r8, r9, lr}^
    24f0:	0074696e 	rsbseq	r6, r4, lr, ror #18
    24f4:	000002ac 	andeq	r0, r0, ip, lsr #5
    24f8:	5f434441 	svcpl	0x00434441
    24fc:	75727453 	ldrbvc	r7, [r2, #-1107]!
    2500:	6e497463 	cdpvs	4, 4, cr7, cr9, cr3, {3}
    2504:	d1007469 	tstle	r0, r9, ror #8
    2508:	41000002 	tstmi	r0, r2
    250c:	435f4344 	cmpmi	pc, #268435457	; 0x10000001
    2510:	0600646d 	streq	r6, [r0], -sp, ror #8
    2514:	41000003 	tstmi	r0, r3
    2518:	445f4344 	ldrbmi	r4, [pc], #836	; 2520 <__Stack_Size+0x2120>
    251c:	6d43414d 	stfvse	f4, [r3, #-308]
    2520:	033b0064 	teqeq	fp, #100	; 0x64
    2524:	44410000 	strbmi	r0, [r1]
    2528:	54495f43 	strbpl	r5, [r9], #-3907
    252c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2530:	8e006769 	cdphi	7, 0, cr6, cr0, cr9, {3}
    2534:	41000003 	tstmi	r0, r3
    2538:	525f4344 	subspl	r4, pc, #268435457	; 0x10000001
    253c:	74657365 	strbtvc	r7, [r5], #-869
    2540:	696c6143 	stmdbvs	ip!, {r0, r1, r6, r8, sp, lr}^
    2544:	74617262 	strbtvc	r7, [r1], #-610
    2548:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    254c:	000003b5 	strheq	r0, [r0], -r5
    2550:	5f434441 	svcpl	0x00434441
    2554:	52746547 	rsbspl	r6, r4, #297795584	; 0x11c00000
    2558:	74657365 	strbtvc	r7, [r5], #-869
    255c:	696c6143 	stmdbvs	ip!, {r0, r1, r6, r8, sp, lr}^
    2560:	74617262 	strbtvc	r7, [r1], #-610
    2564:	536e6f69 	cmnpl	lr, #420	; 0x1a4
    2568:	75746174 	ldrbvc	r6, [r4, #-372]!
    256c:	03ee0073 	mvneq	r0, #115	; 0x73
    2570:	44410000 	strbmi	r0, [r1]
    2574:	74535f43 	ldrbvc	r5, [r3], #-3907
    2578:	43747261 	cmnmi	r4, #268435462	; 0x10000006
    257c:	62696c61 	rsbvs	r6, r9, #24832	; 0x6100
    2580:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
    2584:	15006e6f 	strne	r6, [r0, #-3695]
    2588:	41000004 	tstmi	r0, r4
    258c:	475f4344 	ldrbmi	r4, [pc, -r4, asr #6]
    2590:	61437465 	cmpvs	r3, r5, ror #8
    2594:	7262696c 	rsbvc	r6, r2, #1769472	; 0x1b0000
    2598:	6f697461 	svcvs	0x00697461
    259c:	6174536e 	cmnvs	r4, lr, ror #6
    25a0:	00737574 	rsbseq	r7, r3, r4, ror r5
    25a4:	0000044e 	andeq	r0, r0, lr, asr #8
    25a8:	5f434441 	svcpl	0x00434441
    25ac:	74666f53 	strbtvc	r6, [r6], #-3923
    25b0:	65726177 	ldrbvs	r6, [r2, #-375]!
    25b4:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
    25b8:	6e6f4374 	mcrvs	3, 3, r4, cr15, cr4, {3}
    25bc:	646d4376 	strbtvs	r4, [sp], #-886
    25c0:	00048300 	andeq	r8, r4, r0, lsl #6
    25c4:	43444100 	movtmi	r4, #16640	; 0x4100
    25c8:	7465475f 	strbtvc	r4, [r5], #-1887
    25cc:	74666f53 	strbtvc	r6, [r6], #-3923
    25d0:	65726177 	ldrbvs	r6, [r2, #-375]!
    25d4:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
    25d8:	6e6f4374 	mcrvs	3, 3, r4, cr15, cr4, {3}
    25dc:	61745376 	cmnvs	r4, r6, ror r3
    25e0:	00737574 	rsbseq	r7, r3, r4, ror r5
    25e4:	000004bc 	strheq	r0, [r0], -ip
    25e8:	5f434441 	svcpl	0x00434441
    25ec:	63736944 	cmnvs	r3, #1114112	; 0x110000
    25f0:	65646f4d 	strbvs	r6, [r4, #-3917]!
    25f4:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
    25f8:	436c656e 	cmnmi	ip, #461373440	; 0x1b800000
    25fc:	746e756f 	strbtvc	r7, [lr], #-1391
    2600:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2604:	0d006769 	stceq	7, cr6, [r0, #-420]
    2608:	41000005 	tstmi	r0, r5
    260c:	445f4344 	ldrbmi	r4, [pc], #836	; 2614 <__Stack_Size+0x2214>
    2610:	4d637369 	stclmi	3, cr7, [r3, #-420]!
    2614:	4365646f 	cmnmi	r5, #1862270976	; 0x6f000000
    2618:	4200646d 	andmi	r6, r0, #1828716544	; 0x6d000000
    261c:	41000005 	tstmi	r0, r5
    2620:	525f4344 	subspl	r4, pc, #268435457	; 0x10000001
    2624:	6c756765 	ldclvs	7, cr6, [r5], #-404
    2628:	68437261 	stmdavs	r3, {r0, r5, r6, r9, ip, sp, lr}^
    262c:	656e6e61 	strbvs	r6, [lr, #-3681]!
    2630:	6e6f436c 	cdpvs	3, 6, cr4, cr15, cr12, {3}
    2634:	00676966 	rsbeq	r6, r7, r6, ror #18
    2638:	000005b7 	strheq	r0, [r0], -r7
    263c:	5f434441 	svcpl	0x00434441
    2640:	65747845 	ldrbvs	r7, [r4, #-2117]!
    2644:	6c616e72 	stclvs	14, cr6, [r1], #-456
    2648:	67697254 	undefined
    264c:	766e6f43 	strbtvc	r6, [lr], -r3, asr #30
    2650:	00646d43 	rsbeq	r6, r4, r3, asr #26
    2654:	000005ec 	andeq	r0, r0, ip, ror #11
    2658:	5f434441 	svcpl	0x00434441
    265c:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    2660:	65766e6f 	ldrbvs	r6, [r6, #-3695]!
    2664:	6f697372 	svcvs	0x00697372
    2668:	6c61566e 	stclvs	6, cr5, [r1], #-440
    266c:	19006575 	stmdbne	r0, {r0, r2, r4, r5, r6, r8, sl, sp, lr}
    2670:	41000006 	tstmi	r0, r6
    2674:	475f4344 	ldrbmi	r4, [pc, -r4, asr #6]
    2678:	75447465 	strbvc	r7, [r4, #-1125]
    267c:	6f4d6c61 	svcvs	0x004d6c61
    2680:	6f436564 	svcvs	0x00436564
    2684:	7265766e 	rsbvc	r7, r5, #115343360	; 0x6e00000
    2688:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
    268c:	756c6156 	strbvc	r6, [ip, #-342]!
    2690:	06310065 	ldrteq	r0, [r1], -r5, rrx
    2694:	44410000 	strbmi	r0, [r1]
    2698:	75415f43 	strbvc	r5, [r1, #-3907]
    269c:	6e496f74 	mcrvs	15, 2, r6, cr9, cr4, {3}
    26a0:	7463656a 	strbtvc	r6, [r3], #-1386
    26a4:	6f436465 	svcvs	0x00436465
    26a8:	6d43766e 	stclvs	6, cr7, [r3, #-440]
    26ac:	06660064 	strbteq	r0, [r6], -r4, rrx
    26b0:	44410000 	strbmi	r0, [r1]
    26b4:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    26b8:	7463656a 	strbtvc	r6, [r3], #-1386
    26bc:	69446465 	stmdbvs	r4, {r0, r2, r5, r6, sl, sp, lr}^
    26c0:	6f4d6373 	svcvs	0x004d6373
    26c4:	6d436564 	cfstr64vs	mvdx6, [r3, #-400]
    26c8:	069b0064 	ldreq	r0, [fp], r4, rrx
    26cc:	44410000 	strbmi	r0, [r1]
    26d0:	78455f43 	stmdavc	r5, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    26d4:	6e726574 	mrcvs	5, 3, r6, cr2, cr4, {3}
    26d8:	72546c61 	subsvc	r6, r4, #24832	; 0x6100
    26dc:	6e496769 	cdpvs	7, 4, cr6, cr9, cr9, {3}
    26e0:	7463656a 	strbtvc	r6, [r3], #-1386
    26e4:	6f436465 	svcvs	0x00436465
    26e8:	6f43766e 	svcvs	0x0043766e
    26ec:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    26f0:	0006e200 	andeq	lr, r6, r0, lsl #4
    26f4:	43444100 	movtmi	r4, #16640	; 0x4100
    26f8:	7478455f 	ldrbtvc	r4, [r8], #-1375
    26fc:	616e7265 	cmnvs	lr, r5, ror #4
    2700:	6972546c 	ldmdbvs	r2!, {r2, r3, r5, r6, sl, ip, lr}^
    2704:	6a6e4967 	bvs	1b94ca8 <__Stack_Size+0x1b948a8>
    2708:	65746365 	ldrbvs	r6, [r4, #-869]!
    270c:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    2710:	646d4376 	strbtvs	r4, [sp], #-886
    2714:	00071700 	andeq	r1, r7, r0, lsl #14
    2718:	43444100 	movtmi	r4, #16640	; 0x4100
    271c:	666f535f 	undefined
    2720:	72617774 	rsbvc	r7, r1, #30408704	; 0x1d00000
    2724:	61745365 	cmnvs	r4, r5, ror #6
    2728:	6e497472 	mcrvs	4, 2, r7, cr9, cr2, {3}
    272c:	7463656a 	strbtvc	r6, [r3], #-1386
    2730:	6f436465 	svcvs	0x00436465
    2734:	6d43766e 	stclvs	6, cr7, [r3, #-440]
    2738:	074c0064 	strbeq	r0, [ip, -r4, rrx]
    273c:	44410000 	strbmi	r0, [r1]
    2740:	65475f43 	strbvs	r5, [r7, #-3907]
    2744:	666f5374 	undefined
    2748:	72617774 	rsbvc	r7, r1, #30408704	; 0x1d00000
    274c:	61745365 	cmnvs	r4, r5, ror #6
    2750:	6e497472 	mcrvs	4, 2, r7, cr9, cr2, {3}
    2754:	7463656a 	strbtvc	r6, [r3], #-1386
    2758:	6f436465 	svcvs	0x00436465
    275c:	6d43766e 	stclvs	6, cr7, [r3, #-440]
    2760:	61745364 	cmnvs	r4, r4, ror #6
    2764:	00737574 	rsbseq	r7, r3, r4, ror r5
    2768:	00000785 	andeq	r0, r0, r5, lsl #15
    276c:	5f434441 	svcpl	0x00434441
    2770:	656a6e49 	strbvs	r6, [sl, #-3657]!
    2774:	64657463 	strbtvs	r7, [r5], #-1123
    2778:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
    277c:	436c656e 	cmnmi	ip, #461373440	; 0x1b800000
    2780:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2784:	08060067 	stmdaeq	r6, {r0, r1, r2, r5, r6}
    2788:	44410000 	strbmi	r0, [r1]
    278c:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    2790:	7463656a 	strbtvc	r6, [r3], #-1386
    2794:	65536465 	ldrbvs	r6, [r3, #-1125]
    2798:	6e657571 	mcrvs	5, 3, r7, cr5, cr1, {3}
    279c:	4c726563 	cfldr64mi	mvdx6, [r2], #-396
    27a0:	74676e65 	strbtvc	r6, [r7], #-3685
    27a4:	6e6f4368 	cdpvs	3, 6, cr4, cr15, cr8, {3}
    27a8:	00676966 	rsbeq	r6, r7, r6, ror #18
    27ac:	00000857 	andeq	r0, r0, r7, asr r8
    27b0:	5f434441 	svcpl	0x00434441
    27b4:	49746553 	ldmdbmi	r4!, {r0, r1, r4, r6, r8, sl, sp, lr}^
    27b8:	63656a6e 	cmnvs	r5, #450560	; 0x6e000
    27bc:	4f646574 	svcmi	0x00646574
    27c0:	65736666 	ldrbvs	r6, [r3, #-1638]!
    27c4:	089e0074 	ldmeq	lr, {r2, r4, r5, r6}
    27c8:	44410000 	strbmi	r0, [r1]
    27cc:	65475f43 	strbvs	r5, [r7, #-3907]
    27d0:	6a6e4974 	bvs	1b94da8 <__Stack_Size+0x1b949a8>
    27d4:	65746365 	ldrbvs	r6, [r4, #-869]!
    27d8:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    27dc:	73726576 	cmnvc	r2, #494927872	; 0x1d800000
    27e0:	566e6f69 	strbtpl	r6, [lr], -r9, ror #30
    27e4:	65756c61 	ldrbvs	r6, [r5, #-3169]!
    27e8:	0008db00 	andeq	sp, r8, r0, lsl #22
    27ec:	43444100 	movtmi	r4, #16640	; 0x4100
    27f0:	616e415f 	cmnvs	lr, pc, asr r1
    27f4:	57676f6c 	strbpl	r6, [r7, -ip, ror #30]!
    27f8:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
    27fc:	43676f64 	cmnmi	r7, #400	; 0x190
    2800:	2200646d 	andcs	r6, r0, #1828716544	; 0x6d000000
    2804:	41000009 	tstmi	r0, r9
    2808:	415f4344 	cmpmi	pc, r4, asr #6
    280c:	6f6c616e 	svcvs	0x006c616e
    2810:	74615767 	strbtvc	r5, [r1], #-1895
    2814:	6f646863 	svcvs	0x00646863
    2818:	72685467 	rsbvc	r5, r8, #1728053248	; 0x67000000
    281c:	6f687365 	svcvs	0x00687365
    2820:	4373646c 	cmnmi	r3, #1811939328	; 0x6c000000
    2824:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2828:	09650067 	stmdbeq	r5!, {r0, r1, r2, r5, r6}^
    282c:	44410000 	strbmi	r0, [r1]
    2830:	6e415f43 	cdpvs	15, 4, cr5, cr1, cr3, {2}
    2834:	676f6c61 	strbvs	r6, [pc, -r1, ror #24]!
    2838:	63746157 	cmnvs	r4, #-1073741803	; 0xc0000015
    283c:	676f6468 	strbvs	r6, [pc, -r8, ror #8]!
    2840:	676e6953 	undefined
    2844:	6843656c 	stmdavs	r3, {r2, r3, r5, r6, r8, sl, sp, lr}^
    2848:	656e6e61 	strbvs	r6, [lr, #-3681]!
    284c:	6e6f436c 	cdpvs	3, 6, cr4, cr15, cr12, {3}
    2850:	00676966 	rsbeq	r6, r7, r6, ror #18
    2854:	000009ac 	andeq	r0, r0, ip, lsr #19
    2858:	5f434441 	svcpl	0x00434441
    285c:	706d6554 	rsbvc	r6, sp, r4, asr r5
    2860:	736e6553 	cmnvc	lr, #348127232	; 0x14c00000
    2864:	7256726f 	subsvc	r7, r6, #-268435450	; 0xf0000006
    2868:	6e696665 	cdpvs	6, 6, cr6, cr9, cr5, {3}
    286c:	646d4374 	strbtvs	r4, [sp], #-884
    2870:	0009d300 	andeq	sp, r9, r0, lsl #6
    2874:	43444100 	movtmi	r4, #16640	; 0x4100
    2878:	7465475f 	strbtvc	r4, [r5], #-1887
    287c:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    2880:	74617453 	strbtvc	r7, [r1], #-1107
    2884:	1a007375 	bne	1f660 <__Stack_Size+0x1f260>
    2888:	4100000a 	tstmi	r0, sl
    288c:	435f4344 	cmpmi	pc, #268435457	; 0x10000001
    2890:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    2894:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    2898:	000a5100 	andeq	r5, sl, r0, lsl #2
    289c:	43444100 	movtmi	r4, #16640	; 0x4100
    28a0:	7465475f 	strbtvc	r4, [r5], #-1887
    28a4:	74535449 	ldrbvc	r5, [r3], #-1097
    28a8:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    28ac:	000ab600 	andeq	fp, sl, r0, lsl #12
    28b0:	43444100 	movtmi	r4, #16640	; 0x4100
    28b4:	656c435f 	strbvs	r4, [ip, #-863]!
    28b8:	54497261 	strbpl	r7, [r9], #-609
    28bc:	646e6550 	strbtvs	r6, [lr], #-1360
    28c0:	42676e69 	rsbmi	r6, r7, #1680	; 0x690
    28c4:	f9007469 	undefined instruction 0xf9007469
    28c8:	4100000a 	tstmi	r0, sl
    28cc:	445f4344 	ldrbmi	r4, [pc], #836	; 28d4 <__Stack_Size+0x24d4>
    28d0:	696e4965 	stmdbvs	lr!, {r0, r2, r5, r6, r8, fp, lr}^
    28d4:	00000074 	andeq	r0, r0, r4, ror r0
    28d8:	026a0000 	rsbeq	r0, sl, #0	; 0x0
    28dc:	00020000 	andeq	r0, r2, r0
    28e0:	000081ed 	andeq	r8, r0, sp, ror #3
    28e4:	0000073a 	andeq	r0, r0, sl, lsr r7
    28e8:	00000237 	andeq	r0, r0, r7, lsr r2
    28ec:	53414c46 	movtpl	r4, #7238	; 0x1c46
    28f0:	65535f48 	ldrbvs	r5, [r3, #-3912]
    28f4:	74614c74 	strbtvc	r4, [r1], #-3188
    28f8:	79636e65 	stmdbvc	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    28fc:	00025e00 	andeq	r5, r2, r0, lsl #28
    2900:	414c4600 	cmpmi	ip, r0, lsl #12
    2904:	485f4853 	ldmdami	pc, {r0, r1, r4, r6, fp, lr}^
    2908:	43666c61 	cmnmi	r6, #24832	; 0x6100
    290c:	656c6379 	strbvs	r6, [ip, #-889]!
    2910:	65636341 	strbvs	r6, [r3, #-833]!
    2914:	6d437373 	stclvs	3, cr7, [r3, #-460]
    2918:	02850064 	addeq	r0, r5, #100	; 0x64
    291c:	4c460000 	marmi	acc0, r0, r6
    2920:	5f485341 	svcpl	0x00485341
    2924:	66657250 	undefined
    2928:	68637465 	stmdavs	r3!, {r0, r2, r5, r6, sl, ip, sp, lr}^
    292c:	66667542 	strbtvs	r7, [r6], -r2, asr #10
    2930:	6d437265 	sfmvs	f7, 2, [r3, #-404]
    2934:	02ac0064 	adceq	r0, ip, #100	; 0x64
    2938:	4c460000 	marmi	acc0, r0, r6
    293c:	5f485341 	svcpl	0x00485341
    2940:	6f6c6e55 	svcvs	0x006c6e55
    2944:	bf006b63 	svclt	0x00006b63
    2948:	46000002 	strmi	r0, [r0], -r2
    294c:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    2950:	636f4c5f 	cmnvs	pc, #24320	; 0x5f00
    2954:	02d2006b 	sbcseq	r0, r2, #107	; 0x6b
    2958:	4c460000 	marmi	acc0, r0, r6
    295c:	5f485341 	svcpl	0x00485341
    2960:	55746547 	ldrbpl	r6, [r4, #-1351]!
    2964:	4f726573 	svcmi	0x00726573
    2968:	6f697470 	svcvs	0x00697470
    296c:	7479426e 	ldrbtvc	r4, [r9], #-622
    2970:	02ea0065 	rsceq	r0, sl, #101	; 0x65
    2974:	4c460000 	marmi	acc0, r0, r6
    2978:	5f485341 	svcpl	0x00485341
    297c:	57746547 	ldrbpl	r6, [r4, -r7, asr #10]!
    2980:	65746972 	ldrbvs	r6, [r4, #-2418]!
    2984:	746f7250 	strbtvc	r7, [pc], #592	; 298c <__Stack_Size+0x258c>
    2988:	69746365 	ldmdbvs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    298c:	704f6e6f 	subvc	r6, pc, pc, ror #28
    2990:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2994:	65747942 	ldrbvs	r7, [r4, #-2370]!
    2998:	00030200 	andeq	r0, r3, r0, lsl #4
    299c:	414c4600 	cmpmi	ip, r0, lsl #12
    29a0:	475f4853 	undefined
    29a4:	65527465 	ldrbvs	r7, [r2, #-1125]
    29a8:	754f6461 	strbvc	r6, [pc, #-1121]	; 254f <__Stack_Size+0x214f>
    29ac:	6f725074 	svcvs	0x00725074
    29b0:	74636574 	strbtvc	r6, [r3], #-1396
    29b4:	536e6f69 	cmnpl	lr, #420	; 0x1a4
    29b8:	75746174 	ldrbvc	r6, [r4, #-372]!
    29bc:	032b0073 	teqeq	fp, #115	; 0x73
    29c0:	4c460000 	marmi	acc0, r0, r6
    29c4:	5f485341 	svcpl	0x00485341
    29c8:	50746547 	rsbspl	r6, r4, r7, asr #10
    29cc:	65666572 	strbvs	r6, [r6, #-1394]!
    29d0:	42686374 	rsbmi	r6, r8, #-805306367	; 0xd0000001
    29d4:	65666675 	strbvs	r6, [r6, #-1653]!
    29d8:	61745372 	cmnvs	r4, r2, ror r3
    29dc:	00737574 	rsbseq	r7, r3, r4, ror r5
    29e0:	00000354 	andeq	r0, r0, r4, asr r3
    29e4:	53414c46 	movtpl	r4, #7238	; 0x1c46
    29e8:	54495f48 	strbpl	r5, [r9], #-3912
    29ec:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    29f0:	89006769 	stmdbhi	r0, {r0, r3, r5, r6, r8, r9, sl, sp, lr}
    29f4:	46000003 	strmi	r0, [r0], -r3
    29f8:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    29fc:	7465475f 	strbtvc	r4, [r5], #-1887
    2a00:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    2a04:	74617453 	strbtvc	r7, [r1], #-1107
    2a08:	c6007375 	undefined
    2a0c:	46000003 	strmi	r0, [r0], -r3
    2a10:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    2a14:	656c435f 	strbvs	r4, [ip, #-863]!
    2a18:	6c467261 	sfmvs	f7, 2, [r6], {97}
    2a1c:	ed006761 	stc	7, cr6, [r0, #-388]
    2a20:	46000003 	strmi	r0, [r0], -r3
    2a24:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    2a28:	7465475f 	strbtvc	r4, [r5], #-1887
    2a2c:	74617453 	strbtvc	r7, [r1], #-1107
    2a30:	0a007375 	beq	1f80c <__Stack_Size+0x1f40c>
    2a34:	46000004 	strmi	r0, [r0], -r4
    2a38:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    2a3c:	6961575f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, lr}^
    2a40:	726f4674 	rsbvc	r4, pc, #121634816	; 0x7400000
    2a44:	7473614c 	ldrbtvc	r6, [r3], #-332
    2a48:	7265704f 	rsbvc	r7, r5, #79	; 0x4f
    2a4c:	6f697461 	svcvs	0x00697461
    2a50:	049d006e 	ldreq	r0, [sp], #110
    2a54:	4c460000 	marmi	acc0, r0, r6
    2a58:	5f485341 	svcpl	0x00485341
    2a5c:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
    2a60:	6974704f 	ldmdbvs	r4!, {r0, r1, r2, r3, r6, ip, sp, lr}^
    2a64:	79426e6f 	stmdbvc	r2, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2a68:	6f436574 	svcvs	0x00436574
    2a6c:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2a70:	0004fc00 	andeq	pc, r4, r0, lsl #24
    2a74:	414c4600 	cmpmi	ip, r0, lsl #12
    2a78:	525f4853 	subspl	r4, pc, #5439488	; 0x530000
    2a7c:	4f646165 	svcmi	0x00646165
    2a80:	72507475 	subsvc	r7, r0, #1962934272	; 0x75000000
    2a84:	6365746f 	cmnvs	r5, #1862270976	; 0x6f000000
    2a88:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2a8c:	00053b00 	andeq	r3, r5, r0, lsl #22
    2a90:	414c4600 	cmpmi	ip, r0, lsl #12
    2a94:	455f4853 	ldrbmi	r4, [pc, #-2131]	; 2249 <__Stack_Size+0x1e49>
    2a98:	6c62616e 	stfvse	f6, [r2], #-440
    2a9c:	69725765 	ldmdbvs	r2!, {r0, r2, r5, r6, r8, r9, sl, ip, lr}^
    2aa0:	72506574 	subsvc	r6, r0, #486539264	; 0x1d000000
    2aa4:	6365746f 	cmnvs	r5, #1862270976	; 0x6f000000
    2aa8:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2aac:	0005ba00 	andeq	fp, r5, r0, lsl #20
    2ab0:	414c4600 	cmpmi	ip, r0, lsl #12
    2ab4:	505f4853 	subspl	r4, pc, r3, asr r8
    2ab8:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    2abc:	704f6d61 	subvc	r6, pc, r1, ror #26
    2ac0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2ac4:	65747942 	ldrbvs	r7, [r4, #-2370]!
    2ac8:	61746144 	cmnvs	r4, r4, asr #2
    2acc:	00060900 	andeq	r0, r6, r0, lsl #18
    2ad0:	414c4600 	cmpmi	ip, r0, lsl #12
    2ad4:	505f4853 	subspl	r4, pc, r3, asr r8
    2ad8:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    2adc:	61486d61 	cmpvs	r8, r1, ror #26
    2ae0:	6f57666c 	svcvs	0x0057666c
    2ae4:	58006472 	stmdapl	r0, {r1, r4, r5, r6, sl, sp, lr}
    2ae8:	46000006 	strmi	r0, [r0], -r6
    2aec:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    2af0:	6f72505f 	svcvs	0x0072505f
    2af4:	6d617267 	sfmvs	f7, 2, [r1, #-412]!
    2af8:	64726f57 	ldrbtvs	r6, [r2], #-3927
    2afc:	0006a700 	andeq	sl, r6, r0, lsl #14
    2b00:	414c4600 	cmpmi	ip, r0, lsl #12
    2b04:	455f4853 	ldrbmi	r4, [pc, #-2131]	; 22b9 <__Stack_Size+0x1eb9>
    2b08:	65736172 	ldrbvs	r6, [r3, #-370]!
    2b0c:	6974704f 	ldmdbvs	r4!, {r0, r1, r2, r3, r6, ip, sp, lr}^
    2b10:	79426e6f 	stmdbvc	r2, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2b14:	00736574 	rsbseq	r6, r3, r4, ror r5
    2b18:	000006d4 	ldrdeq	r0, [r0], -r4
    2b1c:	53414c46 	movtpl	r4, #7238	; 0x1c46
    2b20:	72455f48 	subvc	r5, r5, #288	; 0x120
    2b24:	41657361 	cmnmi	r5, r1, ror #6
    2b28:	61506c6c 	cmpvs	r0, ip, ror #24
    2b2c:	00736567 	rsbseq	r6, r3, r7, ror #10
    2b30:	00000701 	andeq	r0, r0, r1, lsl #14
    2b34:	53414c46 	movtpl	r4, #7238	; 0x1c46
    2b38:	72455f48 	subvc	r5, r5, #288	; 0x120
    2b3c:	50657361 	rsbpl	r7, r5, r1, ror #6
    2b40:	00656761 	rsbeq	r6, r5, r1, ror #14
    2b44:	00000000 	andeq	r0, r0, r0
    2b48:	00000177 	andeq	r0, r0, r7, ror r1
    2b4c:	89270002 	stmdbhi	r7!, {r1}
    2b50:	06480000 	strbeq	r0, [r8], -r0
    2b54:	022b0000 	eoreq	r0, fp, #0	; 0x0
    2b58:	50470000 	subpl	r0, r7, r0
    2b5c:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^
    2b60:	0074696e 	rsbseq	r6, r4, lr, ror #18
    2b64:	000002bb 	strheq	r0, [r0], -fp
    2b68:	4f495047 	svcmi	0x00495047
    2b6c:	7274535f 	rsbsvc	r5, r4, #2080374785	; 0x7c000001
    2b70:	49746375 	ldmdbmi	r4!, {r0, r2, r4, r5, r6, r8, r9, sp, lr}^
    2b74:	0074696e 	rsbseq	r6, r4, lr, ror #18
    2b78:	000002e0 	andeq	r0, r0, r0, ror #5
    2b7c:	4f495047 	svcmi	0x00495047
    2b80:	6165525f 	cmnvs	r5, pc, asr r2
    2b84:	706e4964 	rsbvc	r4, lr, r4, ror #18
    2b88:	61447475 	cmpvs	r4, r5, ror r4
    2b8c:	69426174 	stmdbvs	r2, {r2, r4, r5, r6, r8, sp, lr}^
    2b90:	03230074 	teqeq	r3, #116	; 0x74
    2b94:	50470000 	subpl	r0, r7, r0
    2b98:	525f4f49 	subspl	r4, pc, #292	; 0x124
    2b9c:	49646165 	stmdbmi	r4!, {r0, r2, r5, r6, r8, sp, lr}^
    2ba0:	7475706e 	ldrbtvc	r7, [r5], #-110
    2ba4:	61746144 	cmnvs	r4, r4, asr #2
    2ba8:	00035000 	andeq	r5, r3, r0
    2bac:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    2bb0:	65525f4f 	ldrbvs	r5, [r2, #-3919]
    2bb4:	754f6461 	strbvc	r6, [pc, #-1121]	; 275b <__Stack_Size+0x235b>
    2bb8:	74757074 	ldrbtvc	r7, [r5], #-116
    2bbc:	61746144 	cmnvs	r4, r4, asr #2
    2bc0:	00746942 	rsbseq	r6, r4, r2, asr #18
    2bc4:	00000397 	muleq	r0, r7, r3
    2bc8:	4f495047 	svcmi	0x00495047
    2bcc:	6165525f 	cmnvs	r5, pc, asr r2
    2bd0:	74754f64 	ldrbtvc	r4, [r5], #-3940
    2bd4:	44747570 	ldrbtmi	r7, [r4], #-1392
    2bd8:	00617461 	rsbeq	r7, r1, r1, ror #8
    2bdc:	000003c4 	andeq	r0, r0, r4, asr #7
    2be0:	4f495047 	svcmi	0x00495047
    2be4:	7465535f 	strbtvc	r5, [r5], #-863
    2be8:	73746942 	cmnvc	r4, #1081344	; 0x108000
    2bec:	0003f900 	andeq	pc, r3, r0, lsl #18
    2bf0:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    2bf4:	65525f4f 	ldrbvs	r5, [r2, #-3919]
    2bf8:	42746573 	rsbsmi	r6, r4, #482344960	; 0x1cc00000
    2bfc:	00737469 	rsbseq	r7, r3, r9, ror #8
    2c00:	0000042e 	andeq	r0, r0, lr, lsr #8
    2c04:	4f495047 	svcmi	0x00495047
    2c08:	6972575f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, lr}^
    2c0c:	69426574 	stmdbvs	r2, {r2, r4, r5, r6, r8, sl, sp, lr}^
    2c10:	04710074 	ldrbteq	r0, [r1], #-116
    2c14:	50470000 	subpl	r0, r7, r0
    2c18:	575f4f49 	ldrbpl	r4, [pc, -r9, asr #30]
    2c1c:	65746972 	ldrbvs	r6, [r4, #-2418]!
    2c20:	0004a600 	andeq	sl, r4, r0, lsl #12
    2c24:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    2c28:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    2c2c:	636f4c6e 	cmnvs	pc, #28160	; 0x6e00
    2c30:	6e6f436b 	cdpvs	3, 6, cr4, cr15, cr11, {3}
    2c34:	00676966 	rsbeq	r6, r7, r6, ror #18
    2c38:	000004e9 	andeq	r0, r0, r9, ror #9
    2c3c:	4f495047 	svcmi	0x00495047
    2c40:	6576455f 	ldrbvs	r4, [r6, #-1375]!
    2c44:	754f746e 	strbvc	r7, [pc, #-1134]	; 27de <__Stack_Size+0x23de>
    2c48:	74757074 	ldrbtvc	r7, [r5], #-116
    2c4c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2c50:	30006769 	andcc	r6, r0, r9, ror #14
    2c54:	47000005 	strmi	r0, [r0, -r5]
    2c58:	5f4f4950 	svcpl	0x004f4950
    2c5c:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
    2c60:	74754f74 	ldrbtvc	r4, [r5], #-3956
    2c64:	43747570 	cmnmi	r4, #469762048	; 0x1c000000
    2c68:	5700646d 	strpl	r6, [r0, -sp, ror #8]
    2c6c:	47000005 	strmi	r0, [r0, -r5]
    2c70:	5f4f4950 	svcpl	0x004f4950
    2c74:	526e6950 	rsbpl	r6, lr, #1310720	; 0x140000
    2c78:	70616d65 	rsbvc	r6, r1, r5, ror #26
    2c7c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2c80:	c6006769 	strgt	r6, [r0], -r9, ror #14
    2c84:	47000005 	strmi	r0, [r0, -r5]
    2c88:	5f4f4950 	svcpl	0x004f4950
    2c8c:	49545845 	ldmdbmi	r4, {r0, r2, r6, fp, ip, lr}^
    2c90:	656e694c 	strbvs	r6, [lr, #-2380]!
    2c94:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2c98:	0d006769 	stceq	7, cr6, [r0, #-420]
    2c9c:	47000006 	strmi	r0, [r0, -r6]
    2ca0:	5f4f4950 	svcpl	0x004f4950
    2ca4:	4f494641 	svcmi	0x00494641
    2ca8:	6e496544 	cdpvs	5, 4, cr6, cr9, cr4, {2}
    2cac:	22007469 	andcs	r7, r0, #1761607680	; 0x69000000
    2cb0:	47000006 	strmi	r0, [r0, -r6]
    2cb4:	5f4f4950 	svcpl	0x004f4950
    2cb8:	6e496544 	cdpvs	5, 4, cr6, cr9, cr4, {2}
    2cbc:	00007469 	andeq	r7, r0, r9, ror #8
    2cc0:	5c000000 	stcpl	0, cr0, [r0], {0}
    2cc4:	02000003 	andeq	r0, r0, #3	; 0x3
    2cc8:	008f6f00 	addeq	r6, pc, r0, lsl #30
    2ccc:	0008e700 	andeq	lr, r8, r0, lsl #14
    2cd0:	00031000 	andeq	r1, r3, r0
    2cd4:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2cd8:	65445f43 	strbvs	r5, [r4, #-3907]
    2cdc:	74696e49 	strbtvc	r6, [r9], #-3657
    2ce0:	00033500 	andeq	r3, r3, r0, lsl #10
    2ce4:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2ce8:	43535f43 	cmpmi	r3, #268	; 0x10c
    2cec:	49654442 	stmdbmi	r5!, {r1, r6, sl, lr}^
    2cf0:	0074696e 	rsbseq	r6, r4, lr, ror #18
    2cf4:	00000358 	andeq	r0, r0, r8, asr r3
    2cf8:	4349564e 	movtmi	r5, #38478	; 0x964e
    2cfc:	6972505f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, ip, lr}^
    2d00:	7469726f 	strbtvc	r7, [r9], #-623
    2d04:	6f724779 	svcvs	0x00724779
    2d08:	6f437075 	svcvs	0x00437075
    2d0c:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2d10:	00037f00 	andeq	r7, r3, r0, lsl #30
    2d14:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2d18:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    2d1c:	f1007469 	undefined instruction 0xf1007469
    2d20:	4e000003 	cdpmi	0, 0, cr0, cr0, cr3, {0}
    2d24:	5f434956 	svcpl	0x00434956
    2d28:	75727453 	ldrbvc	r7, [r2, #-1107]!
    2d2c:	6e497463 	cdpvs	4, 4, cr7, cr9, cr3, {3}
    2d30:	16007469 	strne	r7, [r0], -r9, ror #8
    2d34:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
    2d38:	5f434956 	svcpl	0x00434956
    2d3c:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    2d40:	65727275 	ldrbvs	r7, [r2, #-629]!
    2d44:	6550746e 	ldrbvs	r7, [r0, #-1134]
    2d48:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
    2d4c:	51524967 	cmppl	r2, r7, ror #18
    2d50:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
    2d54:	006c656e 	rsbeq	r6, ip, lr, ror #10
    2d58:	0000042e 	andeq	r0, r0, lr, lsr #8
    2d5c:	4349564e 	movtmi	r5, #38478	; 0x964e
    2d60:	7465475f 	strbtvc	r4, [r5], #-1887
    2d64:	43515249 	cmpmi	r1, #-1879048188	; 0x90000004
    2d68:	6e6e6168 	powvsez	f6, f6, #0.0
    2d6c:	65506c65 	ldrbvs	r6, [r0, #-3173]
    2d70:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
    2d74:	74694267 	strbtvc	r4, [r9], #-615
    2d78:	74617453 	strbtvc	r7, [r1], #-1107
    2d7c:	75007375 	strvc	r7, [r0, #-885]
    2d80:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
    2d84:	5f434956 	svcpl	0x00434956
    2d88:	49746553 	ldmdbmi	r4!, {r0, r1, r4, r6, r8, sl, sp, lr}^
    2d8c:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
    2d90:	656e6e61 	strbvs	r6, [lr, #-3681]!
    2d94:	6e65506c 	cdpvs	0, 6, cr5, cr5, cr12, {3}
    2d98:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    2d9c:	00746942 	rsbseq	r6, r4, r2, asr #18
    2da0:	0000049c 	muleq	r0, ip, r4
    2da4:	4349564e 	movtmi	r5, #38478	; 0x964e
    2da8:	656c435f 	strbvs	r4, [ip, #-863]!
    2dac:	52497261 	subpl	r7, r9, #268435462	; 0x10000006
    2db0:	61684351 	cmnvs	r8, r1, asr r3
    2db4:	6c656e6e 	stclvs	14, cr6, [r5], #-440
    2db8:	646e6550 	strbtvs	r6, [lr], #-1360
    2dbc:	42676e69 	rsbmi	r6, r7, #1680	; 0x690
    2dc0:	c5007469 	strgt	r7, [r0, #-1129]
    2dc4:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
    2dc8:	5f434956 	svcpl	0x00434956
    2dcc:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    2dd0:	65727275 	ldrbvs	r7, [r2, #-629]!
    2dd4:	6341746e 	movtvs	r7, #5230	; 0x146e
    2dd8:	65766974 	ldrbvs	r6, [r6, #-2420]!
    2ddc:	646e6148 	strbtvs	r6, [lr], #-328
    2de0:	0072656c 	rsbseq	r6, r2, ip, ror #10
    2de4:	000004dd 	ldrdeq	r0, [r0], -sp
    2de8:	4349564e 	movtmi	r5, #38478	; 0x964e
    2dec:	7465475f 	strbtvc	r4, [r5], #-1887
    2df0:	43515249 	cmpmi	r1, #-1879048188	; 0x90000004
    2df4:	6e6e6168 	powvsez	f6, f6, #0.0
    2df8:	63416c65 	movtvs	r6, #7269	; 0x1c65
    2dfc:	65766974 	ldrbvs	r6, [r6, #-2420]!
    2e00:	53746942 	cmnpl	r4, #1081344	; 0x108000
    2e04:	75746174 	ldrbvc	r6, [r4, #-372]!
    2e08:	05240073 	streq	r0, [r4, #-115]!
    2e0c:	564e0000 	strbpl	r0, [lr], -r0
    2e10:	475f4349 	ldrbmi	r4, [pc, -r9, asr #6]
    2e14:	50437465 	subpl	r7, r3, r5, ror #8
    2e18:	00444955 	subeq	r4, r4, r5, asr r9
    2e1c:	0000053c 	andeq	r0, r0, ip, lsr r5
    2e20:	4349564e 	movtmi	r5, #38478	; 0x964e
    2e24:	7465535f 	strbtvc	r5, [r5], #-863
    2e28:	74636556 	strbtvc	r6, [r3], #-1366
    2e2c:	6154726f 	cmpvs	r4, pc, ror #4
    2e30:	00656c62 	rsbeq	r6, r5, r2, ror #24
    2e34:	00000573 	andeq	r0, r0, r3, ror r5
    2e38:	4349564e 	movtmi	r5, #38478	; 0x964e
    2e3c:	6e65475f 	mcrvs	7, 3, r4, cr5, cr15, {2}
    2e40:	74617265 	strbtvc	r7, [r1], #-613
    2e44:	73795365 	cmnvc	r9, #-1811939327	; 0x94000001
    2e48:	526d6574 	rsbpl	r6, sp, #486539264	; 0x1d000000
    2e4c:	74657365 	strbtvc	r7, [r5], #-869
    2e50:	00058700 	andeq	r8, r5, r0, lsl #14
    2e54:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2e58:	65475f43 	strbvs	r5, [r7, #-3907]
    2e5c:	6172656e 	cmnvs	r2, lr, ror #10
    2e60:	6f436574 	svcvs	0x00436574
    2e64:	65526572 	ldrbvs	r6, [r2, #-1394]
    2e68:	00746573 	rsbseq	r6, r4, r3, ror r5
    2e6c:	0000059b 	muleq	r0, fp, r5
    2e70:	4349564e 	movtmi	r5, #38478	; 0x964e
    2e74:	7379535f 	cmnvc	r9, #2080374785	; 0x7c000001
    2e78:	4c6d6574 	cfstr64mi	mvdx6, [sp], #-464
    2e7c:	6e6f4350 	mcrvs	3, 3, r4, cr15, cr0, {2}
    2e80:	00676966 	rsbeq	r6, r7, r6, ror #18
    2e84:	000005d0 	ldrdeq	r0, [r0], -r0
    2e88:	4349564e 	movtmi	r5, #38478	; 0x964e
    2e8c:	7379535f 	cmnvc	r9, #2080374785	; 0x7c000001
    2e90:	486d6574 	stmdami	sp!, {r2, r4, r5, r6, r8, sl, sp, lr}^
    2e94:	6c646e61 	stclvs	14, cr6, [r4], #-388
    2e98:	6f437265 	svcvs	0x00437265
    2e9c:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2ea0:	00061500 	andeq	r1, r6, r0, lsl #10
    2ea4:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2ea8:	79535f43 	ldmdbvc	r3, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    2eac:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    2eb0:	646e6148 	strbtvs	r6, [lr], #-328
    2eb4:	5072656c 	rsbspl	r6, r2, ip, ror #10
    2eb8:	726f6972 	rsbvc	r6, pc, #1867776	; 0x1c8000
    2ebc:	43797469 	cmnmi	r9, #1761607680	; 0x69000000
    2ec0:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2ec4:	06980067 	ldreq	r0, [r8], r7, rrx
    2ec8:	564e0000 	strbpl	r0, [lr], -r0
    2ecc:	475f4349 	ldrbmi	r4, [pc, -r9, asr #6]
    2ed0:	79537465 	ldmdbvc	r3, {r0, r2, r5, r6, sl, ip, sp, lr}^
    2ed4:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    2ed8:	646e6148 	strbtvs	r6, [lr], #-328
    2edc:	5072656c 	rsbspl	r6, r2, ip, ror #10
    2ee0:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    2ee4:	6942676e 	stmdbvs	r2, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    2ee8:	61745374 	cmnvs	r4, r4, ror r3
    2eec:	00737574 	rsbseq	r7, r3, r4, ror r5
    2ef0:	000006ed 	andeq	r0, r0, sp, ror #13
    2ef4:	4349564e 	movtmi	r5, #38478	; 0x964e
    2ef8:	7465535f 	strbtvc	r5, [r5], #-863
    2efc:	74737953 	ldrbtvc	r7, [r3], #-2387
    2f00:	61486d65 	cmpvs	r8, r5, ror #26
    2f04:	656c646e 	strbvs	r6, [ip, #-1134]!
    2f08:	6e655072 	mcrvs	0, 3, r5, cr5, cr2, {3}
    2f0c:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    2f10:	00746942 	rsbseq	r6, r4, r2, asr #18
    2f14:	00000722 	andeq	r0, r0, r2, lsr #14
    2f18:	4349564e 	movtmi	r5, #38478	; 0x964e
    2f1c:	656c435f 	strbvs	r4, [ip, #-863]!
    2f20:	79537261 	ldmdbvc	r3, {r0, r5, r6, r9, ip, sp, lr}^
    2f24:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    2f28:	646e6148 	strbtvs	r6, [lr], #-328
    2f2c:	5072656c 	rsbspl	r6, r2, ip, ror #10
    2f30:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    2f34:	6942676e 	stmdbvs	r2, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    2f38:	07570074 	undefined
    2f3c:	564e0000 	strbpl	r0, [lr], -r0
    2f40:	475f4349 	ldrbmi	r4, [pc, -r9, asr #6]
    2f44:	79537465 	ldmdbvc	r3, {r0, r2, r5, r6, sl, ip, sp, lr}^
    2f48:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    2f4c:	646e6148 	strbtvs	r6, [lr], #-328
    2f50:	4172656c 	cmnmi	r2, ip, ror #10
    2f54:	76697463 	strbtvc	r7, [r9], -r3, ror #8
    2f58:	74694265 	strbtvc	r4, [r9], #-613
    2f5c:	74617453 	strbtvc	r7, [r1], #-1107
    2f60:	aa007375 	bge	1fd3c <__Stack_Size+0x1f93c>
    2f64:	4e000007 	cdpmi	0, 0, cr0, cr0, cr7, {0}
    2f68:	5f434956 	svcpl	0x00434956
    2f6c:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    2f70:	746c7561 	strbtvc	r7, [ip], #-1377
    2f74:	646e6148 	strbtvs	r6, [lr], #-328
    2f78:	5372656c 	cmnpl	r2, #452984832	; 0x1b000000
    2f7c:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    2f80:	07007365 	streq	r7, [r0, -r5, ror #6]
    2f84:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
    2f88:	5f434956 	svcpl	0x00434956
    2f8c:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    2f90:	746c7561 	strbtvc	r7, [ip], #-1377
    2f94:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    2f98:	00737365 	rsbseq	r7, r3, r5, ror #6
    2f9c:	00000850 	andeq	r0, r0, r0, asr r8
    2fa0:	4349564e 	movtmi	r5, #38478	; 0x964e
    2fa4:	7465475f 	strbtvc	r4, [r5], #-1887
    2fa8:	45534142 	ldrbmi	r4, [r3, #-322]
    2fac:	00495250 	subeq	r5, r9, r0, asr r2
    2fb0:	00000869 	andeq	r0, r0, r9, ror #16
    2fb4:	4349564e 	movtmi	r5, #38478	; 0x964e
    2fb8:	5341425f 	movtpl	r4, #4703	; 0x125f
    2fbc:	49525045 	ldmdbmi	r2, {r0, r2, r6, ip, lr}^
    2fc0:	464e4f43 	strbmi	r4, [lr], -r3, asr #30
    2fc4:	92004749 	andls	r4, r0, #19136512	; 0x1240000
    2fc8:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
    2fcc:	5f434956 	svcpl	0x00434956
    2fd0:	45534552 	ldrbmi	r4, [r3, #-1362]
    2fd4:	55414654 	strbpl	r4, [r1, #-1620]
    2fd8:	414d544c 	cmpmi	sp, ip, asr #8
    2fdc:	a7004b53 	smlsdge	r0, r3, fp, r4
    2fe0:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
    2fe4:	5f434956 	svcpl	0x00434956
    2fe8:	46544553 	undefined
    2fec:	544c5541 	strbpl	r5, [ip], #-1345
    2ff0:	4b53414d 	blmi	14d352c <__Stack_Size+0x14d312c>
    2ff4:	0008bc00 	andeq	fp, r8, r0, lsl #24
    2ff8:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2ffc:	45525f43 	ldrbmi	r5, [r2, #-3907]
    3000:	50544553 	subspl	r4, r4, r3, asr r5
    3004:	414d4952 	cmpmi	sp, r2, asr r9
    3008:	d1004b53 	tstle	r0, r3, asr fp
    300c:	4e000008 	cdpmi	0, 0, cr0, cr0, cr8, {0}
    3010:	5f434956 	svcpl	0x00434956
    3014:	50544553 	subspl	r4, r4, r3, asr r5
    3018:	414d4952 	cmpmi	sp, r2, asr r9
    301c:	00004b53 	andeq	r4, r0, r3, asr fp
    3020:	c7000000 	strgt	r0, [r0, -r0]
    3024:	02000000 	andeq	r0, r0, #0	; 0x0
    3028:	00985600 	addseq	r5, r8, r0, lsl #12
    302c:	00024700 	andeq	r4, r2, r0, lsl #14
    3030:	0000d300 	andeq	sp, r0, r0, lsl #6
    3034:	52575000 	subspl	r5, r7, #0	; 0x0
    3038:	6361425f 	cmnvs	r1, #-268435451	; 0xf0000005
    303c:	4170756b 	cmnmi	r0, fp, ror #10
    3040:	73656363 	cmnvc	r5, #-1946157055	; 0x8c000001
    3044:	646d4373 	strbtvs	r4, [sp], #-883
    3048:	0000f800 	andeq	pc, r0, r0, lsl #16
    304c:	52575000 	subspl	r5, r7, #0	; 0x0
    3050:	4456505f 	ldrbmi	r5, [r6], #-95
    3054:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3058:	0000011d 	andeq	r0, r0, sp, lsl r1
    305c:	5f525750 	svcpl	0x00525750
    3060:	4c445650 	mcrrmi	6, 5, r5, r4, cr0
    3064:	6c657665 	stclvs	6, cr7, [r5], #-404
    3068:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    306c:	53006769 	movwpl	r6, #1897	; 0x769
    3070:	50000001 	andpl	r0, r0, r1
    3074:	575f5257 	undefined
    3078:	55656b61 	strbpl	r6, [r5, #-2913]!
    307c:	6e695070 	mcrvs	0, 3, r5, cr9, cr0, {3}
    3080:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3084:	00000178 	andeq	r0, r0, r8, ror r1
    3088:	5f525750 	svcpl	0x00525750
    308c:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    3090:	5367616c 	cmnpl	r7, #27	; 0x1b
    3094:	75746174 	ldrbvc	r6, [r4, #-372]!
    3098:	01ae0073 	undefined instruction 0x01ae0073
    309c:	57500000 	ldrbpl	r0, [r0, -r0]
    30a0:	6c435f52 	mcrrvs	15, 5, r5, r3, cr2
    30a4:	46726165 	ldrbtmi	r6, [r2], -r5, ror #2
    30a8:	0067616c 	rsbeq	r6, r7, ip, ror #2
    30ac:	000001d5 	ldrdeq	r0, [r0], -r5
    30b0:	5f525750 	svcpl	0x00525750
    30b4:	65746e45 	ldrbvs	r6, [r4, #-3653]!
    30b8:	41545372 	cmpmi	r4, r2, ror r3
    30bc:	5942444e 	stmdbpl	r2, {r1, r2, r3, r6, sl, lr}^
    30c0:	65646f4d 	strbvs	r6, [r4, #-3917]!
    30c4:	0001ea00 	andeq	lr, r1, r0, lsl #20
    30c8:	52575000 	subspl	r5, r7, #0	; 0x0
    30cc:	746e455f 	strbtvc	r4, [lr], #-1375
    30d0:	54537265 	ldrbpl	r7, [r3], #-613
    30d4:	6f4d504f 	svcvs	0x004d504f
    30d8:	31006564 	tstcc	r0, r4, ror #10
    30dc:	50000002 	andpl	r0, r0, r2
    30e0:	445f5257 	ldrbmi	r5, [pc], #599	; 30e8 <__Stack_Size+0x2ce8>
    30e4:	696e4965 	stmdbvs	lr!, {r0, r2, r5, r6, r8, fp, lr}^
    30e8:	00000074 	andeq	r0, r0, r4, ror r0
    30ec:	02c00000 	sbceq	r0, r0, #0	; 0x0
    30f0:	00020000 	andeq	r0, r2, r0
    30f4:	00009a9d 	muleq	r0, sp, sl
    30f8:	000008bd 	strheq	r0, [r0], -sp
    30fc:	00000214 	andeq	r0, r0, r4, lsl r2
    3100:	5f434352 	svcpl	0x00434352
    3104:	6e496544 	cdpvs	5, 4, cr6, cr9, cr4, {2}
    3108:	27007469 	strcs	r7, [r0, -r9, ror #8]
    310c:	52000002 	andpl	r0, r0, #2	; 0x2
    3110:	485f4343 	ldmdami	pc, {r0, r1, r6, r8, r9, lr}^
    3114:	6f434553 	svcvs	0x00434553
    3118:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    311c:	00024c00 	andeq	r4, r2, r0, lsl #24
    3120:	43435200 	movtmi	r5, #12800	; 0x3200
    3124:	6961575f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, lr}^
    3128:	726f4674 	rsbvc	r4, pc, #121634816	; 0x7400000
    312c:	53455348 	movtpl	r5, #21320	; 0x5348
    3130:	74726174 	ldrbtvc	r6, [r2], #-372
    3134:	f1007055 	undefined instruction 0xf1007055
    3138:	52000002 	andpl	r0, r0, #2	; 0x2
    313c:	415f4343 	cmpmi	pc, r3, asr #6
    3140:	73756a64 	cmnvc	r5, #409600	; 0x64000
    3144:	49534874 	ldmdbmi	r3, {r2, r4, r5, r6, fp, lr}^
    3148:	696c6143 	stmdbvs	ip!, {r0, r1, r6, r8, sp, lr}^
    314c:	74617262 	strbtvc	r7, [r1], #-610
    3150:	566e6f69 	strbtpl	r6, [lr], -r9, ror #30
    3154:	65756c61 	ldrbvs	r6, [r5, #-3169]!
    3158:	00032300 	andeq	r2, r3, r0, lsl #6
    315c:	43435200 	movtmi	r5, #12800	; 0x3200
    3160:	4953485f 	ldmdbmi	r3, {r0, r1, r2, r3, r4, r6, fp, lr}^
    3164:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3168:	0000034a 	andeq	r0, r0, sl, asr #6
    316c:	5f434352 	svcpl	0x00434352
    3170:	434c4c50 	movtmi	r4, #52304	; 0xcc50
    3174:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    3178:	03910067 	orrseq	r0, r1, #103	; 0x67
    317c:	43520000 	cmpmi	r2, #0	; 0x0
    3180:	4c505f43 	mrrcmi	15, 4, r5, r0, cr3
    3184:	646d434c 	strbtvs	r4, [sp], #-844
    3188:	0003b800 	andeq	fp, r3, r0, lsl #16
    318c:	43435200 	movtmi	r5, #12800	; 0x3200
    3190:	5359535f 	cmppl	r9, #2080374785	; 0x7c000001
    3194:	434b4c43 	movtmi	r4, #48195	; 0xbc43
    3198:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    319c:	03f10067 	mvnseq	r0, #103	; 0x67
    31a0:	43520000 	cmpmi	r2, #0	; 0x0
    31a4:	65475f43 	strbvs	r5, [r7, #-3907]
    31a8:	53595374 	cmppl	r9, #-805306367	; 0xd0000001
    31ac:	534b4c43 	movtpl	r4, #48195	; 0xbc43
    31b0:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    31b4:	04090065 	streq	r0, [r9], #-101
    31b8:	43520000 	cmpmi	r2, #0	; 0x0
    31bc:	43485f43 	movtmi	r5, #36675	; 0x8f43
    31c0:	6f434b4c 	svcvs	0x00434b4c
    31c4:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    31c8:	00044200 	andeq	r4, r4, r0, lsl #4
    31cc:	43435200 	movtmi	r5, #12800	; 0x3200
    31d0:	4c43505f 	mcrrmi	0, 5, r5, r3, cr15
    31d4:	6f43314b 	svcvs	0x0043314b
    31d8:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    31dc:	00047b00 	andeq	r7, r4, r0, lsl #22
    31e0:	43435200 	movtmi	r5, #12800	; 0x3200
    31e4:	4c43505f 	mcrrmi	0, 5, r5, r3, cr15
    31e8:	6f43324b 	svcvs	0x0043324b
    31ec:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    31f0:	0004b000 	andeq	fp, r4, r0
    31f4:	43435200 	movtmi	r5, #12800	; 0x3200
    31f8:	4354495f 	cmpmi	r4, #1556480	; 0x17c000
    31fc:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    3200:	04e50067 	strbteq	r0, [r5], #103
    3204:	43520000 	cmpmi	r2, #0	; 0x0
    3208:	53555f43 	cmppl	r5, #268	; 0x10c
    320c:	4b4c4342 	blmi	1313f1c <__Stack_Size+0x1313b1c>
    3210:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3214:	0c006769 	stceq	7, cr6, [r0], {105}
    3218:	52000005 	andpl	r0, r0, #5	; 0x5
    321c:	415f4343 	cmpmi	pc, r3, asr #6
    3220:	4c434344 	mcrrmi	3, 4, r4, r3, cr4
    3224:	6e6f434b 	cdpvs	3, 6, cr4, cr15, cr11, {2}
    3228:	00676966 	rsbeq	r6, r7, r6, ror #18
    322c:	00000545 	andeq	r0, r0, r5, asr #10
    3230:	5f434352 	svcpl	0x00434352
    3234:	4345534c 	movtmi	r5, #21324	; 0x534c
    3238:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    323c:	056c0067 	strbeq	r0, [ip, #-103]!
    3240:	43520000 	cmpmi	r2, #0	; 0x0
    3244:	534c5f43 	movtpl	r5, #53059	; 0xcf43
    3248:	646d4349 	strbtvs	r4, [sp], #-841
    324c:	00059300 	andeq	r9, r5, r0, lsl #6
    3250:	43435200 	movtmi	r5, #12800	; 0x3200
    3254:	4354525f 	cmpmi	r4, #-268435451	; 0xf0000005
    3258:	434b4c43 	movtmi	r4, #48195	; 0xbc43
    325c:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    3260:	05bc0067 	ldreq	r0, [ip, #103]!
    3264:	43520000 	cmpmi	r2, #0	; 0x0
    3268:	54525f43 	ldrbpl	r5, [r2], #-3907
    326c:	4b4c4343 	blmi	1313f80 <__Stack_Size+0x1313b80>
    3270:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3274:	000005e3 	andeq	r0, r0, r3, ror #11
    3278:	5f434352 	svcpl	0x00434352
    327c:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    3280:	6b636f6c 	blvs	18df038 <__Stack_Size+0x18dec38>
    3284:	65724673 	ldrbvs	r4, [r2, #-1651]!
    3288:	064a0071 	undefined
    328c:	43520000 	cmpmi	r2, #0	; 0x0
    3290:	48415f43 	stmdami	r1, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    3294:	72655042 	rsbvc	r5, r5, #66	; 0x42
    3298:	43687069 	cmnmi	r8, #105	; 0x69
    329c:	6b636f6c 	blvs	18df054 <__Stack_Size+0x18dec54>
    32a0:	00646d43 	rsbeq	r6, r4, r3, asr #26
    32a4:	0000067f 	andeq	r0, r0, pc, ror r6
    32a8:	5f434352 	svcpl	0x00434352
    32ac:	32425041 	subcc	r5, r2, #65	; 0x41
    32b0:	69726550 	ldmdbvs	r2!, {r4, r6, r8, sl, sp, lr}^
    32b4:	6c436870 	mcrrvs	8, 7, r6, r3, cr0
    32b8:	436b636f 	cmnmi	fp, #-1140850687	; 0xbc000001
    32bc:	b400646d 	strlt	r6, [r0], #-1133
    32c0:	52000006 	andpl	r0, r0, #6	; 0x6
    32c4:	415f4343 	cmpmi	pc, r3, asr #6
    32c8:	50314250 	eorspl	r4, r1, r0, asr r2
    32cc:	70697265 	rsbvc	r7, r9, r5, ror #4
    32d0:	6f6c4368 	svcvs	0x006c4368
    32d4:	6d436b63 	vstrvs	d22, [r3, #-396]
    32d8:	06e90064 	strbteq	r0, [r9], r4, rrx
    32dc:	43520000 	cmpmi	r2, #0	; 0x0
    32e0:	50415f43 	subpl	r5, r1, r3, asr #30
    32e4:	65503242 	ldrbvs	r3, [r0, #-578]
    32e8:	68706972 	ldmdavs	r0!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    32ec:	65736552 	ldrbvs	r6, [r3, #-1362]!
    32f0:	646d4374 	strbtvs	r4, [sp], #-884
    32f4:	00071e00 	andeq	r1, r7, r0, lsl #28
    32f8:	43435200 	movtmi	r5, #12800	; 0x3200
    32fc:	4250415f 	subsmi	r4, r0, #-1073741801	; 0xc0000017
    3300:	72655031 	rsbvc	r5, r5, #49	; 0x31
    3304:	52687069 	rsbpl	r7, r8, #105	; 0x69
    3308:	74657365 	strbtvc	r7, [r5], #-869
    330c:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3310:	00000753 	andeq	r0, r0, r3, asr r7
    3314:	5f434352 	svcpl	0x00434352
    3318:	6b636142 	blvs	18db828 <__Stack_Size+0x18db428>
    331c:	65527075 	ldrbvs	r7, [r2, #-117]
    3320:	43746573 	cmnmi	r4, #482344960	; 0x1cc00000
    3324:	7a00646d 	bvc	1c4e0 <__Stack_Size+0x1c0e0>
    3328:	52000007 	andpl	r0, r0, #7	; 0x7
    332c:	435f4343 	cmpmi	pc, #201326593	; 0xc000001
    3330:	6b636f6c 	blvs	18df0e8 <__Stack_Size+0x18dece8>
    3334:	75636553 	strbvc	r6, [r3, #-1363]!
    3338:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    333c:	74737953 	ldrbtvc	r7, [r3], #-2387
    3340:	6d436d65 	stclvs	13, cr6, [r3, #-404]
    3344:	07a10064 	streq	r0, [r1, r4, rrx]!
    3348:	43520000 	cmpmi	r2, #0	; 0x0
    334c:	434d5f43 	movtmi	r5, #57155	; 0xdf43
    3350:	6e6f434f 	cdpvs	3, 6, cr4, cr15, cr15, {2}
    3354:	00676966 	rsbeq	r6, r7, r6, ror #18
    3358:	000007c8 	andeq	r0, r0, r8, asr #15
    335c:	5f434352 	svcpl	0x00434352
    3360:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    3364:	5367616c 	cmnpl	r7, #27	; 0x1b
    3368:	75746174 	ldrbvc	r6, [r4, #-372]!
    336c:	07fc0073 	undefined
    3370:	43520000 	cmpmi	r2, #0	; 0x0
    3374:	6c435f43 	mcrrvs	15, 4, r5, r3, cr3
    3378:	46726165 	ldrbtmi	r6, [r2], -r5, ror #2
    337c:	0067616c 	rsbeq	r6, r7, ip, ror #2
    3380:	00000810 	andeq	r0, r0, r0, lsl r8
    3384:	5f434352 	svcpl	0x00434352
    3388:	49746547 	ldmdbmi	r4!, {r0, r1, r2, r6, r8, sl, sp, lr}^
    338c:	61745354 	cmnvs	r4, r4, asr r3
    3390:	00737574 	rsbseq	r7, r3, r4, ror r5
    3394:	00000849 	andeq	r0, r0, r9, asr #16
    3398:	5f434352 	svcpl	0x00434352
    339c:	61656c43 	cmnvs	r5, r3, asr #24
    33a0:	50544972 	subspl	r4, r4, r2, ror r9
    33a4:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    33a8:	6942676e 	stmdbvs	r2, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    33ac:	00000074 	andeq	r0, r0, r4, ror r0
    33b0:	009d0000 	addseq	r0, sp, r0
    33b4:	00020000 	andeq	r0, r2, r0
    33b8:	0000a35a 	andeq	sl, r0, sl, asr r3
    33bc:	000001ef 	andeq	r0, r0, pc, ror #3
    33c0:	000000f7 	strdeq	r0, [r0], -r7
    33c4:	54737953 	ldrbtpl	r7, [r3], #-2387
    33c8:	5f6b6369 	svcpl	0x006b6369
    33cc:	534b4c43 	movtpl	r4, #48195	; 0xbc43
    33d0:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    33d4:	6e6f4365 	cdpvs	3, 6, cr4, cr15, cr5, {3}
    33d8:	00676966 	rsbeq	r6, r7, r6, ror #18
    33dc:	0000011c 	andeq	r0, r0, ip, lsl r1
    33e0:	54737953 	ldrbtpl	r7, [r3], #-2387
    33e4:	5f6b6369 	svcpl	0x006b6369
    33e8:	52746553 	rsbspl	r6, r4, #348127232	; 0x14c00000
    33ec:	616f6c65 	cmnvs	pc, r5, ror #24
    33f0:	01410064 	cmpeq	r1, r4, rrx
    33f4:	79530000 	ldmdbvc	r3, {}^
    33f8:	63695473 	cmnvs	r9, #1929379840	; 0x73000000
    33fc:	6f435f6b 	svcvs	0x00435f6b
    3400:	65746e75 	ldrbvs	r6, [r4, #-3701]!
    3404:	646d4372 	strbtvs	r4, [sp], #-882
    3408:	00016600 	andeq	r6, r1, r0, lsl #12
    340c:	73795300 	cmnvc	r9, #0	; 0x0
    3410:	6b636954 	blvs	18dd968 <__Stack_Size+0x18dd568>
    3414:	4354495f 	cmpmi	r4, #1556480	; 0x17c000
    3418:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    341c:	018b0067 	orreq	r0, fp, r7, rrx
    3420:	79530000 	ldmdbvc	r3, {}^
    3424:	63695473 	cmnvs	r9, #1929379840	; 0x73000000
    3428:	65475f6b 	strbvs	r5, [r7, #-3947]
    342c:	756f4374 	strbvc	r4, [pc, #-884]!	; 30c0 <__Stack_Size+0x2cc0>
    3430:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    3434:	0001a200 	andeq	sl, r1, r0, lsl #4
    3438:	73795300 	cmnvc	r9, #0	; 0x0
    343c:	6b636954 	blvs	18dd994 <__Stack_Size+0x18dd594>
    3440:	7465475f 	strbtvc	r4, [r5], #-1887
    3444:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    3448:	74617453 	strbtvc	r7, [r1], #-1107
    344c:	00007375 	andeq	r7, r0, r5, ror r3
    3450:	5b000000 	blpl	3458 <__Stack_Size+0x3058>
    3454:	02000002 	andeq	r0, r0, #2	; 0x2
    3458:	00a54900 	adceq	r4, r5, r0, lsl #18
    345c:	00095000 	andeq	r5, r9, r0
    3460:	0002b600 	andeq	fp, r2, r0, lsl #12
    3464:	41535500 	cmpmi	r3, r0, lsl #10
    3468:	535f5452 	cmppl	pc, #1375731712	; 0x52000000
    346c:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    3470:	696e4974 	stmdbvs	lr!, {r2, r4, r5, r6, r8, fp, lr}^
    3474:	02e10074 	rsceq	r0, r1, #116	; 0x74
    3478:	53550000 	cmppl	r5, #0	; 0x0
    347c:	5f545241 	svcpl	0x00545241
    3480:	636f6c43 	cmnvs	pc, #17152	; 0x4300
    3484:	696e496b 	stmdbvs	lr!, {r0, r1, r3, r5, r6, r8, fp, lr}^
    3488:	03300074 	teqeq	r0, #116	; 0x74
    348c:	53550000 	cmppl	r5, #0	; 0x0
    3490:	5f545241 	svcpl	0x00545241
    3494:	636f6c43 	cmnvs	pc, #17152	; 0x4300
    3498:	7274536b 	rsbsvc	r5, r4, #-1409286143	; 0xac000001
    349c:	49746375 	ldmdbmi	r4!, {r0, r2, r4, r5, r6, r8, r9, sp, lr}^
    34a0:	0074696e 	rsbseq	r6, r4, lr, ror #18
    34a4:	00000357 	andeq	r0, r0, r7, asr r3
    34a8:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    34ac:	6d435f54 	stclvs	15, cr5, [r3, #-336]
    34b0:	038c0064 	orreq	r0, ip, #100	; 0x64
    34b4:	53550000 	cmppl	r5, #0	; 0x0
    34b8:	5f545241 	svcpl	0x00545241
    34bc:	6f435449 	svcvs	0x00435449
    34c0:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    34c4:	00040d00 	andeq	r0, r4, r0, lsl #26
    34c8:	41535500 	cmpmi	r3, r0, lsl #10
    34cc:	445f5452 	ldrbmi	r5, [pc], #1106	; 34d4 <__Stack_Size+0x30d4>
    34d0:	6d43414d 	stfvse	f4, [r3, #-308]
    34d4:	04500064 	ldrbeq	r0, [r0], #-100
    34d8:	53550000 	cmppl	r5, #0	; 0x0
    34dc:	5f545241 	svcpl	0x00545241
    34e0:	41746553 	cmnmi	r4, r3, asr r5
    34e4:	65726464 	ldrbvs	r6, [r2, #-1124]!
    34e8:	85007373 	strhi	r7, [r0, #-883]
    34ec:	55000004 	strpl	r0, [r0, #-4]
    34f0:	54524153 	ldrbpl	r4, [r2], #-339
    34f4:	6b61575f 	blvs	1859278 <__Stack_Size+0x1858e78>
    34f8:	43705565 	cmnmi	r0, #423624704	; 0x19400000
    34fc:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    3500:	04bc0067 	ldrteq	r0, [ip], #103
    3504:	53550000 	cmppl	r5, #0	; 0x0
    3508:	5f545241 	svcpl	0x00545241
    350c:	65636552 	strbvs	r6, [r3, #-1362]!
    3510:	72657669 	rsbvc	r7, r5, #110100480	; 0x6900000
    3514:	656b6157 	strbvs	r6, [fp, #-343]!
    3518:	6d437055 	stclvs	0, cr7, [r3, #-340]
    351c:	04f10064 	ldrbteq	r0, [r1], #100
    3520:	53550000 	cmppl	r5, #0	; 0x0
    3524:	5f545241 	svcpl	0x00545241
    3528:	424e494c 	submi	r4, lr, #1245184	; 0x130000
    352c:	6b616572 	blvs	185cafc <__Stack_Size+0x185c6fc>
    3530:	65746544 	ldrbvs	r6, [r4, #-1348]!
    3534:	654c7463 	strbvs	r7, [ip, #-1123]
    3538:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    353c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3540:	28006769 	stmdacs	r0, {r0, r3, r5, r6, r8, r9, sl, sp, lr}
    3544:	55000005 	strpl	r0, [r0, #-5]
    3548:	54524153 	ldrbpl	r4, [r2], #-339
    354c:	4e494c5f 	mcrmi	12, 2, r4, cr9, cr15, {2}
    3550:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3554:	0000055d 	andeq	r0, r0, sp, asr r5
    3558:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    355c:	65535f54 	ldrbvs	r5, [r3, #-3924]
    3560:	6144646e 	cmpvs	r4, lr, ror #8
    3564:	94006174 	strls	r6, [r0], #-372
    3568:	55000005 	strpl	r0, [r0, #-5]
    356c:	54524153 	ldrbpl	r4, [r2], #-339
    3570:	6365525f 	cmnvs	r5, #-268435451	; 0xf0000005
    3574:	65766965 	ldrbvs	r6, [r6, #-2405]!
    3578:	61746144 	cmnvs	r4, r4, asr #2
    357c:	0005c100 	andeq	ip, r5, r0, lsl #2
    3580:	41535500 	cmpmi	r3, r0, lsl #10
    3584:	535f5452 	cmppl	pc, #1375731712	; 0x52000000
    3588:	42646e65 	rsbmi	r6, r4, #1616	; 0x650
    358c:	6b616572 	blvs	185cb5c <__Stack_Size+0x185c75c>
    3590:	0005e800 	andeq	lr, r5, r0, lsl #16
    3594:	41535500 	cmpmi	r3, r0, lsl #10
    3598:	535f5452 	cmppl	pc, #1375731712	; 0x52000000
    359c:	75477465 	strbvc	r7, [r7, #-1125]
    35a0:	54647261 	strbtpl	r7, [r4], #-609
    35a4:	00656d69 	rsbeq	r6, r5, r9, ror #26
    35a8:	0000061d 	andeq	r0, r0, sp, lsl r6
    35ac:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    35b0:	65535f54 	ldrbvs	r5, [r3, #-3924]
    35b4:	65725074 	ldrbvs	r5, [r2, #-116]!
    35b8:	6c616373 	stclvs	3, cr6, [r1], #-460
    35bc:	52007265 	andpl	r7, r0, #1342177286	; 0x50000006
    35c0:	55000006 	strpl	r0, [r0, #-6]
    35c4:	54524153 	ldrbpl	r4, [r2], #-339
    35c8:	616d535f 	cmnvs	sp, pc, asr r3
    35cc:	61437472 	cmpvs	r3, r2, ror r4
    35d0:	6d436472 	cfstrdvs	mvd6, [r3, #-456]
    35d4:	06870064 	streq	r0, [r7], r4, rrx
    35d8:	53550000 	cmppl	r5, #0	; 0x0
    35dc:	5f545241 	svcpl	0x00545241
    35e0:	72616d53 	rsbvc	r6, r1, #5312	; 0x14c0
    35e4:	72614374 	rsbvc	r4, r1, #-805306367	; 0xd0000001
    35e8:	43414e64 	movtmi	r4, #7780	; 0x1e64
    35ec:	646d434b 	strbtvs	r4, [sp], #-843
    35f0:	0006bc00 	andeq	fp, r6, r0, lsl #24
    35f4:	41535500 	cmpmi	r3, r0, lsl #10
    35f8:	485f5452 	ldmdami	pc, {r1, r4, r6, sl, ip, lr}^
    35fc:	44666c61 	strbtmi	r6, [r6], #-3169
    3600:	656c7075 	strbvs	r7, [ip, #-117]!
    3604:	646d4378 	strbtvs	r4, [sp], #-888
    3608:	0006f100 	andeq	pc, r6, r0, lsl #2
    360c:	41535500 	cmpmi	r3, r0, lsl #10
    3610:	495f5452 	ldmdbmi	pc, {r1, r4, r6, sl, ip, lr}^
    3614:	43414472 	movtmi	r4, #5234	; 0x1472
    3618:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    361c:	07280067 	streq	r0, [r8, -r7, rrx]!
    3620:	53550000 	cmppl	r5, #0	; 0x0
    3624:	5f545241 	svcpl	0x00545241
    3628:	41447249 	cmpmi	r4, r9, asr #4
    362c:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3630:	0000075d 	andeq	r0, r0, sp, asr r7
    3634:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    3638:	65475f54 	strbvs	r5, [r7, #-3924]
    363c:	616c4674 	smcvs	50276
    3640:	61745367 	cmnvs	r4, r7, ror #6
    3644:	00737574 	rsbseq	r7, r3, r4, ror r5
    3648:	000007a4 	andeq	r0, r0, r4, lsr #15
    364c:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    3650:	6c435f54 	mcrrvs	15, 5, r5, r3, cr4
    3654:	46726165 	ldrbtmi	r6, [r2], -r5, ror #2
    3658:	0067616c 	rsbeq	r6, r7, ip, ror #2
    365c:	000007db 	ldrdeq	r0, [r0], -fp
    3660:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    3664:	65475f54 	strbvs	r5, [r7, #-3924]
    3668:	53544974 	cmppl	r4, #1900544	; 0x1d0000
    366c:	75746174 	ldrbvc	r6, [r4, #-372]!
    3670:	08520073 	ldmdaeq	r2, {r0, r1, r4, r5, r6}^
    3674:	53550000 	cmppl	r5, #0	; 0x0
    3678:	5f545241 	svcpl	0x00545241
    367c:	61656c43 	cmnvs	r5, r3, asr #24
    3680:	50544972 	subspl	r4, r4, r2, ror r9
    3684:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    3688:	6942676e 	stmdbvs	r2, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    368c:	08a10074 	stmiaeq	r1!, {r2, r4, r5, r6}
    3690:	53550000 	cmppl	r5, #0	; 0x0
    3694:	5f545241 	svcpl	0x00545241
    3698:	74696e49 	strbtvc	r6, [r9], #-3657
    369c:	00092a00 	andeq	r2, r9, r0, lsl #20
    36a0:	41535500 	cmpmi	r3, r0, lsl #10
    36a4:	445f5452 	ldrbmi	r5, [pc], #1106	; 36ac <__Stack_Size+0x32ac>
    36a8:	696e4965 	stmdbvs	lr!, {r0, r2, r5, r6, r8, fp, lr}^
    36ac:	00000074 	andeq	r0, r0, r4, ror r0
    36b0:	00310000 	eorseq	r0, r1, r0
    36b4:	00020000 	andeq	r0, r2, r0
    36b8:	0000af23 	andeq	sl, r0, r3, lsr #30
    36bc:	00000106 	andeq	r0, r0, r6, lsl #2
    36c0:	00000052 	andeq	r0, r0, r2, asr r0
    36c4:	65736552 	ldrbvs	r6, [r3, #-1362]!
    36c8:	61485f74 	cmpvs	r8, r4, ror pc
    36cc:	656c646e 	strbvs	r6, [ip, #-1134]!
    36d0:	00ee0072 	rsceq	r0, lr, r2, ror r0
    36d4:	5f670000 	svcpl	0x00670000
    36d8:	566e6670 	undefined
    36dc:	6f746365 	svcvs	0x00746365
    36e0:	00007372 	andeq	r7, r0, r2, ror r3
    36e4:	19000000 	stmdbne	r0, {}
    36e8:	02000000 	andeq	r0, r0, #0	; 0x0
    36ec:	00b02900 	adcseq	r2, r0, r0, lsl #18
    36f0:	0000c500 	andeq	ip, r0, r0, lsl #10
    36f4:	00009c00 	andeq	r9, r0, r0, lsl #24
    36f8:	65746100 	ldrbvs	r6, [r4, #-256]!
    36fc:	00746978 	rsbseq	r6, r4, r8, ror r9
    3700:	00000000 	andeq	r0, r0, r0
    3704:	00000017 	andeq	r0, r0, r7, lsl r0
    3708:	b0ee0002 	rsclt	r0, lr, r2
    370c:	093a0000 	ldmdbeq	sl!, {}
    3710:	08ff0000 	ldmeq	pc!, {}^
    3714:	78650000 	stmdavc	r5!, {}^
    3718:	00007469 	andeq	r7, r0, r9, ror #8
    371c:	35000000 	strcc	r0, [r0]
    3720:	02000000 	andeq	r0, r0, #0	; 0x0
    3724:	00ba2800 	adcseq	r2, sl, r0, lsl #16
    3728:	00093a00 	andeq	r3, r9, r0, lsl #20
    372c:	00091000 	andeq	r1, r9, r0
    3730:	6d695f00 	stclvs	15, cr5, [r9]
    3734:	65727570 	ldrbvs	r7, [r2, #-1392]!
    3738:	7274705f 	rsbsvc	r7, r4, #95	; 0x5f
    373c:	00092200 	andeq	r2, r9, r0, lsl #4
    3740:	6c675f00 	stclvs	15, cr5, [r7]
    3744:	6c61626f 	sfmvs	f6, 2, [r1], #-444
    3748:	706d695f 	rsbvc	r6, sp, pc, asr r9
    374c:	5f657275 	svcpl	0x00657275
    3750:	00727470 	rsbseq	r7, r2, r0, ror r4
    3754:	00000000 	andeq	r0, r0, r0
    3758:	0000003a 	andeq	r0, r0, sl, lsr r0
    375c:	c3620002 	cmngt	r2, #2	; 0x2
    3760:	01460000 	cmpeq	r6, r0
    3764:	00800000 	addeq	r0, r0, r0
    3768:	5f5f0000 	svcpl	0x005f0000
    376c:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    3770:	6e69665f 	mcrvs	6, 3, r6, cr9, cr15, {2}
    3774:	72615f69 	rsbvc	r5, r1, #420	; 0x1a4
    3778:	00796172 	rsbseq	r6, r9, r2, ror r1
    377c:	000000b2 	strheq	r0, [r0], -r2
    3780:	696c5f5f 	stmdbvs	ip!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, fp, ip, lr}^
    3784:	695f6362 	ldmdbvs	pc, {r1, r5, r6, r8, r9, sp, lr}^
    3788:	5f74696e 	svcpl	0x0074696e
    378c:	61727261 	cmnvs	r2, r1, ror #4
    3790:	00000079 	andeq	r0, r0, r9, ror r0
    3794:	00190000 	andseq	r0, r9, r0
    3798:	00020000 	andeq	r0, r2, r0
    379c:	0000c4a8 	andeq	ip, r0, r8, lsr #9
    37a0:	0000010e 	andeq	r0, r0, lr, lsl #2
    37a4:	0000003e 	andeq	r0, r0, lr, lsr r0
    37a8:	636d656d 	cmnvs	sp, #457179136	; 0x1b400000
    37ac:	00007970 	andeq	r7, r0, r0, ror r9
    37b0:	19000000 	stmdbne	r0, {}
    37b4:	02000000 	andeq	r0, r0, #0	; 0x0
    37b8:	00c5b600 	sbceq	fp, r5, r0, lsl #12
    37bc:	00011300 	andeq	r1, r1, r0, lsl #6
    37c0:	00008800 	andeq	r8, r0, r0, lsl #16
    37c4:	6d656d00 	stclvs	13, cr6, [r5]
    37c8:	00746573 	rsbseq	r6, r4, r3, ror r5
    37cc:	00000000 	andeq	r0, r0, r0
    37d0:	00000026 	andeq	r0, r0, r6, lsr #32
    37d4:	c6c90002 	strbgt	r0, [r9], r2
    37d8:	09a50000 	stmibeq	r5!, {}
    37dc:	091e0000 	ldmdbeq	lr, {}
    37e0:	5f5f0000 	svcpl	0x005f0000
    37e4:	69676572 	stmdbvs	r7!, {r1, r4, r5, r6, r8, sl, sp, lr}^
    37e8:	72657473 	rsbvc	r7, r5, #1929379840	; 0x73000000
    37ec:	6978655f 	ldmdbvs	r8!, {r0, r1, r2, r3, r4, r6, r8, sl, sp, lr}^
    37f0:	6f727074 	svcvs	0x00727074
    37f4:	00000063 	andeq	r0, r0, r3, rrx
    37f8:	00230000 	eoreq	r0, r3, r0
    37fc:	00020000 	andeq	r0, r2, r0
    3800:	0000d06e 	andeq	sp, r0, lr, rrx
    3804:	000009b2 	strheq	r0, [r0], -r2
    3808:	000008ff 	strdeq	r0, [r0], -pc
    380c:	61635f5f 	cmnvs	r3, pc, asr pc
    3810:	655f6c6c 	ldrbvs	r6, [pc, #-3180]	; 2bac <__Stack_Size+0x27ac>
    3814:	70746978 	rsbsvc	r6, r4, r8, ror r9
    3818:	73636f72 	cmnvc	r3, #456	; 0x1c8
    381c:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000049 	andeq	r0, r0, r9, asr #32
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	tsteq	r4, r0
	...
      14:	69747263 	ldmdbvs	r4!, {r0, r1, r5, r6, r9, ip, sp, lr}^
      18:	6d73612e 	ldfvse	f6, [r3, #-184]!
      1c:	5c3a6300 	ldcpl	3, cr6, [sl]
      20:	616e6977 	smcvs	59031
      24:	5c736d72 	ldclpl	13, cr6, [r3], #-456
      28:	6c697562 	cfstr64vs	mvdx7, [r9], #-392
      2c:	63675c64 	cmnvs	r7, #25600	; 0x6400
      30:	75622d63 	strbvc	r2, [r2, #-3427]!
      34:	5c646c69 	stclpl	12, cr6, [r4], #-420
      38:	00636367 	rsbeq	r6, r3, r7, ror #6
      3c:	20554e47 	subscs	r4, r5, r7, asr #28
      40:	32205341 	eorcc	r5, r0, #67108865	; 0x4000001
      44:	2e38312e 	rsfcsep	f3, f0, #0.5
      48:	01003035 	tsteq	r0, r5, lsr r0
      4c:	00008080 	andeq	r8, r0, r0, lsl #1
      50:	12000200 	andne	r0, r0, #0	; 0x0
      54:	04000000 	streq	r0, [r0]
      58:	00004901 	andeq	r4, r0, r1, lsl #18
	...
      64:	2f2e2e00 	svccs	0x002e2e00
      68:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
      6c:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
      70:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
      74:	332e342d 	teqcc	lr, #754974720	; 0x2d000000
      78:	6c2f302e 	stcvs	0, cr3, [pc], #-184
      7c:	6c676269 	sfmvs	f6, 2, [r7], #-420
      80:	2f73736f 	svccs	0x0073736f
      84:	2f6d7261 	svccs	0x006d7261
      88:	30747263 	rsbscc	r7, r4, r3, ror #4
      8c:	6300532e 	movwvs	r5, #814	; 0x32e
      90:	69775c3a 	ldmdbvs	r7!, {r1, r3, r4, r5, sl, fp, ip, lr}^
      94:	6d72616e 	ldfvse	f6, [r2, #-440]!
      98:	75625c73 	strbvc	r5, [r2, #-3187]!
      9c:	5c646c69 	stclpl	12, cr6, [r4], #-420
      a0:	2d636367 	stclcs	3, cr6, [r3, #-412]!
      a4:	6c697562 	cfstr64vs	mvdx7, [r9], #-392
      a8:	72615c64 	rsbvc	r5, r1, #25600	; 0x6400
      ac:	61652d6d 	cmnvs	r5, sp, ror #26
      b0:	6c5c6962 	mrrcvs	9, 6, r6, ip, cr2
      b4:	6c676269 	sfmvs	f6, 2, [r7], #-420
      b8:	5c73736f 	ldclpl	3, cr7, [r3], #-444
      bc:	006d7261 	rsbeq	r7, sp, r1, ror #4
      c0:	20554e47 	subscs	r4, r5, r7, asr #28
      c4:	32205341 	eorcc	r5, r0, #67108865	; 0x4000001
      c8:	2e38312e 	rsfcsep	f3, f0, #0.5
      cc:	01003035 	tsteq	r0, r5, lsr r0
      d0:	00050d80 	andeq	r0, r5, r0, lsl #27
      d4:	26000200 	strcs	r0, [r0], -r0, lsl #4
      d8:	04000000 	streq	r0, [r0]
      dc:	0001fe01 	andeq	pc, r1, r1, lsl #28
      e0:	00470100 	subeq	r0, r7, r0, lsl #2
      e4:	02490000 	subeq	r0, r9, #0	; 0x0
      e8:	31340000 	teqcc	r4, r0
      ec:	344c0800 	strbcc	r0, [ip], #-2048
      f0:	00e30800 	rsceq	r0, r3, r0, lsl #16
      f4:	04020000 	streq	r0, [r2]
      f8:	00012205 	andeq	r2, r1, r5, lsl #4
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
      fc:	05020200 	streq	r0, [r2, #-512]
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
     100:	000004ca 	andeq	r0, r0, sl, asr #9

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
     104:	9e060102 	adflss	f0, f6, f2
     108:	03000004 	movweq	r0, #4	; 0x4
	nextframe_ = getMillis() + frameLength;
     10c:	00323375 	eorseq	r3, r2, r5, ror r3
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     110:	00452702 	subeq	r2, r5, r2, lsl #14
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
     114:	04020000 	streq	r0, [r2]
     118:	00013007 	andeq	r3, r1, r7
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     11c:	31750300 	cmncc	r5, r0, lsl #6
     120:	28020036 	stmdacs	r2, {r1, r2, r4, r5}
     124:	00000057 	andeq	r0, r0, r7, asr r0
		if (nextpose_[i] > pose_[i]) {
     128:	c5070202 	strgt	r0, [r7, #-514]
     12c:	03000001 	movweq	r0, #1	; 0x1
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
     130:	02003875 	andeq	r3, r0, #7667712	; 0x750000
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
     134:	00006829 	andeq	r6, r0, r9, lsr #16
     138:	08010200 	stmdaeq	r1, {r9}
     13c:	0000049c 	muleq	r0, ip, r4
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     140:	001faf04 	andseq	sl, pc, r4, lsl #30
     144:	682a0200 	stmdavs	sl!, {r9}
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
     148:	05000000 	streq	r0, [r0]
     14c:	29060704 	stmdbcs	r6, {r2, r8, r9, sl}
}
     150:	01000005 	tsteq	r0, r5
     154:	00b40d04 	adcseq	r0, r4, r4, lsl #26
     158:	ec070000 	stc	0, cr0, [r7], {0}
     15c:	00000003 	andeq	r0, r0, r3
     160:	0014bb07 	andseq	fp, r4, r7, lsl #22
     164:	63070100 	movwvs	r0, #28928	; 0x7100
     168:	02000000 	andeq	r0, r0, #0	; 0x0
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
     16c:	0004aa07 	andeq	sl, r4, r7, lsl #20
     170:	54080300 	strpl	r0, [r8], #-768
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
     174:	04004458 	streq	r4, [r0], #-1112
     178:	44585208 	ldrbmi	r5, [r8], #-520
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     17c:	41080500 	tstmi	r8, r0, lsl #10
     180:	06005855 	undefined
		nextpose_[i] = 512;
     184:	03020900 	movweq	r0, #10496	; 0x2900
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
     188:	000112cf 	andeq	r1, r1, pc, asr #5
		pose_[i] = 512;
     18c:	06b50700 	ldrteq	r0, [r5], r0, lsl #14
		nextpose_[i] = 512;
     190:	07010000 	streq	r0, [r1, -r0]
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
     194:	000004bc 	strheq	r0, [r0], -ip
     198:	038b0702 	orreq	r0, fp, #524288	; 0x80000
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
     19c:	07040000 	streq	r0, [r4, -r0]
     1a0:	000006c3 	andeq	r0, r0, r3, asr #13
	nextframe_ = getMillis();
     1a4:	05000708 	streq	r0, [r0, #-1800]
     1a8:	07100000 	ldreq	r0, [r0, -r0]
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     1ac:	00000169 	andeq	r0, r0, r9, ror #2
     1b0:	05c10720 	strbeq	r0, [r1, #1824]
     1b4:	00c00000 	sbceq	r0, r0, r0
     1b8:	00023b07 	andeq	r3, r2, r7, lsl #22
     1bc:	07018000 	streq	r8, [r1, -r0]
     1c0:	000006f6 	strdeq	r0, [r0], -r6
     1c4:	8e070280 	cdphi	2, 0, cr0, cr7, cr0, {4}
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1c8:	80000004 	andhi	r0, r0, r4
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
     1cc:	00260704 	eoreq	r0, r6, r4, lsl #14
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d0:	08800000 	stmeq	r0, {}
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1d4:	00032007 	andeq	r2, r3, r7
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d8:	07108000 	ldreq	r8, [r0, -r0]
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
     1dc:	0000015a 	andeq	r0, r0, sl, asr r1
     1e0:	0a002080 	beq	83e8 <__Stack_Size+0x7fe8>
		pose_[i] = 512;
		nextpose_[i] = 512;
     1e4:	016e0301 	cmneq	lr, r1, lsl #6
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1e8:	00000248 	andeq	r0, r0, r8, asr #4
		nextpose_[i] = 512;
     1ec:	00030d07 	andeq	r0, r3, r7, lsl #26
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
     1f0:	e8070000 	stmda	r7, {}
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
     1f4:	01000002 	tsteq	r0, r2
     1f8:	0005f107 	andeq	pc, r5, r7, lsl #2
	interpolating = 0;
     1fc:	d9070200 	stmdble	r7, {r9}
	nextframe_ = getMillis();
     200:	03000002 	movweq	r0, #2	; 0x2
     204:	0000b807 	andeq	fp, r0, r7, lsl #16
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     208:	c6070400 	strgt	r0, [r7], -r0, lsl #8
     20c:	05000000 	streq	r0, [r0]
     210:	0005cc07 	andeq	ip, r5, r7, lsl #24
     214:	ac070600 	stcge	6, cr0, [r7], {0}
     218:	07000005 	streq	r0, [r0, -r5]
     21c:	0001d807 	andeq	sp, r1, r7, lsl #16
     220:	af070800 	svcge	0x00070800
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
     224:	09000001 	stmdbeq	r0, {r0}
     228:	00066907 	andeq	r6, r6, r7, lsl #18
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
     22c:	d4070a00 	strle	r0, [r7], #-2560
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
     230:	0b000004 	bleq	248 <_Minimum_Stack_Size+0x148>
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
     234:	00047507 	andeq	r7, r4, r7, lsl #10
     238:	03070c00 	movweq	r0, #31744	; 0x7c00
	dxl_set_txpacket_parameter(1, 2);
     23c:	0d000001 	stceq	0, cr0, [r0, #-4]
     240:	00036507 	andeq	r6, r3, r7, lsl #10
     244:	54070e00 	strpl	r0, [r7], #-3584
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     248:	0f000003 	svceq	0x00000003
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
     24c:	00008c07 	andeq	r8, r0, r7, lsl #24
     250:	f2071000 	vhadd.s8	d1, d7, d0
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     254:	11000004 	tstne	r0, r4
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     258:	00063707 	andeq	r3, r6, r7, lsl #14
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     25c:	34071200 	strcc	r1, [r7], #-512
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     260:	13000000 	movwne	r0, #0	; 0x0
     264:	00054607 	andeq	r4, r5, r7, lsl #12
     268:	2f071400 	svccs	0x00071400
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     26c:	15000005 	strne	r0, [r0, #-5]
     270:	00039e07 	andeq	r9, r3, r7, lsl #28
     274:	76071600 	strvc	r1, [r7], -r0, lsl #12
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     278:	17000003 	strne	r0, [r0, -r3]
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     27c:	00046307 	andeq	r6, r4, r7, lsl #6
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
     280:	6b071800 	blvs	1c6288 <__Stack_Size+0x1c5e88>
     284:	19000000 	stmdbne	r0, {}
     288:	00007307 	andeq	r7, r0, r7, lsl #6
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
     28c:	3a071a00 	bcc	1c6a94 <__Stack_Size+0x1c6694>
     290:	1b000003 	blne	2a4 <_Minimum_Stack_Size+0x1a4>
     294:	00069507 	andeq	r9, r6, r7, lsl #10
	dxl_txrx_packet();
     298:	0a071c00 	beq	1c72a0 <__Stack_Size+0x1c6ea0>
	u16 CommStatus = dxl_get_result();
     29c:	1d000002 	stcne	0, cr0, [r0, #-8]
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
     2a0:	00067a07 	andeq	r7, r6, r7, lsl #20
		PrintErrorCode();
     2a4:	55071e00 	strpl	r1, [r7, #-3584]
	else
		PrintCommStatus(CommStatus);
     2a8:	1f000006 	svcne	0x00000006
#endif
}
     2ac:	00062407 	andeq	r2, r6, r7, lsl #8
     2b0:	06072000 	streq	r2, [r7], -r0
     2b4:	21000006 	tstcs	r0, r6
     2b8:	00043507 	andeq	r3, r4, r7, lsl #10
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
     2bc:	18072200 	stmdane	r7, {r9, sp}
     2c0:	23000004 	movwcs	r0, #4	; 0x4

	if (interpolating == 0)
     2c4:	0003d507 	andeq	sp, r3, r7, lsl #10
		return 0;
	int i;
	int complete = poseSize;
     2c8:	be072400 	cfcpyslt	mvf2, mvf7
	if (!fWait) {
     2cc:	25000003 	strcs	r0, [r0, #-3]
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
     2d0:	00059007 	andeq	r9, r5, r7
     2d4:	7c072600 	stcvc	6, cr2, [r7], {0}
     2d8:	27000005 	strcs	r0, [r0, -r5]
			return (getMillis() - nextframe_); // We still have some time to do something...
     2dc:	00070407 	andeq	r0, r7, r7, lsl #8
     2e0:	e3072800 	movw	r2, #30720	; 0x7800
     2e4:	29000006 	stmdbcs	r0, {r1, r2}
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
     2e8:	00001207 	andeq	r1, r0, r7, lsl #4
     2ec:	42072a00 	andmi	r2, r7, #0	; 0x0
     2f0:	2b000001 	blcs	2fc <_Minimum_Stack_Size+0x1fc>
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     2f4:	00044807 	andeq	r4, r4, r7, lsl #16
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     2f8:	2c072c00 	stccs	12, cr2, [r7], {0}
     2fc:	2d000002 	stccs	0, cr0, [r0, #-8]
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     300:	0003b307 	andeq	fp, r3, r7, lsl #6
     304:	23072e00 	movwcs	r2, #32256	; 0x7e00
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     308:	2f000002 	svccs	0x00000002
		int diff = nextpose_[i] - pose_[i];
     30c:	00018a07 	andeq	r8, r1, r7, lsl #20
     310:	7e073000 	cdpvc	0, 0, cr3, cr7, cr0, {0}
     314:	31000001 	tstcc	r0, r1
     318:	05080200 	streq	r0, [r8, #-512]
     31c:	0000011d 	andeq	r0, r0, sp, lsl r1
		if (diff == 0) {
     320:	2b070802 	blcs	1c2330 <__Stack_Size+0x1c1f30>
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     324:	0b000001 	bleq	330 <_Minimum_Stack_Size+0x230>
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
     328:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     32c:	04020074 	streq	r0, [r2], #-116
					pose_[i] = nextpose_[i];
     330:	00013507 	andeq	r3, r1, r7, lsl #10
					complete--;
     334:	01960600 	orrseq	r0, r6, r0, lsl #12
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     338:	05010000 	streq	r0, [r1]
     33c:	00029b20 	andeq	r9, r2, r0, lsr #22
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     340:	05e90700 	strbeq	r0, [r9, #1792]!
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     344:	07000000 	streq	r0, [r0, -r0]
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     348:	000006db 	ldrdeq	r0, [r0], -fp
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     34c:	00e40701 	rsceq	r0, r4, r1, lsl #14
     350:	07020000 	streq	r0, [r2, -r0]
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
     354:	000001a7 	andeq	r0, r0, r7, lsr #3
		interpolating = 0;
     358:	02870703 	addeq	r0, r7, #786432	; 0xc0000
	BioloidControllerEx_writePose();
     35c:	07040000 	streq	r0, [r4, -r0]
     360:	00000396 	muleq	r0, r6, r3
	return 0;
}
     364:	02b30705 	adcseq	r0, r3, #1310720	; 0x140000
     368:	00060000 	andeq	r0, r6, r0
     36c:	00028f06 	andeq	r8, r2, r6, lsl #30
     370:	0d060100 	stfeqs	f0, [r6]
     374:	000002cb 	andeq	r0, r0, fp, asr #5
     378:	00505508 	subseq	r5, r0, r8, lsl #10
     37c:	06450700 	strbeq	r0, [r5], -r0, lsl #14
     380:	07010000 	streq	r0, [r1, -r0]
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
     384:	00000000 	andeq	r0, r0, r0
     388:	055d0702 	ldrbeq	r0, [sp, #-1794]
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
     38c:	07030000 	streq	r0, [r3, -r0]
     390:	00000401 	andeq	r0, r0, r1, lsl #8
     394:	494d0804 	stmdbmi	sp, {r2, fp}^
     398:	00050043 	andeq	r0, r5, r3, asr #32
     39c:	0000aa06 	andeq	sl, r0, r6, lsl #20
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
     3a0:	0d070200 	sfmeq	f0, 4, [r7]

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
     3a4:	00000360 	andeq	r0, r0, r0, ror #6
     3a8:	0003fa07 	andeq	pc, r3, r7, lsl #20
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
     3ac:	01eef200 	mvneq	pc, r0, lsl #4
     3b0:	00052107 	andeq	r2, r5, r7, lsl #2
     3b4:	01e1be00 	mvneq	fp, r0, lsl #28
     3b8:	0005a407 	andeq	sl, r5, r7, lsl #8
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
     3bc:	01e1be00 	mvneq	fp, r0, lsl #28
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
     3c0:	0002ac07 	andeq	sl, r2, r7, lsl #24
     3c4:	01d4ea00 	bicseq	lr, r4, r0, lsl #20
     3c8:	0005e107 	andeq	lr, r5, r7, lsl #2
     3cc:	01c8f100 	biceq	pc, r8, r0, lsl #2
     3d0:	0006ad07 	andeq	sl, r6, r7, lsl #26
     3d4:	01c8f100 	biceq	pc, r8, r0, lsl #2
     3d8:	00040707 	andeq	r0, r4, r7, lsl #14
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
     3dc:	01bdce00 	undefined instruction 0x01bdce00
     3e0:	0002b807 	andeq	fp, r2, r7, lsl #16
     3e4:	01b2fc00 	undefined instruction 0x01b2fc00
     3e8:	0000dc07 	andeq	sp, r0, r7, lsl #24
     3ec:	01a8f600 	undefined instruction 0x01a8f600
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     3f0:	00017607 	andeq	r7, r1, r7, lsl #12
     3f4:	01a8f600 	undefined instruction 0x01a8f600
     3f8:	0002bf07 	andeq	fp, r2, r7, lsl #30
     3fc:	019fb800 	orrseq	fp, pc, r0, lsl #16
     400:	00019f07 	andeq	r9, r1, r7, lsl #30
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
     404:	0196bf00 	orrseq	fp, r6, r0, lsl #30
     408:	0002c607 	andeq	ip, r2, r7, lsl #12
     40c:	0196bf00 	orrseq	fp, r6, r0, lsl #30
     410:	00029e07 	andeq	r9, r2, r7, lsl #28
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
     414:	018e8600 	orreq	r8, lr, r0, lsl #12
     418:	0002e007 	andeq	lr, r2, r7
     41c:	01868900 	orreq	r8, r6, r0, lsl #18
     420:	0003f207 	andeq	pc, r3, r7, lsl #4
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
     424:	01868900 	orreq	r8, r6, r0, lsl #18
     428:	0002a507 	andeq	sl, r2, r7, lsl #10
     42c:	00fec600 	rscseq	ip, lr, r0, lsl #12
     430:	98010c00 	stmdals	r1, {sl, fp}
     434:	01000002 	tsteq	r0, r2
     438:	313401ee 	teqcc	r4, lr, ror #3
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     43c:	31360800 	teqcc	r6, r0, lsl #16
     440:	5d010800 	stcpl	8, cr0, [r1]
     444:	1381010d 	orrne	r0, r1, #1073741827	; 0x40000003
     448:	17010000 	strne	r0, [r1, -r0]
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     44c:	00025601 	andeq	r5, r2, r1, lsl #12
     450:	00313800 	eorseq	r3, r1, r0, lsl #16
     454:	00344c08 	eorseq	r4, r4, r8, lsl #24
     458:	00000008 	andeq	r0, r0, r8
     45c:	00042000 	andeq	r2, r4, r0
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     460:	05140e00 	ldreq	r0, [r4, #-3584]
     464:	1c010000 	stcne	0, cr0, [r1], {0}
     468:	0000006f 	andeq	r0, r0, pc, rrx
     46c:	0000002b 	andeq	r0, r0, fp, lsr #32
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     470:	00050c0f 	andeq	r0, r5, pc, lsl #24
     474:	201d0100 	andscs	r0, sp, r0, lsl #2
     478:	0f000004 	svceq	0x00000004
     47c:	000001ee 	andeq	r0, r0, lr, ror #3
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
     480:	04371e01 	ldrteq	r1, [r7], #-3585
     484:	fb100000 	blx	40048e <__Stack_Size+0x40008e>
     488:	01000002 	tsteq	r0, r2
     48c:	02560124 	subseq	r0, r6, #9	; 0x9
     490:	cc010000 	stcgt	0, cr0, [r1], {0}
     494:	11000003 	tstne	r0, r3
     498:	00000256 	andeq	r0, r0, r6, asr r2
     49c:	31f41200 	mvnscc	r1, r0, lsl #4
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     4a0:	32c20800 	sbccc	r0, r2, #0	; 0x0
     4a4:	69130800 	ldmdbvs	r3, {fp}
     4a8:	69010064 	stmdbvs	r1, {r2, r5, r6}
     4ac:	0000005e 	andeq	r0, r0, lr, asr r0
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     4b0:	6e135601 	cfmsub32vs	mvax0, mvfx5, mvfx3, mvfx1
     4b4:	01006d75 	tsteq	r0, r5, ror sp
     4b8:	00005e69 	andeq	r5, r0, r9, ror #28
     4bc:	0e570100 	rdfeqs	f0, f7, f0
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     4c0:	000000a4 	andeq	r0, r0, r4, lsr #1
     4c4:	004c6a01 	subeq	r6, ip, r1, lsl #20
     4c8:	00960000 	addseq	r0, r6, r0
		GaitPosY[GaitCurrentLegNr] = 0;
     4cc:	080f0000 	stmdaeq	pc, {}
     4d0:	0100001e 	tsteq	r0, lr, lsl r0
	}

	//Move body forward
	else {
		GaitPosX[GaitCurrentLegNr] = GaitPosX[GaitCurrentLegNr]
     4d4:	00004c6a 	andeq	r4, r0, sl, ror #24
     4d8:	05630f00 	strbeq	r0, [r3, #-3840]!
     4dc:	6a010000 	bvs	404e4 <__Stack_Size+0x400e4>
     4e0:	0000004c 	andeq	r0, r0, ip, asr #32
     4e4:	00068e0f 	andeq	r8, r6, pc, lsl #28
     4e8:	4c6a0100 	stfmie	f0, [sl]
				- (g_InControlState.TravelLength.x
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitPosY[GaitCurrentLegNr] = 0;
     4ec:	00000000 	andeq	r0, r0, r0
     4f0:	04301400 	ldrteq	r1, [r0], #-1024
     4f4:	04300000 	ldrteq	r0, [r0]
		GaitPosZ[GaitCurrentLegNr] = GaitPosZ[GaitCurrentLegNr]
     4f8:	7a150000 	bvc	540500 <__Stack_Size+0x540100>
     4fc:	7f000000 	svcvc	0x00000000
     500:	08010200 	stmdaeq	r1, {r9}
     504:	000004a5 	andeq	r0, r0, r5, lsr #9
				- (g_InControlState.TravelLength.z
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitRotY[GaitCurrentLegNr] = GaitRotY[GaitCurrentLegNr]
     508:	04300416 	ldrteq	r0, [r0], #-1046
     50c:	690f0000 	stmdbvs	pc, {}
     510:	08000005 	stmdaeq	r0, {r0, r2}
     514:	0004482a 	andeq	r4, r4, sl, lsr #16
				- (g_InControlState.TravelLength.y
						/ (short) g_InControlState.gaitCur.TLDivFactor);
	}

}
     518:	005e1700 	subseq	r1, lr, r0, lsl #14
     51c:	ce0f0000 	cdpgt	0, 0, cr0, cr15, cr0, {0}
     520:	08000002 	stmdaeq	r0, {r1}
     524:	00045828 	andeq	r5, r4, r8, lsr #16
     528:	004c1700 	subeq	r1, ip, r0, lsl #14
     52c:	2b0f0000 	blcs	3c0534 <__Stack_Size+0x3c0134>
     530:	08000004 	stmdaeq	r0, {r2}

}

//--------------------------------------------------------------------
//[GAIT Sequence]
void GaitSeq(void) {
     534:	00045828 	andeq	r5, r4, r8, lsr #16
	//Check if the Gait is in motion - If not if we are going to start a motion try to align our Gaitstep to start with a good foot
	// for the direction we are about to go...

	if (fWalking || (g_InControlState.ForceGaitStepCnt != 0))
     538:	005e1400 	subseq	r1, lr, r0, lsl #8
     53c:	04790000 	ldrbteq	r0, [r9]
     540:	7a180000 	bvc	600548 <__Stack_Size+0x600148>
		TravelRequest = true;   // Is walking or was walking...
     544:	ff000000 	undefined instruction 0xff000000
     548:	af0f0003 	svcge	0x000f0003
	else {
		TravelRequest = (abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
     54c:	08000004 	stmdaeq	r0, {r2}
     550:	00048429 	andeq	r8, r4, r9, lsr #8
     554:	04681700 	strbteq	r1, [r8], #-1792
     558:	4a190000 	bmi	640560 <__Stack_Size+0x640160>
     55c:	08000006 	stmdaeq	r0, {r1, r2}
     560:	00044844 	andeq	r4, r4, r4, asr #16
     564:	0e190000 	wxoreq	wr0, wr9, wr0
     568:	08000004 	stmdaeq	r0, {r2}
     56c:	00044844 	andeq	r4, r4, r4, asr #16
     570:	5e140000 	wxorpl	wr0, wr4, wr0
     574:	b1000000 	tstlt	r0, r0
     578:	15000004 	strne	r0, [r0, #-4]
     57c:	0000007a 	andeq	r0, r0, sl, ror r0
				|| (abs(g_InControlState.TravelLength.y) > cTravelDeadZone);

		if (TravelRequest) {

		} else {    //Clear values under the cTravelDeadZone
			g_InControlState.TravelLength.x = 0;
     580:	ec0f0040 	stc	0, cr0, [pc], {64}
			g_InControlState.TravelLength.z = 0;
     584:	08000000 	stmdaeq	r0, {}
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     588:	0004bc45 	andeq	fp, r4, r5, asr #24
     58c:	04a11700 	strteq	r1, [r1], #1792
     590:	19190000 	ldmdbne	r9, {}
		Gait(LegIndex);
     594:	08000006 	stmdaeq	r0, {r1, r2}
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     598:	00045858 	andeq	r5, r4, r8, asr r8
     59c:	f9190000 	undefined instruction 0xf9190000
     5a0:	08000000 	stmdaeq	r0, {}
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5a4:	00045858 	andeq	r5, r4, r8, asr r8
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5a8:	2d0f0000 	stccs	0, cr0, [pc]
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5ac:	08000003 	stmdaeq	r0, {r0, r1}
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5b0:	0004e459 	andeq	lr, r4, r9, asr r4
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5b4:	04681700 	strbteq	r1, [r8], #-1792
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
		g_InControlState.GaitStep = 1;
     5b8:	ce1a0000 	wxorgt	wr0, wr10, wr0
     5bc:	08000006 	stmdaeq	r0, {r1, r2}

	// If we have a force count decrement it now...
	if (g_InControlState.ForceGaitStepCnt)
     5c0:	00003a14 	andeq	r3, r0, r4, lsl sl
     5c4:	1a010100 	bne	409cc <__Stack_Size+0x405cc>
		g_InControlState.ForceGaitStepCnt--;
     5c8:	00000005 	andeq	r0, r0, r5
}
     5cc:	003a1708 	eorseq	r1, sl, r8, lsl #14
     5d0:	01010000 	tsteq	r1, r0
     5d4:	0000561a 	andeq	r5, r0, sl, lsl r6
     5d8:	3a1a0800 	bcc	6825e0 <__Stack_Size+0x6821e0>
     5dc:	01000000 	tsteq	r0, r0
}
//--------------------------------------------------------------------
//[BalanceBody]
void BalanceBody(void) {

	TotalTransZ = TotalTransZ / BalanceDivFactor;
     5e0:	06690001 	strbteq	r0, [r9], -r1
     5e4:	00020000 	andeq	r0, r2, r0
     5e8:	00000175 	andeq	r0, r0, r5, ror r1
     5ec:	01fe0104 	mvnseq	r0, r4, lsl #2
     5f0:	55010000 	strpl	r0, [r1]
	TotalTransX = TotalTransX / BalanceDivFactor;
     5f4:	4900000a 	stmdbmi	r0, {r1, r3}
     5f8:	4c000002 	stcmi	0, cr0, [r0], {2}
     5fc:	80080034 	andhi	r0, r8, r4, lsr r0
	TotalTransY = TotalTransY / BalanceDivFactor;
     600:	2b080035 	blcs	2006dc <__Stack_Size+0x2002dc>
     604:	02000002 	andeq	r0, r0, #2	; 0x2
     608:	01220504 	teqeq	r2, r4, lsl #10
     60c:	02020000 	andeq	r0, r2, #0	; 0x0

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     610:	0004ca05 	andeq	ip, r4, r5, lsl #20
     614:	06010200 	streq	r0, [r1], -r0, lsl #4
	TotalTransX = TotalTransX / BalanceDivFactor;
	TotalTransY = TotalTransY / BalanceDivFactor;

#ifndef QUADMODE // ??? on PhantomX Hex at no movment YBal1 = 1800, on Quad = 0...  Need to experiment
	if (TotalYBal1 > 0)        //Rotate balance circle by +/- 180 deg
		TotalYBal1 -= 1800;
     618:	0000049e 	muleq	r0, lr, r4
     61c:	30070402 	andcc	r0, r7, r2, lsl #8
	else
		TotalYBal1 += 1800;
     620:	03000001 	movweq	r0, #1	; 0x1
#endif

	if (TotalZBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     624:	00363175 	eorseq	r3, r6, r5, ror r1
     628:	004c2802 	subeq	r2, ip, r2, lsl #16
     62c:	02020000 	andeq	r0, r2, #0	; 0x0
		TotalZBal1 += 3600;
     630:	0001c507 	andeq	ip, r1, r7, lsl #10
     634:	38750300 	ldmdacc	r5!, {r8, r9}^

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     638:	5d290200 	sfmpl	f0, 4, [r9]
     63c:	02000000 	andeq	r0, r0, #0	; 0x0
		TotalXBal1 += 3600;
     640:	049c0801 	ldreq	r0, [ip], #2049
     644:	04040000 	streq	r0, [r4]

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     648:	f8010507 	undefined instruction 0xf8010507
     64c:	0100000b 	tsteq	r0, fp
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     650:	344c0128 	strbcc	r0, [ip], #-296
     654:	344e0800 	strbcc	r0, [lr], #-2048
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     658:	5d010800 	stcpl	8, cr0, [r1]
	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     65c:	09fa0105 	ldmibeq	sl!, {r0, r2, r8}^
     660:	33010000 	movwcc	r0, #4096	; 0x1000
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     664:	00345001 	eorseq	r5, r4, r1
     668:	00345208 	eorseq	r5, r4, r8, lsl #4

}
     66c:	055d0108 	ldrbeq	r0, [sp, #-264]
     670:	000c3101 	andeq	r3, ip, r1, lsl #2
     674:	01420100 	cmpeq	r2, r0, lsl #2
     678:	08003454 	stmdaeq	r0, {r2, r4, r6, sl, ip, sp}
     67c:	08003456 	stmdaeq	r0, {r1, r2, r4, r6, sl, ip, sp}
     680:	01055d01 	tsteq	r5, r1, lsl #26
     684:	00000832 	andeq	r0, r0, r2, lsr r8
     688:	58015101 	stmdapl	r1, {r0, r8, ip, lr}
//sin4        - Output Sinus of AngleDeg
//cos4          - Output Cosinus of AngleDeg
void GetSinCos(short AngleDeg1) {
	short ABSAngleDeg1;   //Absolute value of the Angle in Degrees, decimals = 1
	//Get the absolute value of AngleDeg
	if (AngleDeg1 < 0)
     68c:	5a080034 	bpl	200764 <__Stack_Size+0x200364>
     690:	01080034 	tsteq	r8, r4, lsr r0
		ABSAngleDeg1 = AngleDeg1 * -1;
     694:	8101055d 	tsthi	r1, sp, asr r5
     698:	01000007 	tsteq	r0, r7
	else
		ABSAngleDeg1 = AngleDeg1;

	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
     69c:	345c0160 	ldrbcc	r0, [ip], #-352
     6a0:	345e0800 	ldrbcc	r0, [lr], #-2048
     6a4:	5d010800 	stcpl	8, cr0, [r1]
     6a8:	0a350105 	beq	d40ac4 <__Stack_Size+0xd406c4>
     6ac:	6f010000 	svcvs	0x00010000
     6b0:	00346001 	eorseq	r6, r4, r1
     6b4:	00346208 	eorseq	r6, r4, r8, lsl #4
     6b8:	055d0108 	ldrbeq	r0, [sp, #-264]
     6bc:	00096b01 	andeq	r6, r9, r1, lsl #22
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
     6c0:	017a0100 	cmneq	sl, r0, lsl #2
     6c4:	08003464 	stmdaeq	r0, {r2, r5, r6, sl, ip, sp}
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6c8:	08003466 	stmdaeq	r0, {r1, r2, r5, r6, sl, ip, sp}
     6cc:	01055d01 	tsteq	r5, r1, lsl #26
     6d0:	00000b52 	andeq	r0, r0, r2, asr fp
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6d4:	68018501 	stmdavs	r1, {r0, r8, sl, pc}
     6d8:	6a080034 	bvs	2007b0 <__Stack_Size+0x2003b0>
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6dc:	01080034 	tsteq	r8, r4, lsr r0
     6e0:	6c01055d 	cfstr32vs	mvfx0, [r1], {93}
     6e4:	0100000a 	tsteq	r0, sl
     6e8:	346c019c 	strbtcc	r0, [ip], #-412
     6ec:	346e0800 	strbtcc	r0, [lr], #-2048
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6f0:	5d010800 	stcpl	8, cr0, [r1]
     6f4:	09320105 	ldmdbeq	r2!, {r0, r2, r8}
     6f8:	a7010000 	strge	r0, [r1, -r0]
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
     6fc:	00347001 	eorseq	r7, r4, r1
     700:	00347208 	eorseq	r7, r4, r8, lsl #4
     704:	055d0108 	ldrbeq	r0, [sp, #-264]
     708:	00076f01 	andeq	r6, r7, r1, lsl #30
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     70c:	01b20100 	undefined instruction 0x01b20100
     710:	08003474 	stmdaeq	r0, {r2, r4, r5, r6, sl, ip, sp}
     714:	08003476 	stmdaeq	r0, {r1, r2, r4, r5, r6, sl, ip, sp}
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     718:	01055d01 	tsteq	r5, r1, lsl #26
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     71c:	000007be 	strheq	r0, [r0], -lr
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     720:	7801bd01 	stmdavc	r1, {r0, r8, sl, fp, ip, sp, pc}
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     724:	7a080034 	bvc	2007fc <__Stack_Size+0x2003fc>
     728:	01080034 	tsteq	r8, r4, lsr r0
     72c:	bc01055d 	cfstr32lt	mvfx0, [r1], {93}
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     730:	0100000a 	tsteq	r0, sl
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     734:	347c01c8 	ldrbtcc	r0, [ip], #-456
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     738:	347e0800 	ldrbtcc	r0, [lr], #-2048
     73c:	5d010800 	stcpl	8, cr0, [r1]
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
     740:	0a0d0105 	beq	340b5c <__Stack_Size+0x34075c>
     744:	d3010000 	movwle	r0, #4096	; 0x1000
     748:	00348001 	eorseq	r8, r4, r1
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     74c:	00348208 	eorseq	r8, r4, r8, lsl #4
     750:	055d0108 	ldrbeq	r0, [sp, #-264]
     754:	0009d601 	andeq	sp, r9, r1, lsl #12
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     758:	01de0100 	bicseq	r0, lr, r0, lsl #2
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     75c:	08003484 	stmdaeq	r0, {r2, r7, sl, ip, sp}
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     760:	08003486 	stmdaeq	r0, {r1, r2, r7, sl, ip, sp}
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     764:	01055d01 	tsteq	r5, r1, lsl #26
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     768:	00000908 	andeq	r0, r0, r8, lsl #18
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     76c:	8801e901 	stmdahi	r1, {r0, r8, fp, sp, lr, pc}
     770:	8a080034 	bhi	200848 <__Stack_Size+0x200448>
     774:	01080034 	tsteq	r8, r4, lsr r0
     778:	ce01055d 	cfrshl32gt	mvfx1, mvfx13, r0
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     77c:	0100000b 	tsteq	r0, fp
     780:	348c01f4 	strcc	r0, [ip], #500
     784:	348e0800 	strcc	r0, [lr], #2048
     788:	5d010800 	stcpl	8, cr0, [r1]
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
     78c:	09760105 	ldmdbeq	r6!, {r0, r2, r8}^
     790:	ff010000 	undefined instruction 0xff010000
     794:	00349001 	eorseq	r9, r4, r1
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     798:	00349208 	eorseq	r9, r4, r8, lsl #4
     79c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     7a0:	0009c501 	andeq	ip, r9, r1, lsl #10
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7a4:	010a0100 	tsteq	sl, r0, lsl #2
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7a8:	00349401 	eorseq	r9, r4, r1, lsl #8
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7ac:	00349608 	eorseq	r9, r4, r8, lsl #12
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b0:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7b4:	000bb501 	andeq	fp, fp, r1, lsl #10
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b8:	01150100 	tsteq	r5, r0, lsl #2
     7bc:	00349801 	eorseq	r9, r4, r1, lsl #16
     7c0:	00349a08 	eorseq	r9, r4, r8, lsl #20
     7c4:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7c8:	000bdf01 	andeq	sp, fp, r1, lsl #30
     7cc:	01200100 	teqeq	r0, r0, lsl #2
     7d0:	00349c01 	eorseq	r9, r4, r1, lsl #24
	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));
     7d4:	00349e08 	eorseq	r9, r4, r8, lsl #28
     7d8:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     7dc:	000c1801 	andeq	r1, ip, r1, lsl #16
     7e0:	012b0100 	teqeq	fp, r0, lsl #2
     7e4:	0034a001 	eorseq	sl, r4, r1
     7e8:	0034a208 	eorseq	sl, r4, r8, lsl #4
     7ec:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     7f0:	00072a01 	andeq	r2, r7, r1, lsl #20
     7f4:	01360100 	teqeq	r6, r0, lsl #2
     7f8:	0034a401 	eorseq	sl, r4, r1, lsl #8
	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
	}
}
     7fc:	0034a608 	eorseq	sl, r4, r8, lsl #12
     800:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     804:	00079501 	andeq	r9, r7, r1, lsl #10
     808:	01410100 	cmpeq	r1, r0, lsl #2
     80c:	0034a801 	eorseq	sl, r4, r1, lsl #16
//cos4        - Input Cosinus
//AngleRad4     - Output Angle in AngleRad4
long GetArcCos(short cos4) {
	boolean NegativeValue/*:1*/;    //If the the value is Negative
	//Check for negative value
	if (cos4 < 0) {
     810:	0034aa08 	eorseq	sl, r4, r8, lsl #20
     814:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     818:	000a1c01 	andeq	r1, sl, r1, lsl #24
		cos4 = -cos4;
     81c:	014c0100 	cmpeq	ip, r0, lsl #2
     820:	0034ac01 	eorseq	sl, r4, r1, lsl #24
		NegativeValue = 1;
	} else
		NegativeValue = 0;

	//Limit cos4 to his maximal value
	cos4 = min(cos4, c4DEC);
     824:	0034ae08 	eorseq	sl, r4, r8, lsl #28
     828:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     82c:	000a7c01 	andeq	r7, sl, r1, lsl #24

	if ((cos4 >= 0) && (cos4 < 9000)) {
     830:	01570100 	cmpeq	r7, r0, lsl #2
     834:	0034b001 	eorseq	fp, r4, r1
     838:	0034b208 	eorseq	fp, r4, r8, lsl #4
		AngleRad4 = (byte) pgm_read_byte(&GetACos[cos4 / 79]);
     83c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     840:	0008a001 	andeq	sl, r8, r1
     844:	01630100 	cmneq	r3, r0, lsl #2
		AngleRad4 = ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255) ;
     848:	0034b401 	eorseq	fp, r4, r1, lsl #8
     84c:	0034b608 	eorseq	fp, r4, r8, lsl #12
	} else if ((cos4 >= 9000) && (cos4 < 9900)) {
     850:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     854:	00085401 	andeq	r5, r8, r1, lsl #8
     858:	016f0100 	cmneq	pc, r0, lsl #2
     85c:	0034b801 	eorseq	fp, r4, r1, lsl #16
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9000) / 8 + 114]);
     860:	0034ba08 	eorseq	fp, r4, r8, lsl #20
     864:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     868:	00095101 	andeq	r5, r9, r1, lsl #2
     86c:	017b0100 	cmneq	fp, r0, lsl #2
     870:	0034bc01 	eorseq	fp, r4, r1, lsl #24
     874:	0034be08 	eorseq	fp, r4, r8, lsl #28
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     878:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
	} else if ((cos4 >= 9900) && (cos4 <= 10000)) {
     87c:	0009b201 	andeq	fp, r9, r1, lsl #4
     880:	01860100 	orreq	r0, r6, r0, lsl #2
     884:	0034c001 	eorseq	ip, r4, r1
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9900) / 2 + 227]);
     888:	0034c208 	eorseq	ip, r4, r8, lsl #4
     88c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     890:	000c0501 	andeq	r0, ip, r1, lsl #10
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     894:	01910100 	orrseq	r0, r1, r0, lsl #2
     898:	0034c401 	eorseq	ip, r4, r1, lsl #8
     89c:	0034c608 	eorseq	ip, r4, r8, lsl #12
     8a0:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     8a4:	00098701 	andeq	r8, r9, r1, lsl #14
     8a8:	019c0100 	orrseq	r0, ip, r0, lsl #2
     8ac:	0034c801 	eorseq	ip, r4, r1, lsl #16
	}

	//Add negative sign
	if (NegativeValue)
		AngleRad4 = 31416 - AngleRad4;
     8b0:	0034ca08 	eorseq	ip, r4, r8, lsl #20
     8b4:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     8b8:	00074301 	andeq	r4, r7, r1, lsl #6
     8bc:	01a70100 	undefined instruction 0x01a70100
     8c0:	0034cc01 	eorseq	ip, r4, r1, lsl #24

	return AngleRad4;
}
     8c4:	0034ce08 	eorseq	ip, r4, r8, lsl #28
     8c8:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     8cc:	0009e701 	andeq	lr, r9, r1, lsl #14
     8d0:	01b30100 	undefined instruction 0x01b30100
     8d4:	0034d001 	eorseq	sp, r4, r1
     8d8:	0034d208 	eorseq	sp, r4, r8, lsl #4

unsigned long isqrt32(unsigned long n) //
{
     8dc:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     8e0:	00075701 	andeq	r5, r7, r1, lsl #14

	root = 0;
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
     8e4:	01bf0100 	undefined instruction 0x01bf0100
     8e8:	0034d401 	eorseq	sp, r4, r1, lsl #8
     8ec:	0034d608 	eorseq	sp, r4, r8, lsl #12
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
     8f0:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
			remainder = remainder - root - place;
     8f4:	00087d01 	andeq	r7, r8, r1, lsl #26
     8f8:	01ca0100 	biceq	r0, sl, r0, lsl #2
			root = root + (place << 1);
     8fc:	0034d801 	eorseq	sp, r4, r1, lsl #16

	while (place > remainder)
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
			remainder = remainder - root - place;
     900:	0034da08 	eorseq	sp, r4, r8, lsl #20
			root = root + (place << 1);
		}
		root = root >> 1;
		place = place >> 2;
     904:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
		place = place >> 2;
	while (place) {
     908:	0007ae01 	andeq	sl, r7, r1, lsl #28
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
	XYhyp2 = isqrt32(
     90c:	01d50100 	bicseq	r0, r5, r0, lsl #2
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     910:	0034dc01 	eorseq	sp, r4, r1, lsl #24
	XYhyp2 = isqrt32(
     914:	0034de08 	eorseq	sp, r4, r8, lsl #28
     918:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     91c:	0007cd01 	andeq	ip, r7, r1, lsl #26
	XYhyp2 = isqrt32(
     920:	01e10100 	mvneq	r0, r0, lsl #2
     924:	0034e001 	eorseq	lr, r4, r1
     928:	0034e208 	eorseq	lr, r4, r8, lsl #4
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);
     92c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     930:	0007ed01 	andeq	lr, r7, r1, lsl #26
     934:	01ec0100 	mvneq	r0, r0, lsl #2
     938:	0034e401 	eorseq	lr, r4, r1, lsl #8
     93c:	0034e608 	eorseq	lr, r4, r8, lsl #12
     940:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     944:	000a9501 	andeq	r9, sl, r1, lsl #10

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
     948:	01f70100 	mvnseq	r0, r0, lsl #2
		Atan4 = -AngleRad4;
     94c:	0034e801 	eorseq	lr, r4, r1, lsl #16
	else
		Atan4 = AngleRad4;
     950:	0034ea08 	eorseq	lr, r4, r8, lsl #20
	XYhyp2 = isqrt32(
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
		Atan4 = -AngleRad4;
     954:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
	else
		Atan4 = AngleRad4;
     958:	00071701 	andeq	r1, r7, r1, lsl #14
     95c:	02020100 	andeq	r0, r2, #0	; 0x0
	return Atan4;
}
     960:	0034ec01 	eorseq	lr, r4, r1, lsl #24
     964:	0034ee08 	eorseq	lr, r4, r8, lsl #28
     968:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     96c:	0008dc01 	andeq	sp, r8, r1, lsl #24

}

//--------------------------------------------------------------------
//[BalCalcOneLeg]
void BalCalcOneLeg(long PosX, long PosZ, long PosY, byte BalLegNr) {
     970:	020d0100 	andeq	r0, sp, #0	; 0x0
	long CPR_Y;            //Final Y value for centerpoint of rotation
	long CPR_Z;            //Final Z value for centerpoint of rotation

	long lAtan;
	//Calculating totals from center of the body to the feet
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BalLegNr]) + PosZ;
     974:	0034f001 	eorseq	pc, r4, r1
     978:	0034f208 	eorseq	pc, r4, r8, lsl #4
	CPR_X = (short) pgm_read_word(&cOffsetX[BalLegNr]) + PosX;
     97c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     980:	000b1201 	andeq	r1, fp, r1, lsl #4
	CPR_Y = 150 + PosY; // using the value 150 to lower the centerpoint of rotation 'g_InControlState.BodyPos.y +

	TotalTransY += (long) PosY;
     984:	02180100 	andseq	r0, r8, #0	; 0x0
     988:	0034f401 	eorseq	pc, r4, r1, lsl #8
     98c:	0034f608 	eorseq	pc, r4, r8, lsl #12
	TotalTransZ += (long) CPR_Z;
     990:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     994:	00082201 	andeq	r2, r8, r1, lsl #4
     998:	02230100 	eoreq	r0, r3, #0	; 0x0
	TotalTransX += (long) CPR_X;
     99c:	0034f801 	eorseq	pc, r4, r1, lsl #16
     9a0:	0034fa08 	eorseq	pc, r4, r8, lsl #20
     9a4:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     9a8:	00084401 	andeq	r4, r8, r1, lsl #8

	lAtan = GetATan2(CPR_X, CPR_Z);
     9ac:	022e0100 	eoreq	r0, lr, #0	; 0x0
	TotalYBal1 += (lAtan * 1800) / 31415;
     9b0:	0034fc01 	eorseq	pc, r4, r1, lsl #24
     9b4:	0034fe08 	eorseq	pc, r4, r8, lsl #28
     9b8:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     9bc:	000b6d01 	andeq	r6, fp, r1, lsl #26
     9c0:	02470100 	subeq	r0, r7, #0	; 0x0
     9c4:	00350001 	eorseq	r0, r5, r1
     9c8:	00350208 	eorseq	r0, r5, r8, lsl #4
     9cc:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2

	lAtan = GetATan2(CPR_X, CPR_Y);
     9d0:	000ba001 	andeq	sl, fp, r1
     9d4:	02600100 	rsbeq	r0, r0, #0	; 0x0
	TotalZBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     9d8:	00350401 	eorseq	r0, r5, r1, lsl #8
     9dc:	00350608 	eorseq	r0, r5, r8, lsl #12
     9e0:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     9e4:	000aee01 	andeq	lr, sl, r1, lsl #28
     9e8:	026b0100 	rsbeq	r0, fp, #0	; 0x0
     9ec:	00350801 	eorseq	r0, r5, r1, lsl #16
     9f0:	00350a08 	eorseq	r0, r5, r8, lsl #20
     9f4:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     9f8:	0007fd01 	andeq	pc, r7, r1, lsl #26
     9fc:	02760100 	rsbseq	r0, r6, #0	; 0x0

	lAtan = GetATan2(CPR_Z, CPR_Y);
     a00:	00350c01 	eorseq	r0, r5, r1, lsl #24
     a04:	00350e08 	eorseq	r0, r5, r8, lsl #28
	TotalXBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     a08:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     a0c:	000aa801 	andeq	sl, sl, r1, lsl #16
     a10:	02810100 	addeq	r0, r1, #0	; 0x0
     a14:	00351001 	eorseq	r1, r5, r1
     a18:	00351208 	eorseq	r1, r5, r8, lsl #4
     a1c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     a20:	000b5a01 	andeq	r5, fp, r1, lsl #20
     a24:	028d0100 	addeq	r0, sp, #0	; 0x0

}
     a28:	00351401 	eorseq	r1, r5, r1, lsl #8
     a2c:	00351608 	eorseq	r1, r5, r8, lsl #12
     a30:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     a34:	00099a01 	andeq	r9, r9, r1, lsl #20
     a38:	02990100 	addseq	r0, r9, #0	; 0x0
     a3c:	00351801 	eorseq	r1, r5, r1, lsl #16
     a40:	00351a08 	eorseq	r1, r5, r8, lsl #20
     a44:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     a48:	000a4201 	andeq	r4, sl, r1, lsl #4
     a4c:	02a40100 	adceq	r0, r4, #0	; 0x0
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a50:	00351c01 	eorseq	r1, r5, r1, lsl #24
     a54:	00351e08 	eorseq	r1, r5, r8, lsl #28
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a58:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     a5c:	00089001 	andeq	r9, r8, r1
     a60:	02af0100 	adceq	r0, pc, #0	; 0x0
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a64:	00352001 	eorseq	r2, r5, r1
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a68:	00352208 	eorseq	r2, r5, r8, lsl #4
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
     a6c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     a70:	0007dd01 	andeq	sp, r7, r1, lsl #26
     a74:	02ba0100 	adcseq	r0, sl, #0	; 0x0

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     a78:	00352401 	eorseq	r2, r5, r1, lsl #8

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a7c:	00352608 	eorseq	r2, r5, r8, lsl #12
     a80:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a84:	00094101 	andeq	r4, r9, r1, lsl #2
     a88:	02c50100 	sbceq	r0, r5, #0	; 0x0

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a8c:	00352801 	eorseq	r2, r5, r1, lsl #16
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a90:	00352a08 	eorseq	r2, r5, r8, lsl #20
     a94:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
	SinG4 = sin4;
     a98:	00081201 	andeq	r1, r8, r1, lsl #4
	CosG4 = cos4;
     a9c:	02d00100 	sbcseq	r0, r0, #0	; 0x0
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa0:	00352c01 	eorseq	r2, r5, r1, lsl #24
	CosG4 = cos4;
     aa4:	00352e08 	eorseq	r2, r5, r8, lsl #28
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa8:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
	CosG4 = cos4;

	GetSinCos(g_InControlState.BodyRot1.z + TotalZBal1);
     aac:	00086d01 	andeq	r6, r8, r1, lsl #26
	SinB4 = sin4;
     ab0:	02db0100 	sbcseq	r0, fp, #0	; 0x0
     ab4:	00353001 	eorseq	r3, r5, r1
	CosB4 = cos4;
     ab8:	00353208 	eorseq	r3, r5, r8, lsl #4

	GetSinCos(g_InControlState.BodyRot1.y + (RotationY * c1DEC) + TotalYBal1);
     abc:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     ac0:	000acd01 	andeq	ip, sl, r1, lsl #26
     ac4:	02e60100 	rsceq	r0, r6, #0	; 0x0
     ac8:	00353401 	eorseq	r3, r5, r1, lsl #8
     acc:	00353608 	eorseq	r3, r5, r8, lsl #12

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     ad0:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     ad4:	000ade01 	andeq	sp, sl, r1, lsl #28
     ad8:	02ff0100 	rscseq	r0, pc, #0	; 0x0
     adc:	00353801 	eorseq	r3, r5, r1, lsl #16
     ae0:	00353a08 	eorseq	r3, r5, r8, lsl #20
     ae4:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     ae8:	000b0201 	andeq	r0, fp, r1, lsl #4
     aec:	030a0100 	movweq	r0, #41216	; 0xa100
     af0:	00353c01 	eorseq	r3, r5, r1, lsl #24
     af4:	00353e08 	eorseq	r3, r5, r8, lsl #28
     af8:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     afc:	0008c301 	andeq	ip, r8, r1, lsl #6
     b00:	03150100 	tsteq	r5, #0	; 0x0
     b04:	00354001 	eorseq	r4, r5, r1
     b08:	00354208 	eorseq	r4, r5, r8, lsl #4
     b0c:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     b10:	0008ef01 	andeq	lr, r8, r1, lsl #30
     b14:	03200100 	teqeq	r0, #0	; 0x0
     b18:	00354401 	eorseq	r4, r5, r1, lsl #8
     b1c:	00354608 	eorseq	r4, r5, r8, lsl #12
     b20:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     b24:	00091901 	andeq	r1, r9, r1, lsl #18
     b28:	032b0100 	teqeq	fp, #0	; 0x0
     b2c:	00354801 	eorseq	r4, r5, r1, lsl #16
     b30:	00354a08 	eorseq	r4, r5, r8, lsl #20
     b34:	065d0108 	ldrbeq	r0, [sp], -r8, lsl #2
     b38:	000b3701 	andeq	r3, fp, r1, lsl #14
     b3c:	03370100 	teqeq	r7, #0	; 0x0
     b40:	00354c01 	eorseq	r4, r5, r1, lsl #24
     b44:	00354e08 	eorseq	r4, r5, r8, lsl #28
     b48:	075d0108 	ldrbeq	r0, [sp, -r8, lsl #2]
     b4c:	0008b201 	andeq	fp, r8, r1, lsl #4
     b50:	02f10100 	rscseq	r0, r1, #0	; 0x0
     b54:	00355001 	eorseq	r5, r5, r1
     b58:	00355c08 	eorseq	r5, r5, r8, lsl #24
     b5c:	0000a908 	andeq	sl, r0, r8, lsl #18
     b60:	7f010700 	svcvc	0x00010700
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b64:	0100000b 	tsteq	r0, fp
     b68:	5c010252 	sfmpl	f0, 4, [r1], {82}

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     b6c:	68080035 	stmdavs	r8, {r0, r2, r4, r5}
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b70:	d4080035 	strle	r0, [r8], #-53
     b74:	07000000 	streq	r0, [r0, -r0]
     b78:	000b2501 	andeq	r2, fp, r1, lsl #10
     b7c:	02390100 	eorseq	r0, r9, #0	; 0x0
     b80:	00356801 	eorseq	r6, r5, r1, lsl #16
     b84:	00357408 	eorseq	r7, r5, r8, lsl #8
     b88:	0000ff08 	andeq	pc, r0, r8, lsl #30
     b8c:	91010800 	tstls	r1, r0, lsl #16
     b90:	0100000b 	tsteq	r0, fp
     b94:	35740190 	ldrbcc	r0, [r4, #-400]!
     b98:	35800800 	strcc	r0, [r0, #2048]
     b9c:	012a0800 	teqeq	sl, r0, lsl #16
     ba0:	69090000 	stmdbvs	r9, {}
     ba4:	03000005 	movweq	r0, #5	; 0x5
     ba8:	0005cb2a 	andeq	ip, r5, sl, lsr #22
     bac:	00530a00 	subseq	r0, r3, r0, lsl #20
     bb0:	ce090000 	cdpgt	0, 0, cr0, cr9, cr0, {0}
     bb4:	03000002 	movweq	r0, #2	; 0x2
     bb8:	0005db28 	andeq	sp, r5, r8, lsr #22
     bbc:	00410a00 	subeq	r0, r1, r0, lsl #20
     bc0:	2b090000 	blcs	240bc8 <__Stack_Size+0x2407c8>
     bc4:	03000004 	movweq	r0, #4	; 0x4
     bc8:	0005db28 	andeq	sp, r5, r8, lsr #22
     bcc:	00530b00 	subseq	r0, r3, r0, lsl #22
     bd0:	05fc0000 	ldrbeq	r0, [ip]!
     bd4:	640c0000 	strvs	r0, [ip]
     bd8:	ff000000 	undefined instruction 0xff000000
     bdc:	af090003 	svcge	0x00090003
     be0:	03000004 	movweq	r0, #4	; 0x4
     be4:	00060729 	andeq	r0, r6, r9, lsr #14
     be8:	05eb0a00 	strbeq	r0, [fp, #2560]!
     bec:	4a0d0000 	bmi	340bf4 <__Stack_Size+0x3407f4>
     bf0:	03000006 	movweq	r0, #6	; 0x6
     bf4:	0005cb44 	andeq	ip, r5, r4, asr #22
     bf8:	0e0d0000 	cdpeq	0, 0, cr0, cr13, cr0, {0}
     bfc:	03000004 	movweq	r0, #4	; 0x4
     c00:	0005cb44 	andeq	ip, r5, r4, asr #22
     c04:	530b0000 	movwpl	r0, #45056	; 0xb000
     c08:	34000000 	strcc	r0, [r0]
     c0c:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}
     c10:	00000064 	andeq	r0, r0, r4, rrx
     c14:	ec090040 	stc	0, cr0, [r9], {64}
     c18:	03000000 	movweq	r0, #0	; 0x0
     c1c:	00063f45 	andeq	r3, r6, r5, asr #30
     c20:	06240a00 	strteq	r0, [r4], -r0, lsl #20
     c24:	190d0000 	stmdbne	sp, {}
     c28:	03000006 	movweq	r0, #6	; 0x6
     c2c:	0005db58 	andeq	sp, r5, r8, asr fp
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c30:	f90d0000 	undefined instruction 0xf90d0000
	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     c34:	03000000 	movweq	r0, #0	; 0x0
     c38:	0005db58 	andeq	sp, r5, r8, asr fp
     c3c:	2d090000 	stccs	0, cr0, [r9]
     c40:	03000003 	movweq	r0, #3	; 0x3
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c44:	00066759 	andeq	r6, r6, r9, asr r7
     c48:	05eb0a00 	strbeq	r0, [fp, #2560]!
     c4c:	c1000000 	tstgt	r0, r0
     c50:	0200001a 	andeq	r0, r0, #26	; 0x1a
     c54:	00023c00 	andeq	r3, r2, r0, lsl #24
     c58:	fe010400 	cdp2	4, 0, cr0, cr1, cr0, {0}
     c5c:	01000001 	tsteq	r0, r1
     c60:	000014c8 	andeq	r1, r0, r8, asr #9
     c64:	00000249 	andeq	r0, r0, r9, asr #4
	...
     c70:	000003c3 	andeq	r0, r0, r3, asr #7
     c74:	22050402 	andcs	r0, r5, #33554432	; 0x2000000
     c78:	02000001 	andeq	r0, r0, #1	; 0x1
     c7c:	04ca0502 	strbeq	r0, [sl], #1282
     c80:	01020000 	tsteq	r2, r0
     c84:	00049e06 	andeq	r9, r4, r6, lsl #28
     c88:	002c0300 	eoreq	r0, ip, r0, lsl #6
     c8c:	75040000 	strvc	r0, [r4]
     c90:	04003233 	streq	r3, [r0], #-563
     c94:	00004a27 	andeq	r4, r0, r7, lsr #20
     c98:	07040200 	streq	r0, [r4, -r0, lsl #4]
     c9c:	00000130 	andeq	r0, r0, r0, lsr r1
     ca0:	36317504 	ldrtcc	r7, [r1], -r4, lsl #10
     ca4:	5c280400 	cfstrspl	mvf0, [r8]
     ca8:	02000000 	andeq	r0, r0, #0	; 0x0
     cac:	01c50702 	biceq	r0, r5, r2, lsl #14
     cb0:	75040000 	strvc	r0, [r4]
     cb4:	29040038 	stmdbcs	r4, {r3, r4, r5}
     cb8:	0000006d 	andeq	r0, r0, sp, rrx
     cbc:	9c080102 	stflss	f0, [r8], {2}
     cc0:	05000004 	streq	r0, [r0, #-4]
     cc4:	00001faf 	andeq	r1, r0, pc, lsr #31
     cc8:	006d2a04 	rsbeq	r2, sp, r4, lsl #20
     ccc:	01060000 	tsteq	r6, r0
     cd0:	00943804 	addseq	r3, r4, r4, lsl #16
     cd4:	3c070000 	stccc	0, cr0, [r7], {0}
     cd8:	00000014 	andeq	r0, r0, r4, lsl r0
     cdc:	00174507 	andseq	r4, r7, r7, lsl #10
     ce0:	05000100 	streq	r0, [r0, #-256]
     ce4:	00000f96 	muleq	r0, r6, pc
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * SinG4 / c4DEC
					+ (long) CPR_Z * c2DEC * CosG4 / c4DEC * SinA4 / c4DEC
							* SinB4 / c4DEC
					+ (long) CPR_Y * c2DEC * CosB4 / c4DEC * CosG4 / c4DEC))
			/ c2DEC;
}
     ce8:	007f3804 	rsbseq	r3, pc, r4, lsl #16
     cec:	04080000 	streq	r0, [r8]
     cf0:	1d4b0507 	cfstr64ne	mvdx0, [fp, #-28]
     cf4:	63050000 	movwvs	r0, #20480	; 0x5000
     cf8:	000000ad 	andeq	r0, r0, sp, lsr #1
     cfc:	35070402 	strcc	r0, [r7, #-1026]
     d00:	05000001 	streq	r0, [r0, #-1]
     d04:	00000f31 	andeq	r0, r0, r1, lsr pc
     d08:	00636405 	rsbeq	r6, r3, r5, lsl #8
     d0c:	01060000 	tsteq	r6, r0
     d10:	00f22a06 	rscseq	r2, r2, r6, lsl #20
     d14:	63090000 	movwvs	r0, #36864	; 0x9000
     d18:	00005252 	andeq	r5, r0, r2, asr r2
     d1c:	4d526309 	ldclmi	3, cr6, [r2, #-36]
//FemurAngle1           - Output Angle of Femur in degrees
//TibiaAngle1           - Output Angle of Tibia in degrees
//CoxaAngle1            - Output Angle of Coxa in degrees
//--------------------------------------------------------------------
void LegIK(short IKFeetPosX, short IKFeetPosY, short IKFeetPosZ,
		byte LegIKLegNr) {
     d20:	63090100 	movwvs	r0, #37120	; 0x9100
     d24:	02004652 	andeq	r4, r0, #85983232	; 0x5200000
     d28:	524c6309 	subpl	r6, ip, #603979776	; 0x24000000
	long Temp1;
	long Temp2;
	long T3;

	//Calculate IKCoxaAngle and IKFeetPosXZ
	GetATan2(IKFeetPosX, IKFeetPosZ);
     d2c:	63090300 	movwvs	r0, #37632	; 0x9300
	CoxaAngle1[LegIKLegNr] = (((long) Atan4 * 180) / 3141)
     d30:	04004d4c 	streq	r4, [r0], #-3404
     d34:	464c6309 	strbmi	r6, [ip], -r9, lsl #6
     d38:	17070500 	strne	r0, [r7, -r0, lsl #10]
     d3c:	06000012 	undefined
     d40:	0f460a00 	svceq	0x00460a00
     d44:	060c0000 	streq	r0, [ip], -r0
     d48:	0001236a 	andeq	r2, r1, sl, ror #6
     d4c:	00780b00 	rsbseq	r0, r8, r0, lsl #22
     d50:	00256b06 	eoreq	r6, r5, r6, lsl #22
     d54:	23020000 	movwcs	r0, #8192	; 0x2000
	//Length between the Coxa and tars [foot]
	IKFeetPosXZ = XYhyp2 / c2DEC;

	//Using GetAtan2 for solving IKA1 and IKSW
	//IKA14 - Angle between SW line and the ground in radians
	IKA14 = GetATan2(IKFeetPosY - TarsOffsetY,
     d58:	00790b00 	rsbseq	r0, r9, r0, lsl #22
     d5c:	00256c06 	eoreq	r6, r5, r6, lsl #24
     d60:	23020000 	movwcs	r0, #8192	; 0x2000
     d64:	007a0b04 	rsbseq	r0, sl, r4, lsl #22
     d68:	00256d06 	eoreq	r6, r5, r6, lsl #26
     d6c:	23020000 	movwcs	r0, #8192	; 0x2000
     d70:	3c050008 	stccc	0, cr0, [r5], {8}

	//IKSW2 - Length between femur axis and tars
	IKSW2 = XYhyp2;

	//IKA2 - Angle of the line S>W with respect to the femur in radians
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     d74:	06000015 	undefined
     d78:	0000f26e 	andeq	pc, r0, lr, ror #4
     d7c:	110f0a00 	tstne	pc, r0, lsl #20
     d80:	060e0000 	streq	r0, [lr], -r0
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			+ ((long) IKSW2 * IKSW2));
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);
     d84:	0001ab74 	andeq	sl, r1, r4, ror fp
     d88:	13240c00 	teqne	r4, #0	; 0x0
     d8c:	75060000 	strvc	r0, [r6]
     d90:	0000002c 	andeq	r0, r0, ip, lsr #32
     d94:	0c002302 	stceq	3, cr2, [r0], {2}
     d98:	00001346 	andeq	r1, r0, r6, asr #6
     d9c:	00747606 	rsbseq	r7, r4, r6, lsl #12
     da0:	23020000 	movwcs	r0, #8192	; 0x2000
     da4:	0fc60c02 	svceq	0x00c60c02
     da8:	77060000 	strvc	r0, [r6, -r0]
     dac:	00000074 	andeq	r0, r0, r4, ror r0
     db0:	0c032302 	stceq	3, cr2, [r3], {2}
     db4:	000010c0 	andeq	r1, r0, r0, asr #1

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     db8:	00747806 	rsbseq	r7, r4, r6, lsl #16
     dbc:	23020000 	movwcs	r0, #8192	; 0x2000
     dc0:	15630c04 	strbne	r0, [r3, #-3076]!
     dc4:	79060000 	stmdbvc	r6, {}
     dc8:	00000074 	andeq	r0, r0, r4, ror r0
     dcc:	0c052302 	stceq	3, cr2, [r5], {2}
     dd0:	00000e27 	andeq	r0, r0, r7, lsr #28
     dd4:	00747a06 	rsbseq	r7, r4, r6, lsl #20
     dd8:	23020000 	movwcs	r0, #8192	; 0x2000
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     ddc:	12830c06 	addne	r0, r3, #1536	; 0x600
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     de0:	7b060000 	blvc	180de8 <__Stack_Size+0x1809e8>
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     de4:	00000074 	andeq	r0, r0, r4, ror r0
     de8:	0c072302 	stceq	3, cr2, [r7], {2}
			+ ((long) (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr])
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);
     dec:	0000173b 	andeq	r1, r0, fp, lsr r7
     df0:	01ab7e06 	undefined instruction 0x01ab7e06
     df4:	23020000 	movwcs	r0, #8192	; 0x2000
     df8:	740d0008 	strvc	r0, [sp], #-8
     dfc:	bb000000 	bllt	e04 <__Stack_Size+0xa04>
     e00:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
     e04:	0000009f 	muleq	r0, pc, r0
     e08:	6e050005 	cdpvs	0, 0, cr0, cr5, cr5, {0}

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e0c:	0600000d 	streq	r0, [r0], -sp
     e10:	00012e80 	andeq	r2, r1, r0, lsl #29
     e14:	15e30a00 	strbne	r0, [r3, #2560]!
     e18:	06640000 	strbteq	r0, [r4], -r0
     e1c:	0002cf8b 	andeq	ip, r2, fp, lsl #31
     e20:	155a0c00 	ldrbne	r0, [sl, #-3072]
     e24:	8c060000 	stchi	0, cr0, [r6], {0}
     e28:	000000b4 	strheq	r0, [r0], -r4
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e2c:	0c002302 	stceq	3, cr2, [r0], {2}
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e30:	0000144e 	andeq	r1, r0, lr, asr #8
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e34:	00b48d06 	adcseq	r8, r4, r6, lsl #26
     e38:	23020000 	movwcs	r0, #8192	; 0x2000
     e3c:	12570c01 	subsne	r0, r7, #256	; 0x100
     e40:	8f060000 	svchi	0x00060000
     e44:	00000123 	andeq	r0, r0, r3, lsr #2
			< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
					+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]) - 30)
					* c2DEC))
		IKSolution = 1;
     e48:	0c042302 	stceq	3, cr2, [r4], {2}
	else {
		if (IKSW2
     e4c:	00000f19 	andeq	r0, r0, r9, lsl pc
     e50:	01239006 	teqeq	r3, r6
				< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
						+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))
						* c2DEC))
			IKSolutionWarning = 1;
     e54:	23020000 	movwcs	r0, #8192	; 0x2000
     e58:	12c10c10 	sbcne	r0, r1, #4096	; 0x1000
		else
			IKSolutionError = 1;
     e5c:	93060000 	movwls	r0, #24576	; 0x6000
	}

}
     e60:	00000123 	andeq	r0, r0, r3, lsr #2
     e64:	0c1c2302 	ldceq	3, cr2, [ip], {2}
     e68:	00000d9c 	muleq	r0, ip, sp
     e6c:	00749606 	rsbseq	r9, r4, r6, lsl #12
     e70:	23020000 	movwcs	r0, #8192	; 0x2000
     e74:	0f8d0c28 	svceq	0x008d0c28
     e78:	97060000 	strls	r0, [r6, -r0]
     e7c:	00000074 	andeq	r0, r0, r4, ror r0
     e80:	0c292302 	stceq	3, cr2, [r9], #-8
     e84:	000010de 	ldrdeq	r1, [r0], -lr
     e88:	01bb9806 	undefined instruction 0x01bb9806
     e8c:	23020000 	movwcs	r0, #8192	; 0x2000
     e90:	165c0c2a 	ldrbne	r0, [ip], -sl, lsr #24
     e94:	9a060000 	bls	180e9c <__Stack_Size+0x180a9c>
     e98:	0000002c 	andeq	r0, r0, ip, lsr #32
     e9c:	0c382302 	ldceq	3, cr2, [r8], #-8
     ea0:	00000fe5 	andeq	r0, r0, r5, ror #31
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ea4:	01239b06 	teqeq	r3, r6, lsl #22
	if (sVal < s) {
     ea8:	23020000 	movwcs	r0, #8192	; 0x2000
     eac:	17fd0c3c 	undefined
		return s;
	}

	s = (short) pgm_read_word(sMax);
     eb0:	9f060000 	svcls	0x00060000
     eb4:	00000074 	andeq	r0, r0, r4, ror r0
     eb8:	0c482302 	mcrreq	3, 0, r2, r8, cr2

		return s;
	}
	return sVal;

}
     ebc:	000017f9 	strdeq	r1, [r0], -r9
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec0:	0074a006 	rsbseq	sl, r4, r6
}

//--------------------------------------------------------------------
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
     ec4:	23020000 	movwcs	r0, #8192	; 0x2000
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec8:	16720c49 	ldrbtne	r0, [r2], -r9, asr #24
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ecc:	a1060000 	tstge	r6, r0
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     ed0:	00000123 	andeq	r0, r0, r3, lsr #2
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ed4:	0c4c2302 	mcrreq	3, 0, r2, ip, cr2
	if (sVal < s) {
     ed8:	000017ae 	andeq	r1, r0, lr, lsr #15
     edc:	00b4a206 	adcseq	sl, r4, r6, lsl #4
     ee0:	23020000 	movwcs	r0, #8192	; 0x2000
		return s;
	}

	s = (short) pgm_read_word(sMax);
     ee4:	0e470c58 	mcreq	12, 2, r0, cr7, cr8, {2}
     ee8:	a6060000 	strge	r0, [r6], -r0
     eec:	000000b4 	strheq	r0, [r0], -r4
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
     ef0:	0c592302 	mrrceq	3, 0, r2, r9, cr2
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ef4:	00000d2f 	andeq	r0, r0, pc, lsr #26
	if (sVal < s) {
     ef8:	0074a906 	rsbseq	sl, r4, r6, lsl #18
     efc:	23020000 	movwcs	r0, #8192	; 0x2000
     f00:	13d90c5a 	bicsne	r0, r9, #23040	; 0x5a00
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f04:	aa060000 	bge	180f0c <__Stack_Size+0x180b0c>
     f08:	000000a2 	andeq	r0, r0, r2, lsr #1
     f0c:	0c5c2302 	mrrceq	3, 0, r2, ip, cr2
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f10:	000016b4 	strheq	r1, [r0], -r4
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f14:	0074ab06 	rsbseq	sl, r4, r6, lsl #22
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f18:	23020000 	movwcs	r0, #8192	; 0x2000
	if (sVal < s) {
     f1c:	05050060 	streq	r0, [r5, #-96]
     f20:	06000013 	undefined
     f24:	0001c6b1 	strheq	ip, [r1], -r1
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f28:	01960f00 	orrseq	r0, r6, r0, lsl #30
     f2c:	0a010000 	beq	40f34 <__Stack_Size+0x40b34>
     f30:	00031120 	andeq	r1, r3, r0, lsr #2
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
				FemurAngle1[LegIndex], &cFemurMin1[LegIndex],
				&cFemurMax1[LegIndex]);
		TibiaAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f34:	05e90700 	strbeq	r0, [r9, #1792]!
     f38:	07000000 	streq	r0, [r0, -r0]
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     f3c:	000006db 	ldrdeq	r0, [r0], -fp
     f40:	00e40701 	rsceq	r0, r4, r1, lsl #14
				TibiaAngle1[LegIndex], &cTibiaMin1[LegIndex],
				&cTibiaMax1[LegIndex]);

	}
#endif
}
     f44:	07020000 	streq	r0, [r2, -r0]
     f48:	000001a7 	andeq	r0, r0, r7, lsr #3
     f4c:	02870703 	addeq	r0, r7, #786432	; 0xc0000
     f50:	07040000 	streq	r0, [r4, -r0]
     f54:	00000396 	muleq	r0, r6, r3
     f58:	02b30705 	adcseq	r0, r3, #1310720	; 0x140000
     f5c:	00060000 	andeq	r0, r6, r0
     f60:	54070106 	strpl	r0, [r7], #-262
     f64:	000003a8 	andeq	r0, r0, r8, lsr #7
     f68:	000fa007 	andeq	sl, pc, r7
     f6c:	d6070100 	strle	r0, [r7], -r0, lsl #2
// SmoothControl (From Zenta) -  This function makes the body
//            rotation and translation much smoother
//--------------------------------------------------------------------
short SmoothControl(short CtrlMoveInp, short CtrlMoveOut, byte CtrlDivider) {

	if (CtrlMoveOut < (CtrlMoveInp - 4))
     f70:	02000011 	andeq	r0, r0, #17	; 0x11
     f74:	00147507 	andseq	r7, r4, r7, lsl #10
		return CtrlMoveOut + abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f78:	f8070300 	undefined instruction 0xf8070300
     f7c:	0400000e 	streq	r0, [r0], #-14
     f80:	000e8007 	andeq	r8, lr, r7
     f84:	f2070500 	vrshl.s8	d0, d0, d7
     f88:	06000010 	undefined
     f8c:	000ee507 	andeq	lr, lr, r7, lsl #10
     f90:	2a070700 	bcs	1c2b98 <__Stack_Size+0x1c2798>
	else if (CtrlMoveOut > (CtrlMoveInp + 4))
     f94:	0c000017 	stceq	0, cr0, [r0], {23}
		return CtrlMoveOut - abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f98:	00178607 	andseq	r8, r7, r7, lsl #12
     f9c:	24070d00 	strcs	r0, [r7], #-3328
     fa0:	0e000016 	mcreq	0, 0, r0, cr0, cr6, {0}
     fa4:	000d8c07 	andeq	r8, sp, r7, lsl #24
     fa8:	b2070f00 	andlt	r0, r7, #0	; 0x0
     fac:	10000014 	andne	r0, r0, r4, lsl r0
     fb0:	00118d07 	andseq	r8, r1, r7, lsl #26

	return CtrlMoveInp;
}
     fb4:	4b071100 	blmi	1c53bc <__Stack_Size+0x1c4fbc>
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
     fb8:	12000015 	andne	r0, r0, #21	; 0x15
     fbc:	00174a07 	andseq	r4, r7, r7, lsl #20
     fc0:	97071300 	strls	r1, [r7, -r0, lsl #6]

//--------------------------------------------------------------------
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
     fc4:	14000012 	strne	r0, [r0], #-18
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
		return g_wLegsXZLength;

	return isqrt32((LegPosX[0] * LegPosX[0]) + (LegPosZ[0] * LegPosZ[0]));
     fc8:	00111c07 	andseq	r1, r1, r7, lsl #24
     fcc:	83071500 	movwhi	r1, #29952	; 0x7500
     fd0:	1600000c 	strne	r0, [r0], -ip
     fd4:	000dcb07 	andeq	ip, sp, r7, lsl #22
     fd8:	78071700 	stmdavc	r7, {r8, r9, sl, ip}
     fdc:	83000016 	movwhi	r0, #22	; 0x16
}
     fe0:	112a0701 	teqne	sl, r1, lsl #14
     fe4:	01840000 	orreq	r0, r4, r0
     fe8:	0016f007 	andseq	pc, r6, r7
     fec:	07019200 	streq	r9, [r1, -r0, lsl #4]

#ifndef MAX_XZ_LEG_ADJUST
#define MAX_XZ_LEG_ADJUST   (word)(cCoxaLength[0]+cTibiaLength[0] + cFemurLength[0]/4)
#endif

void AdjustLegPositions(word XZLength1) {
     ff0:	000011ed 	andeq	r1, r0, sp, ror #3
     ff4:	060001d0 	undefined
     ff8:	06cf0702 	strbeq	r0, [pc], r2, lsl #14
     ffc:	07000004 	streq	r0, [r0, -r4]
    1000:	000006b5 	strheq	r0, [r0], -r5
		XZLength1 = MAX_XZ_LEG_ADJUST;
	if (XZLength1 < MIN_XZ_LEG_ADJUST)
		XZLength1 = MIN_XZ_LEG_ADJUST;

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
    1004:	04bc0701 	ldrteq	r0, [ip], #1793
    1008:	07020000 	streq	r0, [r2, -r0]
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    100c:	0000038b 	andeq	r0, r0, fp, lsl #7

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
		return;

	g_wLegsXZLength = XZLength1;
    1010:	06c30704 	strbeq	r0, [r3], r4, lsl #14

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));
    1014:	07080000 	streq	r0, [r8, -r0]
    1018:	00000500 	andeq	r0, r0, r0, lsl #10

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
    101c:	01690710 	cmneq	r9, r0, lsl r7
    1020:	07200000 	streq	r0, [r0, -r0]!
    1024:	000005c1 	andeq	r0, r0, r1, asr #11
    1028:	3b0700c0 	blcc	1c1330 <__Stack_Size+0x1c0f30>
    102c:	80000002 	andhi	r0, r0, r2
    1030:	06f60701 	ldrbteq	r0, [r6], r1, lsl #14
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    1034:	02800000 	addeq	r0, r0, #0	; 0x0
    1038:	00048e07 	andeq	r8, r4, r7, lsl #28
    103c:	07048000 	streq	r8, [r4, -r0]
    1040:	00000026 	andeq	r0, r0, r6, lsr #32
    1044:	20070880 	andcs	r0, r7, r0, lsl #17
    1048:	80000003 	andhi	r0, r0, r3
		return;

	g_wLegsXZLength = XZLength1;

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    104c:	015a0710 	cmpeq	sl, r0, lsl r7
		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
	}

	// Make sure we cycle through one gait to have the legs all move into their new locations...
	g_InControlState.ForceGaitStepCnt = g_InControlState.gaitCur.StepsInGait;
    1050:	20800000 	addcs	r0, r0, r0
    1054:	07011000 	streq	r1, [r1, -r0]
}
    1058:	053c016e 	ldreq	r0, [ip, #-366]!
    105c:	0d070000 	stceq	0, cr0, [r7]
    1060:	00000003 	andeq	r0, r0, r3
    1064:	0002e807 	andeq	lr, r2, r7, lsl #16
    1068:	f1070100 	undefined instruction 0xf1070100
    106c:	02000005 	andeq	r0, r0, #5	; 0x5
    1070:	0002d907 	andeq	sp, r2, r7, lsl #18
    1074:	b8070300 	stmdalt	r7, {r8, r9}
    1078:	04000000 	streq	r0, [r0]
		g_InControlState.aCoxaInitAngle1[LegIndex] = (short)pgm_read_word(&cCoxaAngle1[LegIndex]);
#endif
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    107c:	0000c607 	andeq	ip, r0, r7, lsl #12
		else if (g_InControlState.aCoxaInitAngle1[LegIndex] < -700)
		g_InControlState.aCoxaInitAngle1[LegIndex] = -700;
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    1080:	cc070500 	cfstr32gt	mvfx0, [r7], {0}
//     to be appropriate for the current y location of the body...
//--------------------------------------------------------------------

u8 g_iLegInitIndex = 0x00; // remember which index we are currently using...

void AdjustLegPositionsToBodyHeight() {
    1084:	06000005 	streq	r0, [r0], -r5
    1088:	0005ac07 	andeq	sl, r5, r7, lsl #24
#ifdef CNT_HEX_INITS
	// Lets see which of our units we should use...
	// Note: We will also limit our body height here...
	if (g_InControlState.BodyPos.y
    108c:	d8070700 	stmdale	r7, {r8, r9, sl}
			> (short) pgm_read_byte(&g_abHexMaxBodyY[CNT_HEX_INITS-1]))
		g_InControlState.BodyPos.y = (short) pgm_read_byte(
    1090:	08000001 	stmdaeq	r0, {r0}
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    1094:	0001af07 	andeq	sl, r1, r7, lsl #30
    1098:	69070900 	stmdbvs	r7, {r8, fp}
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    109c:	0a000006 	beq	10bc <__Stack_Size+0xcbc>
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    10a0:	0004d407 	andeq	sp, r4, r7, lsl #8
    10a4:	75070b00 	strvc	r0, [r7, #-2816]
    10a8:	0c000004 	stceq	0, cr0, [r0], {4}
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    10ac:	00010307 	andeq	r0, r1, r7, lsl #6
		g_iLegInitIndex = i;  // remember the current index...
		AdjustLegPositions(XZLength1);
    10b0:	65070d00 	strvs	r0, [r7, #-3328]
	}
#endif // CNT_HEX_INITS
}
    10b4:	0e000003 	cdpeq	0, 0, cr0, cr0, cr3, {0}
    10b8:	00035407 	andeq	r5, r3, r7, lsl #8
    10bc:	8c070f00 	stchi	15, cr0, [r7], {0}
}
//--------------------------------------------------------------------
//[CHECK VOLTAGE]
//Reads the input voltage and shuts down the bot when the power drops
byte s_bLVBeepCnt;
boolean CheckVoltage() {
    10c0:	10000000 	andne	r0, r0, r0
    10c4:	0004f207 	andeq	pc, r4, r7, lsl #4
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10c8:	37071100 	strcc	r1, [r7, -r0, lsl #2]

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10cc:	12000006 	andne	r0, r0, #6	; 0x6
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d0:	00003407 	andeq	r3, r0, r7, lsl #8

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10d4:	46071300 	strmi	r1, [r7], -r0, lsl #6
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d8:	14000005 	strne	r0, [r0], #-5

	if (!g_fLowVoltageShutdown) {
		/**PrintString("Voltage : ");
		Printu32d(Voltage);
		PrintString("\n");*/
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {
    10dc:	00052f07 	andeq	r2, r5, r7, lsl #30
    10e0:	9e071500 	cfsh32ls	mvfx1, mvfx7, #0
    10e4:	16000003 	strne	r0, [r0], -r3


			//Turn off
			g_InControlState.BodyPos.x = 0;
    10e8:	00037607 	andeq	r7, r3, r7, lsl #12
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;

#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
    10ec:	63071700 	movwvs	r1, #30464	; 0x7700
    10f0:	18000004 	stmdane	r0, {r2}
#endif
			g_fLowVoltageShutdown = 1;
    10f4:	00006b07 	andeq	r6, r0, r7, lsl #22
			s_bLVBeepCnt = 0;    // how many times we beeped...
    10f8:	73071900 	movwvc	r1, #30976	; 0x7900
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {


			//Turn off
			g_InControlState.BodyPos.x = 0;
			g_InControlState.BodyPos.y = 0;
    10fc:	1a000000 	bne	1104 <__Stack_Size+0xd04>
			g_InControlState.BodyPos.z = 0;
			g_InControlState.BodyRot1.x = 0;
    1100:	00033a07 	andeq	r3, r3, r7, lsl #20
			g_InControlState.BodyRot1.y = 0;
			g_InControlState.BodyRot1.z = 0;
    1104:	95071b00 	strls	r1, [r7, #-2816]
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;
    1108:	1c000006 	stcne	0, cr0, [r0], {6}
#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
#endif
			g_fLowVoltageShutdown = 1;
			s_bLVBeepCnt = 0;    // how many times we beeped...
    110c:	00020a07 	andeq	r0, r2, r7, lsl #20
			g_InControlState.fRobotOn = false;
    1110:	7a071d00 	bvc	1c8518 <__Stack_Size+0x1c8118>
		}
#ifdef cTurnOnVol
	} else if ((Voltage > cTurnOnVol) && (Voltage < 1999)) {
    1114:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
    1118:	00065507 	andeq	r5, r6, r7, lsl #10

		g_fLowVoltageShutdown = 0;
    111c:	24071f00 	strcs	r1, [r7], #-3840
    1120:	20000006 	andcs	r0, r0, r6

#endif
	} else {
		if (s_bLVBeepCnt < 5) {
    1124:	00060607 	andeq	r0, r6, r7, lsl #12
    1128:	35072100 	strcc	r2, [r7, #-256]
			s_bLVBeepCnt++;
    112c:	22000004 	andcs	r0, r0, #4	; 0x4

			//MSound( 1, 45, 2000);
			Buzzed(45, 2000);
    1130:	00041807 	andeq	r1, r4, r7, lsl #16
    1134:	d5072300 	strle	r2, [r7, #-768]
    1138:	24000003 	strcs	r0, [r0], #-3
		}
		mDelay(2000);
    113c:	0003be07 	andeq	fp, r3, r7, lsl #28
    1140:	90072500 	andls	r2, r7, r0, lsl #10
    1144:	26000005 	strcs	r0, [r0], -r5
	}
#endif

	return g_fLowVoltageShutdown;
}
    1148:	00057c07 	andeq	r7, r5, r7, lsl #24
    114c:	04072700 	streq	r2, [r7], #-1792
    1150:	28000007 	stmdacs	r0, {r0, r1, r2}
    1154:	0006e307 	andeq	lr, r6, r7, lsl #6
    1158:	12072900 	andne	r2, r7, #0	; 0x0

//==============================================================================
// BackgroundProcess - Allows us to have some background processing for those
//    servo drivers that need us to do things like polling...
//==============================================================================
void BackgroundProcess(void) {
    115c:	2a000000 	bcs	1164 <__Stack_Size+0xd64>
    1160:	00014207 	andeq	r4, r1, r7, lsl #4
	if (g_fAXSpeedControl)
    1164:	48072b00 	stmdami	r7, {r8, r9, fp, sp}
		return;  // nothing to do in this mode...

	if (ServosEnabled) {
		//DebugToggle(A3);
		BioloidControllerEx_interpolateStep(false); // Do our background stuff...
    1168:	2c000004 	stccs	0, cr0, [r0], {4}
		Battery_Monitor_Alarm();
    116c:	00022c07 	andeq	r2, r2, r7, lsl #24
	}
}
    1170:	b3072d00 	movwlt	r2, #32000	; 0x7d00
    1174:	2e000003 	cdpcs	0, 0, cr0, cr0, cr3, {0}
//Function that gets called from the main loop if the robot is not logically
//     on.  Gives us a chance to play some...
//--------------------------------------------------------------------
static u8 g_iIdleServoNum = (u8) - 1;
static u8 g_iIdleLedState = 1;  // what state to we wish to set...
void IdleTime(void) {
    1178:	00022307 	andeq	r2, r2, r7, lsl #6
    117c:	8a072f00 	bhi	1ccd84 <__Stack_Size+0x1cc984>
	// Each time we call this set servos LED on or off...
	g_iIdleServoNum++;
    1180:	30000001 	andcc	r0, r0, r1
	if (g_iIdleServoNum >= NUMSERVOS) {
    1184:	00017e07 	andeq	r7, r1, r7, lsl #28
    1188:	02003100 	andeq	r3, r0, #0	; 0x0
		g_iIdleServoNum = 0;
    118c:	011d0508 	tsteq	sp, r8, lsl #10
		g_iIdleLedState = 1 - g_iIdleLedState;
    1190:	08020000 	stmdaeq	r2, {}
    1194:	00012b07 	andeq	r2, r1, r7, lsl #22
	}
	dxl_write_byte(pgm_read_byte(&cPinTable[g_iIdleServoNum]), AXM_LED,
    1198:	05041100 	streq	r1, [r4, #-256]
    119c:	00746e69 	rsbseq	r6, r4, r9, ror #28
    11a0:	48010106 	stmdami	r1, {r1, r2, r8}
    11a4:	00000578 	andeq	r0, r0, r8, ror r5
    11a8:	0016e707 	andseq	lr, r6, r7, lsl #14
			g_iIdleLedState);
	//ax12ReadPacket(6);  // get the response...


}
    11ac:	35070000 	strcc	r0, [r7]
    11b0:	01000018 	tsteq	r0, r8, lsl r0
    11b4:	000ddc07 	andeq	sp, sp, r7, lsl #24
    11b8:	95070200 	strls	r0, [r7, #-512]

//--------------------------------------------------------------------
//[SetRegOnAllServos] Function that is called to set the state of one
//  register in all of the servos, like Torque on...
//--------------------------------------------------------------------
void SetRegOnAllServos(u8 bReg, u8 bVal) {
    11bc:	03000018 	movweq	r0, #24	; 0x18
    11c0:	000cf807 	andeq	pc, ip, r7, lsl #16
    11c4:	06000400 	streq	r0, [r0], -r0, lsl #8
	 ax12write(bVal);

  }
  ax12write(0xff - (checksum % 256));
  setRX(0);*/
	 dxl_set_txpacket_id (BROADCAST_ID);
    11c8:	994f0101 	stmdbls	pc, {r0, r8}^
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    11cc:	07000005 	streq	r0, [r0, -r5]
	dxl_set_txpacket_parameter(0,bReg);
    11d0:	000010a9 	andeq	r1, r0, r9, lsr #1
    11d4:	0e8c0700 	cdpeq	7, 8, cr0, cr12, cr0, {0}
	dxl_set_txpacket_parameter(1,2);
    11d8:	07010000 	streq	r0, [r1, -r0]
    11dc:	0000133c 	andeq	r1, r0, ip, lsr r3
    11e0:	11be0702 	undefined instruction 0x11be0702
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
    11e4:	00030000 	andeq	r0, r3, r0
    11e8:	17cd0112 	bfine	r0, r2, #2, #12
    11ec:	85030000 	strhi	r0, [r3]
    11f0:	002c0105 	eoreq	r0, ip, r5, lsl #2
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    11f4:	e7010000 	str	r0, [r1, -r0]
    11f8:	13000005 	movwne	r0, #5	; 0x5
    11fc:	00444973 	subeq	r4, r4, r3, ror r9
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1200:	2c058403 	cfstrscs	mvf8, [r5], {3}
    1204:	14000000 	strne	r0, [r0]
    1208:	00000cf3 	strdeq	r0, [r0], -r3
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    120c:	2c058403 	cfstrscs	mvf8, [r5], {3}
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1210:	14000000 	strne	r0, [r0]
	 dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0,bReg);
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
    1214:	00001292 	muleq	r0, r2, r2
    1218:	e7058403 	str	r8, [r5, -r3, lsl #8]
    121c:	14000005 	strne	r0, [r0], #-5
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
	}

	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
    1220:	0000131f 	andeq	r1, r0, pc, lsl r3
    1224:	e7058503 	str	r8, [r5, -r3, lsl #10]
    1228:	15000005 	strne	r0, [r0, #-5]
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- SetRegOnAllServos ---\n");
#endif
	dxl_txrx_packet();
    122c:	89030073 	stmdbhi	r3, {r0, r1, r4, r5, r6}

	u16 CommStatus = dxl_get_result();
    1230:	00002c05 	andeq	r2, r0, r5, lsl #24
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
    1234:	04160000 	ldreq	r0, [r6]
		PrintErrorCode();
    1238:	0000003a 	andeq	r0, r0, sl, lsr r0
	else
		PrintCommStatus(CommStatus);
    123c:	0f5a0117 	svceq	0x005a0117
#endif
}
    1240:	c8010000 	stmdagt	r1, {}
    1244:	06070101 	streq	r0, [r7], -r1, lsl #2
    1248:	48180000 	ldmdami	r8, {}
//--------------------------------------------------------------------
//[MakeSureServosAreOn] Function that is called to handle when you are
//  transistioning from servos all off to being on.  May need to read
//  in the current pose...
//--------------------------------------------------------------------
void MakeSureServosAreOn(void) {
    124c:	01000016 	tsteq	r0, r6, lsl r0

	if (ServosEnabled) {

		if (!g_fServosFree)
    1250:	0000b4c8 	andeq	fp, r0, r8, asr #9
			return;    // we are not free

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {
    1254:	01190000 	tsteq	r9, r0
    1258:	0000117a 	andeq	r1, r0, sl, ror r1

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
    125c:	0105f003 	tstpeq	r5, r3
    1260:	0c011901 	stceq	9, cr1, [r1], {1}
    1264:	03000017 	movweq	r0, #23	; 0x17
    1268:	01010399 	strbeq	r0, [r1, -r9]
						AXM_PRESENT_POSITION_L);
				mDelay(25);
    126c:	0e9d011a 	mrceq	1, 4, r0, cr13, cr10, {0}
    1270:	b5010000 	strlt	r0, [r1]

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
    1274:	011b0101 	tsteq	fp, r1, lsl #2
    1278:	00001231 	andeq	r1, r0, r1, lsr r2
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
						AXM_PRESENT_POSITION_L);
				mDelay(25);
			}
		} else {
			BioloidControllerEx_readPose();
    127c:	01060003 	tsteq	r6, r3
		}

		SetRegOnAllServos(AXM_TORQUE_ENABLE, 1);  // Use sync write to do it.
    1280:	00064301 	andeq	r4, r6, r1, lsl #6
    1284:	17671400 	strbne	r1, [r7, -r0, lsl #8]!

		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = false;
    1288:	00030000 	andeq	r0, r3, r0
	}

}
    128c:	00054a06 	andeq	r4, r5, r6, lsl #20
    1290:	01190000 	tsteq	r9, r0
    1294:	00000f39 	andeq	r0, r0, r9, lsr pc
    1298:	01031d03 	tsteq	r3, r3, lsl #26
    129c:	061d1c01 	ldreq	r1, [sp], -r1, lsl #24
	...
		{

	MakeSureServosAreOn();
	if (ServosEnabled) {

		if (g_fAXSpeedControl) {
    12a8:	5d010000 	stcpl	0, cr0, [r1]
    12ac:	0005ed1d 	andeq	lr, r5, sp, lsl sp
	...

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awCurAXPos[i] = g_awGoalAXPos[i];
    12b8:	785d0100 	ldmdavc	sp, {r8}^
		if (g_fAXSpeedControl) {

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
    12bc:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
				g_awCurAXPos[i] = g_awGoalAXPos[i];
			}
#endif
		} else
			BioloidControllerEx_interpolateStep(true); // Make sure we call at least once
    12c0:	000005fb 	strdeq	r0, [r0], -fp
    12c4:	1f005001 	svcne	0x00005001

	}
}
    12c8:	00179801 	andseq	r9, r7, r1, lsl #16
    12cc:	01d70100 	bicseq	r0, r7, r0, lsl #2
    12d0:	00000001 	andeq	r0, r0, r1
    12d4:	00000000 	andeq	r0, r0, r0
}

//--------------------------------------------------------------------
//[FREE SERVOS] Frees all the servos
//--------------------------------------------------------------------
void FreeServos(void) {
    12d8:	205d0100 	subscs	r0, sp, r0, lsl #2
    12dc:	000e3301 	andeq	r3, lr, r1, lsl #6

	if (!g_fServosFree) {
    12e0:	020b0100 	andeq	r0, fp, #0	; 0x0
	...
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
    12ec:	01215d01 	teqeq	r1, r1, lsl #26
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
			Relax(pgm_read_byte(&cPinTable[i]));
    12f0:	0000141b 	andeq	r1, r0, fp, lsl r4
    12f4:	01021201 	tsteq	r2, r1, lsl #4
	...
		}
		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = true;
    1300:	06c65d01 	strbeq	r5, [r6], r1, lsl #26
	}
}
    1304:	44220000 	strtmi	r0, [r2]
    1308:	0100000c 	tsteq	r0, ip
    130c:	004a0212 	subeq	r0, sl, r2, lsl r2
extern void SetRegOnAllServos(u8 bReg, u8 bVal);

//--------------------------------------------------------------------
//Init
//--------------------------------------------------------------------
void Servo_Init(void) {
    1310:	50010000 	andpl	r0, r1, r0
	// First lets get the actual servo positions for all of our servos...
	//pinMode(0, OUTPUT);
	g_fServosFree = true;
    1314:	c0012300 	andgt	r2, r1, r0, lsl #6

  poseSize = NUMSERVOS;
    1318:	0200000e 	andeq	r0, r0, #14	; 0xe
    131c:	00a201fb 	strdeq	r0, [r2], fp
	...
#ifdef cVoltagePin
	for (byte i=0; i < 8; i++)
	GetBatteryVoltage();  // init the voltage pin
#endif

	g_fAXSpeedControl = false;
    1328:	5d010000 	stcpl	0, cr0, [r1]



	// Added - try to speed things up later if we do a query...
	SetRegOnAllServos(AXM_RETURN_DELAY_TIME, 0); // tell servos to give us back their info as quick as they can...
    132c:	00000734 	andeq	r0, r0, r4, lsr r7
    1330:	00106424 	andseq	r6, r0, r4, lsr #8

}
    1334:	a2fb0200 	rscsge	r0, fp, #0	; 0x0
    1338:	55000000 	strpl	r0, [r0]
    133c:	25000001 	strcs	r0, [r0, #-1]
    1340:	00001605 	andeq	r1, r0, r5, lsl #12

}

void setupPhoenix() {

	g_fShowDebugPrompt = true;
    1344:	00a2fb02 	adceq	pc, r2, r2, lsl #22
void readSensors(){


}

void setupPhoenix() {
    1348:	51010000 	tstpl	r1, r0

	g_fShowDebugPrompt = true;
	g_fDebugOutput = false;
    134c:	0014c225 	andseq	ip, r4, r5, lsr #4
    1350:	a2fb0200 	rscsge	r0, fp, #0	; 0x0
	//init BioloidEx
	BioloidControllerEx();
    1354:	01000000 	tsteq	r0, r0

	// Init our ServoDriver
	Servo_Init();
    1358:	18132652 	ldmdane	r3, {r1, r4, r6, r9, sl, sp}

	mDelay(10);
    135c:	fc020000 	stc2	0, cr0, [r2], {0}

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1360:	000000a2 	andeq	r0, r0, r2, lsr #1
    1364:	00000173 	andeq	r0, r0, r3, ror r1
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    1368:	00154427 	andseq	r4, r5, r7, lsr #8
    136c:	3ffd0200 	svccc	0x00fd0200
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1370:	26000000 	strcs	r0, [r0], -r0

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1374:	0000114e 	andeq	r1, r0, lr, asr #2
    1378:	00a2fe02 	adceq	pc, r2, r2, lsl #28
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    137c:	01860000 	orreq	r0, r6, r0
    1380:	1f000000 	svcne	0x00000000
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1384:	0013e601 	andseq	lr, r3, r1, lsl #12
    1388:	02c90300 	sbceq	r0, r9, #0	; 0x0
    138c:	00000001 	andeq	r0, r0, r1
	Servo_Init();

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1390:	00000000 	andeq	r0, r0, r0
    1394:	1c5d0100 	ldfnee	f0, [sp], {0}
    1398:	00000643 	andeq	r0, r0, r3, asr #12
	...
	ResetLegInitAngles();

	//Single leg control. Make sure no leg is selected
#ifdef OPT_SINGLELEG
	g_InControlState.SelectedLeg = 255; // No Leg selected
	g_InControlState.PrevSelectedLeg = 255;
    13a4:	01285d01 	teqeq	r8, r1, lsl #26
#endif
	//Body Positions
	g_InControlState.BodyPos.x = 0;
    13a8:	00001362 	andeq	r1, r0, r2, ror #6
	g_InControlState.BodyPos.y = 0;
	g_InControlState.BodyPos.z = 0;
    13ac:	01035e03 	tsteq	r3, r3, lsl #28
	...
	g_InControlState.BodyRot1.x = 0;
	g_InControlState.BodyRot1.y = 0;
	g_InControlState.BodyRot1.z = 0;
	g_InControlState.BodyRotOffset.x = 0;
	g_InControlState.BodyRotOffset.y = 0; //Input Y offset value to adjust centerpoint of rotation
	g_InControlState.BodyRotOffset.z = 0;
    13b8:	00000199 	muleq	r0, r9, r1

	//Gait
	g_InControlState.GaitType = 0;
    13bc:	00061229 	andeq	r1, r6, r9, lsr #4
	...
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
	g_InControlState.ForceGaitStepCnt = 0; // added to try to adjust starting positions depending on height...
	g_InControlState.GaitStep = 1;
    13c8:	0001b800 	andeq	fp, r1, r0, lsl #16
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    13cc:	4d012a00 	fstsmi	s4, [r1]
	g_InControlState.BodyRotOffset.z = 0;

	//Gait
	g_InControlState.GaitType = 0;
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
    13d0:	03000013 	movweq	r0, #19	; 0x13
    13d4:	000103cb 	andeq	r0, r1, fp, asr #7
void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    13d8:	00000000 	andeq	r0, r0, r0
    13dc:	e3000000 	movw	r0, #0	; 0x0
    13e0:	b9000001 	stmdblt	r0, {r0}
//==============================================================================

// If both PS2 and XBee are defined then we will become secondary to the xbee
void CommanderInputController_Init(void) {

	g_BodyYOffset = 0;
    13e4:	2b000007 	blcs	1408 <__Stack_Size+0x1008>
    13e8:	00001220 	andeq	r1, r0, r0, lsr #4
    13ec:	7403cb03 	strvc	ip, [r3], #-2819
	g_BodyYShift = 0;
	//begin(XBEE_BAUD);
	GPSeq = 0;  // init to something...
    13f0:	02000000 	andeq	r0, r0, #0	; 0x0
    13f4:	2c000002 	stccs	0, cr0, [r0], {2}

	ControlMode = WALKMODE;
    13f8:	00000dc3 	andeq	r0, r0, r3, asr #27
	HeightSpeedMode = NORM_NORM;
    13fc:	2c03ce03 	stccs	14, cr12, [r3], {3}
	//    DoubleHeightOn = false;
	DoubleTravelOn = false;
    1400:	15000000 	strne	r0, [r0]
	bJoystickWalkMode = 0;
    1404:	00000002 	andeq	r0, r0, r2
	GaitSelect();

	CommanderInputController_Init();

	// Servo Driver
	ServoMoveTime = 150;
    1408:	166a0128 	strbtne	r0, [sl], -r8, lsr #2
	g_InControlState.fRobotOn = 0;
    140c:	a6030000 	strge	r0, [r3], -r0
	g_fLowVoltageShutdown = false;
    1410:	00000103 	andeq	r0, r0, r3, lsl #2

}
    1414:	00000000 	andeq	r0, r0, r0
    1418:	02a10000 	adceq	r0, r1, #0	; 0x0
    141c:	01280000 	teqeq	r8, r0
    1420:	000013be 	strheq	r1, [r0], -lr
    1424:	01044d03 	tsteq	r4, r3, lsl #26
	...
    1430:	000002c0 	andeq	r0, r0, r0, asr #5
    1434:	1373012a 	cmnne	r3, #-2147483638	; 0x8000000a
    1438:	6b030000 	blvs	c1440 <__Stack_Size+0xc1040>
    143c:	00000104 	andeq	r0, r0, r4, lsl #2
    1440:	00000000 	andeq	r0, r0, r0
    1444:	02df0000 	sbcseq	r0, pc, #0	; 0x0
    1448:	08200000 	stmdaeq	r0!, {}
    144c:	db2b0000 	blle	ac1454 <__Stack_Size+0xac1054>
    1450:	0300000f 	movweq	r0, #15	; 0xf
    1454:	002c046b 	eoreq	r0, ip, fp, ror #8
    1458:	02fe0000 	rscseq	r0, lr, #0	; 0x0
    145c:	d82c0000 	stmdale	ip!, {}
    1460:	0300000f 	movweq	r0, #15	; 0xf
    1464:	002c046c 	eoreq	r0, ip, ip, ror #8
//[CommitServoDriver Updates the positions of the servos - This outputs
//         as much of the command as we can without committing it.  This
//         allows us to once the previous update was completed to quickly
//        get the next command to start
//--------------------------------------------------------------------
void CommitServoDriver(word wMoveTime) {
    1468:	03530000 	cmpeq	r3, #0	; 0x0
    146c:	2d000000 	stccs	0, cr0, [r0]
    1470:	0013ca01 	andseq	ip, r3, r1, lsl #20


	CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1474:	04950300 	ldreq	r0, [r5], #768

      }
      ax12write(0xff - (checksum % 256));
      setRX(0);
*/
  	    dxl_set_txpacket_id (BROADCAST_ID);
    1478:	00002501 	andeq	r2, r0, r1, lsl #10
	...
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
    1484:	00036600 	andeq	r6, r3, r0, lsl #12
    1488:	00085f00 	andeq	r5, r8, r0, lsl #30
		dxl_set_txpacket_parameter(1, 2);
    148c:	0f9b2b00 	svceq	0x009b2b00
    1490:	95030000 	strls	r0, [r3]
    1494:	00002c04 	andeq	r2, r0, r4, lsl #24
    1498:	00038500 	andeq	r8, r3, r0, lsl #10
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
			wSpeed = CalculateAX12MoveSpeed(g_awCurAXPos[i], g_awGoalAXPos[i], wMoveTime);    // What order should we store these values?
    149c:	11c82c00 	bicne	r2, r8, r0, lsl #24
    14a0:	96030000 	strls	r0, [r3], -r0
    14a4:	0000b404 	andeq	fp, r0, r4, lsl #8
    14a8:	0003da00 	andeq	sp, r3, r0, lsl #20
			//dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
			byte id = pgm_read_byte(&cPinTable[i]);
			dxl_set_txpacket_parameter(2 + 3 * i, id);
    14ac:	012e0000 	teqeq	lr, r0
    14b0:	000017bc 	strheq	r1, [r0], -ip
    14b4:	0104b403 	tsteq	r4, r3, lsl #8
    14b8:	0000004a 	andeq	r0, r0, sl, asr #32
	...
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(g_awGoalAXPos[i]));
    14c4:	08b45d01 	ldmeq	r4!, {r0, r8, sl, fp, ip, lr}
    14c8:	6e2f0000 	cdpvs	0, 2, cr0, cr15, cr0, {0}
    14cc:	04b30300 	ldrteq	r0, [r3], #768
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
    14d0:	0000004a 	andeq	r0, r0, sl, asr #32
    14d4:	000003f8 	strdeq	r0, [r0], -r8
    14d8:	000ce230 	andeq	lr, ip, r0, lsr r2
    14dc:	04b50300 	ldrteq	r0, [r5], #768
    14e0:	0000004a 	andeq	r0, r0, sl, asr #32
    14e4:	dc305001 	ldcle	0, cr5, [r0], #-4
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
    14e8:	03000018 	movweq	r0, #24	; 0x18
    14ec:	004a04b6 	strheq	r0, [sl], #-70
    14f0:	51010000 	tstpl	r1, r0
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
    14f4:	0013fb30 	andseq	pc, r3, r0, lsr fp
    14f8:	04b70300 	ldrteq	r0, [r7], #768
    14fc:	0000004a 	andeq	r0, r0, sl, asr #32
    1500:	2d005201 	sfmcs	f5, 4, [r0, #-4]
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
		dxl_set_txpacket_parameter(1, 2);
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
    1504:	000c9201 	andeq	r9, ip, r1, lsl #4
    1508:	04d00300 	ldrbeq	r0, [r0], #768
    150c:	00002c01 	andeq	r2, r0, r1, lsl #24
	...
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
		}

		dxl_set_txpacket_length((4 + 1) * poseSize + 4);
    1518:	00040b00 	andeq	r0, r4, r0, lsl #22
    151c:	0008f300 	andeq	pc, r8, r0, lsl #6
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- CommitServoDriver ---\n");
#endif
		dxl_txrx_packet();
    1520:	10762b00 	rsbsne	r2, r6, r0, lsl #22

			u16 CommStatus = dxl_get_result();
    1524:	d0030000 	andle	r0, r3, r0
#ifdef USING_PC_UART
			if (CommStatus == DXL_RXSUCCESS)
    1528:	00002c04 	andeq	r2, r0, r4, lsl #24
				PrintErrorCode();
    152c:	00043600 	andeq	r3, r4, r0, lsl #12
			else
				PrintCommStatus(CommStatus);
    1530:	107c2b00 	rsbsne	r2, ip, r0, lsl #22
    1534:	d0030000 	andle	r0, r3, r0
#endif
#endif
		} else {
			BioloidControllerEx_interpolateSetup(wMoveTime);
    1538:	00002c04 	andeq	r2, r0, r4, lsl #24

	}

	CommanderInputController_AllowControllerInterrupts(true);

}
    153c:	00045400 	andeq	r5, r4, r0, lsl #8
    1540:	012a0000 	teqeq	sl, r0
    1544:	00001004 	andeq	r1, r0, r4
    1548:	01043203 	tsteq	r4, r3, lsl #4
	...
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    1554:	00000472 	andeq	r0, r0, r2, ror r4
    1558:	00000986 	andeq	r0, r0, r6, lsl #19
    155c:	0018ec2b 	andseq	lr, r8, fp, lsr #24
    1560:	04320300 	ldrteq	r0, [r2], #-768
    1564:	00000025 	andeq	r0, r0, r5, lsr #32


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1568:	0000049d 	muleq	r0, sp, r4
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    156c:	0019022b 	andseq	r0, r9, fp, lsr #4
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1570:	04320300 	ldrteq	r0, [r2], #-768
    1574:	00000025 	andeq	r0, r0, r5, lsr #32
    1578:	000004b0 	strheq	r0, [r0], -r0
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    157c:	0018f72b 	andseq	pc, r8, fp, lsr #14
    1580:	04320300 	ldrteq	r0, [r2], #-768
    1584:	00000025 	andeq	r0, r0, r5, lsr #32


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1588:	000004c3 	andeq	r0, r0, r3, asr #9
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    158c:	0017172b 	andseq	r1, r7, fp, lsr #14
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1590:	04320300 	ldrteq	r0, [r2], #-768
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1594:	00000074 	andeq	r0, r0, r4, ror r0
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    1598:	000004e1 	andeq	r0, r0, r1, ror #9

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
    159c:	0012ca2c 	andseq	ip, r2, ip, lsr #20
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    15a0:	04330300 	ldrteq	r0, [r3], #-768
			g_awGoalAXPos[FIRSTTIBIAPIN + LegIndex] = wTibiaSDV;
    15a4:	00000025 	andeq	r0, r0, r5, lsr #32
    15a8:	000004f4 	strdeq	r0, [r0], -r4
    15ac:	00103431 	andseq	r3, r0, r1, lsr r4

#endif
		} else {
			BioloidControllerEx_setNextPose(
    15b0:	04340300 	ldrteq	r0, [r4], #-768
    15b4:	00000025 	andeq	r0, r0, r5, lsr #32
					pgm_read_byte(&cPinTable[FIRSTCOXAPIN + LegIndex]),
					wCoxaSDV);
			BioloidControllerEx_setNextPose(
    15b8:	00103a2c 	andseq	r3, r0, ip, lsr #20
    15bc:	04350300 	ldrteq	r0, [r5], #-768
    15c0:	00000025 	andeq	r0, r0, r5, lsr #32
					pgm_read_byte(&cPinTable[FIRSTFEMURPIN + LegIndex]),
					wFemurSDV);
			BioloidControllerEx_setNextPose(
    15c4:	00000507 	andeq	r0, r0, r7, lsl #10
    15c8:	00102e31 	andseq	r2, r0, r1, lsr lr
					wTibiaSDV);

		}
	}
	CommanderInputController_AllowControllerInterrupts(true); // Ok for hserial again...
}
    15cc:	04370300 	ldrteq	r0, [r7], #-768
    15d0:	00000025 	andeq	r0, r0, r5, lsr #32
    15d4:	1b012a00 	blne	4bddc <__Stack_Size+0x4b9dc>
    15d8:	0300000e 	movweq	r0, #14	; 0xe
    15dc:	000104eb 	andeq	r0, r1, fp, ror #9

void StartUpdateServos() {
    15e0:	00000000 	andeq	r0, r0, r0
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update
    15e4:	1a000000 	bne	15ec <__Stack_Size+0x11ec>
    15e8:	77000005 	strvc	r0, [r0, -r5]
    15ec:	2b00000a 	blcs	161c <__Stack_Size+0x121c>

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		OutputServoInfoForLeg(LegIndex,
    15f0:	000018ec 	andeq	r1, r0, ip, ror #17
    15f4:	2c04eb03 	stccs	11, cr14, [r4], {3}
    15f8:	46000000 	strmi	r0, [r0], -r0
    15fc:	2b000005 	blcs	1618 <__Stack_Size+0x1218>
    1600:	00001902 	andeq	r1, r0, r2, lsl #18
    1604:	2c04eb03 	stccs	11, cr14, [r4], {3}
    1608:	59000000 	stmdbpl	r0, {}
    160c:	2b000005 	blcs	1628 <__Stack_Size+0x1228>
    1610:	000018f7 	strdeq	r1, [r0], -r7
    1614:	2c04eb03 	stccs	11, cr14, [r4], {3}
    1618:	6c000000 	stcvs	0, cr0, [r0], {0}
    161c:	2b000005 	blcs	1638 <__Stack_Size+0x1238>
    1620:	00000f27 	andeq	r0, r0, r7, lsr #30
    1624:	2c04eb03 	stccs	11, cr14, [r4], {3}
    1628:	8a000000 	bhi	1630 <__Stack_Size+0x1230>
    162c:	2b000005 	blcs	1648 <__Stack_Size+0x1248>
    1630:	00000d5e 	andeq	r0, r0, lr, asr sp
    1634:	7404eb03 	strvc	lr, [r4], #-2819
    1638:	a9000000 	stmdbge	r0, {}
    163c:	31000005 	tstcc	r0, r5
    1640:	00000cb1 	strheq	r0, [r0], -r1
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1644:	2c04ec03 	stccs	12, cr14, [r4], {3}
				cTibiaInv[LegIndex] ?
						-TibiaAngle1[LegIndex] : TibiaAngle1[LegIndex]);

	}

}
    1648:	31000000 	tstcc	r0, r0
    164c:	000013b8 	strheq	r1, [r0], -r8
    1650:	2c04ed03 	stccs	13, cr14, [r4], {3}
    1654:	2c000000 	stccs	0, cr0, [r0], {0}
    1658:	00000d68 	andeq	r0, r0, r8, ror #26
    165c:	2c04ee03 	stccs	14, cr14, [r4], {3}
    1660:	c8000000 	stmdagt	r0, {}
#else
word g_wLastVoltage = 0xffff;    // save the last voltage we retrieved...
byte g_bLegVoltage = 0;		// what leg did we last check?
unsigned long g_ulTimeLastBatteryVoltage;
#define VOLTAGE_REPEAT_MAX  3
word GetBatteryVoltage(void) {
    1664:	2c000005 	stccs	0, cr0, [r0], {5}
	if (interpolating && (g_wLastVoltage != 0xffff)
    1668:	00001436 	andeq	r1, r0, r6, lsr r4
    166c:	2c04ef03 	stccs	15, cr14, [r4], {3}
    1670:	db000000 	blle	1678 <__Stack_Size+0x1278>
    1674:	30000005 	andcc	r0, r0, r5
    1678:	00001017 	andeq	r1, r0, r7, lsl r0
    167c:	2c04f003 	stccs	0, cr15, [r4], {3}
    1680:	02000000 	andeq	r0, r0, #0	; 0x0
    1684:	ae30207d 	mrcge	0, 1, r2, cr0, cr13, {3}
			&& ((getMillis() - g_ulTimeLastBatteryVoltage)
					< VOLTAGE_MAX_TIME_BETWEEN_CALLS))
		return g_wLastVoltage;
    1688:	03000016 	movweq	r0, #22	; 0x16

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
    168c:	002c04f1 	strdeq	r0, [ip], -r1
    1690:	7d020000 	stcvc	0, cr0, [r2]
    1694:	12ca2c24 	sbcne	r2, sl, #9216	; 0x2400
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    1698:	f2030000 	vhadd.s8	d0, d3, d0
			g_wLastVoltage = wVoltage * 10;
    169c:	00002c04 	andeq	r2, r0, r4, lsl #24

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    16a0:	0005ee00 	andeq	lr, r5, r0, lsl #28
			g_wLastVoltage = wVoltage * 10;
    16a4:	10342c00 	eorsne	r2, r4, r0, lsl #24
		}
	} while (--bLoopCnt);

	return 0;

}
    16a8:	f3030000 	vhadd.u8	d0, d3, d0
    16ac:	00002c04 	andeq	r2, r0, r4, lsl #24
    16b0:	00060100 	andeq	r0, r6, r0, lsl #2
    16b4:	103a2c00 	eorsne	r2, sl, r0, lsl #24
// ReadMsgs
//==============================================================================

/* process messages coming from Commander
 *  format = 0xFF RIGHT_H RIGHT_V LEFT_H LEFT_V BUTTONS EXT CHECKSUM */
int Commander_ReadMsgs() {
    16b8:	f4030000 	vst4.8	{d0-d3}, [r3], r0
	 }
	 #endif
	 */
	//while (CheckZBNewArrive() > 0) {
	while (1) {
		if (zgb_rx_check_arduino() == 1) {
    16bc:	00002c04 	andeq	r2, r0, r4, lsl #24
    16c0:	00062000 	andeq	r2, r6, r0

			leftV = (signed char) (zgb_rx_data_right_V_());
    16c4:	012a0000 	teqeq	sl, r0
    16c8:	00000c49 	andeq	r0, r0, r9, asr #24
			leftH = (signed char) (zgb_rx_data_right_H_());
    16cc:	01053503 	tsteq	r5, r3, lsl #10
	...
			rightV = (signed char) (zgb_rx_data_left_V_());
    16d8:	0000063f 	andeq	r0, r0, pc, lsr r6
			rightH = (signed char) (zgb_rx_data_left_H_());
    16dc:	00000b27 	andeq	r0, r0, r7, lsr #22
    16e0:	0014fd2b 	andseq	pc, r4, fp, lsr #26
			buttons = zgb_rx_data_buttons();
    16e4:	05340300 	ldreq	r0, [r4, #-768]!
    16e8:	0000002c 	andeq	r0, r0, ip, lsr #32
			ext = zgb_rx_data_extra();
    16ec:	0000066a 	andeq	r0, r0, sl, ror #12
    16f0:	0015082b 	andseq	r0, r5, fp, lsr #16

	}

	return 0;

}
    16f4:	05340300 	ldreq	r0, [r4, #-768]!
    16f8:	0000002c 	andeq	r0, r0, ip, lsr #32
    16fc:	0000067d 	andeq	r0, r0, sp, ror r6
    1700:	0015132b 	andseq	r1, r5, fp, lsr #6
    1704:	05340300 	ldreq	r0, [r4, #-768]!
    1708:	0000002c 	andeq	r0, r0, ip, lsr #32
    170c:	0000069b 	muleq	r0, fp, r6
    1710:	0013312b 	andseq	r3, r3, fp, lsr #2

//==============================================================================
// This is The main code to input function to read inputs from the Commander and then
//process any commands.
//==============================================================================
void CommanderInputController_ControlInput(void) {
    1714:	05350300 	ldreq	r0, [r5, #-768]!

	// See if we have a new command available...
	if (Commander_ReadMsgs() > 0) {
    1718:	00000074 	andeq	r0, r0, r4, ror r0
    171c:	000006ae 	andeq	r0, r0, lr, lsr #13
    1720:	0015b030 	andseq	fp, r5, r0, lsr r0
    1724:	05360300 	ldreq	r0, [r6, #-768]!
		// If we receive a valid message than turn robot on...
		boolean fAdjustLegPositions = false;
		short sLegInitXZAdjust = 0;
		short sLegInitAngleAdjust = 0;

		if (!g_InControlState.fRobotOn) {
    1728:	0000004a 	andeq	r0, r0, sl, asr #32
    172c:	b6315701 	ldrtlt	r5, [r1], -r1, lsl #14
			g_InControlState.fRobotOn = true;
    1730:	03000017 	movweq	r0, #23	; 0x17
    1734:	004a0537 	subeq	r0, sl, r7, lsr r5
		}

		// [SWITCH MODES]

		// Cycle through modes...
		if ((buttons & BUT_LT) && !(buttonsPrev & BUT_LT)) {
    1738:	1b310000 	blne	c41740 <__Stack_Size+0xc41340>
    173c:	03000018 	movweq	r0, #24	; 0x18
    1740:	004a0538 	subeq	r0, sl, r8, lsr r5
    1744:	e3310000 	teq	r1, #0	; 0x0
    1748:	03000017 	movweq	r0, #23	; 0x17
    174c:	002c0539 	eoreq	r0, ip, r9, lsr r5

			if (++ControlMode >= MODECNT) {
    1750:	aa310000 	bge	c41758 <__Stack_Size+0xc41358>
    1754:	0300000f 	movweq	r0, #15	; 0xf
    1758:	0025053e 	eoreq	r0, r5, lr, lsr r5
    175c:	b0310000 	eorslt	r0, r1, r0
				ControlMode = WALKMODE;    // cycled back around...
				Buzzed(50, 2000);
    1760:	0300000f 	movweq	r0, #15	; 0xf
    1764:	0025053f 	eoreq	r0, r5, pc, lsr r5
    1768:	54150000 	ldrpl	r0, [r5]
				Buzzed(50, 3000);
    176c:	40030033 	andmi	r0, r3, r3, lsr r0
    1770:	00002505 	andeq	r2, r0, r5, lsl #10

			} else {
				Buzzed(50, 2000);
    1774:	991d0000 	ldmdbls	sp, {}
    1778:	00000005 	andeq	r0, r0, r5
    177c:	00000000 	andeq	r0, r0, r0
			}
			if (ControlMode != SINGLELEGMODE)
    1780:	01000000 	tsteq	r0, r0
    1784:	000b645d 	andeq	r6, fp, sp, asr r4
				g_InControlState.SelectedLeg = 255;
    1788:	05ac3200 	streq	r3, [ip, #512]!
    178c:	06cc0000 	strbeq	r0, [ip], r0
    1790:	b81e0000 	ldmdalt	lr, {}

		}

		//[Common functions]
		//Switch Balance mode on/off
		if ((buttons & BUT_L4) && !(buttonsPrev & BUT_L4)) {
    1794:	01000005 	tsteq	r0, r5
    1798:	05c41e51 	strbeq	r1, [r4, #3665]
    179c:	52010000 	andpl	r0, r1, #0	; 0x0
    17a0:	0005d032 	andeq	sp, r5, r2, lsr r0
    17a4:	0006df00 	andeq	sp, r6, r0, lsl #30
    17a8:	05dc3300 	ldrbeq	r3, [ip, #768]

			g_InControlState.BalanceMode = !g_InControlState.BalanceMode;
    17ac:	06fd0000 	ldrbteq	r0, [sp], r0
    17b0:	2a000000 	bcs	17b8 <__Stack_Size+0x13b8>
    17b4:	000df501 	andeq	pc, sp, r1, lsl #10
    17b8:	059a0300 	ldreq	r0, [sl, #768]
    17bc:	00000001 	andeq	r0, r0, r1
			if (g_InControlState.BalanceMode) {
    17c0:	00000000 	andeq	r0, r0, r0
				Buzzed(250, 1500);
    17c4:	00073100 	andeq	r3, r7, r0, lsl #2
    17c8:	000c2100 	andeq	r2, ip, r0, lsl #2
			} else {
				Buzzed(100, 2000);
    17cc:	00731500 	rsbseq	r1, r3, r0, lsl #10
    17d0:	2c059c03 	stccs	12, cr9, [r5], {3}
				Buzzed(50, 4000);
    17d4:	34000000 	strcc	r0, [r0]
    17d8:	00000599 	muleq	r0, r9, r5
    17dc:	00000020 	andeq	r0, r0, r0, lsr #32
			}
		}

		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
    17e0:	bc059e03 	stclt	14, cr9, [r5], {3}
    17e4:	3500000b 	strcc	r0, [r0, #-11]
    17e8:	00000b51 	andeq	r0, r0, r1, asr fp
    17ec:	000b4a35 	andeq	r4, fp, r5, lsr sl
    17f0:	0b433500 	bleq	10cebf8 <__Stack_Size+0x10ce7f8>
    17f4:	3a350000 	bcc	d417fc <__Stack_Size+0xd413fc>
			if (g_BodyYOffset > 0)
    17f8:	3600000b 	strcc	r0, [r0], -fp
    17fc:	00000038 	andeq	r0, r0, r8, lsr r0
				g_BodyYOffset = 0;
    1800:	0005dc33 	andeq	sp, r5, r3, lsr ip
    1804:	00075000 	andeq	r5, r7, r0
			else
				g_BodyYOffset = 35;
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1808:	34000000 	strcc	r0, [r0]
		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
			if (g_BodyYOffset > 0)
				g_BodyYOffset = 0;
			else
				g_BodyYOffset = 35;
    180c:	00000599 	muleq	r0, r9, r5
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1810:	00000050 	andeq	r0, r0, r0, asr r0
    1814:	f005a003 	undefined instruction 0xf005a003

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1818:	3500000b 	strcc	r0, [r0, #-11]
		int ly = leftV;
		if (buttons & BUT_L6) {
    181c:	00000b51 	andeq	r0, r0, r1, asr fp

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1820:	000b4a35 	andeq	r4, fp, r5, lsr sl
    1824:	0b433500 	bleq	10cec2c <__Stack_Size+0x10ce82c>
		int ly = leftV;
    1828:	3a350000 	bcc	d41830 <__Stack_Size+0xd41430>
    182c:	3600000b 	strcc	r0, [r0], -fp
		if (buttons & BUT_L6) {
    1830:	00000068 	andeq	r0, r0, r8, rrx
    1834:	0005dc33 	andeq	sp, r5, r3, lsr ip
			// raise or lower the robot on the joystick up /down
			// Maybe should have Min/Max
			int delta = rightV / 25;
    1838:	0007a500 	andeq	sl, r7, r0, lsl #10
    183c:	37000000 	strcc	r0, [r0, -r0]
    1840:	00000599 	muleq	r0, r9, r5
    1844:	00000080 	andeq	r0, r0, r0, lsl #1
    1848:	3505a303 	strcc	sl, [r5, #-771]
    184c:	00000b51 	andeq	r0, r0, r1, asr fp
			if (delta) {
    1850:	000b4a35 	andeq	r4, fp, r5, lsr sl
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
    1854:	0b433500 	bleq	10cec5c <__Stack_Size+0x10ce85c>
    1858:	3a350000 	bcc	d41860 <__Stack_Size+0xd41460>
    185c:	3600000b 	strcc	r0, [r0], -fp
    1860:	00000098 	muleq	r0, r8, r0
    1864:	0005dc33 	andeq	sp, r5, r3, lsr ip
    1868:	00081000 	andeq	r1, r8, r0
    186c:	00000000 	andeq	r0, r0, r0
    1870:	16d9012e 	ldrbne	r0, [r9], lr, lsr #2
    1874:	af030000 	svcge	0x00030000
			sLegInitAngleAdjust = ly / 8;
			lx = 0;
			ly = 0;

			// Likewise for Speed control
			delta = rightH / 16;   //
    1878:	002c0105 	eoreq	r0, ip, r5, lsl #2
	...
    1884:	5d010000 	stcpl	0, cr0, [r1]
    1888:	00000c6a 	andeq	r0, r0, sl, ror #24
			if ((delta < 0) && g_InControlState.SpeedControl) {
    188c:	0013862b 	andseq	r8, r3, fp, lsr #12
    1890:	05af0300 	streq	r0, [pc, #768]!	; 1b98 <__Stack_Size+0x1798>
    1894:	0000002c 	andeq	r0, r0, ip, lsr #32
				if ((word)(-delta) < g_InControlState.SpeedControl)
    1898:	00000886 	andeq	r0, r0, r6, lsl #17
					g_InControlState.SpeedControl += delta;
    189c:	000c9b22 	andeq	r9, ip, r2, lsr #22
				else
					g_InControlState.SpeedControl = 0;
    18a0:	05af0300 	streq	r0, [pc, #768]!	; 1ba8 <__Stack_Size+0x17a8>
    18a4:	0000002c 	andeq	r0, r0, ip, lsr #32

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
    18a8:	5c225101 	stfpls	f5, [r2], #-4
    18ac:	03000014 	movweq	r0, #20	; 0x14
    18b0:	007405af 	rsbseq	r0, r4, pc, lsr #11
				g_InControlState.SpeedControl += delta;
				if (g_InControlState.SpeedControl > 2000)
    18b4:	52010000 	andpl	r0, r1, #0	; 0x0
					g_InControlState.SpeedControl = 0;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
				g_InControlState.SpeedControl += delta;
    18b8:	2c013800 	stccs	8, cr3, [r1], {0}
				if (g_InControlState.SpeedControl > 2000)
					g_InControlState.SpeedControl = 2000;
    18bc:	03000015 	movweq	r0, #21	; 0x15
    18c0:	a20105bd 	andge	r0, r1, #792723456	; 0x2f400000
	...

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
    18cc:	af000000 	svcge	0x00000000
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18d0:	2a000008 	bcs	18f8 <__Stack_Size+0x14f8>
    18d4:	0016c601 	andseq	ip, r6, r1, lsl #12
    18d8:	05d10300 	ldrbeq	r0, [r1, #768]
    18dc:	00000001 	andeq	r0, r0, r1
			sLegInitAngleAdjust = ly / 8;
    18e0:	00000000 	andeq	r0, r0, r0
    18e4:	0008da00 	andeq	sp, r8, r0, lsl #20
    18e8:	000cbb00 	andeq	fp, ip, r0, lsl #22
    18ec:	11702b00 	cmnne	r0, r0, lsl #22
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f0:	d1030000 	tstle	r3, r0
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18f4:	0000a205 	andeq	sl, r0, r5, lsl #4
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f8:	00090500 	andeq	r0, r9, r0, lsl #10
		}

		//[Walk functions]
		if (ControlMode == WALKMODE) {
    18fc:	0da53100 	stfeqs	f3, [r5]
    1900:	de030000 	cdple	0, 0, cr0, cr3, cr0, {0}
    1904:	00006305 	andeq	r6, r0, r5, lsl #6

			//Switch gates
			if (((buttons & BUT_R1) && !(buttonsPrev & BUT_R1))
    1908:	071c0000 	ldreq	r0, [ip, -r0]
    190c:	00000006 	andeq	r0, r0, r6
    1910:	00000000 	andeq	r0, r0, r0
    1914:	01000000 	tsteq	r0, r0
    1918:	06271d5d 	undefined
	...
    1924:	5d010000 	stcpl	0, cr0, [r1]
    1928:	00000ce5 	andeq	r0, r0, r5, ror #25
    192c:	0006361e 	andeq	r3, r6, lr, lsl r6
    1930:	00500100 	subseq	r0, r0, r0, lsl #2
    1934:	15c30139 	strbne	r0, [r3, #313]
    1938:	1c030000 	stcne	0, cr0, [r3], {0}
    193c:	00000006 	andeq	r0, r0, r6
    1940:	00000000 	andeq	r0, r0, r0
    1944:	00092300 	andeq	r2, r9, r0, lsl #6
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1948:	000d1d00 	andeq	r1, sp, r0, lsl #26
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    194c:	00693a00 	rsbeq	r3, r9, r0, lsl #20
    1950:	63062503 	movwvs	r2, #25859	; 0x6503
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1954:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    1958:	2c000009 	stccs	0, cr0, [r0], {9}
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
					Buzzed(50, 2000);
    195c:	00001170 	andeq	r1, r0, r0, ror r1
    1960:	a2062603 	andge	r2, r6, #3145728	; 0x300000
    1964:	6c000000 	stcvs	0, cr0, [r0], {0}
				} else {
					Buzzed(50, 2000);
    1968:	00000009 	andeq	r0, r0, r9
    196c:	0c4f0138 	stfeqe	f0, [pc], {56}
    1970:	24030000 	strcs	r0, [r3]
					Buzzed(50, 2250);
    1974:	00b40103 	adcseq	r0, r4, r3, lsl #2
	...
					g_InControlState.GaitType = 0;
    1980:	098a0000 	stmibeq	sl, {}
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    1984:	01280000 	teqeq	r8, r0
    1988:	0000125f 	andeq	r1, r0, pc, asr r2
    198c:	0101e602 	tsteq	r1, r2, lsl #12
	...

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    1998:	000009b5 	strheq	r0, [r0], -r5
    199c:	14e70128 	strbtne	r0, [r7], #296
    19a0:	b3020000 	movwlt	r0, #8192	; 0x2000
				}
				GaitSelect();
			}

			//Double leg lift height
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    19a4:	00000101 	andeq	r0, r0, r1, lsl #2
    19a8:	00000000 	andeq	r0, r0, r0
    19ac:	09e00000 	stmibeq	r0!, {}^
    19b0:	012a0000 	teqeq	sl, r0
    19b4:	000012a6 	andeq	r1, r0, r6, lsr #5
				Buzzed(50, 2000);
    19b8:	01011c02 	tsteq	r1, r2, lsl #24
	...
				HeightSpeedMode = (HeightSpeedMode + 1) & 0x3; // wrap around mode
    19c4:	00000a0b 	andeq	r0, r0, fp, lsl #20
    19c8:	00000dcb 	andeq	r0, r0, fp, asr #27
    19cc:	0012122b 	andseq	r1, r2, fp, lsr #4
				DoubleTravelOn = HeightSpeedMode & 0x1;
    19d0:	011c0200 	tsteq	ip, r0, lsl #4
    19d4:	00000063 	andeq	r0, r0, r3, rrx
				if (HeightSpeedMode & 0x2)
    19d8:	00000a36 	andeq	r0, r0, r6, lsr sl
    19dc:	000ebb2b 	andeq	fp, lr, fp, lsr #22
					g_InControlState.LegLiftHeight = 80;
    19e0:	011c0200 	tsteq	ip, r0, lsl #4
    19e4:	00000063 	andeq	r0, r0, r3, rrx
				else
					g_InControlState.LegLiftHeight = 50;
			}

			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {
    19e8:	00000a54 	andeq	r0, r0, r4, asr sl
    19ec:	0200693b 	andeq	r6, r0, #966656	; 0xec000
    19f0:	054a0135 	strbeq	r0, [sl, #-309]
    19f4:	55010000 	strpl	r0, [r1]
    19f8:	001e3031 	andseq	r3, lr, r1, lsr r0

				if ((++bJoystickWalkMode) > 1)
    19fc:	01430200 	cmpeq	r3, r0, lsl #4
    1a00:	00000051 	andeq	r0, r0, r1, asr r0
    1a04:	0000003c 	andeq	r0, r0, ip, lsr r0

					bJoystickWalkMode = 0;
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a08:	00000000 	andeq	r0, r0, r0
			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {

				if ((++bJoystickWalkMode) > 1)

					bJoystickWalkMode = 0;
    1a0c:	64691500 	strbtvs	r1, [r9], #-1280
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a10:	01370200 	teqeq	r7, r0, lsl #4
    1a14:	00000074 	andeq	r0, r0, r4, ror r0
    1a18:	012a0000 	teqeq	sl, r0
    1a1c:	00001571 	andeq	r1, r0, r1, ror r5
			}

			//Walking
			switch (bJoystickWalkMode) {
    1a20:	0101c602 	tsteq	r1, r2, lsl #12
	...
			case 0:
				g_InControlState.TravelLength.x = -lx;
    1a2c:	00000a72 	andeq	r0, r0, r2, ror sl
    1a30:	00000dfa 	strdeq	r0, [r0], -sl
    1a34:	0000b036 	andeq	fp, r0, r6, lsr r0
				g_InControlState.TravelLength.z = -ly;
    1a38:	00693a00 	rsbeq	r3, r9, r0, lsl #20
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
				break;
			case 1:
				g_InControlState.TravelLength.z = (rightV); //Right Stick Up/Down
    1a3c:	4a01d002 	bmi	75a4c <__Stack_Size+0x7564c>
    1a40:	91000005 	tstls	r0, r5
    1a44:	0000000a 	andeq	r0, r0, sl
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
    1a48:	cd013d00 	stcgt	13, cr3, [r1]
    1a4c:	02000010 	andeq	r0, r0, #16	; 0x10
    1a50:	000001b2 	strheq	r0, [r0], -r2
    1a54:	00000000 	andeq	r0, r0, r0
    1a58:	0aaf0000 	beq	febc1a60 <SCS_BASE+0x1ebb3a60>
    1a5c:	0e230000 	cdpeq	0, 2, cr0, cr3, cr0, {0}
				break;

			}

			if (!DoubleTravelOn) {  //(Double travel length)
    1a60:	c8360000 	ldmdagt	r6!, {}
				g_InControlState.TravelLength.x =
    1a64:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    1a68:	bb020069 	bllt	81c14 <__Stack_Size+0x81814>
    1a6c:	00000074 	andeq	r0, r0, r4, ror r0
						g_InControlState.TravelLength.x / 2;
				g_InControlState.TravelLength.z =
    1a70:	012a0000 	teqeq	sl, r0
    1a74:	00001498 	muleq	r0, r8, r4
    1a78:	01019f02 	tsteq	r1, r2, lsl #30
	...

		}

		//[Translate functions]
		g_BodyYShift = 0;
		if (ControlMode == TRANSLATEMODE) {
    1a84:	00000ada 	ldrdeq	r0, [r0], -sl
    1a88:	00000e52 	andeq	r0, r0, r2, asr lr

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
    1a8c:	0000003c 	andeq	r0, r0, ip, lsr r0
    1a90:	00000000 	andeq	r0, r0, r0
    1a94:	00691500 	rsbeq	r1, r9, r0, lsl #10
    1a98:	7401a402 	strvc	sl, [r1], #-1026
    1a9c:	00000000 	andeq	r0, r0, r0
    1aa0:	34013f00 	strcc	r3, [r1], #-3840
    1aa4:	02000016 	andeq	r0, r0, #22	; 0x16
    1aa8:	00000165 	andeq	r0, r0, r5, ror #2
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1aac:	00000000 	andeq	r0, r0, r0
    1ab0:	0b050000 	bleq	141ab8 <__Stack_Size+0x1416b8>
    1ab4:	012a0000 	teqeq	sl, r0
    1ab8:	0000164f 	andeq	r1, r0, pc, asr #12
    1abc:	0102ce03 	tsteq	r2, r3, lsl #28
	...
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac8:	00000b30 	andeq	r0, r0, r0, lsr fp
    1acc:	00000e9a 	muleq	r0, sl, lr
    1ad0:	00061240 	andeq	r1, r6, r0, asr #4
    1ad4:	0000e000 	andeq	lr, r0, r0


			//      g_InControlState.BodyPos.x = (lx)/2;
			//      g_InControlState.BodyPos.z = -(ly)/3;
			//      g_InControlState.BodyRot1.y = (rightH)*2;
			g_BodyYShift = (-(rightV) / 2);
    1ad8:	02fb0300 	rscseq	r0, fp, #0	; 0x0
    1adc:	00061d40 	andeq	r1, r6, r0, asr #26
    1ae0:	00010000 	andeq	r0, r1, r0
    1ae4:	02fd0300 	rscseq	r0, sp, #0	; 0x0
    1ae8:	f3012a00 	vpmax.u8	d2, d1, d0
    1aec:	02000015 	andeq	r0, r0, #21	; 0x15
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
    1af0:	00010151 	andeq	r0, r1, r1, asr r1
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1af4:	00000000 	andeq	r0, r0, r0
    1af8:	4f000000 	svcmi	0x00000000
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1afc:	0e00000b 	cdpeq	0, 0, cr0, cr0, cr11, {0}
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1b00:	2b00000f 	blcs	1b44 <__Stack_Size+0x1744>
			g_BodyYShift = (-(rightV) / 2);
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
    1b04:	000017ef 	andeq	r1, r0, pc, ror #15
			g_InControlState.BodyRot1.y = (rightH) * 2;
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1b08:	a2015102 	andge	r5, r1, #-2147483648	; 0x80000000
    1b0c:	7a000000 	bvc	1b14 <__Stack_Size+0x1714>
    1b10:	3c00000b 	stccc	0, cr0, [r0], {11}
	...
		}

		//[Single leg functions]
#ifdef OPT_SINGLELEG
		if (ControlMode == SINGLELEGMODE) {
    1b1c:	0200693a 	andeq	r6, r0, #950272	; 0xe8000

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
    1b20:	054a0177 	strbeq	r0, [sl, #-375]
    1b24:	0ba50000 	bleq	fe941b2c <SCS_BASE+0x1e933b2c>
    1b28:	4e2c0000 	cdpmi	0, 2, cr0, cr12, cr0, {0}
    1b2c:	02000011 	andeq	r0, r0, #17	; 0x11
    1b30:	00a20178 	adceq	r0, r2, r8, ror r1
				Buzzed(50,2000);
    1b34:	0be90000 	bleq	ffa41b3c <SCS_BASE+0x1fa33b3c>
    1b38:	30310000 	eorscc	r0, r1, r0
    1b3c:	0200001e 	andeq	r0, r0, #30	; 0x1e
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b40:	0051018a 	subseq	r0, r1, sl, lsl #3
    1b44:	003c0000 	eorseq	r0, ip, r0
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
				} else {
					g_InControlState.SelectedLeg = 0;
    1b48:	00000000 	andeq	r0, r0, r0
		if (ControlMode == SINGLELEGMODE) {

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
				Buzzed(50,2000);
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b4c:	15000000 	strne	r0, [r0]
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
    1b50:	02006469 	andeq	r6, r0, #1761607680	; 0x69000000
			   g_InControlState.SLLeg.x= (signed char)((int)((int)lx+128)/2); //Left Stick Right/Left
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
    1b54:	0074017c 	rsbseq	r0, r4, ip, ror r1
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b58:	00000000 	andeq	r0, r0, r0
    1b5c:	0e013d00 	cdpeq	13, 0, cr3, cr1, cr0, {0}
    1b60:	02000016 	andeq	r0, r0, #22	; 0x16
    1b64:	000001cf 	andeq	r0, r0, pc, asr #3
    1b68:	00000000 	andeq	r0, r0, r0
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b6c:	0bfc0000 	bleq	fff01b74 <SCS_BASE+0x1fef3b74>
    1b70:	0f850000 	svceq	0x00850000
    1b74:	a5240000 	strge	r0, [r4]!
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b78:	0200000d 	andeq	r0, r0, #13	; 0xd
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b7c:	000074cc 	andeq	r7, r0, ip, asr #9
    1b80:	000c2700 	andeq	r2, ip, r0, lsl #14
    1b84:	10e62400 	rscne	r2, r6, r0, lsl #8
				Buzzed(50,2000);
    1b88:	cc020000 	stcgt	0, cr0, [r2], {0}
    1b8c:	0000002c 	andeq	r0, r0, ip, lsr #32
				g_InControlState.fSLHold = !g_InControlState.fSLHold;
    1b90:	00000c45 	andeq	r0, r0, r5, asr #24
    1b94:	0018cf24 	andseq	ip, r8, r4, lsr #30
    1b98:	2ccc0200 	sfmcs	f0, 2, [ip], {0}
    1b9c:	58000000 	stmdapl	r0, {}
			}
		}
#endif

		//Calculate walking time delay
		g_InControlState.InputTimeDelay = 128- max(max(abs(lx), abs(ly)), abs(rightH));
    1ba0:	2400000c 	strcs	r0, [r0], #-12
    1ba4:	000014f0 	strdeq	r1, [r0], -r0
    1ba8:	002ccd02 	eoreq	ip, ip, r2, lsl #26
    1bac:	0c6b0000 	stcleq	0, cr0, [fp]
    1bb0:	f2270000 	vhadd.s32	d0, d7, d0
    1bb4:	02000013 	andeq	r0, r0, #19	; 0x13
    1bb8:	0000a2d0 	ldrdeq	sl, [r0], -r0
    1bbc:	148e2700 	strne	r2, [lr], #1792
    1bc0:	d1020000 	tstle	r2, r0
    1bc4:	000000a2 	andeq	r0, r0, r2, lsr #1
    1bc8:	00184e27 	andseq	r4, r8, r7, lsr #28
    1bcc:	a2d20200 	sbcsge	r0, r2, #0	; 0x0
    1bd0:	00000000 	andeq	r0, r0, r0

		//Calculate g_InControlState.BodyPos.y
		g_InControlState.BodyPos.y = max(g_BodyYOffset + g_BodyYShift, 0);
    1bd4:	13a6012a 	undefined instruction 0x13a6012a
    1bd8:	06030000 	streq	r0, [r3], -r0
    1bdc:	00000103 	andeq	r0, r0, r3, lsl #2
    1be0:	00000000 	andeq	r0, r0, r0
    1be4:	0c7e0000 	ldcleq	0, cr0, [lr]
    1be8:	0fb00000 	svceq	0x00b00000

		if (sLegInitXZAdjust || sLegInitAngleAdjust) {
    1bec:	a52c0000 	strge	r0, [ip]!
    1bf0:	0300000d 	movweq	r0, #13	; 0xd
			// User asked for manual leg adjustment - only do when we have finished any previous adjustment

			if (!g_InControlState.ForceGaitStepCnt) {
    1bf4:	00740307 	rsbseq	r0, r4, r7, lsl #6
				if (sLegInitXZAdjust)
    1bf8:	0ca90000 	stceq	0, cr0, [r9]
					g_fDynamicLegXZLength = true;
    1bfc:	41000000 	tstmi	r0, r0
    1c00:	0010fd01 	andseq	pc, r0, r1, lsl #26

				sLegInitXZAdjust += GetLegsXZLength(); // Add on current length to our adjustment...
    1c04:	01990200 	orrseq	r0, r9, r0, lsl #4
    1c08:	000000a2 	andeq	r0, r0, r2, lsr #1
	...
				// Give system time to process previous calls
				AdjustLegPositions(sLegInitXZAdjust);
			}
		}

		if (fAdjustLegPositions && !g_fDynamicLegXZLength)
    1c14:	00000cbc 	strheq	r0, [r0], -ip
    1c18:	00000fee 	andeq	r0, r0, lr, ror #31
			AdjustLegPositionsToBodyHeight(); // Put main workings into main program file
    1c1c:	000f0727 	andeq	r0, pc, r7, lsr #14
		// Save away the buttons state as to not process the same press twice.
		buttonsPrev = buttons;
    1c20:	639f0200 	orrsvs	r0, pc, #0	; 0x0
    1c24:	3c000000 	stccc	0, cr0, [r0], {0}
	...
		extPrev = ext;
		g_ulLastMsgTime = getMillis();
    1c30:	00163f27 	andseq	r3, r6, r7, lsr #30
    1c34:	a2a10200 	adcge	r0, r1, #0	; 0x0
	} else {
		// We did not receive a valid packet.  check for a timeout to see if we should turn robot off...
		if (g_InControlState.fRobotOn) {
    1c38:	00000000 	andeq	r0, r0, r0
			if ((getMillis() - g_ulLastMsgTime) > ARBOTIX_TO)
    1c3c:	cf014200 	svcgt	0x00014200
    1c40:	0100000c 	tsteq	r0, ip
    1c44:	054a021c 	strbeq	r0, [sl, #-540]
	...
				CommanderTurnRobotOff();
    1c50:	0cdb0000 	ldcleq	0, cr0, [fp], {0}
		}
	}

}
    1c54:	013d0000 	teqeq	sp, r0
    1c58:	00001688 	andeq	r1, r0, r8, lsl #13
    1c5c:	0001d001 	andeq	sp, r1, r1
    1c60:	00000000 	andeq	r0, r0, r0
    1c64:	06000000 	streq	r0, [r0], -r0
    1c68:	a400000d 	strge	r0, [r0], #-13
    1c6c:	3c000010 	stccc	0, cr0, [r0], {16}
	...
    1c78:	0016c526 	andseq	ip, r6, r6, lsr #10
    1c7c:	b4d50100 	ldrblt	r0, [r5], #256
    1c80:	31000000 	tstcc	r0, r0
    1c84:	2600000d 	strcs	r0, [r0], -sp
    1c88:	000018a3 	andeq	r1, r0, r3, lsr #17
    1c8c:	002cd601 	eoreq	sp, ip, r1, lsl #12
    1c90:	0d690000 	stcleq	0, cr0, [r9]
    1c94:	92260000 	eorls	r0, r6, #0	; 0x0
    1c98:	01000013 	tsteq	r0, r3, lsl r0
    1c9c:	00002cd7 	ldrdeq	r2, [r0], -r7
    1ca0:	000da100 	andeq	sl, sp, r0, lsl #2
    1ca4:	786c3a00 	stmdavc	ip!, {r9, fp, ip, sp}^
    1ca8:	010b0100 	tsteq	fp, r0, lsl #2
    1cac:	0000054a 	andeq	r0, r0, sl, asr #10

extern void setupPhoenix(void);
extern void readSensors(void);


int Big_main(void) {
    1cb0:	00000dd9 	ldrdeq	r0, [r0], -r9

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
    1cb4:	00796c3a 	rsbseq	r6, r9, sl, lsr ip
	setupPhoenix();
    1cb8:	4a010c01 	bmi	44cc4 <__Stack_Size+0x448c4>
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1cbc:	1d000005 	stcne	0, cr0, [r0, #-20]

	while (1){
		while (1) {
			//Start time
			unsigned long lTimeWaitEnd;
			lTimerStart = getMillis();
    1cc0:	4300000e 	movwmi	r0, #14	; 0xe
	...
#ifdef MILLIS
			PrintString("Barebones lTimerStart ");
			Printu32d(lTimerStart);
			PrintString("\n");
#endif
			DoBackgroundProcess();
    1ccc:	00001092 	muleq	r0, r2, r0
			//Read input
			CheckVoltage();        // check our voltages...
    1cd0:	0015262c 	andseq	r2, r5, ip, lsr #12
			if (!g_fLowVoltageShutdown) {
    1cd4:	01100100 	tsteq	r0, r0, lsl #2
    1cd8:	0000054a 	andeq	r0, r0, sl, asr #10
				CommanderInputController_ControlInput();
    1cdc:	00000e51 	andeq	r0, r0, r1, asr lr
			}
			WriteOutputs();        // Write Outputs
			//Single leg control
			SingleLegControl();
    1ce0:	06124400 	ldreq	r4, [r2], -r0, lsl #8
	...
			DoBackgroundProcess();

			//Gait
			GaitSeq();

			DoBackgroundProcess();
    1cec:	43010000 	movwmi	r0, #4096	; 0x1000

			//Balance calculations
			TotalTransX = 0;     //reset values used for calculation of balance
    1cf0:	2d000001 	stccs	0, cr0, [r0, #-4]
    1cf4:	00137d01 	andseq	r7, r3, r1, lsl #26
			TotalTransZ = 0;
    1cf8:	01dc0300 	bicseq	r0, ip, r0, lsl #6
			TotalTransY = 0;
    1cfc:	00054a01 	andeq	r4, r5, r1, lsl #20
	...
			TotalXBal1 = 0;
			TotalYBal1 = 0;
    1d08:	000e7a00 	andeq	r7, lr, r0, lsl #20
    1d0c:	0010dd00 	andseq	sp, r0, r0, lsl #26
			TotalZBal1 = 0;
    1d10:	00003c00 	andeq	r3, r0, r0, lsl #24

			if (g_InControlState.BalanceMode) {
    1d14:	00000000 	andeq	r0, r0, r0
    1d18:	ff2c0000 	undefined instruction 0xff2c0000
    1d1c:	03000016 	movweq	r0, #22	; 0x16

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d20:	004a01e6 	subeq	r0, sl, r6, ror #3

					DoBackgroundProcess();
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d24:	0ea50000 	cdpeq	0, 10, cr0, cr5, cr0, {0}
    1d28:	00000000 	andeq	r0, r0, r0
    1d2c:	00056927 	andeq	r6, r5, r7, lsr #18

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs

					DoBackgroundProcess();
    1d30:	e82a0800 	stmda	sl!, {fp}
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d34:	45000010 	strmi	r0, [r0, #-16]
    1d38:	00000063 	andeq	r0, r0, r3, rrx
    1d3c:	0002ce27 	andeq	ip, r2, r7, lsr #28
    1d40:	f8280800 	undefined instruction 0xf8280800
    1d44:	45000010 	strmi	r0, [r0, #-16]
    1d48:	00000051 	andeq	r0, r0, r1, asr r0
    1d4c:	00042b27 	andeq	r2, r4, r7, lsr #22
    1d50:	f8280800 	undefined instruction 0xf8280800
    1d54:	0d000010 	stceq	0, cr0, [r0, #-64]
    1d58:	00000063 	andeq	r0, r0, r3, rrx
    1d5c:	00001119 	andeq	r1, r0, r9, lsl r1
    1d60:	00009f46 	andeq	r9, r0, r6, asr #30
    1d64:	0003ff00 	andeq	pc, r3, r0, lsl #30
    1d68:	0004af27 	andeq	sl, r4, r7, lsr #30
    1d6c:	24290800 	strtcs	r0, [r9], #-2048
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d70:	45000011 	strmi	r0, [r0, #-17]
    1d74:	00001108 	andeq	r1, r0, r8, lsl #2
    1d78:	00064a47 	andeq	r4, r6, r7, asr #20
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1d7c:	e8440800 	stmda	r4, {fp}^
    1d80:	00000010 	andeq	r0, r0, r0, lsl r0
					DoBackgroundProcess();
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d84:	00040e47 	andeq	r0, r4, r7, asr #28
    1d88:	e8440800 	stmda	r4, {fp}^
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
					DoBackgroundProcess();
    1d8c:	00000010 	andeq	r0, r0, r0, lsl r0
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d90:	0000630d 	andeq	r6, r0, sp, lsl #6
    1d94:	00115100 	andseq	r5, r1, r0, lsl #2
    1d98:	009f0e00 	addseq	r0, pc, r0, lsl #28
    1d9c:	00400000 	subeq	r0, r0, r0
    1da0:	0000ec27 	andeq	lr, r0, r7, lsr #24
    1da4:	5c450800 	mcrrpl	8, 0, r0, r5, cr0
    1da8:	45000011 	strmi	r0, [r0, #-17]
    1dac:	00001141 	andeq	r1, r0, r1, asr #2
    1db0:	00061947 	andeq	r1, r6, r7, asr #18
    1db4:	f8580800 	undefined instruction 0xf8580800
    1db8:	00000010 	andeq	r0, r0, r0, lsl r0
    1dbc:	0000f947 	andeq	pc, r0, r7, asr #18
    1dc0:	f8580800 	undefined instruction 0xf8580800
    1dc4:	00000010 	andeq	r0, r0, r0, lsl r0
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1dc8:	00032d27 	andeq	r2, r3, r7, lsr #26
    1dcc:	84590800 	ldrbhi	r0, [r9], #-2048
    1dd0:	45000011 	strmi	r0, [r0, #-17]
							LegPosZ[LegIndex] + GaitPosZ[LegIndex],
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}
				BalanceBody();
    1dd4:	00001108 	andeq	r1, r0, r8, lsl #2
			}

			//Reset IKsolution indicators
			IKSolution = 0;
    1dd8:	00210248 	eoreq	r0, r1, r8, asr #4
    1ddc:	6d8c0100 	stfvss	f0, [ip]
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1de0:	05000000 	streq	r0, [r0]
			}

			//Reset IKsolution indicators
			IKSolution = 0;
			IKSolutionWarning = 0;
			IKSolutionError = 0;
    1de4:	00000003 	andeq	r0, r0, r3
    1de8:	0ed74800 	cdpeq	8, 13, cr4, cr7, cr0, {0}

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
				DoBackgroundProcess();
    1dec:	9f010000 	svcls	0x00010000
				BodyFK(
    1df0:	0000002c 	andeq	r0, r0, ip, lsr #32
    1df4:	00000305 	andeq	r0, r0, r5, lsl #6
    1df8:	68480000 	stmdavs	r8, {}^
    1dfc:	01000014 	tsteq	r0, r4, lsl r0
    1e00:	00002ca0 	andeq	r2, r0, r0, lsr #25
    1e04:	00030500 	andeq	r0, r3, r0, lsl #10
    1e08:	48000000 	stmdami	r0, {}
    1e0c:	00000ff8 	strdeq	r0, [r0], -r8
    1e10:	0074a101 	rsbseq	sl, r4, r1, lsl #2
    1e14:	03050000 	movweq	r0, #20480	; 0x5000
    1e18:	00000000 	andeq	r0, r0, r0
    1e1c:	000fb648 	andeq	fp, pc, r8, asr #12
    1e20:	74a20100 	strtvc	r0, [r2], #256
    1e24:	05000000 	streq	r0, [r0]
    1e28:	00000003 	andeq	r0, r0, r3
    1e2c:	12f64800 	rscsne	r4, r6, #0	; 0x0
    1e30:	a4010000 	strge	r0, [r1]
    1e34:	00000094 	muleq	r0, r4, r0
    1e38:	00000305 	andeq	r0, r0, r5, lsl #6
    1e3c:	71480000 	cmpvc	r8, r0
    1e40:	01000012 	tsteq	r0, r2, lsl r0
    1e44:	000074a5 	andeq	r7, r0, r5, lsr #9
    1e48:	00030500 	andeq	r0, r3, r0, lsl #10
    1e4c:	48000000 	stmdami	r0, {}
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);

				LegIK(
    1e50:	00001040 	andeq	r1, r0, r0, asr #32
    1e54:	0074a801 	rsbseq	sl, r4, r1, lsl #16
    1e58:	03050000 	movweq	r0, #20480	; 0x5000
    1e5c:	00000000 	andeq	r0, r0, r0
    1e60:	00151e48 	andseq	r1, r5, r8, asr #28
    1e64:	74a90100 	strtvc	r0, [r9], #256
    1e68:	05000000 	streq	r0, [r0]
    1e6c:	00000003 	andeq	r0, r0, r3
    1e70:	00740d00 	rsbseq	r0, r4, r0, lsl #26
    1e74:	12320000 	eorsne	r0, r2, #0	; 0x0
    1e78:	9f0e0000 	svcls	0x000e0000
    1e7c:	11000000 	tstne	r0, r0
    1e80:	182b4800 	stmdane	fp!, {fp, lr}
    1e84:	3f020000 	svccc	0x00020000
    1e88:	00001243 	andeq	r1, r0, r3, asr #4
    1e8c:	00000305 	andeq	r0, r0, r5, lsl #6
    1e90:	22030000 	andcs	r0, r3, #0	; 0x0
    1e94:	30000012 	andcc	r0, r0, r2, lsl r0
    1e98:	0000113e 	andeq	r1, r0, lr, lsr r1
    1e9c:	6301b102 	movwvs	fp, #4354	; 0x1102
    1ea0:	05000000 	streq	r0, [r0]
    1ea4:	00000003 	andeq	r0, r0, r3
    1ea8:	0d1f3000 	ldceq	0, cr3, [pc]
    1eac:	b2020000 	andlt	r0, r2, #0	; 0x0
    1eb0:	00006301 	andeq	r6, r0, r1, lsl #6
    1eb4:	00030500 	andeq	r0, r3, r0, lsl #10
    1eb8:	0d000000 	stceq	0, cr0, [r0]
    1ebc:	00000074 	andeq	r0, r0, r4, ror r0
    1ec0:	0000127d 	andeq	r1, r0, sp, ror r2
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1ec4:	00009f46 	andeq	r9, r0, r6, asr #30
    1ec8:	00011500 	andeq	r1, r1, r0, lsl #10
    1ecc:	0011e548 	andseq	lr, r1, r8, asr #10
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1ed0:	8e470300 	cdphi	3, 4, cr0, cr7, cr0, {0}
    1ed4:	05000012 	streq	r0, [r0, #-18]
				DoBackgroundProcess();
    1ed8:	00000003 	andeq	r0, r0, r3
				BodyFK(
    1edc:	126c0300 	rsbne	r0, ip, #0	; 0x0
    1ee0:	a20d0000 	andge	r0, sp, #0	; 0x0
    1ee4:	a3000000 	movwge	r0, #0	; 0x0
    1ee8:	0e000012 	mcreq	0, 0, r0, cr0, cr2, {0}
    1eec:	0000009f 	muleq	r0, pc, r0
    1ef0:	964800b4 	undefined
    1ef4:	0300000e 	movweq	r0, #14	; 0xe
    1ef8:	0012b45b 	andseq	fp, r2, fp, asr r4
    1efc:	00030500 	andeq	r0, r3, r0, lsl #10
    1f00:	03000000 	movweq	r0, #0	; 0x0
    1f04:	00001293 	muleq	r0, r3, r2
    1f08:	00182149 	andseq	r2, r8, r9, asr #2
    1f0c:	01be0300 	undefined instruction 0x01be0300
    1f10:	00000074 	andeq	r0, r0, r4, ror r0
    1f14:	00030501 	andeq	r0, r3, r1, lsl #10
    1f18:	49000000 	stmdbmi	r0, {}
    1f1c:	0000104c 	andeq	r1, r0, ip, asr #32
    1f20:	b4010d03 	strlt	r0, [r1], #-3331
    1f24:	01000000 	tsteq	r0, r0
    1f28:	00000305 	andeq	r0, r0, r5, lsl #6
    1f2c:	55490000 	strbpl	r0, [r9]
    1f30:	03000011 	movweq	r0, #17	; 0x11
    1f34:	00b4010e 	adcseq	r0, r4, lr, lsl #2
    1f38:	05010000 	streq	r0, [r1]
    1f3c:	00000003 	andeq	r0, r0, r3
    1f40:	0d4b4900 	stcleq	9, cr4, [fp]
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);
				LegIK(
    1f44:	69030000 	stmdbvs	r3, {}
    1f48:	0000b401 	andeq	fp, r0, r1, lsl #8
    1f4c:	03050100 	movweq	r0, #20736	; 0x5100
    1f50:	00000000 	andeq	r0, r0, r0
    1f54:	0015e24a 	andseq	lr, r5, sl, asr #4
    1f58:	cf100300 	svcgt	0x00100300
    1f5c:	01000002 	tsteq	r0, r2
    1f60:	00000305 	andeq	r0, r0, r5, lsl #6
    1f64:	740d0000 	strvc	r0, [sp]
    1f68:	27000000 	strcs	r0, [r0, -r0]
    1f6c:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    1f70:	0000009f 	muleq	r0, pc, r0
    1f74:	b64a0001 	strblt	r0, [sl], -r1
    1f78:	03000015 	movweq	r0, #21	; 0x15
    1f7c:	00133914 	andseq	r3, r3, r4, lsl r9
    1f80:	03050100 	movweq	r0, #20736	; 0x5100
    1f84:	00000000 	andeq	r0, r0, r0
    1f88:	00131703 	andseq	r1, r3, r3, lsl #14
    1f8c:	187b4a00 	ldmdane	fp!, {r9, fp, lr}^
    1f90:	15030000 	strne	r0, [r3]
    1f94:	00001350 	andeq	r1, r0, r0, asr r3
    1f98:	00030501 	andeq	r0, r3, r1, lsl #10
    1f9c:	03000000 	movweq	r0, #0	; 0x0
    1fa0:	00001317 	andeq	r1, r0, r7, lsl r3
    1fa4:	000d3e4a 	andeq	r3, sp, sl, asr #28
    1fa8:	33860100 	orrcc	r0, r6, #0	; 0x0
    1fac:	01000000 	tsteq	r0, r0
    1fb0:	00000305 	andeq	r0, r0, r5, lsl #6
    1fb4:	184a0000 	stmdane	sl, {}^
    1fb8:	0100000d 	tsteq	r0, sp
    1fbc:	00003387 	andeq	r3, r0, r7, lsl #7
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1fc0:	03050100 	movweq	r0, #20736	; 0x5100
    1fc4:	00000000 	andeq	r0, r0, r0
    1fc8:	000ff24a 	andeq	pc, pc, sl, asr #4
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Check mechanical limits
			CheckAngles();
    1fcc:	33880100 	orrcc	r0, r8, #0	; 0x0

			//Drive Servos
			if (g_InControlState.fRobotOn) {
    1fd0:	01000000 	tsteq	r0, r0
    1fd4:	00000305 	andeq	r0, r0, r5, lsl #6
    1fd8:	d24a0000 	suble	r0, sl, #0	; 0x0
				if (g_InControlState.fRobotOn && !g_InControlState.fPrev_RobotOn) {
					// MSound(3, 60, 2000, 80, 2250, 100, 2500);
					Buzzed(30, 2000);
    1fdc:	0100000f 	tsteq	r0, pc
    1fe0:	00003389 	andeq	r3, r0, r9, lsl #7
    1fe4:	03050100 	movweq	r0, #20736	; 0x5100
					Buzzed(80, 2250);
    1fe8:	00000000 	andeq	r0, r0, r0
    1fec:	7478654b 	ldrbtvc	r6, [r8], #-1355
					Buzzed(100, 2500);
    1ff0:	6d8d0100 	stfvss	f0, [sp]
    1ff4:	01000000 	tsteq	r0, r0
    1ff8:	00000305 	andeq	r0, r0, r5, lsl #6

				}

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
    1ffc:	6d0d0000 	stcvs	0, cr0, [sp]
    2000:	bf000000 	svclt	0x00000000
    2004:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    2008:	0000009f 	muleq	r0, pc, r0
    200c:	224a0006 	subcs	r0, sl, #6	; 0x6
    2010:	0100000e 	tsteq	r0, lr
    2014:	0013af92 	mulseq	r3, r2, pc
    2018:	03050100 	movweq	r0, #20736	; 0x5100
    201c:	00000000 	andeq	r0, r0, r0
    2020:	0014854a 	andseq	r8, r4, sl, asr #10
    2024:	4a940100 	bmi	fe50242c <SCS_BASE+0x1e4f442c>
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2028:	01000005 	tsteq	r0, r5
    202c:	00000305 	andeq	r0, r0, r5, lsl #6
    2030:	084a0000 	stmdaeq	sl, {}^
    2034:	0100000d 	tsteq	r0, sp
    2038:	00004a9b 	muleq	r0, fp, sl
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
    203c:	03050100 	movweq	r0, #20736	; 0x5100

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2040:	00000000 	andeq	r0, r0, r0
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
						ServoMoveTime = ServoMoveTime + BALANCE_DELAY;
    2044:	000c5c4a 	andeq	r5, ip, sl, asr #24
    2048:	2c9c0100 	ldfcss	f0, [ip], {0}
				} else
					//Movement speed excl. Walking
					ServoMoveTime = 200 + g_InControlState.SpeedControl;
    204c:	01000000 	tsteq	r0, r0
    2050:	00000305 	andeq	r0, r0, r5, lsl #6
    2054:	584a0000 	stmdapl	sl, {}^

				// note we broke up the servo driver into start/commit that way we can output all of the servo information
				// before we wait and only have the termination information to output after the wait.  That way we hopefully
				// be more accurate with our timings...
				DoBackgroundProcess();
    2058:	01000018 	tsteq	r0, r8, lsl r0
				StartUpdateServos();
    205c:	0000b49d 	muleq	r0, sp, r4

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    2060:	03050100 	movweq	r0, #20736	; 0x5100
					if ((GaitPosX[LegIndex] > cGPlimit)
    2064:	00000000 	andeq	r0, r0, r0
    2068:	000d454a 	andeq	r4, sp, sl, asr #10
    206c:	74a60100 	strtvc	r0, [r6], #256
    2070:	01000000 	tsteq	r0, r0
    2074:	00000305 	andeq	r0, r0, r5, lsl #6
    2078:	d44a0000 	strble	r0, [sl]
    207c:	02000013 	andeq	r0, r0, #19	; 0x13
    2080:	0000b42d 	andeq	fp, r0, sp, lsr #8
    2084:	03050100 	movweq	r0, #20736	; 0x5100
    2088:	00000000 	andeq	r0, r0, r0
    208c:	0017594c 	andseq	r5, r7, ip, asr #18
    2090:	6d410900 	stclvs	9, cr0, [r1]
    2094:	01000000 	tsteq	r0, r0
    2098:	17c44c01 	strbne	r4, [r4, r1, lsl #24]
    209c:	43090000 	movwmi	r0, #36864	; 0x9000
							|| (GaitPosZ[LegIndex] > cGPlimit)
							|| (GaitPosZ[LegIndex] < -cGPlimit)
							|| (GaitRotY[LegIndex] > cGPlimit)
							|| (GaitRotY[LegIndex] < -cGPlimit)) {

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
    20a0:	0000054a 	andeq	r0, r0, sl, asr #10
    20a4:	a20d0101 	andge	r0, sp, #1073741824	; 0x40000000
    20a8:	67000000 	strvs	r0, [r0, -r0]

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    20ac:	0e000014 	mcreq	0, 0, r0, cr0, cr4, {0}
    20b0:	0000009f 	muleq	r0, pc, r0

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
						break;
					}
				}
				if (bExtraCycle > 0) {
    20b4:	b34a0011 	movtlt	r0, #40977	; 0xa011
					bExtraCycle--;
    20b8:	02000010 	andeq	r0, r0, #16	; 0x10
    20bc:	00145733 	andseq	r5, r4, r3, lsr r7
					fWalking = !(bExtraCycle == 0);
    20c0:	03050100 	movweq	r0, #20736	; 0x5100
    20c4:	00000000 	andeq	r0, r0, r0

					//Get endtime and calculate wait time
					lTimeWaitEnd = lTimerStart + PrevServoMoveTime;
    20c8:	0018c14a 	andseq	ip, r8, sl, asr #2
    20cc:	57340200 	ldrpl	r0, [r4, -r0, lsl #4]!
    20d0:	01000014 	tsteq	r0, r4, lsl r0
					PrintString("\n");
#endif
					//DebugWrite(A1, HIGH);
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    20d4:	00000305 	andeq	r0, r0, r5, lsl #6
					} while (getMillis() < lTimeWaitEnd);
    20d8:	e74a0000 	strb	r0, [sl, -r0]
    20dc:	0200000d 	andeq	r0, r0, #13	; 0xd
					PrintString("\n");
#endif

				}
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
    20e0:	0000b44e 	andeq	fp, r0, lr, asr #8
    20e4:	03050100 	movweq	r0, #20736	; 0x5100
    20e8:	00000000 	andeq	r0, r0, r0
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
    20ec:	0014a34a 	andseq	sl, r4, sl, asr #6
					PrintString("Barebones lTimeWaitEnd-Millis  ");
					Printu32d(getMillis);
					PrintString("\n");
#endif
				} else {
					FreeServos();
    20f0:	a2950200 	addsge	r0, r5, #0	; 0x0
    20f4:	01000000 	tsteq	r0, r0
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
					ServoMoveTime = 600;
    20f8:	00000305 	andeq	r0, r0, r5, lsl #6
    20fc:	db4a0000 	blle	1282104 <__Stack_Size+0x1281d04>
					StartUpdateServos();
    2100:	02000012 	andeq	r0, r0, #18	; 0x12
					CommitServoDriver(ServoMoveTime);
    2104:	00007496 	muleq	r0, r6, r4
					//MSound(3, 100, 2500, 80, 2250, 60, 2000);
					Buzzed(100, 2500);
    2108:	03050100 	movweq	r0, #20736	; 0x5100
    210c:	00000000 	andeq	r0, r0, r0
    2110:	000e534a 	andeq	r5, lr, sl, asr #6
					Buzzed(80, 2250);
    2114:	4a970200 	bmi	fe5c291c <SCS_BASE+0x1e5b491c>
    2118:	01000000 	tsteq	r0, r0
					Buzzed(60, 2000);
    211c:	00000305 	andeq	r0, r0, r5, lsl #6
    2120:	2c0d0000 	stccs	0, cr0, [sp], {0}
    2124:	e3000000 	movw	r0, #0	; 0x0

					//lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
					lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
    2128:	0e000014 	mcreq	0, 0, r0, cr0, cr4, {0}
    212c:	0000009f 	muleq	r0, pc, r0
					Printu32d(lTimeWaitEnd);
					PrintString("\n");
#endif
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    2130:	ae4a0005 	cdpge	0, 4, cr0, cr10, cr5, {0}
					} while (getMillis() < lTimeWaitEnd);
    2134:	0300000d 	movweq	r0, #13	; 0xd
    2138:	0014f5d2 	ldrsbeq	pc, [r4], -r2
				} else {
					FreeServos();
				}

				// Allow the Servo driver to do stuff durint our idle time
				IdleTime();
    213c:	03050100 	movweq	r0, #20736	; 0x5100
				mDelay(20); // give a pause between times we call if nothing is happening
    2140:	00000000 	andeq	r0, r0, r0
			}
			PrevServoMoveTime = ServoMoveTime;
    2144:	0014d303 	andseq	sp, r4, r3, lsl #6
    2148:	17204a00 	strne	r4, [r0, -r0, lsl #20]!

			//Store previous g_InControlState.fRobotOn State
			if (g_InControlState.fRobotOn)
    214c:	d4030000 	strle	r0, [r3]
    2150:	0000150c 	andeq	r1, r0, ip, lsl #10
				g_InControlState.fPrev_RobotOn = 1;
			else
				g_InControlState.fPrev_RobotOn = 0;
    2154:	00030501 	andeq	r0, r3, r1, lsl #10
    2158:	03000000 	movweq	r0, #0	; 0x0
    215c:	000014d3 	ldrdeq	r1, [r0], -r3
    2160:	0013144a 	andseq	r1, r3, sl, asr #8
    2164:	23d60300 	bicscs	r0, r6, #0	; 0x0
    2168:	01000015 	tsteq	r0, r5, lsl r0
    216c:	00000305 	andeq	r0, r0, r5, lsl #6
    2170:	d3030000 	movwle	r0, #12288	; 0x3000
    2174:	4a000014 	bmi	21cc <__Stack_Size+0x1dcc>
    2178:	0000101d 	andeq	r1, r0, sp, lsl r0
    217c:	153ad903 	ldrne	sp, [sl, #-2307]!
    2180:	05010000 	streq	r0, [r1]
    2184:	00000003 	andeq	r0, r0, r3
    2188:	14d30300 	ldrbne	r0, [r3], #768
    218c:	d04a0000 	suble	r0, sl, r0
    2190:	03000012 	movweq	r0, #18	; 0x12
    2194:	001551dc 	ldrsbeq	r5, [r5], -ip
    2198:	03050100 	movweq	r0, #20736	; 0x5100
    219c:	00000000 	andeq	r0, r0, r0
    21a0:	0014d303 	andseq	sp, r4, r3, lsl #6
    21a4:	18434a00 	stmdane	r3, {r9, fp, lr}^
    21a8:	df030000 	svcle	0x00030000
    21ac:	00001568 	andeq	r1, r0, r8, ror #10
    21b0:	00030501 	andeq	r0, r3, r1, lsl #10
    21b4:	03000000 	movweq	r0, #0	; 0x0
    21b8:	000014d3 	ldrdeq	r1, [r0], -r3
    21bc:	0000940d 	andeq	r9, r0, sp, lsl #8
    21c0:	00157d00 	andseq	r7, r5, r0, lsl #26
    21c4:	009f0e00 	addseq	r0, pc, r0, lsl #28
    21c8:	00050000 	andeq	r0, r5, r0
    21cc:	0010824a 	andseq	r8, r0, sl, asr #4
    21d0:	8fe60300 	svchi	0x00e60300
    21d4:	01000015 	tsteq	r0, r5, lsl r0
    21d8:	00000305 	andeq	r0, r0, r5, lsl #6
    21dc:	6d030000 	stcvs	0, cr0, [r3]
    21e0:	4a000015 	bmi	223c <__Stack_Size+0x1e3c>
    21e4:	00001411 	andeq	r1, r0, r1, lsl r4
    21e8:	156de803 	strbne	lr, [sp, #-2051]!
    21ec:	05010000 	streq	r0, [r1]
    21f0:	00000003 	andeq	r0, r0, r3
    21f4:	18094a00 	stmdane	r9, {r9, fp, lr}
    21f8:	ea030000 	b	c2200 <__Stack_Size+0xc1e00>
    21fc:	000015b8 	strheq	r1, [r0], -r8
    2200:	00030501 	andeq	r0, r3, r1, lsl #10
    2204:	03000000 	movweq	r0, #0	; 0x0
    2208:	0000156d 	andeq	r1, r0, sp, ror #10
    220c:	0014424a 	andseq	r4, r4, sl, asr #4
    2210:	cfee0300 	svcgt	0x00ee0300
    2214:	01000015 	tsteq	r0, r5, lsl r0
    2218:	00000305 	andeq	r0, r0, r5, lsl #6
    221c:	ab030000 	blge	c2224 <__Stack_Size+0xc1e24>
    2220:	4a000001 	bmi	222c <__Stack_Size+0x1e2c>
    2224:	000012e9 	andeq	r1, r0, r9, ror #5
    2228:	15e6f103 	strbne	pc, [r6, #259]!
    222c:	05010000 	streq	r0, [r1]
    2230:	00000003 	andeq	r0, r0, r3
    2234:	01ab0300 	undefined instruction 0x01ab0300
    2238:	6e4a0000 	cdpvs	0, 4, cr0, cr10, cr0, {0}
    223c:	03000018 	movweq	r0, #24	; 0x18
    2240:	0015fdf4 	ldrsheq	pc, [r5], -r4
    2244:	03050100 	movweq	r0, #20736	; 0x5100
    2248:	00000000 	andeq	r0, r0, r0
    224c:	0001ab03 	andeq	sl, r1, r3, lsl #22
    2250:	11ac4a00 	undefined instruction 0x11ac4a00
    2254:	f9030000 	undefined instruction 0xf9030000
    2258:	00001614 	andeq	r1, r0, r4, lsl r6
    225c:	00030501 	andeq	r0, r3, r1, lsl #10
    2260:	03000000 	movweq	r0, #0	; 0x0
    2264:	000014d3 	ldrdeq	r1, [r0], -r3
    2268:	0011b54a 	andseq	fp, r1, sl, asr #10
    226c:	2bfb0300 	blcs	ffec2e74 <SCS_BASE+0x1feb4e74>
    2270:	01000016 	tsteq	r0, r6, lsl r0
    2274:	00000305 	andeq	r0, r0, r5, lsl #6
    2278:	d3030000 	movwle	r0, #12288	; 0x3000
    227c:	4a000014 	bmi	22d4 <__Stack_Size+0x1ed4>
    2280:	00000ce7 	andeq	r0, r0, r7, ror #25
    2284:	1642ff03 	strbne	pc, [r2], -r3, lsl #30
    2288:	05010000 	streq	r0, [r1]
    228c:	00000003 	andeq	r0, r0, r3
    2290:	14d30300 	ldrbne	r0, [r3], #768
    2294:	8b490000 	blhi	124229c <__Stack_Size+0x1241e9c>
    2298:	03000010 	movweq	r0, #16	; 0x10
    229c:	165a0104 	ldrbne	r0, [sl], -r4, lsl #2
    22a0:	05010000 	streq	r0, [r1]
    22a4:	00000003 	andeq	r0, r0, r3
    22a8:	14d30300 	ldrbne	r0, [r3], #768
    22ac:	95490000 	strbls	r0, [r9]
    22b0:	03000010 	movweq	r0, #16	; 0x10
    22b4:	16720106 	ldrbtne	r0, [r2], -r6, lsl #2
    22b8:	05010000 	streq	r0, [r1]
    22bc:	00000003 	andeq	r0, r0, r3
    22c0:	14d30300 	ldrbne	r0, [r3], #768
    22c4:	9f490000 	svcls	0x00490000
    22c8:	03000010 	movweq	r0, #16	; 0x10
    22cc:	168a0108 	strne	r0, [sl], r8, lsl #2
    22d0:	05010000 	streq	r0, [r1]
    22d4:	00000003 	andeq	r0, r0, r3
    22d8:	14d30300 	ldrbne	r0, [r3], #768
    22dc:	73490000 	movtvc	r0, #36864	; 0x9000
    22e0:	03000017 	movweq	r0, #23	; 0x17
    22e4:	00b4010c 	adcseq	r0, r4, ip, lsl #2
    22e8:	05010000 	streq	r0, [r1]
    22ec:	00000003 	andeq	r0, r0, r3
    22f0:	0ce84900 	stcleq	9, cr4, [r8]
    22f4:	12030000 	andne	r0, r3, #0	; 0x0
    22f8:	0014d301 	andseq	sp, r4, r1, lsl #6
    22fc:	03050100 	movweq	r0, #20736	; 0x5100
    2300:	00000000 	andeq	r0, r0, r0
    2304:	0018d049 	andseq	sp, r8, r9, asr #32
    2308:	01130300 	tsteq	r3, r0, lsl #6
    230c:	000014d3 	ldrdeq	r1, [r0], -r3
    2310:	00030501 	andeq	r0, r3, r1, lsl #10
    2314:	49000000 	stmdbmi	r0, {}
    2318:	000014f1 	strdeq	r1, [r0], -r1
    231c:	d3011403 	movwle	r1, #5123	; 0x1403
    2320:	01000014 	tsteq	r0, r4, lsl r0
    2324:	00000305 	andeq	r0, r0, r5, lsl #6
    2328:	b7490000 	strblt	r0, [r9, -r0]
    232c:	0300000c 	movweq	r0, #12	; 0xc
    2330:	14d30119 	ldrbne	r0, [r3], #281
    2334:	05010000 	streq	r0, [r1]
    2338:	00000003 	andeq	r0, r0, r3
    233c:	0cbf4900 	ldceq	9, cr4, [pc]
    2340:	1a030000 	bne	c2348 <__Stack_Size+0xc1f48>
    2344:	0014d301 	andseq	sp, r4, r1, lsl #6
    2348:	03050100 	movweq	r0, #20736	; 0x5100
    234c:	00000000 	andeq	r0, r0, r0
    2350:	000cc749 	andeq	ip, ip, r9, asr #14
    2354:	011b0300 	tsteq	fp, r0, lsl #6
    2358:	000014d3 	ldrdeq	r1, [r0], -r3
    235c:	00030501 	andeq	r0, r3, r1, lsl #10
    2360:	49000000 	stmdbmi	r0, {}
    2364:	00000da8 	andeq	r0, r0, r8, lsr #27
    2368:	74011e03 	strvc	r1, [r1], #-3587
    236c:	01000000 	tsteq	r0, r0
    2370:	00000305 	andeq	r0, r0, r5, lsl #6
    2374:	a5490000 	strbge	r0, [r9]
    2378:	0300000d 	movweq	r0, #13	; 0xd
    237c:	0074011f 	rsbseq	r0, r4, pc, lsl r1
    2380:	05010000 	streq	r0, [r1]
    2384:	00000003 	andeq	r0, r0, r3
    2388:	0fdb4900 	svceq	0x00db4900
    238c:	22030000 	andcs	r0, r3, #0	; 0x0
    2390:	00002c01 	andeq	r2, r0, r1, lsl #24
    2394:	03050100 	movweq	r0, #20736	; 0x5100
    2398:	00000000 	andeq	r0, r0, r0
    239c:	00101249 	andseq	r1, r0, r9, asr #4
    23a0:	01230300 	teqeq	r3, r0, lsl #6
    23a4:	0000002c 	andeq	r0, r0, ip, lsr #32
    23a8:	00030501 	andeq	r0, r3, r1, lsl #10
    23ac:	49000000 	stmdbmi	r0, {}
    23b0:	00000f9b 	muleq	r0, fp, pc
    23b4:	2c012403 	cfstrscs	mvf2, [r1], {3}
    23b8:	01000000 	tsteq	r0, r0
    23bc:	00000305 	andeq	r0, r0, r5, lsl #6
    23c0:	6c490000 	marvs	acc0, r0, r9
    23c4:	03000010 	movweq	r0, #16	; 0x10
    23c8:	002c0125 	eoreq	r0, ip, r5, lsr #2
    23cc:	05010000 	streq	r0, [r1]
    23d0:	00000003 	andeq	r0, r0, r3
    23d4:	10764900 	rsbsne	r4, r6, r0, lsl #18
    23d8:	28030000 	stmdacs	r3, {}
    23dc:	00002c01 	andeq	r2, r0, r1, lsl #24
    23e0:	03050100 	movweq	r0, #20736	; 0x5100
    23e4:	00000000 	andeq	r0, r0, r0
    23e8:	00107c49 	andseq	r7, r0, r9, asr #24
    23ec:	01290300 	teqeq	r9, r0, lsl #6
    23f0:	0000002c 	andeq	r0, r0, ip, lsr #32
    23f4:	00030501 	andeq	r0, r3, r1, lsl #10
    23f8:	49000000 	stmdbmi	r0, {}
    23fc:	00001028 	andeq	r1, r0, r8, lsr #32
    2400:	2c012a03 	stccs	10, cr2, [r1], {3}
    2404:	01000000 	tsteq	r0, r0
    2408:	00000305 	andeq	r0, r0, r5, lsl #6
    240c:	85490000 	strbhi	r0, [r9]
    2410:	03000015 	movweq	r0, #21	; 0x15
    2414:	0025012b 	eoreq	r0, r5, fp, lsr #2
    2418:	05010000 	streq	r0, [r1]
    241c:	00000003 	andeq	r0, r0, r3
    2420:	18ec4900 	stmiane	ip!, {r8, fp, lr}^
    2424:	2e030000 	cdpcs	0, 0, cr0, cr3, cr0, {0}
    2428:	00002c01 	andeq	r2, r0, r1, lsl #24
    242c:	03050100 	movweq	r0, #20736	; 0x5100
    2430:	00000000 	andeq	r0, r0, r0
    2434:	00190249 	andseq	r0, r9, r9, asr #4
    2438:	012f0300 	teqeq	pc, r0, lsl #6
    243c:	0000002c 	andeq	r0, r0, ip, lsr #32
    2440:	00030501 	andeq	r0, r3, r1, lsl #10
    2444:	49000000 	stmdbmi	r0, {}
    2448:	000018f7 	strdeq	r1, [r0], -r7
    244c:	2c013003 	stccs	0, cr3, [r1], {3}
    2450:	01000000 	tsteq	r0, r0
    2454:	00000305 	andeq	r0, r0, r5, lsl #6
    2458:	e6490000 	strb	r0, [r9], -r0
    245c:	03000018 	movweq	r0, #24	; 0x18
    2460:	00250131 	eoreq	r0, r5, r1, lsr r1
    2464:	05010000 	streq	r0, [r1]
    2468:	00000003 	andeq	r0, r0, r3
    246c:	18f14900 	ldmne	r1!, {r8, fp, lr}^
    2470:	32030000 	andcc	r0, r3, #0	; 0x0
    2474:	00002501 	andeq	r2, r0, r1, lsl #10
    2478:	03050100 	movweq	r0, #20736	; 0x5100
    247c:	00000000 	andeq	r0, r0, r0
    2480:	0018fc49 	andseq	pc, r8, r9, asr #24
    2484:	01330300 	teqeq	r3, r0, lsl #6
    2488:	00000025 	andeq	r0, r0, r5, lsr #32
    248c:	00030501 	andeq	r0, r3, r1, lsl #10
    2490:	49000000 	stmdbmi	r0, {}
    2494:	000014fd 	strdeq	r1, [r0], -sp
    2498:	25013603 	strcs	r3, [r1, #-1539]
    249c:	01000000 	tsteq	r0, r0
    24a0:	00000305 	andeq	r0, r0, r5, lsl #6
    24a4:	08490000 	stmdaeq	r9, {}^
    24a8:	03000015 	movweq	r0, #21	; 0x15
    24ac:	00250137 	eoreq	r0, r5, r7, lsr r1
    24b0:	05010000 	streq	r0, [r1]
    24b4:	00000003 	andeq	r0, r0, r3
    24b8:	15134900 	ldrne	r4, [r3, #-2304]
    24bc:	38030000 	stmdacc	r3, {}
    24c0:	00002501 	andeq	r2, r0, r1, lsl #10
    24c4:	03050100 	movweq	r0, #20736	; 0x5100
    24c8:	00000000 	andeq	r0, r0, r0
    24cc:	000db849 	andeq	fp, sp, r9, asr #16
    24d0:	01390300 	teqeq	r9, r0, lsl #6
    24d4:	000000b4 	strheq	r0, [r0], -r4
    24d8:	00030501 	andeq	r0, r3, r1, lsl #10
    24dc:	49000000 	stmdbmi	r0, {}
    24e0:	00000d7a 	andeq	r0, r0, sl, ror sp
    24e4:	b4013a03 	strlt	r3, [r1], #-2563
    24e8:	01000000 	tsteq	r0, r0
    24ec:	00000305 	andeq	r0, r0, r5, lsl #6
    24f0:	9c490000 	marls	acc0, r0, r9
    24f4:	03000011 	movweq	r0, #17	; 0x11
    24f8:	00b4013b 	adcseq	r0, r4, fp, lsr r1
    24fc:	05010000 	streq	r0, [r1]
    2500:	00000003 	andeq	r0, r0, r3
    2504:	14db4900 	ldrbne	r4, [fp], #2304
    2508:	3e030000 	cdpcc	0, 0, cr0, cr3, cr0, {0}
    250c:	00004a01 	andeq	r4, r0, r1, lsl #20
    2510:	03050100 	movweq	r0, #20736	; 0x5100
    2514:	00000000 	andeq	r0, r0, r0
    2518:	000ca749 	andeq	sl, ip, r9, asr #14
    251c:	013f0300 	teqeq	pc, r0, lsl #6
    2520:	0000004a 	andeq	r0, r0, sl, asr #32
    2524:	00030501 	andeq	r0, r3, r1, lsl #10
    2528:	49000000 	stmdbmi	r0, {}
    252c:	0000188b 	andeq	r1, r0, fp, lsl #17
    2530:	74014003 	strvc	r4, [r1], #-3
    2534:	01000000 	tsteq	r0, r0
    2538:	00000305 	andeq	r0, r0, r5, lsl #6
    253c:	49490000 	stmdbmi	r9, {}^
    2540:	03000012 	movweq	r0, #18	; 0x12
    2544:	00a20142 	adceq	r0, r2, r2, asr #2
    2548:	05010000 	streq	r0, [r1]
    254c:	00000003 	andeq	r0, r0, r3
    2550:	12454900 	subne	r4, r5, #0	; 0x0
    2554:	43030000 	movwmi	r0, #12288	; 0x3000
    2558:	0000a201 	andeq	sl, r0, r1, lsl #4
    255c:	03050100 	movweq	r0, #20736	; 0x5100
    2560:	00000000 	andeq	r0, r0, r0
    2564:	0011fc49 	andseq	pc, r1, r9, asr #24
    2568:	01490300 	cmpeq	r9, r0, lsl #6
    256c:	000000b4 	strheq	r0, [r0], -r4
    2570:	00030501 	andeq	r0, r3, r1, lsl #10
    2574:	49000000 	stmdbmi	r0, {}
    2578:	000012e1 	andeq	r1, r0, r1, ror #5
    257c:	a2014a03 	andge	r4, r1, #12288	; 0x3000
    2580:	01000000 	tsteq	r0, r0
    2584:	00000305 	andeq	r0, r0, r5, lsl #6
    2588:	8c490000 	marhi	acc0, r0, r9
    258c:	03000015 	movweq	r0, #21	; 0x15
    2590:	00250150 	eoreq	r0, r5, r0, asr r1
    2594:	05010000 	streq	r0, [r1]
    2598:	00000003 	andeq	r0, r0, r3
    259c:	15a44900 	strne	r4, [r4, #2304]!
    25a0:	51030000 	tstpl	r3, r0
    25a4:	00002501 	andeq	r2, r0, r1, lsl #10
    25a8:	03050100 	movweq	r0, #20736	; 0x5100
    25ac:	00000000 	andeq	r0, r0, r0
    25b0:	00159849 	andseq	r9, r5, r9, asr #16
    25b4:	01520300 	cmpeq	r2, r0, lsl #6
    25b8:	00000025 	andeq	r0, r0, r5, lsr #32
    25bc:	00030501 	andeq	r0, r3, r1, lsl #10
    25c0:	49000000 	stmdbmi	r0, {}
    25c4:	00001165 	andeq	r1, r0, r5, ror #2
    25c8:	25015303 	strcs	r5, [r1, #-771]
    25cc:	01000000 	tsteq	r0, r0
    25d0:	00000305 	andeq	r0, r0, r5, lsl #6
    25d4:	2b490000 	blcs	12425dc <__Stack_Size+0x12421dc>
    25d8:	03000014 	movweq	r0, #20	; 0x14
    25dc:	00250154 	eoreq	r0, r5, r4, asr r1
    25e0:	05010000 	streq	r0, [r1]
    25e4:	00000003 	andeq	r0, r0, r3
    25e8:	0f4f4900 	svceq	0x004f4900
    25ec:	55030000 	strpl	r0, [r3]
    25f0:	00002501 	andeq	r2, r0, r1, lsl #10
    25f4:	03050100 	movweq	r0, #20736	; 0x5100
    25f8:	00000000 	andeq	r0, r0, r0
    25fc:	000d0049 	andeq	r0, sp, r9, asr #32
    2600:	01570300 	cmpeq	r7, r0, lsl #6
    2604:	000000b4 	strheq	r0, [r0], -r4
    2608:	00030501 	andeq	r0, r3, r1, lsl #10
    260c:	49000000 	stmdbmi	r0, {}
    2610:	00000e01 	andeq	r0, r0, r1, lsl #28
    2614:	b4015b03 	strlt	r5, [r1], #-2819
    2618:	01000000 	tsteq	r0, r0
    261c:	00000305 	andeq	r0, r0, r5, lsl #6
    2620:	250d0000 	strcs	r0, [sp]
    2624:	e3000000 	movw	r0, #0	; 0x0
    2628:	0e000019 	mcreq	0, 0, r0, cr0, cr9, {0}
    262c:	0000009f 	muleq	r0, pc, r0
    2630:	b8490005 	stmdalt	r9, {r0, r2}^
    2634:	03000012 	movweq	r0, #18	; 0x12
    2638:	19d3015d 	ldmibne	r3, {r0, r2, r3, r4, r6, r8}^
    263c:	05010000 	streq	r0, [r1]
    2640:	00000003 	andeq	r0, r0, r3
    2644:	0e6e4900 	cdpeq	9, 6, cr4, cr14, cr0, {0}
    2648:	5e030000 	cdppl	0, 0, cr0, cr3, cr0, {0}
    264c:	0019d301 	andseq	sp, r9, r1, lsl #6
    2650:	03050100 	movweq	r0, #20736	; 0x5100
    2654:	00000000 	andeq	r0, r0, r0
    2658:	000e7749 	andeq	r7, lr, r9, asr #14
    265c:	015f0300 	cmpeq	pc, r0, lsl #6
    2660:	000019d3 	ldrdeq	r1, [r0], -r3
    2664:	00030501 	andeq	r0, r3, r1, lsl #10
    2668:	49000000 	stmdbmi	r0, {}
    266c:	00000f10 	andeq	r0, r0, r0, lsl pc
    2670:	d3016003 	movwle	r6, #4099	; 0x1003
    2674:	01000019 	tsteq	r0, r9, lsl r0
    2678:	00000305 	andeq	r0, r0, r5, lsl #6
    267c:	5b490000 	blpl	1242684 <__Stack_Size+0x1242284>
    2680:	03000010 	movweq	r0, #16	; 0x10
    2684:	00b40165 	adcseq	r0, r4, r5, ror #2
    2688:	05010000 	streq	r0, [r1]
    268c:	00000003 	andeq	r0, r0, r3
    2690:	0e0f4900 	cdpeq	9, 0, cr4, cr15, cr0, {0}
    2694:	66030000 	strvs	r0, [r3], -r0
    2698:	00007401 	andeq	r7, r0, r1, lsl #8
    269c:	03050100 	movweq	r0, #20736	; 0x5100
    26a0:	00000000 	andeq	r0, r0, r0
    26a4:	000c6e49 	andeq	r6, ip, r9, asr #28
    26a8:	016a0300 	cmneq	sl, r0, lsl #6
    26ac:	000000b4 	strheq	r0, [r0], -r4
    26b0:	00030501 	andeq	r0, r3, r1, lsl #10
    26b4:	0d000000 	stceq	0, cr0, [r0]
    26b8:	000001bb 	strheq	r0, [r0], -fp
    26bc:	00001a78 	andeq	r1, r0, r8, ror sl
    26c0:	00009f0e 	andeq	r9, r0, lr, lsl #30
    26c4:	4d000500 	cfstr32mi	mvfx0, [r0]
    26c8:	00475041 	subeq	r5, r7, r1, asr #32
    26cc:	68019003 	stmdavs	r1, {r0, r1, ip, pc}
    26d0:	0100001a 	tsteq	r0, sl, lsl r0
    26d4:	00000305 	andeq	r0, r0, r5, lsl #6
    26d8:	b4490000 	strblt	r0, [r9]
    26dc:	03000018 	movweq	r0, #24	; 0x18
    26e0:	00740323 	rsbseq	r0, r4, r3, lsr #6
    26e4:	05010000 	streq	r0, [r1]
    26e8:	00000003 	andeq	r0, r0, r3
    26ec:	13524900 	cmpne	r2, #0	; 0x0
    26f0:	bc030000 	stclt	0, cr0, [r3], {0}
    26f4:	0000a205 	andeq	sl, r0, r5, lsl #4
    26f8:	03050100 	movweq	r0, #20736	; 0x5100
    26fc:	00000000 	andeq	r0, r0, r0
    2700:	00140149 	andseq	r0, r4, r9, asr #2
    2704:	061a0300 	ldreq	r0, [sl], -r0, lsl #6
    2708:	00000063 	andeq	r0, r0, r3, rrx
    270c:	00030501 	andeq	r0, r3, r1, lsl #10
    2710:	00000000 	andeq	r0, r0, r0
    2714:	0000077c 	andeq	r0, r0, ip, ror r7
    2718:	06be0002 	ldrteq	r0, [lr], r2
    271c:	01040000 	tsteq	r4, r0
    2720:	000001fe 	strdeq	r0, [r0], -lr
    2724:	0019ef01 	andseq	lr, r9, r1, lsl #30
    2728:	00024900 	andeq	r4, r2, r0, lsl #18
	...
    2734:	000a4300 	andeq	r4, sl, r0, lsl #6
    2738:	05040200 	streq	r0, [r4, #-512]
    273c:	00000122 	andeq	r0, r0, r2, lsr #2
    2740:	ca050202 	bgt	142f50 <__Stack_Size+0x142b50>
    2744:	02000004 	andeq	r0, r0, #4	; 0x4
    2748:	049e0601 	ldreq	r0, [lr], #1537
    274c:	04020000 	streq	r0, [r2]
    2750:	00013007 	andeq	r3, r1, r7
    2754:	31750300 	cmncc	r5, r0, lsl #6
    2758:	28020036 	stmdacs	r2, {r1, r2, r4, r5}
    275c:	0000004c 	andeq	r0, r0, ip, asr #32
    2760:	c5070202 	strgt	r0, [r7, #-514]
    2764:	03000001 	movweq	r0, #1	; 0x1
    2768:	02003875 	andeq	r3, r0, #7667712	; 0x750000
    276c:	00005d29 	andeq	r5, r0, r9, lsr #26
    2770:	08010200 	stmdaeq	r1, {r9}
    2774:	0000049c 	muleq	r0, ip, r4
    2778:	38020104 	stmdacc	r2, {r2, r8}
    277c:	00000079 	andeq	r0, r0, r9, ror r0
    2780:	00143c05 	andseq	r3, r4, r5, lsl #24
    2784:	45050000 	strmi	r0, [r5]
    2788:	01000017 	tsteq	r0, r7, lsl r0
    278c:	0f960600 	svceq	0x00960600
    2790:	38020000 	stmdacc	r2, {}
    2794:	00000064 	andeq	r0, r0, r4, rrx
    2798:	27030807 	strcs	r0, [r3, -r7, lsl #16]
    279c:	000000a9 	andeq	r0, r0, r9, lsr #1
    27a0:	0027f208 	eoreq	pc, r7, r8, lsl #4
    27a4:	a9280300 	stmdbge	r8!, {r8, r9}
    27a8:	02000000 	andeq	r0, r0, #0	; 0x0
    27ac:	f4080023 	vst4.8	{d0-d3}, [r8, :128], r3
    27b0:	03000024 	movweq	r0, #36	; 0x24
    27b4:	0000b629 	andeq	fp, r0, r9, lsr #12
    27b8:	04230200 	strteq	r0, [r3], #-512
    27bc:	af040900 	svcge	0x00040900
    27c0:	02000000 	andeq	r0, r0, #0	; 0x0
    27c4:	01350704 	teqeq	r5, r4, lsl #14
    27c8:	040a0000 	streq	r0, [sl]
    27cc:	746e6905 	strbtvc	r6, [lr], #-2309
    27d0:	19bd0600 	ldmibne	sp!, {r9, sl}
    27d4:	2a030000 	bcs	c27dc <__Stack_Size+0xc23dc>
    27d8:	00000084 	andeq	r0, r0, r4, lsl #1
    27dc:	54040104 	strpl	r0, [r4], #-260
    27e0:	0000015f 	andeq	r0, r0, pc, asr r1
    27e4:	000fa005 	andeq	sl, pc, r5
    27e8:	d6050100 	strle	r0, [r5], -r0, lsl #2
    27ec:	02000011 	andeq	r0, r0, #17	; 0x11
    27f0:	00147505 	andseq	r7, r4, r5, lsl #10
    27f4:	f8050300 	undefined instruction 0xf8050300
    27f8:	0400000e 	streq	r0, [r0], #-14
    27fc:	000e8005 	andeq	r8, lr, r5
    2800:	f2050500 	vrshl.s8	d0, d0, d5
    2804:	06000010 	undefined
    2808:	000ee505 	andeq	lr, lr, r5, lsl #10
    280c:	2a050700 	bcs	144414 <__Stack_Size+0x144014>
    2810:	0c000017 	stceq	0, cr0, [r0], {23}
    2814:	00178605 	andseq	r8, r7, r5, lsl #12
    2818:	24050d00 	strcs	r0, [r5], #-3328
    281c:	0e000016 	mcreq	0, 0, r0, cr0, cr6, {0}
    2820:	000d8c05 	andeq	r8, sp, r5, lsl #24
    2824:	b2050f00 	andlt	r0, r5, #0	; 0x0
    2828:	10000014 	andne	r0, r0, r4, lsl r0
    282c:	00118d05 	andseq	r8, r1, r5, lsl #26
    2830:	4b051100 	blmi	146c38 <__Stack_Size+0x146838>
    2834:	12000015 	andne	r0, r0, #21	; 0x15
    2838:	00174a05 	andseq	r4, r7, r5, lsl #20
    283c:	97051300 	strls	r1, [r5, -r0, lsl #6]
    2840:	14000012 	strne	r0, [r0], #-18
    2844:	00111c05 	andseq	r1, r1, r5, lsl #24
    2848:	83051500 	movwhi	r1, #21760	; 0x5500
    284c:	1600000c 	strne	r0, [r0], -ip
    2850:	000dcb05 	andeq	ip, sp, r5, lsl #22
    2854:	78051700 	stmdavc	r5, {r8, r9, sl, ip}
    2858:	83000016 	movwhi	r0, #22	; 0x16
    285c:	112a0501 	teqne	sl, r1, lsl #10
    2860:	01840000 	orreq	r0, r4, r0
    2864:	0016f005 	andseq	pc, r6, r5
    2868:	05019200 	streq	r9, [r1, #-512]
    286c:	000011ed 	andeq	r1, r0, sp, ror #3
    2870:	040001d0 	streq	r0, [r0], #-464
    2874:	bdcf0402 	cfstrdlt	mvd0, [pc, #8]
    2878:	05000001 	streq	r0, [r0, #-1]
    287c:	000006b5 	strheq	r0, [r0], -r5
    2880:	04bc0501 	ldrteq	r0, [ip], #1281
    2884:	05020000 	streq	r0, [r2]
    2888:	0000038b 	andeq	r0, r0, fp, lsl #7
    288c:	06c30504 	strbeq	r0, [r3], r4, lsl #10
    2890:	05080000 	streq	r0, [r8]
    2894:	00000500 	andeq	r0, r0, r0, lsl #10
    2898:	01690510 	cmneq	r9, r0, lsl r5
    289c:	05200000 	streq	r0, [r0]!
    28a0:	000005c1 	andeq	r0, r0, r1, asr #11
    28a4:	3b0500c0 	blcc	142bac <__Stack_Size+0x1427ac>
    28a8:	80000002 	andhi	r0, r0, r2
    28ac:	06f60501 	ldrbteq	r0, [r6], r1, lsl #10
    28b0:	02800000 	addeq	r0, r0, #0	; 0x0
    28b4:	00048e05 	andeq	r8, r4, r5, lsl #28
    28b8:	05048000 	streq	r8, [r4]
    28bc:	00000026 	andeq	r0, r0, r6, lsr #32
    28c0:	20050880 	andcs	r0, r5, r0, lsl #17
    28c4:	80000003 	andhi	r0, r0, r3
    28c8:	015a0510 	cmpeq	sl, r0, lsl r5
    28cc:	20800000 	addcs	r0, r0, r0
    28d0:	04010b00 	streq	r0, [r1], #-2816
    28d4:	02f3016e 	rscseq	r0, r3, #-2147483621	; 0x8000001b
    28d8:	0d050000 	stceq	0, cr0, [r5]
    28dc:	00000003 	andeq	r0, r0, r3
    28e0:	0002e805 	andeq	lr, r2, r5, lsl #16
    28e4:	f1050100 	undefined instruction 0xf1050100
    28e8:	02000005 	andeq	r0, r0, #5	; 0x5
    28ec:	0002d905 	andeq	sp, r2, r5, lsl #18
    28f0:	b8050300 	stmdalt	r5, {r8, r9}
    28f4:	04000000 	streq	r0, [r0]
    28f8:	0000c605 	andeq	ip, r0, r5, lsl #12
    28fc:	cc050500 	cfstr32gt	mvfx0, [r5], {0}
    2900:	06000005 	streq	r0, [r0], -r5
    2904:	0005ac05 	andeq	sl, r5, r5, lsl #24
    2908:	d8050700 	stmdale	r5, {r8, r9, sl}
    290c:	08000001 	stmdaeq	r0, {r0}
    2910:	0001af05 	andeq	sl, r1, r5, lsl #30
    2914:	69050900 	stmdbvs	r5, {r8, fp}
    2918:	0a000006 	beq	2938 <__Stack_Size+0x2538>
    291c:	0004d405 	andeq	sp, r4, r5, lsl #8
    2920:	75050b00 	strvc	r0, [r5, #-2816]
    2924:	0c000004 	stceq	0, cr0, [r0], {4}
    2928:	00010305 	andeq	r0, r1, r5, lsl #6
    292c:	65050d00 	strvs	r0, [r5, #-3328]
    2930:	0e000003 	cdpeq	0, 0, cr0, cr0, cr3, {0}
    2934:	00035405 	andeq	r5, r3, r5, lsl #8
    2938:	8c050f00 	stchi	15, cr0, [r5], {0}
    293c:	10000000 	andne	r0, r0, r0
    2940:	0004f205 	andeq	pc, r4, r5, lsl #4
    2944:	37051100 	strcc	r1, [r5, -r0, lsl #2]
    2948:	12000006 	andne	r0, r0, #6	; 0x6
    294c:	00003405 	andeq	r3, r0, r5, lsl #8
    2950:	46051300 	strmi	r1, [r5], -r0, lsl #6
    2954:	14000005 	strne	r0, [r0], #-5
    2958:	00052f05 	andeq	r2, r5, r5, lsl #30
    295c:	9e051500 	cfsh32ls	mvfx1, mvfx5, #0
    2960:	16000003 	strne	r0, [r0], -r3
    2964:	00037605 	andeq	r7, r3, r5, lsl #12
    2968:	63051700 	movwvs	r1, #22272	; 0x5700
    296c:	18000004 	stmdane	r0, {r2}
    2970:	00006b05 	andeq	r6, r0, r5, lsl #22
    2974:	73051900 	movwvc	r1, #22784	; 0x5900
    2978:	1a000000 	bne	2980 <__Stack_Size+0x2580>
    297c:	00033a05 	andeq	r3, r3, r5, lsl #20
    2980:	95051b00 	strls	r1, [r5, #-2816]
    2984:	1c000006 	stcne	0, cr0, [r0], {6}
    2988:	00020a05 	andeq	r0, r2, r5, lsl #20
    298c:	7a051d00 	bvc	149d94 <__Stack_Size+0x149994>
    2990:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
    2994:	00065505 	andeq	r5, r6, r5, lsl #10
    2998:	24051f00 	strcs	r1, [r5], #-3840
    299c:	20000006 	andcs	r0, r0, r6
    29a0:	00060605 	andeq	r0, r6, r5, lsl #12
    29a4:	35052100 	strcc	r2, [r5, #-256]
    29a8:	22000004 	andcs	r0, r0, #4	; 0x4
    29ac:	00041805 	andeq	r1, r4, r5, lsl #16
    29b0:	d5052300 	strle	r2, [r5, #-768]
    29b4:	24000003 	strcs	r0, [r0], #-3
    29b8:	0003be05 	andeq	fp, r3, r5, lsl #28
    29bc:	90052500 	andls	r2, r5, r0, lsl #10
    29c0:	26000005 	strcs	r0, [r0], -r5
    29c4:	00057c05 	andeq	r7, r5, r5, lsl #24
    29c8:	04052700 	streq	r2, [r5], #-1792
    29cc:	28000007 	stmdacs	r0, {r0, r1, r2}
    29d0:	0006e305 	andeq	lr, r6, r5, lsl #6
    29d4:	12052900 	andne	r2, r5, #0	; 0x0
    29d8:	2a000000 	bcs	29e0 <__Stack_Size+0x25e0>
    29dc:	00014205 	andeq	r4, r1, r5, lsl #4
    29e0:	48052b00 	stmdami	r5, {r8, r9, fp, sp}
    29e4:	2c000004 	stccs	0, cr0, [r0], {4}
    29e8:	00022c05 	andeq	r2, r2, r5, lsl #24
    29ec:	b3052d00 	movwlt	r2, #23808	; 0x5d00
    29f0:	2e000003 	cdpcs	0, 0, cr0, cr0, cr3, {0}
    29f4:	00022305 	andeq	r2, r2, r5, lsl #6
    29f8:	8a052f00 	bhi	14e600 <__Stack_Size+0x14e200>
    29fc:	30000001 	andcc	r0, r0, r1
    2a00:	00017e05 	andeq	r7, r1, r5, lsl #28
    2a04:	0c003100 	stfeqs	f3, [r0], {0}
    2a08:	08020704 	stmdaeq	r2, {r2, r8, r9, sl}
    2a0c:	00011d05 	andeq	r1, r1, r5, lsl #26
    2a10:	07080200 	streq	r0, [r8, -r0, lsl #4]
    2a14:	0000012b 	andeq	r0, r0, fp, lsr #2
    2a18:	1951010d 	ldmdbne	r1, {r0, r2, r3, r8}^
    2a1c:	4e010000 	cdpmi	0, 0, cr0, cr1, cr0, {0}
    2a20:	00000001 	andeq	r0, r0, r1
    2a24:	00000000 	andeq	r0, r0, r0
    2a28:	355d0100 	ldrbcc	r0, [sp, #-256]
    2a2c:	0e000003 	cdpeq	0, 0, cr0, cr0, cr3, {0}
    2a30:	00001a8a 	andeq	r1, r0, sl, lsl #21
    2a34:	00b64e01 	adcseq	r4, r6, r1, lsl #28
    2a38:	50010000 	andpl	r0, r1, r0
    2a3c:	0064690f 	rsbeq	r6, r4, pc, lsl #18
    2a40:	00b64e01 	adcseq	r4, r6, r1, lsl #28
    2a44:	51010000 	tstpl	r1, r0
    2a48:	70011000 	andvc	r1, r1, r0
    2a4c:	0100001a 	tsteq	r0, sl, lsl r0
    2a50:	00b60151 	adcseq	r0, r6, r1, asr r1
	...
    2a5c:	5d010000 	stcpl	0, cr0, [r1]
    2a60:	00000360 	andeq	r0, r0, r0, ror #6
    2a64:	001a8a11 	andseq	r8, sl, r1, lsl sl
    2a68:	b6510100 	ldrblt	r0, [r1], -r0, lsl #2
    2a6c:	ef000000 	svc	0x00000000
    2a70:	0000000e 	andeq	r0, r0, lr
    2a74:	1a03010d 	bne	c2eb0 <__Stack_Size+0xc2ab0>
    2a78:	56010000 	strpl	r0, [r1], -r0
    2a7c:	00000001 	andeq	r0, r0, r1
    2a80:	00000000 	andeq	r0, r0, r0
    2a84:	8e5d0100 	rdfhie	f0, f5, f0
    2a88:	0e000003 	cdpeq	0, 0, cr0, cr0, cr3, {0}
    2a8c:	000050c4 	andeq	r5, r0, r4, asr #1
    2a90:	038e5601 	orreq	r5, lr, #1048576	; 0x100000
    2a94:	50010000 	andpl	r0, r1, r0
    2a98:	01006912 	tsteq	r0, r2, lsl r9
    2a9c:	0000b657 	andeq	fp, r0, r7, asr r6
    2aa0:	04090000 	streq	r0, [r9]
    2aa4:	00000394 	muleq	r0, r4, r3
    2aa8:	0000af13 	andeq	sl, r0, r3, lsl pc
    2aac:	6b011000 	blvs	46ab4 <__Stack_Size+0x466b4>
    2ab0:	01000019 	tsteq	r0, r9, lsl r0
    2ab4:	00b601f1 	ldrshteq	r0, [r6], r1
	...
    2ac0:	5d010000 	stcpl	0, cr0, [r1]
    2ac4:	000003d0 	ldrdeq	r0, [r0], -r0
    2ac8:	00646914 	rsbeq	r6, r4, r4, lsl r9
    2acc:	00b6f101 	adcseq	pc, r6, r1, lsl #2
    2ad0:	0f020000 	svceq	0x00020000
    2ad4:	69150000 	ldmdbvs	r5, {}
    2ad8:	b6f20100 	ldrbtlt	r0, [r2], r0, lsl #2
    2adc:	20000000 	andcs	r0, r0, r0
    2ae0:	0000000f 	andeq	r0, r0, pc
    2ae4:	199d0110 	ldmibne	sp, {r4, r8}
    2ae8:	fb010000 	blx	42af2 <__Stack_Size+0x426f2>
    2aec:	0000b601 	andeq	fp, r0, r1, lsl #12
	...
    2af8:	075d0100 	ldrbeq	r0, [sp, -r0, lsl #2]
    2afc:	14000004 	strne	r0, [r0], #-4
    2b00:	01006469 	tsteq	r0, r9, ror #8
    2b04:	0000b6fb 	strdeq	fp, [r0], -fp
    2b08:	000f3e00 	andeq	r3, pc, r0, lsl #28
    2b0c:	00691500 	rsbeq	r1, r9, r0, lsl #10
    2b10:	00b6fc01 	adcseq	pc, r6, r1, lsl #24
    2b14:	0f5c0000 	svceq	0x005c0000
    2b18:	16000000 	strne	r0, [r0], -r0
    2b1c:	001a2001 	andseq	r2, sl, r1
    2b20:	01050100 	tsteq	r5, r0, lsl #2
    2b24:	00000001 	andeq	r0, r0, r1
    2b28:	00000000 	andeq	r0, r0, r0
    2b2c:	000f7a00 	andeq	r7, pc, r0, lsl #20
    2b30:	00044900 	andeq	r4, r4, r0, lsl #18
    2b34:	64691700 	strbtvs	r1, [r9], #-1792
    2b38:	01050100 	tsteq	r5, r0, lsl #2
    2b3c:	000000b6 	strheq	r0, [r0], -r6
    2b40:	70175001 	andsvc	r5, r7, r1
    2b44:	0100736f 	tsteq	r0, pc, ror #6
    2b48:	00b60105 	adcseq	r0, r6, r5, lsl #2
    2b4c:	51010000 	tstpl	r1, r0
    2b50:	01006918 	tsteq	r0, r8, lsl r9
    2b54:	00b60106 	adcseq	r0, r6, r6, lsl #2
    2b58:	52010000 	andpl	r0, r1, #0	; 0x0
    2b5c:	07011900 	streq	r1, [r1, -r0, lsl #18]
    2b60:	01000019 	tsteq	r0, r9, lsl r0
    2b64:	00010111 	andeq	r0, r1, r1, lsl r1
    2b68:	00000000 	andeq	r0, r0, r0
    2b6c:	01000000 	tsteq	r0, r0
    2b70:	00047e5d 	andeq	r7, r4, sp, asr lr
    2b74:	1a8a1a00 	bne	fe28937c <SCS_BASE+0x1e27b37c>
    2b78:	11010000 	tstne	r1, r0
    2b7c:	0000b601 	andeq	fp, r0, r1, lsl #12
    2b80:	17500100 	ldrbne	r0, [r0, -r0, lsl #2]
    2b84:	00736f70 	rsbseq	r6, r3, r0, ror pc
    2b88:	b6011101 	strlt	r1, [r1], -r1, lsl #2
    2b8c:	01000000 	tsteq	r0, r0
    2b90:	011b0051 	tsteq	fp, r1, asr r0
    2b94:	00001a90 	muleq	r0, r0, sl
    2b98:	00018e01 	andeq	r8, r1, r1, lsl #28
    2b9c:	00000000 	andeq	r0, r0, r0
    2ba0:	99000000 	stmdbls	r0, {}
    2ba4:	bf00000f 	svclt	0x0000000f
    2ba8:	11000004 	tstne	r0, r4
    2bac:	000024f4 	strdeq	r2, [r0], -r4
    2bb0:	00b68e01 	adcseq	r8, r6, r1, lsl #28
    2bb4:	0fb80000 	svceq	0x00b80000
    2bb8:	691c0000 	ldmdbvs	ip, {}
    2bbc:	b68f0100 	strlt	r0, [pc], r0, lsl #2
    2bc0:	01000000 	tsteq	r0, r0
    2bc4:	1b161d50 	blne	58a10c <__Stack_Size+0x589d0c>
    2bc8:	90010000 	andls	r0, r1, r0
    2bcc:	000000b6 	strheq	r0, [r0], -r6
    2bd0:	1b005501 	blne	17fdc <__Stack_Size+0x17bdc>
    2bd4:	00198a01 	andseq	r8, r9, r1, lsl #20
    2bd8:	01380100 	teqeq	r8, r0, lsl #2
	...
    2be4:	00000fcb 	andeq	r0, r0, fp, asr #31
    2be8:	000004f5 	strdeq	r0, [r0], -r5
    2bec:	001acb11 	andseq	ip, sl, r1, lsl fp
    2bf0:	b6380100 	ldrtlt	r0, [r8], -r0, lsl #2
    2bf4:	f6000000 	undefined instruction 0xf6000000
    2bf8:	1500000f 	strne	r0, [r0, #-15]
    2bfc:	39010069 	stmdbcc	r1, {r0, r3, r5, r6}
    2c00:	000000b6 	strheq	r0, [r0], -r6
    2c04:	00001009 	andeq	r1, r0, r9
    2c08:	d5011e00 	strle	r1, [r1, #-3584]
    2c0c:	0100001a 	tsteq	r0, sl, lsl r0
    2c10:	00000020 	andeq	r0, r0, r0, lsr #32
    2c14:	00000000 	andeq	r0, r0, r0
    2c18:	00101c00 	andseq	r1, r0, r0, lsl #24
    2c1c:	00051700 	andeq	r1, r5, r0, lsl #14
    2c20:	00691200 	rsbeq	r1, r9, r0, lsl #4
    2c24:	00b62101 	adcseq	r2, r6, r1, lsl #2
    2c28:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    2c2c:	0019d101 	andseq	sp, r9, r1, lsl #2
    2c30:	00730100 	rsbseq	r0, r3, r0, lsl #2
    2c34:	00000000 	andeq	r0, r0, r0
    2c38:	3b000000 	blcc	2c40 <__Stack_Size+0x2840>
    2c3c:	55000010 	strpl	r0, [r0, #-16]
    2c40:	1f000005 	svcne	0x00000005
    2c44:	00001998 	muleq	r0, r8, r9
    2c48:	00b67401 	adcseq	r7, r6, r1, lsl #8
    2c4c:	10660000 	rsbne	r0, r6, r0
    2c50:	691c0000 	ldmdbvs	ip, {}
    2c54:	b6790100 	ldrbtlt	r0, [r9], -r0, lsl #2
    2c58:	01000000 	tsteq	r0, r0
    2c5c:	1e302056 	mrcne	0, 1, r2, cr0, cr6, {2}
    2c60:	83010000 	movwhi	r0, #4096	; 0x1000
    2c64:	00000041 	andeq	r0, r0, r1, asr #32
    2c68:	e9012100 	stmdb	r1, {r8, sp}
    2c6c:	0100001a 	tsteq	r0, sl, lsl r0
    2c70:	00b601ae 	adcseq	r0, r6, lr, lsr #3
	...
    2c7c:	10790000 	rsbsne	r0, r9, r0
    2c80:	05b30000 	ldreq	r0, [r3]!
    2c84:	4b110000 	blmi	442c8c <__Stack_Size+0x44288c>
    2c88:	01000019 	tsteq	r0, r9, lsl r0
    2c8c:	000079ae 	andeq	r7, r0, lr, lsr #19
    2c90:	0010a400 	andseq	sl, r0, r0, lsl #8
    2c94:	00691c00 	rsbeq	r1, r9, r0, lsl #24
    2c98:	00b6b201 	adcseq	fp, r6, r1, lsl #4
    2c9c:	55010000 	strpl	r0, [r1]
    2ca0:	001b0d1d 	andseq	r0, fp, sp, lsl sp
    2ca4:	b6b30100 	ldrtlt	r0, [r3], r0, lsl #2
    2ca8:	01000000 	tsteq	r0, r0
    2cac:	00002254 	andeq	r2, r0, r4, asr r2
    2cb0:	00000000 	andeq	r0, r0, r0
    2cb4:	461f0000 	ldrmi	r0, [pc], -r0
    2cb8:	01000019 	tsteq	r0, r9, lsl r0
    2cbc:	0000b6cd 	andeq	fp, r0, sp, asr #13
    2cc0:	0010cd00 	andseq	ip, r0, r0, lsl #26
    2cc4:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    2cc8:	001a4901 	andseq	r4, sl, r1, lsl #18
    2ccc:	005e0100 	subseq	r0, lr, r0, lsl #2
    2cd0:	00000000 	andeq	r0, r0, r0
    2cd4:	0c000000 	stceq	0, cr0, [r0], {0}
    2cd8:	d7000011 	smladle	r0, r1, r0, r0
    2cdc:	1c000005 	stcne	0, cr0, [r0], {5}
    2ce0:	5f010069 	svcpl	0x00010069
    2ce4:	000000b6 	strheq	r0, [r0], -r6
    2ce8:	20005401 	andcs	r5, r0, r1, lsl #8
    2cec:	00000569 	andeq	r0, r0, r9, ror #10
    2cf0:	05e22a05 	strbeq	r2, [r2, #2565]!
    2cf4:	53230000 	teqpl	r3, #0	; 0x0
    2cf8:	20000000 	andcs	r0, r0, r0
    2cfc:	000002ce 	andeq	r0, r0, lr, asr #5
    2d00:	05f22805 	ldrbeq	r2, [r2, #2053]!
    2d04:	41230000 	teqmi	r3, r0
    2d08:	20000000 	andcs	r0, r0, r0
    2d0c:	0000042b 	andeq	r0, r0, fp, lsr #8
    2d10:	05f22805 	ldrbeq	r2, [r2, #2053]!
    2d14:	53240000 	teqpl	r4, #0	; 0x0
    2d18:	13000000 	movwne	r0, #0	; 0x0
    2d1c:	25000006 	strcs	r0, [r0, #-6]
    2d20:	000002f3 	strdeq	r0, [r0], -r3
    2d24:	200003ff 	strdcs	r0, [r0], -pc
    2d28:	000004af 	andeq	r0, r0, pc, lsr #9
    2d2c:	061e2905 	ldreq	r2, [lr], -r5, lsl #18
    2d30:	02230000 	eoreq	r0, r3, #0	; 0x0
    2d34:	26000006 	strcs	r0, [r0], -r6
    2d38:	0000064a 	andeq	r0, r0, sl, asr #12
    2d3c:	05e24405 	strbeq	r4, [r2, #1029]!
    2d40:	26000000 	strcs	r0, [r0], -r0
    2d44:	0000040e 	andeq	r0, r0, lr, lsl #8
    2d48:	05e24405 	strbeq	r4, [r2, #1029]!
    2d4c:	24000000 	strcs	r0, [r0]
    2d50:	00000053 	andeq	r0, r0, r3, asr r0
    2d54:	0000064b 	andeq	r0, r0, fp, asr #12
    2d58:	0002f327 	andeq	pc, r2, r7, lsr #6
    2d5c:	20004000 	andcs	r4, r0, r0
    2d60:	000000ec 	andeq	r0, r0, ip, ror #1
    2d64:	06564505 	ldrbeq	r4, [r6], -r5, lsl #10
    2d68:	3b230000 	blcc	8c2d70 <__Stack_Size+0x8c2970>
    2d6c:	26000006 	strcs	r0, [r0], -r6
    2d70:	00000619 	andeq	r0, r0, r9, lsl r6
    2d74:	05f25805 	ldrbeq	r5, [r2, #2053]!
    2d78:	26000000 	strcs	r0, [r0], -r0
    2d7c:	000000f9 	strdeq	r0, [r0], -r9
    2d80:	05f25805 	ldrbeq	r5, [r2, #2053]!
    2d84:	20000000 	andcs	r0, r0, r0
    2d88:	0000032d 	andeq	r0, r0, sp, lsr #6
    2d8c:	067e5905 	ldrbteq	r5, [lr], -r5, lsl #18
    2d90:	02230000 	eoreq	r0, r3, #0	; 0x0
    2d94:	28000006 	stmdacs	r0, {r1, r2}
    2d98:	00001759 	andeq	r1, r0, r9, asr r7
    2d9c:	005d1001 	subseq	r1, sp, r1
    2da0:	05010000 	streq	r0, [r1]
    2da4:	00000003 	andeq	r0, r0, r3
    2da8:	1ab52800 	bne	fed4cdb0 <SCS_BASE+0x1ed3edb0>
    2dac:	11010000 	tstne	r1, r0
    2db0:	0000005d 	andeq	r0, r0, sp, asr r0
    2db4:	00030501 	andeq	r0, r3, r1, lsl #10
    2db8:	28000000 	stmdacs	r0, {}
    2dbc:	000017c4 	andeq	r1, r0, r4, asr #15
    2dc0:	00b61201 	adcseq	r1, r6, r1, lsl #4
    2dc4:	05010000 	streq	r0, [r1]
    2dc8:	00000003 	andeq	r0, r0, r3
    2dcc:	192e2800 	stmdbne	lr!, {fp, sp}
    2dd0:	13010000 	movwne	r0, #4096	; 0x1000
    2dd4:	00000053 	andeq	r0, r0, r3, asr r0
    2dd8:	00030501 	andeq	r0, r3, r1, lsl #10
    2ddc:	24000000 	strcs	r0, [r0]
    2de0:	000000af 	andeq	r0, r0, pc, lsr #1
    2de4:	000006db 	ldrdeq	r0, [r0], -fp
    2de8:	0002f327 	andeq	pc, r2, r7, lsr #6
    2dec:	28001100 	stmdacs	r0, {r8, ip}
    2df0:	00001a6a 	andeq	r1, r0, sl, ror #20
    2df4:	06cb1401 	strbeq	r1, [fp], r1, lsl #8
    2df8:	05010000 	streq	r0, [r1]
    2dfc:	00000003 	andeq	r0, r0, r3
    2e00:	1a662800 	bne	198ce08 <__Stack_Size+0x198ca08>
    2e04:	15010000 	strne	r0, [r1]
    2e08:	000006cb 	andeq	r0, r0, fp, asr #13
    2e0c:	00030501 	andeq	r0, r3, r1, lsl #10
    2e10:	24000000 	strcs	r0, [r0]
    2e14:	000000b6 	strheq	r0, [r0], -r6
    2e18:	0000070f 	andeq	r0, r0, pc, lsl #14
    2e1c:	0002f327 	andeq	pc, r2, r7, lsr #6
    2e20:	28001100 	stmdacs	r0, {r8, ip}
    2e24:	000019ca 	andeq	r1, r0, sl, asr #19
    2e28:	06ff1601 	ldrbteq	r1, [pc], r1, lsl #12
    2e2c:	05010000 	streq	r0, [r1]
    2e30:	00000003 	andeq	r0, r0, r3
    2e34:	005d2400 	subseq	r2, sp, r0, lsl #8
    2e38:	07310000 	ldreq	r0, [r1, -r0]!
    2e3c:	f3270000 	vhadd.u32	d0, d7, d0
    2e40:	11000002 	tstne	r0, r2
    2e44:	64692900 	strbtvs	r2, [r9], #-2304
    2e48:	1701005f 	smlsdne	r1, pc, r0, r0
    2e4c:	00000721 	andeq	r0, r0, r1, lsr #14
    2e50:	00030501 	andeq	r0, r3, r1, lsl #10
    2e54:	28000000 	stmdacs	r0, {}
    2e58:	00001ac0 	andeq	r1, r0, r0, asr #21
    2e5c:	003a1a01 	eorseq	r1, sl, r1, lsl #20
    2e60:	05010000 	streq	r0, [r1]
    2e64:	00000003 	andeq	r0, r0, r3
    2e68:	1a402800 	bne	100ce70 <__Stack_Size+0x100ca70>
    2e6c:	1b010000 	blne	42e74 <__Stack_Size+0x42a74>
    2e70:	00000767 	andeq	r0, r0, r7, ror #14
    2e74:	00030501 	andeq	r0, r3, r1, lsl #10
    2e78:	09000000 	stmdbeq	r0, {}
    2e7c:	0000bd04 	andeq	fp, r0, r4, lsl #26
    2e80:	193a2800 	ldmdbne	sl!, {fp, sp}
    2e84:	1c010000 	stcne	0, cr0, [r1], {0}
    2e88:	000000b6 	strheq	r0, [r0], -r6
    2e8c:	00030501 	andeq	r0, r3, r1, lsl #10
    2e90:	00000000 	andeq	r0, r0, r0
    2e94:	00000837 	andeq	r0, r0, r7, lsr r8
    2e98:	09180002 	ldmdbeq	r8, {r1}
    2e9c:	01040000 	tsteq	r4, r0
    2ea0:	000001fe 	strdeq	r0, [r0], -lr
    2ea4:	001cc001 	andseq	ip, ip, r1
    2ea8:	00024900 	andeq	r4, r2, r0, lsl #18
    2eac:	00358000 	eorseq	r8, r5, r0
    2eb0:	003c3608 	eorseq	r3, ip, r8, lsl #12
    2eb4:	000bc608 	andeq	ip, fp, r8, lsl #12
    2eb8:	33730200 	cmncc	r3, #0	; 0x0
    2ebc:	17020032 	smladxne	r2, r2, r0, r0
    2ec0:	00000030 	andeq	r0, r0, r0, lsr r0
    2ec4:	22050403 	andcs	r0, r5, #50331648	; 0x3000000
    2ec8:	02000001 	andeq	r0, r0, #1	; 0x1
    2ecc:	00363173 	eorseq	r3, r6, r3, ror r1
    2ed0:	00421802 	subeq	r1, r2, r2, lsl #16
    2ed4:	02030000 	andeq	r0, r3, #0	; 0x0
    2ed8:	0004ca05 	andeq	ip, r4, r5, lsl #20
    2edc:	38730200 	ldmdacc	r3!, {r9}^
    2ee0:	53190200 	tstpl	r9, #0	; 0x0
    2ee4:	03000000 	movweq	r0, #0	; 0x0
    2ee8:	049e0601 	ldreq	r0, [lr], #1537
    2eec:	75020000 	strvc	r0, [r2]
    2ef0:	02003233 	andeq	r3, r0, #805306371	; 0x30000003
    2ef4:	00006527 	andeq	r6, r0, r7, lsr #10
    2ef8:	07040300 	streq	r0, [r4, -r0, lsl #6]
    2efc:	00000130 	andeq	r0, r0, r0, lsr r1
    2f00:	36317502 	ldrtcc	r7, [r1], -r2, lsl #10
    2f04:	77280200 	strvc	r0, [r8, -r0, lsl #4]!
    2f08:	03000000 	movweq	r0, #0	; 0x0
    2f0c:	01c50702 	biceq	r0, r5, r2, lsl #14
    2f10:	75020000 	strvc	r0, [r2]
    2f14:	29020038 	stmdbcs	r2, {r3, r4, r5}
    2f18:	00000088 	andeq	r0, r0, r8, lsl #1
    2f1c:	9c080103 	stflss	f0, [r8], {3}
    2f20:	04000004 	streq	r0, [r0], #-4
    2f24:	00001faf 	andeq	r1, r0, pc, lsr #31
    2f28:	00882a02 	addeq	r2, r8, r2, lsl #20
    2f2c:	04050000 	streq	r0, [r5]
    2f30:	03010607 	movweq	r0, #5639	; 0x1607
    2f34:	0000d1b5 	strheq	sp, [r0], -r5
    2f38:	1bda0700 	blne	ff684b40 <SCS_BASE+0x1f676b40>
    2f3c:	00c00000 	sbceq	r0, r0, r0
    2f40:	001d0b07 	andseq	r0, sp, r7, lsl #22
    2f44:	52072000 	andpl	r2, r7, #0	; 0x0
    2f48:	1000001b 	andne	r0, r0, fp, lsl r0
    2f4c:	001cf307 	andseq	pc, ip, r7, lsl #6
    2f50:	62070800 	andvs	r0, r7, #0	; 0x0
    2f54:	0400001b 	streq	r0, [r0], #-27
    2f58:	001bcd07 	andseq	ip, fp, r7, lsl #26
    2f5c:	2f070200 	svccs	0x00070200
    2f60:	0100001c 	tsteq	r0, ip, lsl r0
    2f64:	03020600 	movweq	r0, #9728	; 0x2600
    2f68:	00012fcf 	andeq	r2, r1, pc, asr #31
    2f6c:	06b50700 	ldrteq	r0, [r5], r0, lsl #14
    2f70:	07010000 	streq	r0, [r1, -r0]
    2f74:	000004bc 	strheq	r0, [r0], -ip
    2f78:	038b0702 	orreq	r0, fp, #524288	; 0x80000
    2f7c:	07040000 	streq	r0, [r4, -r0]
    2f80:	000006c3 	andeq	r0, r0, r3, asr #13
    2f84:	05000708 	streq	r0, [r0, #-1800]
    2f88:	07100000 	ldreq	r0, [r0, -r0]
    2f8c:	00000169 	andeq	r0, r0, r9, ror #2
    2f90:	05c10720 	strbeq	r0, [r1, #1824]
    2f94:	00c00000 	sbceq	r0, r0, r0
    2f98:	00023b07 	andeq	r3, r2, r7, lsl #22
    2f9c:	07018000 	streq	r8, [r1, -r0]
    2fa0:	000006f6 	strdeq	r0, [r0], -r6
    2fa4:	8e070280 	cdphi	2, 0, cr0, cr7, cr0, {4}
    2fa8:	80000004 	andhi	r0, r0, r4
    2fac:	00260704 	eoreq	r0, r6, r4, lsl #14
    2fb0:	08800000 	stmeq	r0, {}
    2fb4:	00032007 	andeq	r2, r3, r7
    2fb8:	07108000 	ldreq	r8, [r0, -r0]
    2fbc:	0000015a 	andeq	r0, r0, sl, asr r1
    2fc0:	03002080 	movweq	r2, #128	; 0x80
    2fc4:	011d0508 	tsteq	sp, r8, lsl #10
    2fc8:	08030000 	stmdaeq	r3, {}
    2fcc:	00012b07 	andeq	r2, r1, r7, lsl #22
    2fd0:	05040800 	streq	r0, [r4, #-2048]
    2fd4:	00746e69 	rsbseq	r6, r4, r9, ror #28
    2fd8:	35070403 	strcc	r0, [r7, #-1027]
    2fdc:	09000001 	stmdbeq	r0, {r0}
    2fe0:	001c3e01 	andseq	r3, ip, r1, lsl #28
    2fe4:	010e0100 	tsteq	lr, r0, lsl #2
    2fe8:	0000008f 	andeq	r0, r0, pc, lsl #1
    2fec:	08003580 	stmdaeq	r0, {r7, r8, sl, ip, sp}
    2ff0:	08003598 	stmdaeq	r0, {r3, r4, r7, r8, sl, ip, sp}
    2ff4:	010a5d01 	tsteq	sl, r1, lsl #26
    2ff8:	00001cdc 	ldrdeq	r1, [r0], -ip
    2ffc:	8f011401 	svchi	0x00011401
    3000:	98000000 	stmdals	r0, {}
    3004:	c8080035 	stmdagt	r8, {r0, r2, r4, r5}
    3008:	01080035 	tsteq	r8, r5, lsr r0
    300c:	00018b5d 	andeq	r8, r1, sp, asr fp
    3010:	1c8f0b00 	vstmiane	pc, {d0-d-1}
    3014:	15010000 	strne	r0, [r1]
    3018:	0000008f 	andeq	r0, r0, pc, lsl #1
    301c:	0c005001 	stceq	0, cr5, [r0], {1}
    3020:	001b2d01 	andseq	r2, fp, r1, lsl #26
    3024:	01ed0100 	mvneq	r0, r0, lsl #2
    3028:	0035c801 	eorseq	ip, r5, r1, lsl #16
    302c:	00363408 	eorseq	r3, r6, r8, lsl #8
    3030:	00113708 	andseq	r3, r1, r8, lsl #14
    3034:	0001f000 	andeq	pc, r1, r0
    3038:	1c140d00 	ldcne	13, cr0, [r4], {0}
    303c:	ec010000 	stc	0, cr0, [r1], {0}
    3040:	00002501 	andeq	r2, r0, r1, lsl #10
    3044:	00116200 	andseq	r6, r1, r0, lsl #4
    3048:	1b7b0e00 	blne	1ec6850 <__Stack_Size+0x1ec6450>
    304c:	ee010000 	cdp	0, 0, cr0, cr1, cr0, {0}
    3050:	00007e01 	andeq	r7, r0, r1, lsl #28
    3054:	0f570100 	svceq	0x00570100
    3058:	00001b9c 	muleq	r0, ip, fp
    305c:	7e01ee01 	cdpvc	14, 0, cr14, cr1, cr1, {0}
    3060:	80000000 	andhi	r0, r0, r0
    3064:	0e000011 	mcreq	0, 0, r0, cr0, cr1, {0}
    3068:	00001bed 	andeq	r1, r0, sp, ror #23
    306c:	2501ef01 	strcs	lr, [r1, #-3841]
    3070:	01000000 	tsteq	r0, r0
    3074:	1ca60e55 	stcne	14, cr0, [r6], #340
    3078:	ef010000 	svc	0x00010000
    307c:	00002501 	andeq	r2, r0, r1, lsl #10
    3080:	00560100 	subseq	r0, r6, r0, lsl #2
    3084:	1c1a010c 	ldfnes	f0, [sl], {12}
    3088:	c7010000 	strgt	r0, [r1, -r0]
    308c:	36340101 	ldrtcc	r0, [r4], -r1, lsl #2
    3090:	36c40800 	strbcc	r0, [r4], r0, lsl #16
    3094:	11ac0800 	undefined instruction 0x11ac0800
    3098:	02650000 	rsbeq	r0, r5, #0	; 0x0
    309c:	270d0000 	strcs	r0, [sp, -r0]
    30a0:	0100001b 	tsteq	r0, fp, lsl r0
    30a4:	003701c6 	eorseq	r0, r7, r6, asr #3
    30a8:	11d70000 	bicsne	r0, r7, r0
    30ac:	7b0e0000 	blvc	3830b4 <__Stack_Size+0x382cb4>
    30b0:	0100001b 	tsteq	r0, fp, lsl r0
    30b4:	007e01c8 	rsbseq	r0, lr, r8, asr #3
    30b8:	57010000 	strpl	r0, [r1, -r0]
    30bc:	001b9c0f 	andseq	r9, fp, pc, lsl #24
    30c0:	01c80100 	biceq	r0, r8, r0, lsl #2
    30c4:	0000007e 	andeq	r0, r0, lr, ror r0
    30c8:	000011f5 	strdeq	r1, [r0], -r5
    30cc:	001cee0e 	andseq	lr, ip, lr, lsl #28
    30d0:	01c90100 	biceq	r0, r9, r0, lsl #2
    30d4:	0000006c 	andeq	r0, r0, ip, rrx
    30d8:	590e5401 	stmdbpl	lr, {r0, sl, ip, lr}
    30dc:	0100001c 	tsteq	r0, ip, lsl r0
    30e0:	006c01c9 	rsbeq	r0, ip, r9, asr #3
    30e4:	56010000 	strpl	r0, [r1], -r0
    30e8:	001ce70f 	andseq	lr, ip, pc, lsl #14
    30ec:	01ca0100 	biceq	r0, sl, r0, lsl #2
    30f0:	0000007e 	andeq	r0, r0, lr, ror r0
    30f4:	00001239 	andeq	r1, r0, r9, lsr r2
    30f8:	84010c00 	strhi	r0, [r1], #-3072
    30fc:	0100001c 	tsteq	r0, ip, lsl r0
    3100:	c40101a2 	strgt	r0, [r1], #-418
    3104:	4c080036 	stcmi	0, cr0, [r8], {54}
    3108:	71080037 	tstvc	r8, r7, lsr r0
    310c:	d9000012 	stmdble	r0, {r1, r4}
    3110:	0d000002 	stceq	0, cr0, [r0, #-8]
    3114:	00001b27 	andeq	r1, r0, r7, lsr #22
    3118:	4901a101 	stmdbmi	r1, {r0, r8, sp, pc}
    311c:	9c000000 	stcls	0, cr0, [r0], {0}
    3120:	0e000012 	mcreq	0, 0, r0, cr0, cr2, {0}
    3124:	00001b7b 	andeq	r1, r0, fp, ror fp
    3128:	7e01a301 	cdpvc	3, 0, cr10, cr1, cr1, {0}
    312c:	02000000 	andeq	r0, r0, #0	; 0x0
    3130:	9c0e007d 	stcls	0, cr0, [lr], {125}
    3134:	0100001b 	tsteq	r0, fp, lsl r0
    3138:	007e01a3 	rsbseq	r0, lr, r3, lsr #3
    313c:	57010000 	strpl	r0, [r1, -r0]
    3140:	001cee0e 	andseq	lr, ip, lr, lsl #28
    3144:	01a40100 	undefined instruction 0x01a40100
    3148:	0000006c 	andeq	r0, r0, ip, rrx
    314c:	590e5401 	stmdbpl	lr, {r0, sl, ip, lr}
    3150:	0100001c 	tsteq	r0, ip, lsl r0
    3154:	006c01a4 	rsbeq	r0, ip, r4, lsr #3
    3158:	56010000 	strpl	r0, [r1], -r0
    315c:	001ce70f 	andseq	lr, ip, pc, lsl #14
    3160:	01a50100 	undefined instruction 0x01a50100
    3164:	0000007e 	andeq	r0, r0, lr, ror r0
    3168:	000012ba 	strheq	r1, [r0], -sl
    316c:	90010c00 	andls	r0, r1, r0, lsl #24
    3170:	0100001b 	tsteq	r0, fp, lsl r0
    3174:	4c010183 	stfmis	f0, [r1], {131}
    3178:	a4080037 	strge	r0, [r8], #-55
    317c:	f2080037 	vqadd.s8	d0, d8, d23
    3180:	3e000012 	mcrcc	0, 0, r0, cr0, cr2, {0}
    3184:	0d000003 	stceq	0, cr0, [r0, #-12]
    3188:	00001b27 	andeq	r1, r0, r7, lsr #22
    318c:	5a018201 	bpl	63998 <__Stack_Size+0x63598>
    3190:	1d000000 	stcne	0, cr0, [r0]
    3194:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    3198:	00001b7b 	andeq	r1, r0, fp, ror fp
    319c:	7e018401 	cdpvc	4, 0, cr8, cr1, cr1, {0}
    31a0:	01000000 	tsteq	r0, r0
    31a4:	1b9c0f56 	blne	fe706f04 <SCS_BASE+0x1e6f8f04>
    31a8:	84010000 	strhi	r0, [r1]
    31ac:	00007e01 	andeq	r7, r0, r1, lsl #28
    31b0:	00133b00 	andseq	r3, r3, r0, lsl #22
    31b4:	1cee0e00 	stclne	14, cr0, [lr]
    31b8:	85010000 	strhi	r0, [r1]
    31bc:	00005a01 	andeq	r5, r0, r1, lsl #20
    31c0:	0e550100 	rdfeqs	f0, f5, f0
    31c4:	00001c59 	andeq	r1, r0, r9, asr ip
    31c8:	5a018501 	bpl	645d4 <__Stack_Size+0x641d4>
    31cc:	01000000 	tsteq	r0, r0
    31d0:	010c0054 	qaddeq	r0, r4, ip
    31d4:	00001bc1 	andeq	r1, r0, r1, asr #23
    31d8:	01016501 	tsteq	r1, r1, lsl #10
    31dc:	080037a4 	stmdaeq	r0, {r2, r5, r7, r8, r9, sl, ip, sp}
    31e0:	080037fc 	stmdaeq	r0, {r2, r3, r4, r5, r6, r7, r8, r9, sl, ip, sp}
    31e4:	00001367 	andeq	r1, r0, r7, ror #6
    31e8:	000003a3 	andeq	r0, r0, r3, lsr #7
    31ec:	001b270d 	andseq	r2, fp, sp, lsl #14
    31f0:	01640100 	cmneq	r4, r0, lsl #2
    31f4:	0000006c 	andeq	r0, r0, ip, rrx
    31f8:	00001392 	muleq	r0, r2, r3
    31fc:	001b7b0e 	andseq	r7, fp, lr, lsl #22
    3200:	01660100 	cmneq	r6, r0, lsl #2
    3204:	0000007e 	andeq	r0, r0, lr, ror r0
    3208:	9c0f5601 	stcls	6, cr5, [pc], {1}
    320c:	0100001b 	tsteq	r0, fp, lsl r0
    3210:	007e0166 	rsbseq	r0, lr, r6, ror #2
    3214:	13b00000 	movsne	r0, #0	; 0x0
    3218:	ee0e0000 	cdp	0, 0, cr0, cr14, cr0, {0}
    321c:	0100001c 	tsteq	r0, ip, lsl r0
    3220:	006c0167 	rsbeq	r0, ip, r7, ror #2
    3224:	55010000 	strpl	r0, [r1]
    3228:	001c590e 	andseq	r5, ip, lr, lsl #18
    322c:	01670100 	cmneq	r7, r0, lsl #2
    3230:	0000006c 	andeq	r0, r0, ip, rrx
    3234:	0c005401 	cfstrseq	mvf5, [r0], {1}
    3238:	001cd101 	andseq	sp, ip, r1, lsl #2
    323c:	01590100 	cmpeq	r9, r0, lsl #2
    3240:	0037fc01 	eorseq	pc, r7, r1, lsl #24
    3244:	00386008 	eorseq	r6, r8, r8
    3248:	0013dc08 	andseq	sp, r3, r8, lsl #24
    324c:	0003de00 	andeq	sp, r3, r0, lsl #28
    3250:	1d050d00 	stcne	13, cr0, [r5]
    3254:	58010000 	stmdapl	r1, {}
    3258:	00007e01 	andeq	r7, r0, r1, lsl #28
    325c:	00140700 	andseq	r0, r4, r0, lsl #14
    3260:	1d000f00 	stcne	15, cr0, [r0]
    3264:	5a010000 	bpl	4326c <__Stack_Size+0x42e6c>
    3268:	00007e01 	andeq	r7, r0, r1, lsl #28
    326c:	00143000 	andseq	r3, r4, r0
    3270:	01100000 	tsteq	r0, r0
    3274:	00001bf2 	strdeq	r1, [r0], -r2
    3278:	3d012f01 	stccc	15, cr2, [r1, #-4]
    327c:	60000001 	andvs	r0, r0, r1
    3280:	7c080038 	stcvc	0, cr0, [r8], {56}
    3284:	4e080038 	mcrmi	0, 0, r0, cr8, cr8, {1}
    3288:	09000014 	stmdbeq	r0, {r2, r4}
    328c:	11000004 	tstne	r0, r4
    3290:	2f010063 	svccs	0x00010063
    3294:	00000409 	andeq	r0, r0, r9, lsl #8
    3298:	0000146d 	andeq	r1, r0, sp, ror #8
    329c:	08010300 	stmdaeq	r1, {r8, r9}
    32a0:	000004a5 	andeq	r0, r0, r5, lsr #9
    32a4:	1c4f0110 	stfnee	f0, [pc], {16}
    32a8:	d2010000 	andle	r0, r1, #0	; 0x0
    32ac:	00013d01 	andeq	r3, r1, r1, lsl #26
    32b0:	00387c00 	eorseq	r7, r8, r0, lsl #24
    32b4:	00388808 	eorseq	r8, r8, r8, lsl #16
    32b8:	00148b08 	andseq	r8, r4, r8, lsl #22
    32bc:	00043b00 	andeq	r3, r4, r0, lsl #22
    32c0:	00631100 	rsbeq	r1, r3, r0, lsl #2
    32c4:	0409d201 	streq	sp, [r9], #-513
    32c8:	14b60000 	ldrtne	r0, [r6]
    32cc:	10000000 	andne	r0, r0, r0
    32d0:	001c7b01 	andseq	r7, ip, r1, lsl #22
    32d4:	013b0100 	teqeq	fp, r0, lsl #2
    32d8:	0000013d 	andeq	r0, r0, sp, lsr r1
    32dc:	08003888 	stmdaeq	r0, {r3, r7, fp, ip, sp}
    32e0:	080038a4 	stmdaeq	r0, {r2, r5, r7, fp, ip, sp}
    32e4:	000014c9 	andeq	r1, r0, r9, asr #9
    32e8:	00000473 	andeq	r0, r0, r3, ror r4
    32ec:	72747311 	rsbsvc	r7, r4, #1140850688	; 0x44000000
    32f0:	733b0100 	teqvc	fp, #0	; 0x0
    32f4:	f4000004 	vst4.8	{d0-d3}, [r0], r4
    32f8:	12000014 	andne	r0, r0, #20	; 0x14
    32fc:	3c01006e 	stccc	0, cr0, [r1], {110}
    3300:	0000013d 	andeq	r0, r0, sp, lsr r1
    3304:	13005401 	movwne	r5, #1025	; 0x401
    3308:	00047904 	andeq	r7, r4, r4, lsl #18
    330c:	04091400 	streq	r1, [r9], #-1024
    3310:	010c0000 	tsteq	ip, r0
    3314:	00001cb7 	strheq	r1, [r0], -r7
    3318:	01014501 	tsteq	r1, r1, lsl #10
    331c:	080038a4 	stmdaeq	r0, {r2, r5, r7, fp, ip, sp}
    3320:	080038ee 	stmdaeq	r0, {r1, r2, r3, r5, r6, r7, fp, ip, sp}
    3324:	00001512 	andeq	r1, r0, r2, lsl r5
    3328:	000004b8 	strheq	r0, [r0], -r8
    332c:	001c950d 	andseq	r9, ip, sp, lsl #10
    3330:	01450100 	cmpeq	r5, r0, lsl #2
    3334:	0000007e 	andeq	r0, r0, lr, ror r0
    3338:	0000153d 	andeq	r1, r0, sp, lsr r5
    333c:	74756f15 	ldrbtvc	r6, [r5], #-3861
    3340:	01460100 	cmpeq	r6, r0, lsl #2
    3344:	000004b8 	strheq	r0, [r0], -r8
    3348:	00739102 	rsbseq	r9, r3, r2, lsl #2
    334c:	00040916 	andeq	r0, r4, r6, lsl r9
    3350:	0004c800 	andeq	ip, r4, r0, lsl #16
    3354:	009a1700 	addseq	r1, sl, r0, lsl #14
    3358:	00040000 	andeq	r0, r4, r0
    335c:	1b1d010c 	blne	743794 <__Stack_Size+0x743394>
    3360:	2a010000 	bcs	43368 <__Stack_Size+0x42f68>
    3364:	38f00101 	ldmcc	r0!, {r0, r8}^
    3368:	39660800 	stmdbcc	r6!, {fp}^
    336c:	15500800 	ldrbne	r0, [r0, #-2048]
    3370:	05020000 	streq	r0, [r2]
    3374:	600d0000 	andvs	r0, sp, r0
    3378:	0100001c 	tsteq	r0, ip, lsl r0
    337c:	006c012a 	rsbeq	r0, ip, sl, lsr #2
    3380:	157b0000 	ldrbne	r0, [fp]!
    3384:	6f150000 	svcvs	0x00150000
    3388:	01007475 	tsteq	r0, r5, ror r4
    338c:	0502012b 	streq	r0, [r2, #-299]
    3390:	91020000 	tstls	r2, r0
    3394:	09160071 	ldmdbeq	r6, {r0, r4, r5, r6}
    3398:	12000004 	andne	r0, r0, #4	; 0x4
    339c:	17000005 	strne	r0, [r0, -r5]
    33a0:	0000009a 	muleq	r0, sl, r0
    33a4:	010c0006 	tsteq	ip, r6
    33a8:	00001c0a 	andeq	r1, r0, sl, lsl #24
    33ac:	01010401 	tsteq	r1, r1, lsl #8
    33b0:	08003968 	stmdaeq	r0, {r3, r5, r6, r8, fp, ip, sp}
    33b4:	080039dc 	stmdaeq	r0, {r2, r3, r4, r6, r7, r8, fp, ip, sp}
    33b8:	0000158e 	andeq	r1, r0, lr, lsl #11
    33bc:	00000594 	muleq	r0, r4, r5
    33c0:	001c750d 	andseq	r7, ip, sp, lsl #10
    33c4:	01040100 	tsteq	r4, r0, lsl #2
    33c8:	00000025 	andeq	r0, r0, r5, lsr #32
    33cc:	000015b9 	strheq	r1, [r0], -r9
    33d0:	0019980f 	andseq	r9, r9, pc, lsl #16
    33d4:	01050100 	tsteq	r5, r0, lsl #2
    33d8:	0000005a 	andeq	r0, r0, sl, asr r0
    33dc:	000015cc 	andeq	r1, r0, ip, asr #11
    33e0:	001bbc0f 	andseq	fp, fp, pc, lsl #24
    33e4:	01050100 	tsteq	r5, r0, lsl #2
    33e8:	0000005a 	andeq	r0, r0, sl, asr r0
    33ec:	000015df 	ldrdeq	r1, [r0], -pc
    33f0:	76696418 	undefined
    33f4:	01050100 	tsteq	r5, r0, lsl #2
    33f8:	0000005a 	andeq	r0, r0, sl, asr r0
    33fc:	000015f2 	strdeq	r1, [r0], -r2
    3400:	74756f15 	ldrbtvc	r6, [r5], #-3861
    3404:	01060100 	tsteq	r6, r0, lsl #2
    3408:	00000594 	muleq	r0, r4, r5
    340c:	186c9102 	stmdane	ip!, {r1, r8, ip, pc}^
    3410:	07010069 	streq	r0, [r1, -r9, rrx]
    3414:	00007e01 	andeq	r7, r0, r1, lsl #28
    3418:	00161b00 	andseq	r1, r6, r0, lsl #22
    341c:	006a1900 	rsbeq	r1, sl, r0, lsl #18
    3420:	7e010701 	cdpvc	7, 0, cr0, cr1, cr1, {0}
    3424:	00000000 	andeq	r0, r0, r0
    3428:	00040916 	andeq	r0, r4, r6, lsl r9
    342c:	0005a400 	andeq	sl, r5, r0, lsl #8
    3430:	009a1700 	addseq	r1, sl, r0, lsl #14
    3434:	000b0000 	andeq	r0, fp, r0
    3438:	1cad011a 	stfnes	f0, [sp], #104
    343c:	e6010000 	str	r0, [r1], -r0
    3440:	0039dc01 	eorseq	sp, r9, r1, lsl #24
    3444:	003a4c08 	eorseq	r4, sl, r8, lsl #24
    3448:	00162e08 	andseq	r2, r6, r8, lsl #28
    344c:	00060b00 	andeq	r0, r6, r0, lsl #22
    3450:	1bbc1b00 	blne	fef0a058 <SCS_BASE+0x1eefc058>
    3454:	e6010000 	str	r0, [r1], -r0
    3458:	0000005a 	andeq	r0, r0, sl, asr r0
    345c:	00001659 	andeq	r1, r0, r9, asr r6
    3460:	0019981c 	andseq	r9, r9, ip, lsl r8
    3464:	5ae70100 	bpl	ff9c386c <SCS_BASE+0x1f9b586c>
    3468:	1d000000 	stcne	0, cr0, [r0]
    346c:	00766964 	rsbseq	r6, r6, r4, ror #18
    3470:	005ae701 	subseq	lr, sl, r1, lsl #14
    3474:	166c0000 	strbtne	r0, [ip], -r0
    3478:	6f120000 	svcvs	0x00120000
    347c:	01007475 	tsteq	r0, r5, ror r4
    3480:	00060be8 	andeq	r0, r6, r8, ror #23
    3484:	6d910200 	lfmvs	f0, 4, [r1]
    3488:	0100691d 	tsteq	r0, sp, lsl r9
    348c:	00007ee9 	andeq	r7, r0, r9, ror #29
    3490:	00169500 	andseq	r9, r6, r0, lsl #10
    3494:	006a1e00 	rsbeq	r1, sl, r0, lsl #28
    3498:	007ee901 	rsbseq	lr, lr, r1, lsl #18
    349c:	16000000 	strne	r0, [r0], -r0
    34a0:	00000409 	andeq	r0, r0, r9, lsl #8
    34a4:	0000061b 	andeq	r0, r0, fp, lsl r6
    34a8:	00009a17 	andeq	r9, r0, r7, lsl sl
    34ac:	10000a00 	andne	r0, r0, r0, lsl #20
    34b0:	001bfe01 	andseq	pc, fp, r1, lsl #28
    34b4:	01d70100 	bicseq	r0, r7, r0, lsl #2
    34b8:	0000013d 	andeq	r0, r0, sp, lsr r1
    34bc:	08003a4c 	stmdaeq	r0, {r2, r3, r6, r9, fp, ip, sp}
    34c0:	08003a58 	stmdaeq	r0, {r3, r4, r6, r9, fp, ip, sp}
    34c4:	000016a8 	andeq	r1, r0, r8, lsr #13
    34c8:	00000646 	andeq	r0, r0, r6, asr #12
    34cc:	01007311 	tsteq	r0, r1, lsl r3
    34d0:	000473d7 	ldrdeq	r7, [r4], -r7
    34d4:	0016d300 	andseq	sp, r6, r0, lsl #6
    34d8:	011a0000 	tsteq	sl, r0
    34dc:	00001c65 	andeq	r1, r0, r5, ror #24
    34e0:	58019b01 	stmdapl	r1, {r0, r8, r9, fp, ip, pc}
    34e4:	e008003a 	and	r0, r8, sl, lsr r0
    34e8:	e608003a 	undefined
    34ec:	6f000016 	svcvs	0x00000016
    34f0:	1b000006 	blne	3510 <__Stack_Size+0x3110>
    34f4:	00004445 	andeq	r4, r0, r5, asr #8
    34f8:	006c9b01 	rsbeq	r9, ip, r1, lsl #22
    34fc:	17050000 	strne	r0, [r5, -r0]
    3500:	1f000000 	svcne	0x00000000
    3504:	001ba501 	andseq	sl, fp, r1, lsl #10
    3508:	01ba0100 	undefined instruction 0x01ba0100
    350c:	08003ae0 	stmdaeq	r0, {r5, r6, r7, r9, fp, ip, sp}
    3510:	08003b74 	stmdaeq	r0, {r2, r4, r5, r6, r8, r9, fp, ip, sp}
    3514:	0000177b 	andeq	r1, r0, fp, ror r7
    3518:	1b720110 	blne	1c83960 <__Stack_Size+0x1c83560>
    351c:	7c010000 	stcvc	0, cr0, [r1], {0}
    3520:	0006c701 	andeq	ip, r6, r1, lsl #14
    3524:	003b7400 	eorseq	r7, fp, r0, lsl #8
    3528:	003bce08 	eorseq	ip, fp, r8, lsl #28
    352c:	0017a608 	andseq	sl, r7, r8, lsl #12
    3530:	0006c700 	andeq	ip, r6, r0, lsl #14
    3534:	74731100 	ldrbtvc	r1, [r3], #-256
    3538:	7c010072 	stcvc	0, cr0, [r1], {114}
    353c:	000006c7 	andeq	r0, r0, r7, asr #13
    3540:	000017c5 	andeq	r1, r0, r5, asr #15
    3544:	0100631e 	tsteq	r0, lr, lsl r3
    3548:	00007e7d 	andeq	r7, r0, sp, ror lr
    354c:	656c1200 	strbvs	r1, [ip, #-512]!
    3550:	7d01006e 	stcvc	0, cr0, [r1, #-440]
    3554:	0000007e 	andeq	r0, r0, lr, ror r0
    3558:	13005401 	movwne	r5, #1025	; 0x401
    355c:	00040904 	andeq	r0, r4, r4, lsl #18
    3560:	39011000 	stmdbcc	r1, {ip}
    3564:	0100001b 	tsteq	r0, fp, lsl r0
    3568:	06c701e1 	strbeq	r0, [r7], r1, ror #3
    356c:	3bd00000 	blcc	ff403574 <SCS_BASE+0x1f3f5574>
    3570:	3bdc0800 	blcc	ff705578 <SCS_BASE+0x1f6f7578>
    3574:	17e30800 	strbne	r0, [r3, r0, lsl #16]!
    3578:	06f80000 	ldrbteq	r0, [r8], r0
    357c:	73110000 	tstvc	r1, #0	; 0x0
    3580:	c7e10100 	strbgt	r0, [r1, r0, lsl #2]!
    3584:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}
    3588:	00000018 	andeq	r0, r0, r8, lsl r0
    358c:	1c9a0110 	ldfnes	f0, [sl], {16}
    3590:	44010000 	strmi	r0, [r1]
    3594:	00013d01 	andeq	r3, r1, r1, lsl #26
    3598:	003bdc00 	eorseq	sp, fp, r0, lsl #24
    359c:	003c0c08 	eorseq	r0, ip, r8, lsl #24
    35a0:	00182108 	andseq	r2, r8, r8, lsl #2
    35a4:	00072100 	andeq	r2, r7, r0, lsl #2
    35a8:	00631200 	rsbeq	r1, r3, r0, lsl #4
    35ac:	04094501 	streq	r4, [r9], #-1281
    35b0:	50010000 	andpl	r0, r1, r0
    35b4:	b4012000 	strlt	r2, [r1]
    35b8:	0100001b 	tsteq	r0, fp, lsl r0
    35bc:	013d01dc 	ldrsbeq	r0, [sp, -ip]!
    35c0:	3c0c0000 	stccc	0, cr0, [ip], {0}
    35c4:	3c180800 	ldccc	8, cr0, [r8], {0}
    35c8:	184c0800 	stmdane	ip, {fp}^
    35cc:	011f0000 	tsteq	pc, r0
    35d0:	00001b82 	andeq	r1, r0, r2, lsl #23
    35d4:	18012a01 	stmdane	r1, {r0, r9, fp, sp}
    35d8:	2408003c 	strcs	r0, [r8], #-60
    35dc:	7708003c 	smladxvc	r8, ip, r0, r0
    35e0:	10000018 	andne	r0, r0, r8, lsl r0
    35e4:	001b4301 	andseq	r4, fp, r1, lsl #6
    35e8:	01220100 	teqeq	r2, r0, lsl #2
    35ec:	0000007e 	andeq	r0, r0, lr, ror r0
    35f0:	08003c24 	stmdaeq	r0, {r2, r5, sl, fp, ip, sp}
    35f4:	08003c36 	stmdaeq	r0, {r1, r2, r4, r5, sl, fp, ip, sp}
    35f8:	000018a2 	andeq	r1, r0, r2, lsr #17
    35fc:	0000077c 	andeq	r0, r0, ip, ror r7
    3600:	001c261b 	andseq	r2, ip, fp, lsl r6
    3604:	5a220100 	bpl	883a0c <__Stack_Size+0x88360c>
    3608:	cd000000 	stcgt	0, cr0, [r0]
    360c:	00000018 	andeq	r0, r0, r8, lsl r0
    3610:	0005691c 	andeq	r6, r5, ip, lsl r9
    3614:	872a0400 	strhi	r0, [sl, -r0, lsl #8]!
    3618:	21000007 	tstcs	r0, r7
    361c:	0000007e 	andeq	r0, r0, lr, ror r0
    3620:	0002ce0b 	andeq	ip, r2, fp, lsl #28
    3624:	9d280400 	cfstrsls	mvf0, [r8]
    3628:	05000007 	streq	r0, [r0, #-7]
    362c:	0008e003 	andeq	lr, r8, r3
    3630:	006c2120 	rsbeq	r2, ip, r0, lsr #2
    3634:	2b0b0000 	blcs	2c363c <__Stack_Size+0x2c323c>
    3638:	04000004 	streq	r0, [r0], #-4
    363c:	00079d28 	andeq	r9, r7, r8, lsr #26
    3640:	e2030500 	and	r0, r3, #0	; 0x0
    3644:	16200008 	strtne	r0, [r0], -r8
    3648:	0000007e 	andeq	r0, r0, lr, ror r0
    364c:	000007c4 	andeq	r0, r0, r4, asr #15
    3650:	00009a22 	andeq	r9, r0, r2, lsr #20
    3654:	0003ff00 	andeq	pc, r3, r0, lsl #30
    3658:	0004af0b 	andeq	sl, r4, fp, lsl #30
    365c:	d5290400 	strle	r0, [r9, #-1024]!
    3660:	05000007 	streq	r0, [r0, #-7]
    3664:	0004e003 	andeq	lr, r4, r3
    3668:	07b32120 	ldreq	r2, [r3, r0, lsr #2]!
    366c:	4a230000 	bmi	8c3674 <__Stack_Size+0x8c3274>
    3670:	04000006 	streq	r0, [r0], #-6
    3674:	00078744 	andeq	r8, r7, r4, asr #14
    3678:	0e230000 	cdpeq	0, 2, cr0, cr3, cr0, {0}
    367c:	04000004 	streq	r0, [r0], #-4
    3680:	00078744 	andeq	r8, r7, r4, asr #14
    3684:	7e160000 	wxorvc	wr0, wr6, wr0
    3688:	02000000 	andeq	r0, r0, #0	; 0x0
    368c:	17000008 	strne	r0, [r0, -r8]
    3690:	0000009a 	muleq	r0, sl, r0
    3694:	ec1c0040 	ldc	0, cr0, [ip], {64}
    3698:	04000000 	streq	r0, [r0]
    369c:	00080d45 	andeq	r0, r8, r5, asr #26
    36a0:	07f22100 	ldrbeq	r2, [r2, r0, lsl #2]!
    36a4:	19230000 	stmdbne	r3!, {}
    36a8:	04000006 	streq	r0, [r0], #-6
    36ac:	00079d58 	andeq	r9, r7, r8, asr sp
    36b0:	f9230000 	undefined instruction 0xf9230000
    36b4:	04000000 	streq	r0, [r0]
    36b8:	00079d58 	andeq	r9, r7, r8, asr sp
    36bc:	2d1c0000 	ldccs	0, cr0, [ip]
    36c0:	04000003 	streq	r0, [r0], #-3
    36c4:	00083559 	andeq	r3, r8, r9, asr r5
    36c8:	07b32100 	ldreq	r2, [r3, r0, lsl #2]!
    36cc:	1b000000 	blne	36d4 <__Stack_Size+0x32d4>
    36d0:	0200000a 	andeq	r0, r0, #10	; 0xa
    36d4:	000b1c00 	andeq	r1, fp, r0, lsl #24
    36d8:	fe010400 	cdp2	4, 0, cr0, cr1, cr0, {0}
    36dc:	01000001 	tsteq	r0, r1
    36e0:	00001f2d 	andeq	r1, r0, sp, lsr #30
    36e4:	00000249 	andeq	r0, r0, r9, asr #4
    36e8:	08003c38 	stmdaeq	r0, {r3, r4, r5, sl, fp, ip, sp}
    36ec:	08004248 	stmdaeq	r0, {r3, r6, r9, lr}
    36f0:	00000de9 	andeq	r0, r0, r9, ror #27
    36f4:	22050402 	andcs	r0, r5, #33554432	; 0x2000000
    36f8:	02000001 	andeq	r0, r0, #1	; 0x1
    36fc:	04ca0502 	strbeq	r0, [sl], #1282
    3700:	01020000 	tsteq	r2, r0
    3704:	00049e06 	andeq	r9, r4, r6, lsl #28
    3708:	33750300 	cmncc	r5, #0	; 0x0
    370c:	27020032 	smladxcs	r2, r2, r0, r0
    3710:	00000045 	andeq	r0, r0, r5, asr #32
    3714:	30070402 	andcc	r0, r7, r2, lsl #8
    3718:	03000001 	movweq	r0, #1	; 0x1
    371c:	00363175 	eorseq	r3, r6, r5, ror r1
    3720:	00572802 	subseq	r2, r7, r2, lsl #16
    3724:	02020000 	andeq	r0, r2, #0	; 0x0
    3728:	0001c507 	andeq	ip, r1, r7, lsl #10
    372c:	38750300 	ldmdacc	r5!, {r8, r9}^
    3730:	68290200 	stmdavs	r9!, {r9}
    3734:	02000000 	andeq	r0, r0, #0	; 0x0
    3738:	049c0801 	ldreq	r0, [ip], #2049
    373c:	04040000 	streq	r0, [r4]
    3740:	03010507 	movweq	r0, #5383	; 0x1507
    3744:	0000993f 	andeq	r9, r0, pc, lsr r9
    3748:	1e230600 	cfmadda32ne	mvax0, mvax0, mvfx3, mvfx0
    374c:	06020000 	streq	r0, [r2], -r0
    3750:	00001d36 	andeq	r1, r0, r6, lsr sp
    3754:	1da50603 	stcne	6, cr0, [r5, #12]!
    3758:	06040000 	streq	r0, [r4], -r0
    375c:	00001efe 	strdeq	r1, [r0], -lr
    3760:	1dea0604 	stclne	6, cr0, [sl, #16]!
    3764:	00050000 	andeq	r0, r5, r0
    3768:	54030105 	strpl	r0, [r3], #-261
    376c:	00000130 	andeq	r0, r0, r0, lsr r1
    3770:	000fa006 	andeq	sl, pc, r6
    3774:	d6060100 	strle	r0, [r6], -r0, lsl #2
    3778:	02000011 	andeq	r0, r0, #17	; 0x11
    377c:	00147506 	andseq	r7, r4, r6, lsl #10
    3780:	f8060300 	undefined instruction 0xf8060300
    3784:	0400000e 	streq	r0, [r0], #-14
    3788:	000e8006 	andeq	r8, lr, r6
    378c:	f2060500 	vrshl.s8	d0, d0, d6
    3790:	06000010 	undefined
    3794:	000ee506 	andeq	lr, lr, r6, lsl #10
    3798:	2a060700 	bcs	1853a0 <__Stack_Size+0x184fa0>
    379c:	0c000017 	stceq	0, cr0, [r0], {23}
    37a0:	00178606 	andseq	r8, r7, r6, lsl #12
    37a4:	24060d00 	strcs	r0, [r6], #-3328
    37a8:	0e000016 	mcreq	0, 0, r0, cr0, cr6, {0}
    37ac:	000d8c06 	andeq	r8, sp, r6, lsl #24
    37b0:	b2060f00 	andlt	r0, r6, #0	; 0x0
    37b4:	10000014 	andne	r0, r0, r4, lsl r0
    37b8:	00118d06 	andseq	r8, r1, r6, lsl #26
    37bc:	4b061100 	blmi	187bc4 <__Stack_Size+0x1877c4>
    37c0:	12000015 	andne	r0, r0, #21	; 0x15
    37c4:	00174a06 	andseq	r4, r7, r6, lsl #20
    37c8:	97061300 	strls	r1, [r6, -r0, lsl #6]
    37cc:	14000012 	strne	r0, [r0], #-18
    37d0:	00111c06 	andseq	r1, r1, r6, lsl #24
    37d4:	83061500 	movwhi	r1, #25856	; 0x6500
    37d8:	1600000c 	strne	r0, [r0], -ip
    37dc:	000dcb06 	andeq	ip, sp, r6, lsl #22
    37e0:	78061700 	stmdavc	r6, {r8, r9, sl, ip}
    37e4:	83000016 	movwhi	r0, #22	; 0x16
    37e8:	112a0601 	teqne	sl, r1, lsl #12
    37ec:	01840000 	orreq	r0, r4, r0
    37f0:	0016f006 	andseq	pc, r6, r6
    37f4:	06019200 	streq	r9, [r1], -r0, lsl #4
    37f8:	000011ed 	andeq	r1, r0, sp, ror #3
    37fc:	050001d0 	streq	r0, [r0, #-464]
    3800:	8ecf0302 	cdphi	3, 12, cr0, cr15, cr2, {0}
    3804:	06000001 	streq	r0, [r0], -r1
    3808:	000006b5 	strheq	r0, [r0], -r5
    380c:	04bc0601 	ldrteq	r0, [ip], #1537
    3810:	06020000 	streq	r0, [r2], -r0
    3814:	0000038b 	andeq	r0, r0, fp, lsl #7
    3818:	06c30604 	strbeq	r0, [r3], r4, lsl #12
    381c:	06080000 	streq	r0, [r8], -r0
    3820:	00000500 	andeq	r0, r0, r0, lsl #10
    3824:	01690610 	cmneq	r9, r0, lsl r6
    3828:	06200000 	strteq	r0, [r0], -r0
    382c:	000005c1 	andeq	r0, r0, r1, asr #11
    3830:	3b0600c0 	blcc	183b38 <__Stack_Size+0x183738>
    3834:	80000002 	andhi	r0, r0, r2
    3838:	06f60601 	ldrbteq	r0, [r6], r1, lsl #12
    383c:	02800000 	addeq	r0, r0, #0	; 0x0
    3840:	00048e06 	andeq	r8, r4, r6, lsl #28
    3844:	06048000 	streq	r8, [r4], -r0
    3848:	00000026 	andeq	r0, r0, r6, lsr #32
    384c:	20060880 	andcs	r0, r6, r0, lsl #17
    3850:	80000003 	andhi	r0, r0, r3
    3854:	015a0610 	cmpeq	sl, r0, lsl r6
    3858:	20800000 	addcs	r0, r0, r0
    385c:	1ddc0700 	ldclne	7, cr0, [ip]
    3860:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
    3864:	00000068 	andeq	r0, r0, r8, rrx
    3868:	001ed707 	andseq	sp, lr, r7, lsl #14
    386c:	573a0400 	ldrpl	r0, [sl, -r0, lsl #8]!
    3870:	02000000 	andeq	r0, r0, #0	; 0x0
    3874:	011d0508 	tsteq	sp, r8, lsl #10
    3878:	08020000 	stmdaeq	r2, {}
    387c:	00012b07 	andeq	r2, r1, r7, lsl #22
    3880:	05040800 	streq	r0, [r4, #-2048]
    3884:	00746e69 	rsbseq	r6, r4, r9, ror #28
    3888:	35070402 	strcc	r0, [r7, #-1026]
    388c:	07000001 	streq	r0, [r0, -r1]
    3890:	00001de4 	andeq	r1, r0, r4, ror #27
    3894:	018e0f05 	orreq	r0, lr, r5, lsl #30
    3898:	d5070000 	strle	r0, [r7]
    389c:	0500001d 	streq	r0, [r0, #-29]
    38a0:	00019911 	andeq	r9, r1, r1, lsl r9
    38a4:	5f010900 	svcpl	0x00010900
    38a8:	0100001f 	tsteq	r0, pc, lsl r0
    38ac:	01010193 	strbeq	r0, [r1, -r3]
    38b0:	000001fc 	strdeq	r0, [r0], -ip
    38b4:	0100690a 	tsteq	r0, sl, lsl #18
    38b8:	005e0194 	ldrbeq	r0, [lr], #-20
    38bc:	6d0a0000 	stcvs	0, cr0, [sl]
    38c0:	01007861 	tsteq	r0, r1, ror #16
    38c4:	005e0194 	ldrbeq	r0, [lr], #-20
    38c8:	0b000000 	bleq	38d0 <__Stack_Size+0x34d0>
    38cc:	001dc101 	andseq	ip, sp, r1, lsl #2
    38d0:	01ea0100 	mvneq	r0, r0, lsl #2
    38d4:	00021501 	andeq	r1, r2, r1, lsl #10
    38d8:	64690c00 	strbtvs	r0, [r9], #-3072
    38dc:	5eea0100 	cdppl	1, 14, cr0, cr10, cr0, {0}
    38e0:	00000000 	andeq	r0, r0, r0
    38e4:	1e44010b 	dvfnes	f0, f4, #3.0
    38e8:	ef010000 	svc	0x00010000
    38ec:	022f0101 	eoreq	r0, pc, #1073741824	; 0x40000000
    38f0:	550d0000 	strpl	r0, [sp]
    38f4:	0100001e 	tsteq	r0, lr, lsl r0
    38f8:	00005eef 	andeq	r5, r0, pc, ror #29
    38fc:	010b0000 	tsteq	fp, r0
    3900:	00001d1b 	andeq	r1, r0, fp, lsl sp
    3904:	0101f401 	tstpeq	r1, r1, lsl #8
    3908:	00000254 	andeq	r0, r0, r4, asr r2
    390c:	001a8a0d 	andseq	r8, sl, sp, lsl #20
    3910:	5ef40100 	cdppl	1, 15, cr0, cr4, cr0, {0}
    3914:	0d000000 	stceq	0, cr0, [r0]
    3918:	00004da2 	andeq	r4, r0, r2, lsr #27
    391c:	005ef401 	subseq	pc, lr, r1, lsl #8
    3920:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    3924:	001eee01 	andseq	lr, lr, r1, lsl #28
    3928:	01230100 	teqeq	r3, r0, lsl #2
    392c:	00005e01 	andeq	r5, r0, r1, lsl #28
    3930:	02800100 	addeq	r0, r0, #0	; 0x0
    3934:	4b0f0000 	blmi	3c393c <__Stack_Size+0x3c353c>
    3938:	0100001d 	tsteq	r0, sp, lsl r0
    393c:	004c0123 	subeq	r0, ip, r3, lsr #2
    3940:	98100000 	ldmdals	r0, {}
    3944:	01000019 	tsteq	r0, r9, lsl r0
    3948:	004c0124 	subeq	r0, ip, r4, lsr #2
    394c:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    3950:	001ec601 	andseq	ip, lr, r1, lsl #12
    3954:	01290100 	teqeq	r9, r0, lsl #2
    3958:	00005e01 	andeq	r5, r0, r1, lsl #28
    395c:	02ac0100 	adceq	r0, ip, #0	; 0x0
    3960:	4b0f0000 	blmi	3c3968 <__Stack_Size+0x3c3568>
    3964:	0100001d 	tsteq	r0, sp, lsl r0
    3968:	004c0129 	subeq	r0, ip, r9, lsr #2
    396c:	98100000 	ldmdals	r0, {}
    3970:	01000019 	tsteq	r0, r9, lsl r0
    3974:	004c012a 	subeq	r0, ip, sl, lsr #2
    3978:	0b000000 	bleq	3980 <__Stack_Size+0x3580>
    397c:	001e7201 	andseq	r7, lr, r1, lsl #4
    3980:	01f90100 	mvnseq	r0, r0, lsl #2
    3984:	0002c601 	andeq	ip, r2, r1, lsl #12
    3988:	1d9e0d00 	ldcne	13, cr0, [lr]
    398c:	f9010000 	undefined instruction 0xf9010000
    3990:	0000005e 	andeq	r0, r0, lr, asr r0
    3994:	b9010e00 	stmdblt	r1, {r9, sl, fp}
    3998:	0100001e 	tsteq	r0, lr, lsl r0
    399c:	4c010119 	stfmis	f0, [r1], {25}
    39a0:	01000000 	tsteq	r0, r0
    39a4:	000002fe 	strdeq	r0, [r0], -lr
    39a8:	001ef60f 	andseq	pc, lr, pc, lsl #12
    39ac:	01190100 	tsteq	r9, r0, lsl #2
    39b0:	0000005e 	andeq	r0, r0, lr, asr r0
    39b4:	001ece0f 	andseq	ip, lr, pc, lsl #28
    39b8:	01190100 	tsteq	r9, r0, lsl #2
    39bc:	0000005e 	andeq	r0, r0, lr, asr r0
    39c0:	001d4b10 	andseq	r4, sp, r0, lsl fp
    39c4:	011a0100 	tsteq	sl, r0, lsl #2
    39c8:	0000004c 	andeq	r0, r0, ip, asr #32
    39cc:	b2011100 	andlt	r1, r1, #0	; 0x0
    39d0:	0100001d 	tsteq	r0, sp, lsl r0
    39d4:	004c01e5 	subeq	r0, ip, r5, ror #3
    39d8:	3c380000 	ldccc	0, cr0, [r8]
    39dc:	3c440800 	mcrrcc	8, 0, r0, r4, cr0
    39e0:	5d010800 	stcpl	8, cr0, [r1]
    39e4:	0001fc12 	andeq	pc, r1, r2, lsl ip
    39e8:	003c4400 	eorseq	r4, ip, r0, lsl #8
    39ec:	003c5008 	eorseq	r5, ip, r8
    39f0:	305d0108 	subscc	r0, sp, r8, lsl #2
    39f4:	13000003 	movwne	r0, #3	; 0x3
    39f8:	0000020a 	andeq	r0, r0, sl, lsl #4
    39fc:	12005001 	andne	r5, r0, #1	; 0x1
    3a00:	00000215 	andeq	r0, r0, r5, lsl r2
    3a04:	08003c50 	stmdaeq	r0, {r4, r6, sl, fp, ip, sp}
    3a08:	08003c5c 	stmdaeq	r0, {r2, r3, r4, r6, sl, fp, ip, sp}
    3a0c:	034b5d01 	movteq	r5, #48385	; 0xbd01
    3a10:	23130000 	tstcs	r3, #0	; 0x0
    3a14:	01000002 	tsteq	r0, r2
    3a18:	2f120050 	svccs	0x00120050
    3a1c:	5c000002 	stcpl	0, cr0, [r0], {2}
    3a20:	6808003c 	stmdavs	r8, {r2, r3, r4, r5}
    3a24:	0108003c 	tsteq	r8, ip, lsr r0
    3a28:	00036d5d 	andeq	r6, r3, sp, asr sp
    3a2c:	023d1300 	eorseq	r1, sp, #0	; 0x0
    3a30:	50010000 	andpl	r0, r1, r0
    3a34:	00024813 	andeq	r4, r2, r3, lsl r8
    3a38:	00510100 	subseq	r0, r1, r0, lsl #2
    3a3c:	0002ac12 	andeq	sl, r2, r2, lsl ip
    3a40:	003c6800 	eorseq	r6, ip, r0, lsl #16
    3a44:	003c7408 	eorseq	r7, ip, r8, lsl #8
    3a48:	885d0108 	ldmdahi	sp, {r3, r8}^
    3a4c:	13000003 	movwne	r0, #3	; 0x3
    3a50:	000002ba 	strheq	r0, [r0], -sl
    3a54:	14005001 	strne	r5, [r0], #-1
    3a58:	001df701 	andseq	pc, sp, r1, lsl #14
    3a5c:	01fe0100 	mvnseq	r0, r0, lsl #2
    3a60:	0000005e 	andeq	r0, r0, lr, asr r0
    3a64:	08003c74 	stmdaeq	r0, {r2, r4, r5, r6, sl, fp, ip, sp}
    3a68:	08003c98 	stmdaeq	r0, {r3, r4, r7, sl, fp, ip, sp}
    3a6c:	03b35d01 	undefined instruction 0x03b35d01
    3a70:	0e150000 	wxoreq	wr0, wr5, wr0
    3a74:	0100001e 	tsteq	r0, lr, lsl r0
    3a78:	00005efe 	strdeq	r5, [r0], -lr
    3a7c:	0018e000 	andseq	lr, r8, r0
    3a80:	01160000 	tsteq	r6, r0
    3a84:	00001d8d 	andeq	r1, r0, sp, lsl #27
    3a88:	01010901 	tsteq	r1, r1, lsl #18
    3a8c:	0000005e 	andeq	r0, r0, lr, asr r0
    3a90:	08003c98 	stmdaeq	r0, {r3, r4, r7, sl, fp, ip, sp}
    3a94:	08003cb4 	stmdaeq	r0, {r2, r4, r5, r7, sl, fp, ip, sp}
    3a98:	01175d01 	tsteq	r7, r1, lsl #26
    3a9c:	00001e9e 	muleq	r0, lr, lr
    3aa0:	01011101 	tsteq	r1, r1, lsl #2
    3aa4:	0000005e 	andeq	r0, r0, lr, asr r0
    3aa8:	08003cb4 	stmdaeq	r0, {r2, r4, r5, r7, sl, fp, ip, sp}
    3aac:	08003cd4 	stmdaeq	r0, {r2, r4, r6, r7, sl, fp, ip, sp}
    3ab0:	03f85d01 	mvnseq	r5, #64	; 0x40
    3ab4:	8a180000 	bhi	603abc <__Stack_Size+0x6036bc>
    3ab8:	0100001a 	tsteq	r0, sl, lsl r0
    3abc:	005e0111 	subseq	r0, lr, r1, lsl r1
    3ac0:	18fe0000 	ldmne	lr!, {}^
    3ac4:	12000000 	andne	r0, r0, #0	; 0x0
    3ac8:	000002c6 	andeq	r0, r0, r6, asr #5
    3acc:	08003cd4 	stmdaeq	r0, {r2, r4, r6, r7, sl, fp, ip, sp}
    3ad0:	08003cdc 	stmdaeq	r0, {r2, r3, r4, r6, r7, sl, fp, ip, sp}
    3ad4:	04215d01 	strteq	r5, [r1], #-3329
    3ad8:	d9190000 	ldmdble	r9, {}
    3adc:	1c000002 	stcne	0, cr0, [r0], {2}
    3ae0:	13000019 	movwne	r0, #25	; 0x19
    3ae4:	000002e5 	andeq	r0, r0, r5, ror #5
    3ae8:	f11a5101 	undefined instruction 0xf11a5101
    3aec:	00000002 	andeq	r0, r0, r2
    3af0:	00025412 	andeq	r5, r2, r2, lsl r4
    3af4:	003cdc00 	eorseq	sp, ip, r0, lsl #24
    3af8:	003ce008 	eorseq	lr, ip, r8
    3afc:	435d0108 	cmpmi	sp, #2	; 0x2
    3b00:	19000004 	stmdbne	r0, {r2}
    3b04:	00000267 	andeq	r0, r0, r7, ror #4
    3b08:	0000192f 	andeq	r1, r0, pc, lsr #18
    3b0c:	0002731a 	andeq	r7, r2, sl, lsl r3
    3b10:	80120000 	andshi	r0, r2, r0
    3b14:	e0000002 	and	r0, r0, r2
    3b18:	e408003c 	str	r0, [r8], #-60
    3b1c:	0108003c 	tsteq	r8, ip, lsr r0
    3b20:	0004655d 	andeq	r6, r4, sp, asr r5
    3b24:	02931900 	addseq	r1, r3, #0	; 0x0
    3b28:	19420000 	stmdbne	r2, {}^
    3b2c:	9f1a0000 	svcls	0x001a0000
    3b30:	00000002 	andeq	r0, r0, r2
    3b34:	0001d612 	andeq	sp, r1, r2, lsl r6
    3b38:	003ce400 	eorseq	lr, ip, r0, lsl #8
    3b3c:	003d1c08 	eorseq	r1, sp, r8, lsl #24
    3b40:	8b5d0108 	blhi	1743f68 <__Stack_Size+0x1743b68>
    3b44:	1b000004 	blne	3b5c <__Stack_Size+0x375c>
    3b48:	000001e5 	andeq	r0, r0, r5, ror #3
    3b4c:	00001955 	andeq	r1, r0, r5, asr r9
    3b50:	0001ef1b 	andeq	lr, r1, fp, lsl pc
    3b54:	00197e00 	andseq	r7, r9, r0, lsl #28
    3b58:	011c0000 	tsteq	ip, r0
    3b5c:	00001ee0 	andeq	r1, r0, r0, ror #29
    3b60:	1c016d01 	stcne	13, cr6, [r1], {1}
    3b64:	a008003d 	andge	r0, r8, sp, lsr r0
    3b68:	9c08003e 	stcls	0, cr0, [r8], {62}
    3b6c:	d9000019 	stmdble	r0, {r0, r3, r4}
    3b70:	1d000004 	stcne	0, cr0, [r0, #-16]
    3b74:	6e010069 	cdpvs	0, 0, cr0, cr1, cr9, {3}
    3b78:	0000005e 	andeq	r0, r0, lr, asr r0
    3b7c:	000019c7 	andeq	r1, r0, r7, asr #19
    3b80:	01006a1d 	tsteq	r0, sp, lsl sl
    3b84:	00005e6e 	andeq	r5, r0, lr, ror #28
    3b88:	001a1100 	andseq	r1, sl, r0, lsl #2
    3b8c:	1e981e00 	cdpne	14, 9, cr1, cr8, cr0, {0}
    3b90:	6e010000 	cdpvs	0, 0, cr0, cr1, cr0, {0}
    3b94:	0000005e 	andeq	r0, r0, lr, asr r0
    3b98:	0014851f 	andseq	r8, r4, pc, lsl r5
    3b9c:	5e6f0100 	powple	f0, f7, f0
    3ba0:	3a000000 	bcc	3ba8 <__Stack_Size+0x37a8>
    3ba4:	0000001a 	andeq	r0, r0, sl, lsl r0
    3ba8:	1d64011c 	stfnee	f0, [r4, #-112]!
    3bac:	30010000 	andcc	r0, r1, r0
    3bb0:	003ea001 	eorseq	sl, lr, r1
    3bb4:	003f9c08 	eorseq	r9, pc, r8, lsl #24
    3bb8:	001a5808 	andseq	r5, sl, r8, lsl #16
    3bbc:	00052700 	andeq	r2, r5, r0, lsl #14
    3bc0:	00691d00 	rsbeq	r1, r9, r0, lsl #26
    3bc4:	005e3101 	subseq	r3, lr, r1, lsl #2
    3bc8:	1a830000 	bne	fe0c3bd0 <SCS_BASE+0x1e0b5bd0>
    3bcc:	8e200000 	cdphi	0, 2, cr0, cr0, cr0, {0}
    3bd0:	0100001e 	tsteq	r0, lr, lsl r0
    3bd4:	00005e32 	andeq	r5, r0, r2, lsr lr
    3bd8:	1e540100 	rdfnes	f0, f4, f0
    3bdc:	00001e8a 	andeq	r1, r0, sl, lsl #29
    3be0:	005e3201 	subseq	r3, lr, r1, lsl #4
    3be4:	851f0000 	ldrhi	r0, [pc, #0]	; 3bec <__Stack_Size+0x37ec>
    3be8:	01000014 	tsteq	r0, r4, lsl r0
    3bec:	00005e33 	andeq	r5, r0, r3, lsr lr
    3bf0:	001aa100 	andseq	sl, sl, r0, lsl #2
    3bf4:	011c0000 	tsteq	ip, r0
    3bf8:	00001f1d 	andeq	r1, r0, sp, lsl pc
    3bfc:	9c01c801 	stcls	8, cr12, [r1], {1}
    3c00:	fc08003f 	stc2	0, cr0, [r8], {63}
    3c04:	bf08003f 	svclt	0x0008003f
    3c08:	6d00001a 	stcvs	0, cr0, [r0, #-104]
    3c0c:	21000005 	tstcs	r0, r5
    3c10:	000001d6 	ldrdeq	r0, [r0], -r6
    3c14:	08003fac 	stmdaeq	r0, {r2, r3, r5, r7, r8, r9, sl, fp, ip, sp}
    3c18:	08003fdc 	stmdaeq	r0, {r2, r3, r4, r6, r7, r8, r9, sl, fp, ip, sp}
    3c1c:	ac22d601 	stcge	6, cr13, [r2], #-4
    3c20:	dc08003f 	stcle	0, cr0, [r8], {63}
    3c24:	1b08003f 	blne	203d28 <__Stack_Size+0x203928>
    3c28:	000001e5 	andeq	r0, r0, r5, ror #3
    3c2c:	00001ade 	ldrdeq	r1, [r0], -lr
    3c30:	0001ef1b 	andeq	lr, r1, fp, lsl pc
    3c34:	001b0700 	andseq	r0, fp, r0, lsl #14
    3c38:	00000000 	andeq	r0, r0, r0
    3c3c:	1f0a0123 	svcne	0x000a0123
    3c40:	ac010000 	stcge	0, cr0, [r1], {0}
    3c44:	3ffc0101 	svccc	0x00fc0101
    3c48:	40a40800 	adcmi	r0, r4, r0, lsl #16
    3c4c:	1b250800 	blne	945c54 <__Stack_Size+0x945854>
    3c50:	06f50000 	ldrbteq	r0, [r5], r0
    3c54:	72180000 	andsvc	r0, r8, #0	; 0x0
    3c58:	0100001d 	tsteq	r0, sp, lsl r0
    3c5c:	01b201ab 	undefined instruction 0x01b201ab
    3c60:	1b500000 	blne	1403c68 <__Stack_Size+0x1403868>
    3c64:	69240000 	stmdbvs	r4!, {}
    3c68:	01007364 	tsteq	r0, r4, ror #6
    3c6c:	06f501ab 	ldrbteq	r0, [r5], fp, lsr #3
    3c70:	1b6e0000 	blne	1b83c78 <__Stack_Size+0x1b83878>
    3c74:	12180000 	andsne	r0, r8, #0	; 0x0
    3c78:	01000029 	tsteq	r0, r9, lsr #32
    3c7c:	070001ab 	streq	r0, [r0, -fp, lsr #3]
    3c80:	1b8c0000 	blne	fe303c88 <SCS_BASE+0x1e2f5c88>
    3c84:	0a180000 	beq	603c8c <__Stack_Size+0x60388c>
    3c88:	01000027 	tsteq	r0, r7, lsr #32
    3c8c:	070001ab 	streq	r0, [r0, -fp, lsr #3]
    3c90:	1baa0000 	blne	fea83c98 <SCS_BASE+0x1ea75c98>
    3c94:	69250000 	stmdbvs	r5!, {}
    3c98:	01ad0100 	undefined instruction 0x01ad0100
    3c9c:	000001b2 	strheq	r0, [r0], -r2
    3ca0:	00001bc8 	andeq	r1, r0, r8, asr #23
    3ca4:	0001fc26 	andeq	pc, r1, r6, lsr #24
    3ca8:	00401200 	subeq	r1, r0, r0, lsl #4
    3cac:	00401808 	subeq	r1, r0, r8, lsl #16
    3cb0:	01ba0108 	undefined instruction 0x01ba0108
    3cb4:	000005ef 	andeq	r0, r0, pc, ror #11
    3cb8:	00032827 	andeq	r2, r3, r7, lsr #16
    3cbc:	15260000 	strne	r0, [r6]!
    3cc0:	18000002 	stmdane	r0, {r1}
    3cc4:	1c080040 	stcne	0, cr0, [r8], {64}
    3cc8:	01080040 	tsteq	r8, r0, asr #32
    3ccc:	060901bc 	undefined
    3cd0:	43270000 	teqmi	r7, #0	; 0x0
    3cd4:	00000003 	andeq	r0, r0, r3
    3cd8:	00022f26 	andeq	r2, r2, r6, lsr #30
    3cdc:	00401c00 	subeq	r1, r0, r0, lsl #24
    3ce0:	00402008 	subeq	r2, r0, r8
    3ce4:	01be0108 	undefined instruction 0x01be0108
    3ce8:	00000628 	andeq	r0, r0, r8, lsr #12
    3cec:	00036527 	andeq	r6, r3, r7, lsr #10
    3cf0:	035e2700 	cmpeq	lr, #0	; 0x0
    3cf4:	26000000 	strcs	r0, [r0], -r0
    3cf8:	0000022f 	andeq	r0, r0, pc, lsr #4
    3cfc:	08004020 	stmdaeq	r0, {r5, lr}
    3d00:	08004032 	stmdaeq	r0, {r1, r4, r5, lr}
    3d04:	4701c001 	strmi	ip, [r1, -r1]
    3d08:	27000006 	strcs	r0, [r0, -r6]
    3d0c:	00000365 	andeq	r0, r0, r5, ror #6
    3d10:	00035e27 	andeq	r5, r3, r7, lsr #28
    3d14:	2f260000 	svccs	0x00260000
    3d18:	32000002 	andcc	r0, r0, #2	; 0x2
    3d1c:	3e080040 	cdpcc	0, 0, cr0, cr8, cr0, {2}
    3d20:	01080040 	tsteq	r8, r0, asr #32
    3d24:	066601c5 	strbteq	r0, [r6], -r5, asr #3
    3d28:	65270000 	strvs	r0, [r7]!
    3d2c:	27000003 	strcs	r0, [r0, -r3]
    3d30:	0000035e 	andeq	r0, r0, lr, asr r3
    3d34:	022f2600 	eoreq	r2, pc, #0	; 0x0
    3d38:	403e0000 	eorsmi	r0, lr, r0
    3d3c:	404c0800 	submi	r0, ip, r0, lsl #16
    3d40:	c6010800 	strgt	r0, [r1], -r0, lsl #16
    3d44:	00068501 	andeq	r8, r6, r1, lsl #10
    3d48:	03652700 	cmneq	r5, #0	; 0x0
    3d4c:	5e270000 	cdppl	0, 2, cr0, cr7, cr0, {0}
    3d50:	00000003 	andeq	r0, r0, r3
    3d54:	00022f26 	andeq	r2, r2, r6, lsr #30
    3d58:	00404c00 	subeq	r4, r0, r0, lsl #24
    3d5c:	00405c08 	subeq	r5, r0, r8, lsl #24
    3d60:	01c70108 	biceq	r0, r7, r8, lsl #2
    3d64:	000006a4 	andeq	r0, r0, r4, lsr #13
    3d68:	00036527 	andeq	r6, r3, r7, lsr #10
    3d6c:	035e2700 	cmpeq	lr, #0	; 0x0
    3d70:	26000000 	strcs	r0, [r0], -r0
    3d74:	0000022f 	andeq	r0, r0, pc, lsr #4
    3d78:	0800405c 	stmdaeq	r0, {r2, r3, r4, r6, lr}
    3d7c:	08004066 	stmdaeq	r0, {r1, r2, r5, r6, lr}
    3d80:	c301c801 	movwgt	ip, #6145	; 0x1801
    3d84:	27000006 	strcs	r0, [r0, -r6]
    3d88:	00000365 	andeq	r0, r0, r5, ror #6
    3d8c:	00035e27 	andeq	r5, r3, r7, lsr #28
    3d90:	2f280000 	svccs	0x00280000
    3d94:	18000002 	stmdane	r0, {r1}
    3d98:	01000001 	tsteq	r0, r1
    3d9c:	06de01c9 	ldrbeq	r0, [lr], r9, asr #3
    3da0:	65270000 	strvs	r0, [r7]!
    3da4:	27000003 	strcs	r0, [r0, -r3]
    3da8:	0000035e 	andeq	r0, r0, lr, asr r3
    3dac:	02ac2900 	adceq	r2, ip, #0	; 0x0
    3db0:	40880000 	addmi	r0, r8, r0
    3db4:	40920800 	addsmi	r0, r2, r0, lsl #16
    3db8:	cd010800 	stcgt	8, cr0, [r1]
    3dbc:	03802701 	orreq	r2, r0, #262144	; 0x40000
    3dc0:	00000000 	andeq	r0, r0, r0
    3dc4:	06fb042a 	ldrbteq	r0, [fp], sl, lsr #8
    3dc8:	c02b0000 	eorgt	r0, fp, r0
    3dcc:	2a000001 	bcs	3dd8 <__Stack_Size+0x39d8>
    3dd0:	0001cb04 	andeq	ip, r1, r4, lsl #22
    3dd4:	8c012c00 	stchi	12, cr2, [r1], {0}
    3dd8:	0100001f 	tsteq	r0, pc, lsl r0
    3ddc:	b2010182 	andlt	r0, r1, #-2147483616	; 0x80000020
    3de0:	a4000001 	strge	r0, [r0], #-1
    3de4:	e4080040 	str	r0, [r8], #-64
    3de8:	db080040 	blle	203ef0 <__Stack_Size+0x203af0>
    3dec:	5400001b 	strpl	r0, [r0], #-27
    3df0:	24000007 	strcs	r0, [r0], #-7
    3df4:	01006469 	tsteq	r0, r9, ror #8
    3df8:	005e0182 	subseq	r0, lr, r2, lsl #3
    3dfc:	1c060000 	stcne	0, cr0, [r6], {0}
    3e00:	26180000 	ldrcs	r0, [r8], -r0
    3e04:	0100003d 	tsteq	r0, sp, lsr r0
    3e08:	005e0182 	subseq	r0, lr, r2, lsl #3
    3e0c:	1c190000 	ldcne	0, cr0, [r9], {0}
    3e10:	a2180000 	andsge	r0, r8, #0	; 0x0
    3e14:	0100004d 	tsteq	r0, sp, asr #32
    3e18:	004c0182 	subeq	r0, ip, r2, lsl #3
    3e1c:	1c2c0000 	stcne	0, cr0, [ip]
    3e20:	2c000000 	stccs	0, cr0, [r0], {0}
    3e24:	001d4201 	andseq	r4, sp, r1, lsl #4
    3e28:	016e0100 	cmneq	lr, r0, lsl #2
    3e2c:	00004c01 	andeq	r4, r0, r1, lsl #24
    3e30:	0040e400 	subeq	lr, r0, r0, lsl #8
    3e34:	00413408 	subeq	r3, r1, r8, lsl #8
    3e38:	001c4a08 	andseq	r4, ip, r8, lsl #20
    3e3c:	0007c000 	andeq	ip, r7, r0
    3e40:	64692400 	strbtvs	r2, [r9], #-1024
    3e44:	016e0100 	cmneq	lr, r0, lsl #2
    3e48:	0000005e 	andeq	r0, r0, lr, asr r0
    3e4c:	00001c75 	andeq	r1, r0, r5, ror ip
    3e50:	003d2618 	eorseq	r2, sp, r8, lsl r6
    3e54:	016e0100 	cmneq	lr, r0, lsl #2
    3e58:	0000005e 	andeq	r0, r0, lr, asr r0
    3e5c:	00001c88 	andeq	r1, r0, r8, lsl #25
    3e60:	0002c629 	andeq	ip, r2, r9, lsr #12
    3e64:	00411200 	subeq	r1, r1, r0, lsl #4
    3e68:	00411e08 	subeq	r1, r1, r8, lsl #28
    3e6c:	017d0108 	cmneq	sp, r8, lsl #2
    3e70:	00041427 	andeq	r1, r4, r7, lsr #8
    3e74:	040b2700 	streq	r2, [fp], #-1792
    3e78:	12220000 	eorne	r0, r2, #0	; 0x0
    3e7c:	1e080041 	cdpne	0, 0, cr0, cr8, cr1, {2}
    3e80:	1b080041 	blne	203f8c <__Stack_Size+0x203b8c>
    3e84:	000002f1 	strdeq	r0, [r0], -r1
    3e88:	00001c9b 	muleq	r0, fp, ip
    3e8c:	2c000000 	stccs	0, cr0, [r0], {0}
    3e90:	001f7101 	andseq	r7, pc, r1, lsl #2
    3e94:	015e0100 	cmpeq	lr, r0, lsl #2
    3e98:	0001b201 	andeq	fp, r1, r1, lsl #4
    3e9c:	00413400 	subeq	r3, r1, r0, lsl #8
    3ea0:	00417008 	subeq	r7, r1, r8
    3ea4:	001cc408 	andseq	ip, ip, r8, lsl #8
    3ea8:	00080e00 	andeq	r0, r8, r0, lsl #28
    3eac:	64692400 	strbtvs	r2, [r9], #-1024
    3eb0:	015e0100 	cmpeq	lr, r0, lsl #2
    3eb4:	0000005e 	andeq	r0, r0, lr, asr r0
    3eb8:	00001cef 	andeq	r1, r0, pc, ror #25
    3ebc:	003d2618 	eorseq	r2, sp, r8, lsl r6
    3ec0:	015e0100 	cmpeq	lr, r0, lsl #2
    3ec4:	0000005e 	andeq	r0, r0, lr, asr r0
    3ec8:	00001d02 	andeq	r1, r0, r2, lsl #26
    3ecc:	004da218 	subeq	sl, sp, r8, lsl r2
    3ed0:	015e0100 	cmpeq	lr, r0, lsl #2
    3ed4:	0000005e 	andeq	r0, r0, lr, asr r0
    3ed8:	00001d15 	andeq	r1, r0, r5, lsl sp
    3edc:	80012300 	andhi	r2, r1, r0, lsl #6
    3ee0:	0100001f 	tsteq	r0, pc, lsl r0
    3ee4:	7001019f 	mulvc	r1, pc, r1
    3ee8:	80080041 	andhi	r0, r8, r1, asr #32
    3eec:	33080041 	movwcc	r0, #32833	; 0x8041
    3ef0:	3800001d 	stmdacc	r0, {r0, r2, r3, r4}
    3ef4:	24000008 	strcs	r0, [r0], #-8
    3ef8:	01006469 	tsteq	r0, r9, ror #8
    3efc:	005e019f 	ldrbeq	r0, [lr], #-31
    3f00:	1d5e0000 	ldclne	0, cr0, [lr]
    3f04:	2c000000 	stccs	0, cr0, [r0], {0}
    3f08:	001fa601 	andseq	sl, pc, r1, lsl #12
    3f0c:	014b0100 	cmpeq	fp, r0, lsl #2
    3f10:	00005e01 	andeq	r5, r0, r1, lsl #28
    3f14:	00418000 	subeq	r8, r1, r0
    3f18:	0041c808 	subeq	ip, r1, r8, lsl #16
    3f1c:	001d7108 	andseq	r7, sp, r8, lsl #2
    3f20:	00087600 	andeq	r7, r8, r0, lsl #12
    3f24:	64692400 	strbtvs	r2, [r9], #-1024
    3f28:	014b0100 	cmpeq	fp, r0, lsl #2
    3f2c:	0000005e 	andeq	r0, r0, lr, asr r0
    3f30:	00001d9c 	muleq	r0, ip, sp
    3f34:	003d2618 	eorseq	r2, sp, r8, lsl r6
    3f38:	014b0100 	cmpeq	fp, r0, lsl #2
    3f3c:	0000005e 	andeq	r0, r0, lr, asr r0
    3f40:	00001daf 	andeq	r1, r0, pc, lsr #27
    3f44:	3b012c00 	blcc	4ef4c <__Stack_Size+0x4eb4c>
    3f48:	0100001e 	tsteq	r0, lr, lsl r0
    3f4c:	b201012f 	andlt	r0, r1, #-1073741813	; 0xc000000b
    3f50:	c8000001 	stmdagt	r0, {r0}
    3f54:	14080041 	strne	r0, [r8], #-65
    3f58:	c2080042 	andgt	r0, r8, #66	; 0x42
    3f5c:	a400001d 	strge	r0, [r0], #-29
    3f60:	24000008 	strcs	r0, [r0], #-8
    3f64:	01006469 	tsteq	r0, r9, ror #8
    3f68:	005e012f 	subseq	r0, lr, pc, lsr #2
    3f6c:	1ded0000 	stclne	0, cr0, [sp]
    3f70:	2d000000 	stccs	0, cr0, [r0]
    3f74:	001d7f01 	andseq	r7, sp, r1, lsl #30
    3f78:	012b0100 	teqeq	fp, r0, lsl #2
    3f7c:	08004214 	stmdaeq	r0, {r2, r4, r9, lr}
    3f80:	08004220 	stmdaeq	r0, {r5, r9, lr}
    3f84:	00001e00 	andeq	r1, r0, r0, lsl #28
    3f88:	1f50012e 	svcne	0x0050012e
    3f8c:	20010000 	andcs	r0, r1, r0
    3f90:	00005e01 	andeq	r5, r0, r1, lsl #28
    3f94:	00422000 	subeq	r2, r2, r0
    3f98:	00424808 	subeq	r4, r2, r8, lsl #16
    3f9c:	001e2b08 	andseq	r2, lr, r8, lsl #22
    3fa0:	0008e600 	andeq	lr, r8, r0, lsl #12
    3fa4:	1c261500 	cfstr32ne	mvfx1, [r6]
    3fa8:	20010000 	andcs	r0, r1, r0
    3fac:	0000003a 	andeq	r0, r0, sl, lsr r0
    3fb0:	00001e56 	andeq	r1, r0, r6, asr lr
    3fb4:	05691e00 	strbeq	r1, [r9, #-3584]!
    3fb8:	2a060000 	bcs	183fc0 <__Stack_Size+0x183bc0>
    3fbc:	000008f1 	strdeq	r0, [r0], -r1
    3fc0:	00005e2f 	andeq	r5, r0, pc, lsr #28
    3fc4:	02ce1e00 	sbceq	r1, lr, #0	; 0x0
    3fc8:	28060000 	stmdacs	r6, {}
    3fcc:	00000901 	andeq	r0, r0, r1, lsl #18
    3fd0:	00004c2f 	andeq	r4, r0, pc, lsr #24
    3fd4:	042b1e00 	strteq	r1, [fp], #-3584
    3fd8:	28060000 	stmdacs	r6, {}
    3fdc:	00000901 	andeq	r0, r0, r1, lsl #18
    3fe0:	00005e30 	andeq	r5, r0, r0, lsr lr
    3fe4:	00092200 	andeq	r2, r9, r0, lsl #4
    3fe8:	006f3100 	rsbeq	r3, pc, r0, lsl #2
    3fec:	03ff0000 	mvnseq	r0, #0	; 0x0
    3ff0:	04af1e00 	strteq	r1, [pc], #3584	; 3ff8 <__Stack_Size+0x3bf8>
    3ff4:	29060000 	stmdbcs	r6, {}
    3ff8:	0000092d 	andeq	r0, r0, sp, lsr #18
    3ffc:	0009112f 	andeq	r1, r9, pc, lsr #2
    4000:	064a3200 	strbeq	r3, [sl], -r0, lsl #4
    4004:	44060000 	strmi	r0, [r6]
    4008:	000008f1 	strdeq	r0, [r0], -r1
    400c:	040e3200 	streq	r3, [lr], #-512
    4010:	44060000 	strmi	r0, [r6]
    4014:	000008f1 	strdeq	r0, [r0], -r1
    4018:	005e3000 	subseq	r3, lr, r0
    401c:	095a0000 	ldmdbeq	sl, {}^
    4020:	6f330000 	svcvs	0x00330000
    4024:	40000000 	andmi	r0, r0, r0
    4028:	00ec1e00 	rsceq	r1, ip, r0, lsl #28
    402c:	45060000 	strmi	r0, [r6]
    4030:	00000965 	andeq	r0, r0, r5, ror #18
    4034:	00094a2f 	andeq	r4, r9, pc, lsr #20
    4038:	06193200 	ldreq	r3, [r9], -r0, lsl #4
    403c:	58060000 	stmdapl	r6, {}
    4040:	00000901 	andeq	r0, r0, r1, lsl #18
    4044:	00f93200 	rscseq	r3, r9, r0, lsl #4
    4048:	58060000 	stmdapl	r6, {}
    404c:	00000901 	andeq	r0, r0, r1, lsl #18
    4050:	032d1e00 	teqeq	sp, #0	; 0x0
    4054:	59060000 	stmdbpl	r6, {}
    4058:	0000098d 	andeq	r0, r0, sp, lsl #19
    405c:	0009112f 	andeq	r1, r9, pc, lsr #2
    4060:	005e3000 	subseq	r3, lr, r0
    4064:	09a20000 	stmibeq	r2!, {}
    4068:	6f330000 	svcvs	0x00330000
    406c:	9f000000 	svcls	0x00000000
    4070:	1d503400 	cfldrdne	mvd3, [r0]
    4074:	15010000 	strne	r0, [r1]
    4078:	00000992 	muleq	r0, r2, r9
    407c:	e4030501 	str	r0, [r3], #-1281
    4080:	30200008 	eorcc	r0, r0, r8
    4084:	0000005e 	andeq	r0, r0, lr, asr r0
    4088:	000009c4 	andeq	r0, r0, r4, asr #19
    408c:	00006f33 	andeq	r6, r0, r3, lsr pc
    4090:	34004f00 	strcc	r4, [r0], #-3840
    4094:	00001f41 	andeq	r1, r0, r1, asr #30
    4098:	09b41601 	ldmibeq	r4!, {r0, r9, sl, ip}
    409c:	05010000 	streq	r0, [r1]
    40a0:	00098403 	andeq	r8, r9, r3, lsl #8
    40a4:	1e613420 	cdpne	4, 6, cr3, cr1, cr0, {1}
    40a8:	17010000 	strne	r0, [r1, -r0]
    40ac:	0000005e 	andeq	r0, r0, lr, asr r0
    40b0:	d4030501 	strle	r0, [r3], #-1281
    40b4:	34200009 	strtcc	r0, [r0], #-9
    40b8:	00001e15 	andeq	r1, r0, r5, lsl lr
    40bc:	005e1801 	subseq	r1, lr, r1, lsl #16
    40c0:	05010000 	streq	r0, [r1]
    40c4:	0009d503 	andeq	sp, r9, r3, lsl #10
    40c8:	1e2e3420 	cdpne	4, 2, cr3, cr14, cr0, {1}
    40cc:	1c010000 	stcne	0, cr0, [r1], {0}
    40d0:	00000901 	andeq	r0, r0, r1, lsl #18
    40d4:	00030501 	andeq	r0, r3, r1, lsl #10
    40d8:	34200000 	strtcc	r0, [r0]
    40dc:	00001f9b 	muleq	r0, fp, pc
    40e0:	08f11d01 	ldmeq	r1!, {r0, r8, sl, fp, ip}^
    40e4:	05010000 	streq	r0, [r1]
    40e8:	0009d603 	andeq	sp, r9, r3, lsl #12
    40ec:	04730020 	ldrbteq	r0, [r3], #-32
    40f0:	00020000 	andeq	r0, r2, r0
    40f4:	00000e17 	andeq	r0, r0, r7, lsl lr
    40f8:	01fe0104 	mvnseq	r0, r4, lsl #2
    40fc:	c1010000 	tstgt	r1, r0
    4100:	4900001f 	stmdbmi	r0, {r0, r1, r2, r3, r4}
    4104:	48000002 	stmdami	r0, {r1}
    4108:	88080042 	stmdahi	r8, {r1, r6}
    410c:	2f080045 	svccs	0x00080045
    4110:	02000010 	andeq	r0, r0, #16	; 0x10
    4114:	01220504 	teqeq	r2, r4, lsl #10
    4118:	02020000 	andeq	r0, r2, #0	; 0x0
    411c:	0004ca05 	andeq	ip, r4, r5, lsl #20
    4120:	06010200 	streq	r0, [r1], -r0, lsl #4
    4124:	0000049e 	muleq	r0, lr, r4
    4128:	32337503 	eorscc	r7, r3, #12582912	; 0xc00000
    412c:	45270200 	strmi	r0, [r7, #-512]!
    4130:	02000000 	andeq	r0, r0, #0	; 0x0
    4134:	01300704 	teqeq	r0, r4, lsl #14
    4138:	75030000 	strvc	r0, [r3]
    413c:	02003631 	andeq	r3, r0, #51380224	; 0x3100000
    4140:	00005728 	andeq	r5, r0, r8, lsr #14
    4144:	07020200 	streq	r0, [r2, -r0, lsl #4]
    4148:	000001c5 	andeq	r0, r0, r5, asr #3
    414c:	00387503 	eorseq	r7, r8, r3, lsl #10
    4150:	00682902 	rsbeq	r2, r8, r2, lsl #18
    4154:	01020000 	tsteq	r2, r0
    4158:	00049c08 	andeq	r9, r4, r8, lsl #24
    415c:	1faf0400 	svcne	0x00af0400
    4160:	2a020000 	bcs	84168 <__Stack_Size+0x83d68>
    4164:	00000068 	andeq	r0, r0, r8, rrx
    4168:	06070405 	streq	r0, [r7], -r5, lsl #8
    416c:	00205f01 	eoreq	r5, r0, r1, lsl #30
    4170:	018c0100 	orreq	r0, ip, r0, lsl #2
    4174:	0000004c 	andeq	r0, r0, ip, asr #32
    4178:	08004248 	stmdaeq	r0, {r3, r6, r9, lr}
    417c:	0800425c 	stmdaeq	r0, {r2, r3, r4, r6, r9, lr}
    4180:	01075d01 	tsteq	r7, r1, lsl #26
    4184:	00002008 	andeq	r2, r0, r8
    4188:	01010d01 	tsteq	r1, r1, lsl #26
    418c:	0000004c 	andeq	r0, r0, ip, asr #32
    4190:	0800425c 	stmdaeq	r0, {r2, r3, r4, r6, r9, lr}
    4194:	08004268 	stmdaeq	r0, {r3, r5, r6, r9, lr}
    4198:	01075d01 	tsteq	r7, r1, lsl #26
    419c:	00001fe1 	andeq	r1, r0, r1, ror #31
    41a0:	01011301 	tsteq	r1, r1, lsl #6
    41a4:	0000004c 	andeq	r0, r0, ip, asr #32
    41a8:	08004268 	stmdaeq	r0, {r3, r5, r6, r9, lr}
    41ac:	08004274 	stmdaeq	r0, {r2, r4, r5, r6, r9, lr}
    41b0:	01075d01 	tsteq	r7, r1, lsl #26
    41b4:	0000211f 	andeq	r2, r0, pc, lsl r1
    41b8:	01011901 	tsteq	r1, r1, lsl #18
    41bc:	0000004c 	andeq	r0, r0, ip, asr #32
    41c0:	08004274 	stmdaeq	r0, {r2, r4, r5, r6, r9, lr}
    41c4:	08004280 	stmdaeq	r0, {r7, r9, lr}
    41c8:	01075d01 	tsteq	r7, r1, lsl #26
    41cc:	000020e3 	andeq	r2, r0, r3, ror #1
    41d0:	01011f01 	tsteq	r1, r1, lsl #30
    41d4:	0000004c 	andeq	r0, r0, ip, asr #32
    41d8:	08004280 	stmdaeq	r0, {r7, r9, lr}
    41dc:	0800428c 	stmdaeq	r0, {r2, r3, r7, r9, lr}
    41e0:	01075d01 	tsteq	r7, r1, lsl #26
    41e4:	000020f6 	strdeq	r2, [r0], -r6
    41e8:	01012501 	tsteq	r1, r1, lsl #10
    41ec:	0000005e 	andeq	r0, r0, lr, asr r0
    41f0:	0800428c 	stmdaeq	r0, {r2, r3, r7, r9, lr}
    41f4:	08004298 	stmdaeq	r0, {r3, r4, r7, r9, lr}
    41f8:	01075d01 	tsteq	r7, r1, lsl #26
    41fc:	00002026 	andeq	r2, r0, r6, lsr #32
    4200:	01012b01 	tsteq	r1, r1, lsl #22
    4204:	0000005e 	andeq	r0, r0, lr, asr r0
    4208:	08004298 	stmdaeq	r0, {r3, r4, r7, r9, lr}
    420c:	080042a8 	stmdaeq	r0, {r3, r5, r7, r9, lr}
    4210:	01075d01 	tsteq	r7, r1, lsl #26
    4214:	0000210a 	andeq	r2, r0, sl, lsl #2
    4218:	01013201 	tsteq	r1, r1, lsl #4
    421c:	0000013c 	andeq	r0, r0, ip, lsr r1
    4220:	080042a8 	stmdaeq	r0, {r3, r5, r7, r9, lr}
    4224:	080042b4 	stmdaeq	r0, {r2, r4, r5, r7, r9, lr}
    4228:	04085d01 	streq	r5, [r8], #-3329
    422c:	746e6905 	strbtvc	r6, [lr], #-2309
    4230:	6b010700 	blvs	45e38 <__Stack_Size+0x45a38>
    4234:	01000020 	tsteq	r0, r0, lsr #32
    4238:	3c010138 	stfccs	f0, [r1], {56}
    423c:	b4000001 	strlt	r0, [r0], #-1
    4240:	c0080042 	andgt	r0, r8, r2, asr #32
    4244:	01080042 	tsteq	r8, r2, asr #32
    4248:	be01075d 	mcrlt	7, 0, r0, cr1, cr13, {2}
    424c:	01000020 	tsteq	r0, r0, lsr #32
    4250:	3c01013e 	stfccs	f0, [r1], {62}
    4254:	c0000001 	andgt	r0, r0, r1
    4258:	cc080042 	stcgt	0, cr0, [r8], {66}
    425c:	01080042 	tsteq	r8, r2, asr #32
    4260:	3801075d 	stmdacc	r1, {r0, r2, r3, r4, r6, r8, r9, sl}
    4264:	01000020 	tsteq	r0, r0, lsr #32
    4268:	3c010144 	stfccs	f0, [r1], {68}
    426c:	cc000001 	stcgt	0, cr0, [r0], {1}
    4270:	d8080042 	stmdale	r8, {r1, r6}
    4274:	01080042 	tsteq	r8, r2, asr #32
    4278:	d201075d 	andle	r0, r1, #24379392	; 0x1740000
    427c:	01000020 	tsteq	r0, r0, lsr #32
    4280:	6f010149 	svcvs	0x00010149
    4284:	d8000000 	stmdale	r0, {}
    4288:	f0080042 	undefined instruction 0xf0080042
    428c:	01080042 	tsteq	r8, r2, asr #32
    4290:	8001095d 	andhi	r0, r1, sp, asr r9
    4294:	01000020 	tsteq	r0, r0, lsr #32
    4298:	005e0193 	ldrbeq	r0, [lr], #-19
    429c:	42f00000 	rscsmi	r0, r0, #0	; 0x0
    42a0:	44100800 	ldrmi	r0, [r0], #-2048
    42a4:	1e690800 	cdpne	8, 6, cr0, cr9, cr0, {0}
    42a8:	01f10000 	mvnseq	r0, r0
    42ac:	010a0000 	tsteq	sl, r0
    42b0:	01000020 	tsteq	r0, r0, lsr #32
    42b4:	00005e96 	muleq	r0, r6, lr
    42b8:	14850a00 	strne	r0, [r5], #2560
    42bc:	97010000 	strls	r0, [r1, -r0]
    42c0:	0000005e 	andeq	r0, r0, lr, asr r0
    42c4:	0100690b 	tsteq	r0, fp, lsl #18
    42c8:	00005e98 	muleq	r0, r8, lr
    42cc:	001e8800 	andseq	r8, lr, r0, lsl #16
    42d0:	006a0b00 	rsbeq	r0, sl, r0, lsl #22
    42d4:	005e9801 	subseq	r9, lr, r1, lsl #16
    42d8:	1ea60000 	cdpne	0, 10, cr0, cr6, cr0, {0}
    42dc:	09000000 	stmdbeq	r0, {}
    42e0:	001fb401 	andseq	fp, pc, r1, lsl #8
    42e4:	01410100 	cmpeq	r1, r0, lsl #2
    42e8:	0000005e 	andeq	r0, r0, lr, asr r0
    42ec:	08004410 	stmdaeq	r0, {r4, sl, lr}
    42f0:	08004508 	stmdaeq	r0, {r3, r8, sl, lr}
    42f4:	00001ec4 	andeq	r1, r0, r4, asr #29
    42f8:	0000023f 	andeq	r0, r0, pc, lsr r2
    42fc:	0020010a 	eoreq	r0, r0, sl, lsl #2
    4300:	5e420100 	dvfpls	f0, f2, f0
    4304:	0a000000 	beq	430c <__Stack_Size+0x3f0c>
    4308:	00001485 	andeq	r1, r0, r5, lsl #9
    430c:	005e4301 	subseq	r4, lr, r1, lsl #6
    4310:	690b0000 	stmdbvs	fp, {}
    4314:	5e440100 	dvfpls	f0, f4, f0
    4318:	ef000000 	svc	0x00000000
    431c:	0b00001e 	bleq	439c <__Stack_Size+0x3f9c>
    4320:	4401006a 	strmi	r0, [r1], #-106
    4324:	0000005e 	andeq	r0, r0, lr, asr r0
    4328:	00001f0d 	andeq	r1, r0, sp, lsl #30
    432c:	a4010900 	strge	r0, [r1], #-2304
    4330:	01000020 	tsteq	r0, r0, lsr #32
    4334:	005e012d 	subseq	r0, lr, sp, lsr #2
    4338:	45080000 	strmi	r0, [r8]
    433c:	454c0800 	strbmi	r0, [ip, #-2048]
    4340:	1f2b0800 	svcne	0x002b0800
    4344:	02980000 	addseq	r0, r8, #0	; 0x0
    4348:	4b0c0000 	blmi	304350 <__Stack_Size+0x303f50>
    434c:	0100001d 	tsteq	r0, sp, lsl r0
    4350:	00004c2c 	andeq	r4, r0, ip, lsr #24
    4354:	001f5600 	andseq	r5, pc, r0, lsl #12
    4358:	201c0d00 	andscs	r0, ip, r0, lsl #26
    435c:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    4360:	00000298 	muleq	r0, r8, r2
    4364:	0e729102 	expeqs	f1, f2
    4368:	00001ef6 	strdeq	r1, [r0], -r6
    436c:	005e2f01 	subseq	r2, lr, r1, lsl #30
    4370:	1f690000 	svcne	0x00690000
    4374:	ce0e0000 	cdpgt	0, 0, cr0, cr14, cr0, {0}
    4378:	0100001e 	tsteq	r0, lr, lsl r0
    437c:	00005e30 	andeq	r5, r0, r0, lsr lr
    4380:	001f7c00 	andseq	r7, pc, r0, lsl #24
    4384:	5e0f0000 	cdppl	0, 0, cr0, cr15, cr0, {0}
    4388:	a8000000 	stmdage	r0, {}
    438c:	10000002 	andne	r0, r0, r2
    4390:	0000007a 	andeq	r0, r0, sl, ror r0
    4394:	01110005 	tsteq	r1, r5
    4398:	000020b0 	strheq	r2, [r0], -r0
    439c:	4c012701 	stcmi	7, cr2, [r1], {1}
    43a0:	58080045 	stmdapl	r8, {r0, r2, r6}
    43a4:	8f080045 	svchi	0x00080045
    43a8:	0900001f 	stmdbeq	r0, {r0, r1, r2, r3, r4}
    43ac:	001fd201 	andseq	sp, pc, r1, lsl #4
    43b0:	011b0100 	tsteq	fp, r0, lsl #2
    43b4:	0000005e 	andeq	r0, r0, lr, asr r0
    43b8:	08004558 	stmdaeq	r0, {r3, r4, r6, r8, sl, lr}
    43bc:	08004588 	stmdaeq	r0, {r3, r7, r8, sl, lr}
    43c0:	00001fba 	strheq	r1, [r0], -sl
    43c4:	000002ea 	andeq	r0, r0, sl, ror #5
    43c8:	001c260c 	andseq	r2, ip, ip, lsl #12
    43cc:	3a1a0100 	bcc	6847d4 <__Stack_Size+0x6843d4>
    43d0:	e5000000 	str	r0, [r0]
    43d4:	0000001f 	andeq	r0, r0, pc, lsl r0
    43d8:	0005690a 	andeq	r6, r5, sl, lsl #18
    43dc:	f52a0300 	undefined instruction 0xf52a0300
    43e0:	12000002 	andne	r0, r0, #2	; 0x2
    43e4:	0000005e 	andeq	r0, r0, lr, asr r0
    43e8:	0002ce0a 	andeq	ip, r2, sl, lsl #28
    43ec:	05280300 	streq	r0, [r8, #-768]!
    43f0:	12000003 	andne	r0, r0, #3	; 0x3
    43f4:	0000004c 	andeq	r0, r0, ip, asr #32
    43f8:	00042b0a 	andeq	r2, r4, sl, lsl #22
    43fc:	05280300 	streq	r0, [r8, #-768]!
    4400:	0f000003 	svceq	0x00000003
    4404:	0000005e 	andeq	r0, r0, lr, asr r0
    4408:	00000326 	andeq	r0, r0, r6, lsr #6
    440c:	00007a13 	andeq	r7, r0, r3, lsl sl
    4410:	0003ff00 	andeq	pc, r3, r0, lsl #30
    4414:	0004af0a 	andeq	sl, r4, sl, lsl #30
    4418:	31290300 	teqcc	r9, r0, lsl #6
    441c:	12000003 	andne	r0, r0, #3	; 0x3
    4420:	00000315 	andeq	r0, r0, r5, lsl r3
    4424:	00064a0d 	andeq	r4, r6, sp, lsl #20
    4428:	f5440300 	undefined instruction 0xf5440300
    442c:	05000002 	streq	r0, [r0, #-2]
    4430:	0009d903 	andeq	sp, r9, r3, lsl #18
    4434:	040e0d20 	streq	r0, [lr], #-3360
    4438:	44030000 	strmi	r0, [r3]
    443c:	000002f5 	strdeq	r0, [r0], -r5
    4440:	09d80305 	ldmibeq	r8, {r0, r2, r8, r9}^
    4444:	5e0f2000 	cdppl	0, 0, cr2, cr15, cr0, {0}
    4448:	68000000 	stmdavs	r0, {}
    444c:	10000003 	andne	r0, r0, r3
    4450:	0000007a 	andeq	r0, r0, sl, ror r0
    4454:	ec0a0040 	stc	0, cr0, [sl], {64}
    4458:	03000000 	movweq	r0, #0	; 0x0
    445c:	00037345 	andeq	r7, r3, r5, asr #6
    4460:	03581200 	cmpeq	r8, #0	; 0x0
    4464:	19140000 	ldmdbne	r4, {}
    4468:	03000006 	movweq	r0, #6	; 0x6
    446c:	00030558 	andeq	r0, r3, r8, asr r5
    4470:	f9140000 	undefined instruction 0xf9140000
    4474:	03000000 	movweq	r0, #0	; 0x0
    4478:	00030558 	andeq	r0, r3, r8, asr r5
    447c:	2d0a0000 	stccs	0, cr0, [sl]
    4480:	03000003 	movweq	r0, #3	; 0x3
    4484:	00039b59 	andeq	r9, r3, r9, asr fp
    4488:	03151200 	tsteq	r5, #0	; 0x0
    448c:	f5150000 	undefined instruction 0xf5150000
    4490:	0100001f 	tsteq	r0, pc, lsl r0
    4494:	0002980b 	andeq	r9, r2, fp, lsl #16
    4498:	03050100 	movweq	r0, #20736	; 0x5100
    449c:	200009da 	ldrdcs	r0, [r0], -sl
    44a0:	00005e0f 	andeq	r5, r0, pc, lsl #28
    44a4:	0003c200 	andeq	ip, r3, r0, lsl #4
    44a8:	007a1000 	rsbseq	r1, sl, r0
    44ac:	00080000 	andeq	r0, r8, r0
    44b0:	00213c15 	eoreq	r3, r1, r5, lsl ip
    44b4:	b20c0100 	andlt	r0, ip, #0	; 0x0
    44b8:	01000003 	tsteq	r0, r3
    44bc:	09e00305 	stmibeq	r0!, {r0, r2, r8, r9}^
    44c0:	95152000 	ldrls	r2, [r5]
    44c4:	01000020 	tsteq	r0, r0, lsr #32
    44c8:	00005e0d 	andeq	r5, r0, sp, lsl #28
    44cc:	03050100 	movweq	r0, #20736	; 0x5100
    44d0:	200009e9 	andcs	r0, r0, r9, ror #19
    44d4:	00204c15 	eoreq	r4, r0, r5, lsl ip
    44d8:	4c0e0100 	stfmis	f0, [lr], {0}
    44dc:	01000000 	tsteq	r0, r0
    44e0:	09ea0305 	stmibeq	sl!, {r0, r2, r8, r9}^
    44e4:	32152000 	andscc	r2, r5, #0	; 0x0
    44e8:	01000021 	tsteq	r0, r1, lsr #32
    44ec:	0002f50f 	andeq	pc, r2, pc, lsl #10
    44f0:	03050100 	movweq	r0, #20736	; 0x5100
    44f4:	200009ec 	andcs	r0, r0, ip, ror #19
    44f8:	00201415 	eoreq	r1, r0, r5, lsl r4
    44fc:	5e110100 	mufpls	f0, f1, f0
    4500:	01000000 	tsteq	r0, r0
    4504:	09ed0305 	stmibeq	sp!, {r0, r2, r8, r9}^
    4508:	ed152000 	ldc	0, cr2, [r5]
    450c:	0100001f 	tsteq	r0, pc, lsl r0
    4510:	00005e12 	andeq	r5, r0, r2, lsl lr
    4514:	03050100 	movweq	r0, #20736	; 0x5100
    4518:	200009ee 	andcs	r0, r0, lr, ror #19
    451c:	00212b15 	eoreq	r2, r1, r5, lsl fp
    4520:	5e130100 	mufpls	f0, f3, f0
    4524:	01000000 	tsteq	r0, r0
    4528:	09ef0305 	stmibeq	pc!, {r0, r2, r8, r9}^
    452c:	ef152000 	svc	0x00152000
    4530:	01000020 	tsteq	r0, r0, lsr #32
    4534:	00005e14 	andeq	r5, r0, r4, lsl lr
    4538:	03050100 	movweq	r0, #20736	; 0x5100
    453c:	200009f0 	strdcs	r0, [r0], -r0
    4540:	00205615 	eoreq	r5, r0, r5, lsl r6
    4544:	5e150100 	mufpls	f0, f5, f0
    4548:	01000000 	tsteq	r0, r0
    454c:	09f10305 	ldmibeq	r1!, {r0, r2, r8, r9}^
    4550:	32152000 	andscc	r2, r5, #0	; 0x0
    4554:	01000020 	tsteq	r0, r0, lsr #32
    4558:	00005e16 	andeq	r5, r0, r6, lsl lr
    455c:	03050100 	movweq	r0, #20736	; 0x5100
    4560:	200009f2 	strdcs	r0, [r0], -r2
    4564:	0009a200 	andeq	sl, r9, r0, lsl #4
    4568:	4b000200 	blmi	4d70 <__Stack_Size+0x4970>
    456c:	0400000f 	streq	r0, [r0], #-15
    4570:	0001fe01 	andeq	pc, r1, r1, lsl #28
    4574:	24f90100 	ldrbtcs	r0, [r9], #256
    4578:	02490000 	subeq	r0, r9, #0	; 0x0
    457c:	45880000 	strmi	r0, [r8]
    4580:	4d140800 	ldcmi	8, cr0, [r4]
    4584:	11600800 	cmnne	r0, r0, lsl #16
    4588:	01020000 	tsteq	r2, r0
    458c:	00049e06 	andeq	r9, r4, r6, lsl #28
    4590:	1ddc0300 	ldclne	3, cr0, [ip]
    4594:	2e020000 	cdpcs	0, 0, cr0, cr2, cr0, {0}
    4598:	00000037 	andeq	r0, r0, r7, lsr r0
    459c:	9c080102 	stflss	f0, [r8], {2}
    45a0:	02000004 	andeq	r0, r0, #4	; 0x4
    45a4:	04ca0502 	strbeq	r0, [sl], #1282
    45a8:	d7030000 	strle	r0, [r3, -r0]
    45ac:	0200001e 	andeq	r0, r0, #30	; 0x1e
    45b0:	0000503a 	andeq	r5, r0, sl, lsr r0
    45b4:	07020200 	streq	r0, [r2, -r0, lsl #4]
    45b8:	000001c5 	andeq	r0, r0, r5, asr #3
    45bc:	22050402 	andcs	r0, r5, #33554432	; 0x2000000
    45c0:	02000001 	andeq	r0, r0, #1	; 0x1
    45c4:	01300704 	teqeq	r0, r4, lsl #14
    45c8:	08020000 	stmdaeq	r2, {}
    45cc:	00011d05 	andeq	r1, r1, r5, lsl #26
    45d0:	07080200 	streq	r0, [r8, -r0, lsl #4]
    45d4:	0000012b 	andeq	r0, r0, fp, lsr #2
    45d8:	69050404 	stmdbvs	r5, {r2, sl}
    45dc:	0200746e 	andeq	r7, r0, #1845493760	; 0x6e000000
    45e0:	01350704 	teqeq	r5, r4, lsl #14
    45e4:	75050000 	strvc	r0, [r5]
    45e8:	03003233 	movweq	r3, #563	; 0x233
    45ec:	00005e27 	andeq	r5, r0, r7, lsr #28
    45f0:	31750500 	cmncc	r5, r0, lsl #10
    45f4:	28030036 	stmdacs	r3, {r1, r2, r4, r5}
    45f8:	00000050 	andeq	r0, r0, r0, asr r0
    45fc:	00387505 	eorseq	r7, r8, r5, lsl #10
    4600:	00372903 	eorseq	r2, r7, r3, lsl #18
    4604:	01060000 	tsteq	r6, r0
    4608:	00b63803 	adcseq	r3, r6, r3, lsl #16
    460c:	3c070000 	stccc	0, cr0, [r7], {0}
    4610:	00000014 	andeq	r0, r0, r4, lsl r0
    4614:	00174507 	andseq	r4, r7, r7, lsl #10
    4618:	03000100 	movweq	r0, #256	; 0x100
    461c:	00000f96 	muleq	r0, r6, pc
    4620:	00a13803 	adceq	r3, r1, r3, lsl #16
    4624:	e4030000 	str	r0, [r3]
    4628:	0400001d 	streq	r0, [r0], #-29
    462c:	00002c0f 	andeq	r2, r0, pc, lsl #24
    4630:	1dd50300 	ldclne	3, cr0, [r5]
    4634:	11040000 	tstne	r4, r0
    4638:	00000045 	andeq	r0, r0, r5, asr #32
    463c:	1b054008 	blne	154664 <__Stack_Size+0x154264>
    4640:	00000118 	andeq	r0, r0, r8, lsl r1
    4644:	00225909 	eoreq	r5, r2, r9, lsl #18
    4648:	181c0500 	ldmdane	ip, {r8, sl}
    464c:	02000001 	andeq	r0, r0, #1	; 0x1
    4650:	58090023 	stmdapl	r9, {r0, r1, r5}
    4654:	05000021 	streq	r0, [r0, #-33]
    4658:	00012b1d 	andeq	r2, r1, sp, lsl fp
    465c:	34230200 	strtcc	r0, [r3], #-512
    4660:	0022bd09 	eoreq	fp, r2, r9, lsl #26
    4664:	971e0500 	ldrls	r0, [lr, -r0, lsl #10]
    4668:	02000000 	andeq	r0, r0, #0	; 0x0
    466c:	f4093e23 	undefined instruction 0xf4093e23
    4670:	05000024 	streq	r0, [r0, #-36]
    4674:	0000971f 	andeq	r9, r0, pc, lsl r7
    4678:	3f230200 	svccc	0x00230200
    467c:	008c0a00 	addeq	r0, ip, r0, lsl #20
    4680:	01280000 	teqeq	r8, r0
    4684:	280b0000 	stmdacs	fp, {}
    4688:	19000001 	stmdbne	r0, {r0}
    468c:	07040c00 	streq	r0, [r4, -r0, lsl #24]
    4690:	00008c0a 	andeq	r8, r0, sl, lsl #24
    4694:	00013b00 	andeq	r3, r1, r0, lsl #22
    4698:	01280b00 	teqeq	r8, r0, lsl #22
    469c:	00040000 	andeq	r0, r4, r0
    46a0:	00245c03 	eoreq	r5, r4, r3, lsl #24
    46a4:	d7200500 	strle	r0, [r0, -r0, lsl #10]!
    46a8:	0d000000 	stceq	0, cr0, [r0]
    46ac:	22050200 	andcs	r0, r5, #0	; 0x0
    46b0:	00000214 	andeq	r0, r0, r4, lsl r2
    46b4:	0022c309 	eoreq	ip, r2, r9, lsl #6
    46b8:	14230500 	strtne	r0, [r3], #-1280
    46bc:	02000002 	andeq	r0, r0, #2	; 0x2
    46c0:	6d090023 	stcvs	0, cr0, [r9, #-140]
    46c4:	05000022 	streq	r0, [r0, #-34]
    46c8:	00009724 	andeq	r9, r0, r4, lsr #14
    46cc:	0f230200 	svceq	0x00230200
    46d0:	316b750e 	cmncc	fp, lr, lsl #10
    46d4:	2b250500 	blcs	945adc <__Stack_Size+0x9456dc>
    46d8:	02000002 	andeq	r0, r0, #2	; 0x2
    46dc:	03091023 	movweq	r1, #36899	; 0x9023
    46e0:	05000023 	streq	r0, [r0, #-35]
    46e4:	00009726 	andeq	r9, r0, r6, lsr #14
    46e8:	14230200 	strtne	r0, [r3], #-512
    46ec:	0021f009 	eoreq	pc, r1, r9
    46f0:	97270500 	strls	r0, [r7, -r0, lsl #10]!
    46f4:	02000000 	andeq	r0, r0, #0	; 0x0
    46f8:	24091523 	strcs	r1, [r9], #-1315
    46fc:	05000023 	streq	r0, [r0, #-35]
    4700:	00009728 	andeq	r9, r0, r8, lsr #14
    4704:	16230200 	strtne	r0, [r3], -r0, lsl #4
    4708:	326b750e 	rsbcc	r7, fp, #58720256	; 0x3800000
    470c:	97290500 	strls	r0, [r9, -r0, lsl #10]!
    4710:	02000000 	andeq	r0, r0, #0	; 0x0
    4714:	c8091723 	stmdagt	r9, {r0, r1, r5, r8, r9, sl, ip}
    4718:	05000022 	streq	r0, [r0, #-34]
    471c:	0000972a 	andeq	r9, r0, sl, lsr #14
    4720:	18230200 	stmdane	r3!, {r9}
    4724:	00233b09 	eoreq	r3, r3, r9, lsl #22
    4728:	972b0500 	strls	r0, [fp, -r0, lsl #10]!
    472c:	02000000 	andeq	r0, r0, #0	; 0x0
    4730:	1b091923 	blne	24abc4 <__Stack_Size+0x24a7c4>
    4734:	05000025 	streq	r0, [r0, #-37]
    4738:	0000972c 	andeq	r9, r0, ip, lsr #14
    473c:	1a230200 	bne	8c4f44 <__Stack_Size+0x8c4b44>
    4740:	336b750e 	cmncc	fp, #58720256	; 0x3800000
    4744:	3b2d0500 	blcc	b45b4c <__Stack_Size+0xb4574c>
    4748:	02000002 	andeq	r0, r0, #2	; 0x2
    474c:	f4091b23 	undefined instruction 0xf4091b23
    4750:	05000022 	streq	r0, [r0, #-34]
    4754:	00024b2e 	andeq	r4, r2, lr, lsr #22
    4758:	20230200 	eorcs	r0, r3, r0, lsl #4
    475c:	346b750e 	strbtcc	r7, [fp], #-1294
    4760:	5b2f0500 	blpl	bc5b68 <__Stack_Size+0xbc5768>
    4764:	02000002 	andeq	r0, r0, #2	; 0x2
    4768:	05093a23 	streq	r3, [r9, #-2595]
    476c:	05000023 	streq	r0, [r0, #-35]
    4770:	00026b30 	andeq	r6, r2, r0, lsr fp
    4774:	40230200 	eormi	r0, r3, r0, lsl #4
    4778:	02240a00 	eoreq	r0, r4, #0	; 0x0
    477c:	02240000 	eoreq	r0, r4, #0	; 0x0
    4780:	280b0000 	stmdacs	fp, {}
    4784:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    4788:	08010200 	stmdaeq	r1, {r9}
    478c:	000004a5 	andeq	r0, r0, r5, lsr #9
    4790:	0000970a 	andeq	r9, r0, sl, lsl #14
    4794:	00023b00 	andeq	r3, r2, r0, lsl #22
    4798:	01280b00 	teqeq	r8, r0, lsl #22
    479c:	00030000 	andeq	r0, r3, r0
    47a0:	0000970a 	andeq	r9, r0, sl, lsl #14
    47a4:	00024b00 	andeq	r4, r2, r0, lsl #22
    47a8:	01280b00 	teqeq	r8, r0, lsl #22
    47ac:	00040000 	andeq	r0, r4, r0
    47b0:	0000970a 	andeq	r9, r0, sl, lsl #14
    47b4:	00025b00 	andeq	r5, r2, r0, lsl #22
    47b8:	01280b00 	teqeq	r8, r0, lsl #22
    47bc:	00190000 	andseq	r0, r9, r0
    47c0:	0000970a 	andeq	r9, r0, sl, lsl #14
    47c4:	00026b00 	andeq	r6, r2, r0, lsl #22
    47c8:	01280b00 	teqeq	r8, r0, lsl #22
    47cc:	00050000 	andeq	r0, r5, r0
    47d0:	00013b0a 	andeq	r3, r1, sl, lsl #22
    47d4:	00027b00 	andeq	r7, r2, r0, lsl #22
    47d8:	01280b00 	teqeq	r8, r0, lsl #22
    47dc:	00060000 	andeq	r0, r6, r0
    47e0:	00222903 	eoreq	r2, r2, r3, lsl #18
    47e4:	46310500 	ldrtmi	r0, [r1], -r0, lsl #10
    47e8:	0a000001 	beq	47f4 <__Stack_Size+0x43f4>
    47ec:	0000005e 	andeq	r0, r0, lr, asr r0
    47f0:	00000296 	muleq	r0, r6, r2
    47f4:	0001280b 	andeq	r2, r1, fp, lsl #16
    47f8:	06000600 	streq	r0, [r0], -r0, lsl #12
    47fc:	f4cf0602 	vst3.16	{d16[0],d17[0],d18[0]}, [pc], r2
    4800:	07000002 	streq	r0, [r0, -r2]
    4804:	000006b5 	strheq	r0, [r0], -r5
    4808:	04bc0701 	ldrteq	r0, [ip], #1793
    480c:	07020000 	streq	r0, [r2, -r0]
    4810:	0000038b 	andeq	r0, r0, fp, lsl #7
    4814:	06c30704 	strbeq	r0, [r3], r4, lsl #14
    4818:	07080000 	streq	r0, [r8, -r0]
    481c:	00000500 	andeq	r0, r0, r0, lsl #10
    4820:	01690710 	cmneq	r9, r0, lsl r7
    4824:	07200000 	streq	r0, [r0, -r0]!
    4828:	000005c1 	andeq	r0, r0, r1, asr #11
    482c:	3b0700c0 	blcc	1c4b34 <__Stack_Size+0x1c4734>
    4830:	80000002 	andhi	r0, r0, r2
    4834:	06f60701 	ldrbteq	r0, [r6], r1, lsl #14
    4838:	02800000 	addeq	r0, r0, #0	; 0x0
    483c:	00048e07 	andeq	r8, r4, r7, lsl #28
    4840:	07048000 	streq	r8, [r4, -r0]
    4844:	00000026 	andeq	r0, r0, r6, lsr #32
    4848:	20070880 	andcs	r0, r7, r0, lsl #17
    484c:	80000003 	andhi	r0, r0, r3
    4850:	015a0710 	cmpeq	sl, r0, lsl r7
    4854:	20800000 	addcs	r0, r0, r0
    4858:	24510f00 	ldrbcs	r0, [r1], #-3840
    485c:	01300000 	teqeq	r0, r0
    4860:	03904c01 	orrseq	r4, r0, #256	; 0x100
    4864:	eb090000 	bl	24486c <__Stack_Size+0x24446c>
    4868:	01000023 	tsteq	r0, r3, lsr #32
    486c:	0003904d 	andeq	r9, r3, sp, asr #32
    4870:	00230200 	eoreq	r0, r3, r0, lsl #4
    4874:	00230b09 	eoreq	r0, r3, r9, lsl #22
    4878:	c14e0100 	cmpgt	lr, r0, lsl #2
    487c:	02000000 	andeq	r0, r0, #0	; 0x0
    4880:	86091223 	strhi	r1, [r9], -r3, lsr #4
    4884:	01000022 	tsteq	r0, r2, lsr #32
    4888:	0000c14f 	andeq	ip, r0, pc, asr #2
    488c:	13230200 	teqne	r3, #0	; 0x0
    4890:	00216909 	eoreq	r6, r1, r9, lsl #18
    4894:	c1500100 	cmpgt	r0, r0, lsl #2
    4898:	02000000 	andeq	r0, r0, #0	; 0x0
    489c:	4c091423 	cfstrsmi	mvf1, [r9], {35}
    48a0:	01000023 	tsteq	r0, r3, lsr #32
    48a4:	0000c151 	andeq	ip, r0, r1, asr r1
    48a8:	15230200 	strne	r0, [r3, #-512]!
    48ac:	0021b509 	eoreq	fp, r1, r9, lsl #10
    48b0:	c1520100 	cmpgt	r2, r0, lsl #2
    48b4:	02000000 	andeq	r0, r0, #0	; 0x0
    48b8:	9e091623 	cfmadd32ls	mvax1, mvfx1, mvfx9, mvfx3
    48bc:	01000023 	tsteq	r0, r3, lsr #32
    48c0:	0000c153 	andeq	ip, r0, r3, asr r1
    48c4:	17230200 	strne	r0, [r3, -r0, lsl #4]!
    48c8:	0024dd09 	eoreq	sp, r4, r9, lsl #26
    48cc:	a0540100 	subsge	r0, r4, r0, lsl #2
    48d0:	02000003 	andeq	r0, r0, #3	; 0x3
    48d4:	c3091823 	movwgt	r1, #38947	; 0x9823
    48d8:	01000021 	tsteq	r0, r1, lsr #32
    48dc:	0003b655 	andeq	fp, r3, r5, asr r6
    48e0:	94230300 	strtls	r0, [r3], #-768
    48e4:	28f60902 	ldmcs	r6!, {r1, r8, fp}^
    48e8:	56010000 	strpl	r0, [r1], -r0
    48ec:	000003b6 	strheq	r0, [r0], -r6
    48f0:	02a22303 	adceq	r2, r2, #201326592	; 0xc000000
    48f4:	00c10a00 	sbceq	r0, r1, r0, lsl #20
    48f8:	03a00000 	moveq	r0, #0	; 0x0
    48fc:	280b0000 	stmdacs	fp, {}
    4900:	11000001 	tstne	r0, r1
    4904:	00cc0a00 	sbceq	r0, ip, r0, lsl #20
    4908:	03b60000 	undefined instruction 0x03b60000
    490c:	280b0000 	stmdacs	fp, {}
    4910:	06000001 	streq	r0, [r0], -r1
    4914:	0001280b 	andeq	r2, r1, fp, lsl #16
    4918:	0a001100 	beq	8d20 <__Stack_Size+0x8920>
    491c:	000000cc 	andeq	r0, r0, ip, asr #1
    4920:	000003c6 	andeq	r0, r0, r6, asr #7
    4924:	0001280b 	andeq	r2, r1, fp, lsl #16
    4928:	10000600 	andne	r0, r0, r0, lsl #12
    492c:	00249501 	eoreq	r9, r4, r1, lsl #10
    4930:	03d90100 	bicseq	r0, r9, #0	; 0x0
    4934:	00000073 	andeq	r0, r0, r3, ror r0
    4938:	08004588 	stmdaeq	r0, {r3, r7, r8, sl, lr}
    493c:	0800459c 	stmdaeq	r0, {r2, r3, r4, r7, r8, sl, lr}
    4940:	01115d01 	tsteq	r1, r1, lsl #26
    4944:	00002245 	andeq	r2, r0, r5, asr #4
    4948:	0103ec01 	tsteq	r3, r1, lsl #24
    494c:	0800459c 	stmdaeq	r0, {r2, r3, r4, r7, r8, sl, lr}
    4950:	080045bc 	stmdaeq	r0, {r2, r3, r4, r5, r7, r8, sl, lr}
    4954:	04065d01 	streq	r5, [r6], #-3329
    4958:	90120000 	andsls	r0, r2, r0
    495c:	01000021 	tsteq	r0, r1, lsr #32
    4960:	007303ec 	rsbseq	r0, r3, ip, ror #7
    4964:	1ff80000 	svcne	0x00f80000
    4968:	10000000 	andne	r0, r0, r0
    496c:	0023f501 	eoreq	pc, r3, r1, lsl #10
    4970:	03f50100 	mvnseq	r0, #0	; 0x0
    4974:	00000081 	andeq	r0, r0, r1, lsl #1
    4978:	080045bc 	stmdaeq	r0, {r2, r3, r4, r5, r7, r8, sl, lr}
    497c:	080045c8 	stmdaeq	r0, {r3, r6, r7, r8, sl, lr}
    4980:	01135d01 	tsteq	r3, r1, lsl #26
    4984:	00002445 	andeq	r2, r0, r5, asr #8
    4988:	c803fa01 	stmdagt	r3, {r0, r9, fp, ip, sp, lr, pc}
    498c:	7c080045 	stcvc	0, cr0, [r8], {69}
    4990:	0b080046 	bleq	204ab0 <__Stack_Size+0x2046b0>
    4994:	7d000020 	stcvc	0, cr0, [r0, #-128]
    4998:	14000004 	strne	r0, [r0], #-4
    499c:	080045f2 	stmdaeq	r0, {r1, r4, r5, r6, r7, r8, sl, lr}
    49a0:	0800463a 	stmdaeq	r0, {r1, r3, r4, r5, r9, sl, lr}
    49a4:	0000046a 	andeq	r0, r0, sl, ror #8
    49a8:	01007315 	tsteq	r0, r5, lsl r3
    49ac:	007303fd 	ldrshteq	r0, [r3], #-61
    49b0:	20360000 	eorscs	r0, r6, r0
    49b4:	18160000 	ldmdane	r6, {}
    49b8:	28080046 	stmdacs	r8, {r1, r2, r6}
    49bc:	15080046 	strne	r0, [r8, #-70]
    49c0:	01010069 	tsteq	r1, r9, rrx
    49c4:	00007304 	andeq	r7, r0, r4, lsl #6
    49c8:	00204900 	eoreq	r4, r0, r0, lsl #18
    49cc:	17000000 	strne	r0, [r0, -r0]
    49d0:	00000138 	andeq	r0, r0, r8, lsr r1
    49d4:	01006918 	tsteq	r0, r8, lsl r9
    49d8:	00730408 	rsbseq	r0, r3, r8, lsl #8
    49dc:	54010000 	strpl	r0, [r1]
    49e0:	01190000 	tsteq	r9, r0
    49e4:	0000219d 	muleq	r0, sp, r1
    49e8:	73037c01 	movwvc	r7, #15361	; 0x3c01
    49ec:	7c000000 	stcvc	0, cr0, [r0], {0}
    49f0:	b0080046 	andlt	r0, r8, r6, asr #32
    49f4:	5c080046 	stcpl	0, cr0, [r8], {70}
    49f8:	1a000020 	bne	4a80 <__Stack_Size+0x4680>
    49fc:	0023d901 	eoreq	sp, r3, r1, lsl #18
    4a00:	033d0100 	teqeq	sp, #0	; 0x0
    4a04:	00005e01 	andeq	r5, r0, r1, lsl #28
    4a08:	0046b000 	subeq	fp, r6, r0
    4a0c:	0046ec08 	subeq	lr, r6, r8, lsl #24
    4a10:	00208708 	eoreq	r8, r0, r8, lsl #14
    4a14:	0004d500 	andeq	sp, r4, r0, lsl #10
    4a18:	1b081200 	blne	209220 <__Stack_Size+0x208e20>
    4a1c:	3c010000 	stccc	0, cr0, [r1], {0}
    4a20:	00007303 	andeq	r7, r0, r3, lsl #6
    4a24:	0020a600 	eoreq	sl, r0, r0, lsl #12
    4a28:	22111b00 	andscs	r1, r1, #0	; 0x0
    4a2c:	3f010000 	svccc	0x00010000
    4a30:	00005e03 	andeq	r5, r0, r3, lsl #28
    4a34:	0020da00 	eoreq	sp, r0, r0, lsl #20
    4a38:	011c0000 	tsteq	ip, r0
    4a3c:	00002380 	andeq	r2, r0, r0, lsl #7
    4a40:	73035a01 	movwvc	r5, #14849	; 0x3a01
    4a44:	ec000000 	stc	0, cr0, [r0], {0}
    4a48:	54080046 	strpl	r0, [r8], #-70
    4a4c:	f8080047 	undefined instruction 0xf8080047
    4a50:	21000020 	tstcs	r0, r0, lsr #32
    4a54:	1d000005 	stcne	0, cr0, [r0, #-20]
    4a58:	00002370 	andeq	r2, r0, r0, ror r3
    4a5c:	c1035b01 	tstgt	r3, r1, lsl #22
    4a60:	01000000 	tsteq	r0, r0
    4a64:	21741b56 	cmncs	r4, r6, asr fp
    4a68:	5c010000 	stcpl	0, cr0, [r1], {0}
    4a6c:	00007303 	andeq	r7, r0, r3, lsl #6
    4a70:	00212300 	eoreq	r2, r1, r0, lsl #6
    4a74:	01501700 	cmpeq	r0, r0, lsl #14
    4a78:	691e0000 	ldmdbvs	lr, {}
    4a7c:	035f0100 	cmpeq	pc, #0	; 0x0
    4a80:	000000c1 	andeq	r0, r0, r1, asr #1
    4a84:	011f0000 	tsteq	pc, r0
    4a88:	00002487 	andeq	r2, r0, r7, lsl #9
    4a8c:	01028901 	tsteq	r2, r1, lsl #18
    4a90:	08004754 	stmdaeq	r0, {r2, r4, r6, r8, r9, sl, lr}
    4a94:	08004874 	stmdaeq	r0, {r2, r4, r5, r6, fp, lr}
    4a98:	00002141 	andeq	r2, r0, r1, asr #2
    4a9c:	00000582 	andeq	r0, r0, r2, lsl #11
    4aa0:	00226312 	eoreq	r6, r2, r2, lsl r3
    4aa4:	02890100 	addeq	r0, r9, #0	; 0x0
    4aa8:	00000073 	andeq	r0, r0, r3, ror r0
    4aac:	0000216c 	andeq	r2, r0, ip, ror #2
    4ab0:	01006915 	tsteq	r0, r5, lsl r9
    4ab4:	0073028a 	rsbseq	r0, r3, sl, lsl #5
    4ab8:	218b0000 	orrcs	r0, fp, r0
    4abc:	451b0000 	ldrmi	r0, [fp]
    4ac0:	01000023 	tsteq	r0, r3, lsr #32
    4ac4:	0582028b 	streq	r0, [r2, #651]
    4ac8:	21d90000 	bicscs	r0, r9, r0
    4acc:	b4160000 	ldrlt	r0, [r6]
    4ad0:	58080047 	stmdapl	r8, {r0, r1, r2, r6}
    4ad4:	1d080048 	stcne	0, cr0, [r8, #-288]
    4ad8:	00002463 	andeq	r2, r0, r3, ror #8
    4adc:	73029d01 	movwvc	r9, #11521	; 0x2d01
    4ae0:	01000000 	tsteq	r0, r0
    4ae4:	20000054 	andcs	r0, r0, r4, asr r0
    4ae8:	00058804 	andeq	r8, r5, r4, lsl #16
    4aec:	027b2100 	rsbseq	r2, fp, #0	; 0x0
    4af0:	011a0000 	tsteq	sl, r0
    4af4:	00002479 	andeq	r2, r0, r9, ror r4
    4af8:	01039f01 	tsteq	r3, r1, lsl #30
    4afc:	00000073 	andeq	r0, r0, r3, ror r0
    4b00:	08004874 	stmdaeq	r0, {r2, r4, r5, r6, fp, lr}
    4b04:	08004924 	stmdaeq	r0, {r2, r5, r8, fp, lr}
    4b08:	000021f7 	strdeq	r2, [r0], -r7
    4b0c:	00000661 	andeq	r0, r0, r1, ror #12
    4b10:	00226312 	eoreq	r6, r2, r2, lsl r3
    4b14:	039e0100 	orrseq	r0, lr, #0	; 0x0
    4b18:	00000073 	andeq	r0, r0, r3, ror r0
    4b1c:	00002223 	andeq	r2, r0, r3, lsr #4
    4b20:	0023701b 	eoreq	r7, r3, fp, lsl r0
    4b24:	03a00100 	moveq	r0, #0	; 0x0
    4b28:	000000c1 	andeq	r0, r0, r1, asr #1
    4b2c:	00002236 	andeq	r2, r0, r6, lsr r2
    4b30:	00217422 	eoreq	r7, r1, r2, lsr #8
    4b34:	03a10100 	undefined instruction 0x03a10100
    4b38:	00000073 	andeq	r0, r0, r3, ror r0
    4b3c:	0021601d 	eoreq	r6, r1, sp, lsl r0
    4b40:	03a20100 	undefined instruction 0x03a20100
    4b44:	00000661 	andeq	r0, r0, r1, ror #12
    4b48:	22449102 	subcs	r9, r4, #-2147483648	; 0x80000000
    4b4c:	000024a9 	andeq	r2, r0, r9, lsr #9
    4b50:	8603a501 	strhi	sl, [r3], -r1, lsl #10
    4b54:	22000002 	andcs	r0, r0, #2	; 0x2
    4b58:	000021cd 	andeq	r2, r0, sp, asr #3
    4b5c:	5e03a601 	cfmadd32pl	mvax0, mvfx10, mvfx3, mvfx1
    4b60:	22000000 	andcs	r0, r0, #0	; 0x0
    4b64:	0000228f 	andeq	r2, r0, pc, lsl #5
    4b68:	5e03a601 	cfmadd32pl	mvax0, mvfx10, mvfx3, mvfx1
    4b6c:	23000000 	movwcs	r0, #0	; 0x0
    4b70:	00000168 	andeq	r0, r0, r8, ror #2
    4b74:	0000061e 	andeq	r0, r0, lr, lsl r6
    4b78:	0100691e 	tsteq	r0, lr, lsl r9
    4b7c:	00c103af 	sbceq	r0, r1, pc, lsr #7
    4b80:	16000000 	strne	r0, [r0], -r0
    4b84:	080048b4 	stmdaeq	r0, {r2, r4, r5, r7, fp, lr}
    4b88:	0800490c 	stmdaeq	r0, {r2, r3, r8, fp, lr}
    4b8c:	01007218 	tsteq	r0, r8, lsl r2
    4b90:	007303ba 	ldrhteq	r0, [r3], #-58
    4b94:	56010000 	strpl	r0, [r1], -r0
    4b98:	0048b816 	subeq	fp, r8, r6, lsl r8
    4b9c:	0048fc08 	subeq	pc, r8, r8, lsl #24
    4ba0:	00731508 	rsbseq	r1, r3, r8, lsl #10
    4ba4:	7303bd01 	movwvc	fp, #15617	; 0x3d01
    4ba8:	54000000 	strpl	r0, [r0]
    4bac:	16000022 	strne	r0, [r0], -r2, lsr #32
    4bb0:	080048b8 	stmdaeq	r0, {r3, r4, r5, r7, fp, lr}
    4bb4:	080048c6 	stmdaeq	r0, {r1, r2, r6, r7, fp, lr}
    4bb8:	01006a1e 	tsteq	r0, lr, lsl sl
    4bbc:	007303c0 	rsbseq	r0, r3, r0, asr #7
    4bc0:	00000000 	andeq	r0, r0, r0
    4bc4:	cc0a0000 	stcgt	0, cr0, [sl], {0}
    4bc8:	71000000 	tstvc	r0, r0
    4bcc:	0b000006 	bleq	4bec <__Stack_Size+0x47ec>
    4bd0:	00000128 	andeq	r0, r0, r8, lsr #2
    4bd4:	01130011 	tsteq	r3, r1, lsl r0
    4bd8:	00002279 	andeq	r2, r0, r9, ror r2
    4bdc:	2403e001 	strcs	lr, [r3], #-1
    4be0:	3c080049 	stccc	0, cr0, [r8], {73}
    4be4:	72080049 	andvc	r0, r8, #73	; 0x49
    4be8:	9b000022 	blls	4c78 <__Stack_Size+0x4878>
    4bec:	1b000006 	blne	4c0c <__Stack_Size+0x480c>
    4bf0:	0000230b 	andeq	r2, r0, fp, lsl #6
    4bf4:	7303e101 	movwvc	lr, #12545	; 0x3101
    4bf8:	9d000000 	stcls	0, cr0, [r0]
    4bfc:	00000022 	andeq	r0, r0, r2, lsr #32
    4c00:	24360124 	ldrtcs	r0, [r6], #-292
    4c04:	5d010000 	stcpl	0, cr0, [r1]
    4c08:	0800493c 	stmdaeq	r0, {r2, r3, r4, r5, r8, fp, lr}
    4c0c:	08004978 	stmdaeq	r0, {r3, r4, r5, r6, r8, fp, lr}
    4c10:	000022bb 	strheq	r2, [r0], -fp
    4c14:	000006c7 	andeq	r0, r0, r7, asr #13
    4c18:	00018017 	andeq	r8, r1, r7, lsl r0
    4c1c:	00692500 	rsbeq	r2, r9, r0, lsl #10
    4c20:	00735f01 	rsbseq	r5, r3, r1, lsl #30
    4c24:	22e60000 	rsccs	r0, r6, #0	; 0x0
    4c28:	00000000 	andeq	r0, r0, r0
    4c2c:	23a4011c 	undefined instruction 0x23a4011c
    4c30:	63010000 	movwvs	r0, #4096	; 0x1000
    4c34:	0000c101 	andeq	ip, r0, r1, lsl #2
    4c38:	00497800 	subeq	r7, r9, r0, lsl #16
    4c3c:	004d1408 	subeq	r1, sp, r8, lsl #8
    4c40:	00230408 	eoreq	r0, r3, r8, lsl #8
    4c44:	00073900 	andeq	r3, r7, r0, lsl #18
    4c48:	232f2200 	teqcs	pc, #0	; 0x0
    4c4c:	64010000 	strvs	r0, [r1]
    4c50:	0000c101 	andeq	ip, r0, r1, lsl #2
    4c54:	240f2200 	strcs	r2, [pc], #512	; 4c5c <__Stack_Size+0x485c>
    4c58:	64010000 	strvs	r0, [r1]
    4c5c:	0000c101 	andeq	ip, r0, r1, lsl #2
    4c60:	22a41b00 	adccs	r1, r4, #0	; 0x0
    4c64:	65010000 	strvs	r0, [r1]
    4c68:	00007301 	andeq	r7, r0, r1, lsl #6
    4c6c:	00232f00 	eoreq	r2, r3, r0, lsl #30
    4c70:	22b12200 	adcscs	r2, r1, #0	; 0x0
    4c74:	65010000 	strvs	r0, [r1]
    4c78:	00007301 	andeq	r7, r0, r1, lsl #6
    4c7c:	22351b00 	eorscs	r1, r5, #0	; 0x0
    4c80:	65010000 	strvs	r0, [r1]
    4c84:	00007301 	andeq	r7, r0, r1, lsl #6
    4c88:	00239a00 	eoreq	r9, r3, r0, lsl #20
    4c8c:	01981700 	orrseq	r1, r8, r0, lsl #14
    4c90:	691e0000 	ldmdbvs	lr, {}
    4c94:	01940100 	orrseq	r0, r4, r0, lsl #2
    4c98:	000000c1 	andeq	r0, r0, r1, asr #1
    4c9c:	69260000 	stmdbvs	r6!, {}
    4ca0:	07000005 	streq	r0, [r0, -r5]
    4ca4:	0007442a 	andeq	r4, r7, sl, lsr #8
    4ca8:	00972700 	addseq	r2, r7, r0, lsl #14
    4cac:	ce260000 	cdpgt	0, 2, cr0, cr6, cr0, {0}
    4cb0:	07000002 	streq	r0, [r0, -r2]
    4cb4:	00075428 	andeq	r5, r7, r8, lsr #8
    4cb8:	008c2700 	addeq	r2, ip, r0, lsl #14
    4cbc:	2b260000 	blcs	984cc4 <__Stack_Size+0x9848c4>
    4cc0:	07000004 	streq	r0, [r0, -r4]
    4cc4:	00075428 	andeq	r5, r7, r8, lsr #8
    4cc8:	00970a00 	addseq	r0, r7, r0, lsl #20
    4ccc:	07750000 	ldrbeq	r0, [r5, -r0]!
    4cd0:	28280000 	stmdacs	r8!, {}
    4cd4:	ff000001 	undefined instruction 0xff000001
    4cd8:	af260003 	svcge	0x00260003
    4cdc:	07000004 	streq	r0, [r0, -r4]
    4ce0:	00078029 	andeq	r8, r7, r9, lsr #32
    4ce4:	07642700 	strbeq	r2, [r4, -r0, lsl #14]!
    4ce8:	4a290000 	bmi	a44cf0 <__Stack_Size+0xa448f0>
    4cec:	07000006 	streq	r0, [r0, -r6]
    4cf0:	00074444 	andeq	r4, r7, r4, asr #8
    4cf4:	0e290000 	cdpeq	0, 2, cr0, cr9, cr0, {0}
    4cf8:	07000004 	streq	r0, [r0, -r4]
    4cfc:	00074444 	andeq	r4, r7, r4, asr #8
    4d00:	970a0000 	strls	r0, [sl, -r0]
    4d04:	ad000000 	stcge	0, cr0, [r0]
    4d08:	0b000007 	bleq	4d2c <__Stack_Size+0x492c>
    4d0c:	00000128 	andeq	r0, r0, r8, lsr #2
    4d10:	ec260040 	stc	0, cr0, [r6], #-256
    4d14:	07000000 	streq	r0, [r0, -r0]
    4d18:	0007b845 	andeq	fp, r7, r5, asr #16
    4d1c:	079d2700 	ldreq	r2, [sp, r0, lsl #14]
    4d20:	19290000 	stmdbne	r9!, {}
    4d24:	07000006 	streq	r0, [r0, -r6]
    4d28:	00075458 	andeq	r5, r7, r8, asr r4
    4d2c:	f9290000 	undefined instruction 0xf9290000
    4d30:	07000000 	streq	r0, [r0, -r0]
    4d34:	00075458 	andeq	r5, r7, r8, asr r4
    4d38:	2d260000 	stccs	0, cr0, [r6]
    4d3c:	07000003 	streq	r0, [r0, -r3]
    4d40:	0007e059 	andeq	lr, r7, r9, asr r0
    4d44:	07642700 	strbeq	r2, [r4, -r0, lsl #14]!
    4d48:	c10a0000 	tstgt	sl, r0
    4d4c:	f5000000 	undefined instruction 0xf5000000
    4d50:	0b000007 	bleq	4d74 <__Stack_Size+0x4974>
    4d54:	00000128 	andeq	r0, r0, r8, lsr #2
    4d58:	dc2a0019 	stcle	0, cr0, [sl], #-100
    4d5c:	01000022 	tsteq	r0, r2, lsr #32
    4d60:	0008023d 	andeq	r0, r8, sp, lsr r2
    4d64:	21010100 	tstcs	r1, r0, lsl #2
    4d68:	000007e5 	andeq	r0, r0, r5, ror #15
    4d6c:	00214f2a 	eoreq	r4, r1, sl, lsr #30
    4d70:	143c0100 	ldrtne	r0, [ip], #-256
    4d74:	01000008 	tsteq	r0, r8
    4d78:	03902101 	orrseq	r2, r0, #1073741824	; 0x40000000
    4d7c:	f52b0000 	undefined instruction 0xf52b0000
    4d80:	05000021 	streq	r0, [r0, #-33]
    4d84:	00082b14 	andeq	r2, r8, r4, lsl fp
    4d88:	03050100 	movweq	r0, #20736	; 0x5100
    4d8c:	08007bbc 	stmdaeq	r0, {r2, r3, r4, r5, r7, r8, r9, fp, ip, sp, lr}
    4d90:	0007e521 	andeq	lr, r7, r1, lsr #10
    4d94:	217f2b00 	cmncs	pc, r0, lsl #22
    4d98:	18050000 	stmdane	r5, {}
    4d9c:	00000842 	andeq	r0, r0, r2, asr #16
    4da0:	d6030501 	strle	r0, [r3], -r1, lsl #10
    4da4:	2108007b 	tstcs	r8, fp, ror r0
    4da8:	00000661 	andeq	r0, r0, r1, ror #12
    4dac:	00250a2b 	eoreq	r0, r5, fp, lsr #20
    4db0:	59190500 	ldmdbpl	r9, {r8, sl}
    4db4:	01000008 	tsteq	r0, r8
    4db8:	7bfa0305 	blvc	ffe859d4 <SCS_BASE+0x1fe779d4>
    4dbc:	61210800 	teqvs	r1, r0, lsl #16
    4dc0:	2b000006 	blcs	4de0 <__Stack_Size+0x49e0>
    4dc4:	00002421 	andeq	r2, r0, r1, lsr #8
    4dc8:	08703305 	ldmdaeq	r0!, {r0, r2, r8, r9, ip, sp}^
    4dcc:	05010000 	streq	r0, [r1]
    4dd0:	007c2003 	rsbseq	r2, ip, r3
    4dd4:	05822108 	streq	r2, [r2, #264]
    4dd8:	e72b0000 	str	r0, [fp, -r0]!
    4ddc:	01000022 	tsteq	r0, r2, lsr #32
    4de0:	0000c12d 	andeq	ip, r0, sp, lsr #2
    4de4:	03050100 	movweq	r0, #20736	; 0x5100
    4de8:	200009f4 	strdcs	r0, [r0], -r4
    4dec:	0024682b 	eoreq	r6, r4, fp, lsr #16
    4df0:	5e2e0100 	sufple	f0, f6, f0
    4df4:	01000000 	tsteq	r0, r0
    4df8:	09f80305 	ldmibeq	r8!, {r0, r2, r8, r9}^
    4dfc:	ce2b2000 	cdpgt	0, 2, cr2, cr11, cr0, {0}
    4e00:	01000024 	tsteq	r0, r4, lsr #32
    4e04:	0000c12f 	andeq	ip, r0, pc, lsr #2
    4e08:	03050100 	movweq	r0, #20736	; 0x5100
    4e0c:	200009fc 	strdcs	r0, [r0], -ip
    4e10:	00229a2b 	eoreq	r9, r2, fp, lsr #20
    4e14:	c1300100 	teqgt	r0, r0, lsl #2
    4e18:	01000000 	tsteq	r0, r0
    4e1c:	09fd0305 	ldmibeq	sp!, {r0, r2, r8, r9}^
    4e20:	142b2000 	strtne	r2, [fp]
    4e24:	01000023 	tsteq	r0, r3, lsr #32
    4e28:	00039031 	andeq	r9, r3, r1, lsr r0
    4e2c:	03050100 	movweq	r0, #20736	; 0x5100
    4e30:	20000a10 	andcs	r0, r0, r0, lsl sl
    4e34:	0022112b 	eoreq	r1, r2, fp, lsr #2
    4e38:	5e330100 	rsfpls	f0, f3, f0
    4e3c:	01000000 	tsteq	r0, r0
    4e40:	0a000305 	beq	5a5c <__Stack_Size+0x565c>
    4e44:	e82b2000 	stmda	fp!, {sp}
    4e48:	01000024 	tsteq	r0, r4, lsr #32
    4e4c:	00005e33 	andeq	r5, r0, r3, lsr lr
    4e50:	03050100 	movweq	r0, #20736	; 0x5100
    4e54:	20000a04 	andcs	r0, r0, r4, lsl #20
    4e58:	0023582b 	eoreq	r5, r3, fp, lsr #16
    4e5c:	5e330100 	rsfpls	f0, f3, f0
    4e60:	01000000 	tsteq	r0, r0
    4e64:	0a080305 	beq	205a80 <__Stack_Size+0x205680>
    4e68:	b42b2000 	strtlt	r2, [fp]
    4e6c:	01000024 	tsteq	r0, r4, lsr #32
    4e70:	00008134 	andeq	r8, r0, r4, lsr r1
    4e74:	03050100 	movweq	r0, #20736	; 0x5100
    4e78:	20000a0c 	andcs	r0, r0, ip, lsl #20
    4e7c:	0021e02a 	eoreq	lr, r1, sl, lsr #32
    4e80:	24370100 	ldrtcs	r0, [r7], #-256
    4e84:	01000009 	tsteq	r0, r9
    4e88:	00c12701 	sbceq	r2, r1, r1, lsl #14
    4e8c:	db2a0000 	blle	a84e94 <__Stack_Size+0xa84a94>
    4e90:	01000021 	tsteq	r0, r1, lsr #32
    4e94:	00092438 	andeq	r2, r9, r8, lsr r4
    4e98:	2a010100 	bcs	452a0 <__Stack_Size+0x44ea0>
    4e9c:	00002415 	andeq	r2, r0, r5, lsl r4
    4ea0:	09433901 	stmdbeq	r3, {r0, r8, fp, ip, sp}^
    4ea4:	01010000 	tsteq	r1, r0
    4ea8:	0000b627 	andeq	fp, r0, r7, lsr #12
    4eac:	22212a00 	eorcs	r2, r1, #0	; 0x0
    4eb0:	3f010000 	svccc	0x00010000
    4eb4:	00000924 	andeq	r0, r0, r4, lsr #18
    4eb8:	ba2a0101 	blt	a852c4 <__Stack_Size+0xa84ec4>
    4ebc:	01000023 	tsteq	r0, r3, lsr #32
    4ec0:	00092440 	andeq	r2, r9, r0, asr #8
    4ec4:	2a010100 	bcs	452cc <__Stack_Size+0x44ecc>
    4ec8:	00002363 	andeq	r2, r0, r3, ror #6
    4ecc:	00c14101 	sbceq	r4, r1, r1, lsl #2
    4ed0:	01010000 	tsteq	r1, r0
    4ed4:	00097f0a 	andeq	r7, r9, sl, lsl #30
    4ed8:	00097f00 	andeq	r7, r9, r0, lsl #30
    4edc:	01280b00 	teqeq	r8, r0, lsl #22
    4ee0:	00ff0000 	rscseq	r0, pc, r0
    4ee4:	022b042c 	eoreq	r0, fp, #738197504	; 0x2c000000
    4ee8:	01000022 	tsteq	r0, r2, lsr #32
    4eec:	00096f48 	andeq	r6, r9, r8, asr #30
    4ef0:	03050100 	movweq	r0, #20736	; 0x5100
    4ef4:	20000a24 	andcs	r0, r0, r4, lsr #20
    4ef8:	0023cb2b 	eoreq	ip, r3, fp, lsr #22
    4efc:	f4570100 	undefined instruction 0xf4570100
    4f00:	01000002 	tsteq	r0, r2
    4f04:	0e240305 	cdpeq	3, 2, cr0, cr4, cr5, {0}
    4f08:	c1002000 	tstgt	r0, r0
    4f0c:	02000003 	.word	0x02000003
    4f10:	0011b600 	.word	0x0011b600
    4f14:	fe010400 	.word	0xfe010400
    4f18:	01000001 	.word	0x01000001
    4f1c:	000025cb 	.word	0x000025cb
    4f20:	00000249 	.word	0x00000249
	...
    4f2c:	000013b2 	.word	0x000013b2
    4f30:	9e060102 	.word	0x9e060102
    4f34:	03000004 	.word	0x03000004
    4f38:	00001ddc 	.word	0x00001ddc
    4f3c:	00372e01 	.word	0x00372e01
    4f40:	01020000 	.word	0x01020000
    4f44:	00049c08 	.word	0x00049c08
    4f48:	1ed80300 	.word	0x1ed80300
    4f4c:	39010000 	.word	0x39010000
    4f50:	00000049 	.word	0x00000049
    4f54:	ca050202 	.word	0xca050202
    4f58:	03000004 	.word	0x03000004
    4f5c:	00001ed7 	.word	0x00001ed7
    4f60:	005b3a01 	.word	0x005b3a01
    4f64:	02020000 	.word	0x02020000
    4f68:	0001c507 	.word	0x0001c507
    4f6c:	05040200 	.word	0x05040200
    4f70:	00000122 	.word	0x00000122
    4f74:	30070402 	.word	0x30070402
    4f78:	02000001 	.word	0x02000001
    4f7c:	011d0508 	.word	0x011d0508
    4f80:	08020000 	.word	0x08020000
    4f84:	00012b07 	.word	0x00012b07
    4f88:	05040400 	.word	0x05040400
    4f8c:	00746e69 	.word	0x00746e69
    4f90:	35070402 	.word	0x35070402
    4f94:	05000001 	.word	0x05000001
    4f98:	00000037 	.word	0x00000037
    4f9c:	38020106 	.word	0x38020106
    4fa0:	000000a6 	.word	0x000000a6
    4fa4:	00143c07 	.word	0x00143c07
    4fa8:	45070000 	.word	0x45070000
    4fac:	01000017 	.word	0x01000017
    4fb0:	0f960300 	.word	0x0f960300
    4fb4:	38020000 	.word	0x38020000
    4fb8:	00000091 	.word	0x00000091
    4fbc:	001de403 	.word	0x001de403
    4fc0:	2c0f0300 	.word	0x2c0f0300
    4fc4:	03000000 	.word	0x03000000
    4fc8:	00001dd5 	.word	0x00001dd5
    4fcc:	00501103 	.word	0x00501103
    4fd0:	d6030000 	.word	0xd6030000
    4fd4:	0300001d 	.word	0x0300001d
    4fd8:	00003e12 	.word	0x00003e12
    4fdc:	00b10800 	.word	0x00b10800
    4fe0:	00e20000 	.word	0x00e20000
    4fe4:	e2090000 	.word	0xe2090000
    4fe8:	19000000 	.word	0x19000000
    4fec:	07040a00 	.word	0x07040a00
    4ff0:	0022dc0b 	.word	0x0022dc0b
    4ff4:	f7080400 	.word	0xf7080400
    4ff8:	01000000 	.word	0x01000000
    4ffc:	7c240305 	.word	0x7c240305
    5000:	d20c0800 	.word	0xd20c0800
    5004:	08000000 	.word	0x08000000
    5008:	000000b1 	.word	0x000000b1
    500c:	0000010c 	.word	0x0000010c
    5010:	0000e209 	.word	0x0000e209
    5014:	0b001100 	.word	0x0b001100
    5018:	0000214f 	.word	0x0000214f
    501c:	011e0904 	.word	0x011e0904
    5020:	05010000 	.word	0x05010000
    5024:	007c3e03 	.word	0x007c3e03
    5028:	00fc0c08 	.word	0x00fc0c08
    502c:	4a0b0000 	.word	0x4a0b0000
    5030:	04000025 	.word	0x04000025
    5034:	00008c1f 	.word	0x00008c1f
    5038:	03050100 	.word	0x03050100
    503c:	20000f54 	.word	0x20000f54
    5040:	0026710b 	.word	0x0026710b
    5044:	47200400 	.word	0x47200400
    5048:	01000001 	.word	0x01000001
    504c:	0f9c0305 	.word	0x0f9c0305
    5050:	040d2000 	.word	0x040d2000
    5054:	0000014d 	.word	0x0000014d
    5058:	0001520c 	.word	0x0001520c
    505c:	08010200 	.word	0x08010200
    5060:	000004a5 	.word	0x000004a5
    5064:	0000b108 	.word	0x0000b108
    5068:	00016900 	.word	0x00016900
    506c:	00e20900 	.word	0x00e20900
    5070:	00050000 	.word	0x00050000
    5074:	0025380b 	.word	0x0025380b
    5078:	7b2e0400 	.word	0x7b2e0400
    507c:	01000001 	.word	0x01000001
    5080:	00000305 	.word	0x00000305
    5084:	59050000 	.word	0x59050000
    5088:	08000001 	.word	0x08000001
    508c:	000000c7 	.word	0x000000c7
    5090:	00000190 	.word	0x00000190
    5094:	0000e209 	.word	0x0000e209
    5098:	0b000500 	.word	0x0b000500
    509c:	00002578 	.word	0x00002578
    50a0:	01a23004 	.word	0x01a23004
    50a4:	05010000 	.word	0x05010000
    50a8:	000f5603 	.word	0x000f5603
    50ac:	01800520 	.word	0x01800520
    50b0:	870b0000 	.word	0x870b0000
    50b4:	04000025 	.word	0x04000025
    50b8:	0001b931 	.word	0x0001b931
    50bc:	03050100 	.word	0x03050100
    50c0:	20000f62 	.word	0x20000f62
    50c4:	0000bc05 	.word	0x0000bc05
    50c8:	25970b00 	.word	0x25970b00
    50cc:	32040000 	.word	0x32040000
    50d0:	000001b9 	.word	0x000001b9
    50d4:	64030501 	.word	0x64030501
    50d8:	0b20000f 	.word	0x0b20000f
    50dc:	00002607 	.word	0x00002607
    50e0:	01b93304 	.word	0x01b93304
    50e4:	05010000 	.word	0x05010000
    50e8:	000f6603 	.word	0x000f6603
    50ec:	25e00b20 	.word	0x25e00b20
    50f0:	34040000 	.word	0x34040000
    50f4:	000001f4 	.word	0x000001f4
    50f8:	68030501 	.word	0x68030501
    50fc:	0520000f 	.word	0x0520000f
    5100:	000000c7 	.word	0x000000c7
    5104:	0025eb0b 	.word	0x0025eb0b
    5108:	f4350400 	.word	0xf4350400
    510c:	01000001 	.word	0x01000001
    5110:	0f6a0305 	.word	0x0f6a0305
    5114:	8d0b2000 	.word	0x8d0b2000
    5118:	04000026 	.word	0x04000026
    511c:	0001b936 	.word	0x0001b936
    5120:	03050100 	.word	0x03050100
    5124:	20000f6c 	.word	0x20000f6c
    5128:	0025660b 	.word	0x0025660b
    512c:	b9370400 	.word	0xb9370400
    5130:	01000001 	.word	0x01000001
    5134:	0f6e0305 	.word	0x0f6e0305
    5138:	a80b2000 	.word	0xa80b2000
    513c:	04000025 	.word	0x04000025
    5140:	0001b938 	.word	0x0001b938
    5144:	03050100 	.word	0x03050100
    5148:	20000f70 	.word	0x20000f70
    514c:	0025f60b 	.word	0x0025f60b
    5150:	b9390400 	.word	0xb9390400
    5154:	01000001 	.word	0x01000001
    5158:	0f720305 	.word	0x0f720305
    515c:	e00b2000 	.word	0xe00b2000
    5160:	04000021 	.word	0x04000021
    5164:	0002653c 	.word	0x0002653c
    5168:	03050100 	.word	0x03050100
    516c:	20000f74 	.word	0x20000f74
    5170:	0000b105 	.word	0x0000b105
    5174:	21db0b00 	.word	0x21db0b00
    5178:	3d040000 	.word	0x3d040000
    517c:	00000265 	.word	0x00000265
    5180:	75030501 	.word	0x75030501
    5184:	0b20000f 	.word	0x0b20000f
    5188:	00002415 	.word	0x00002415
    518c:	028e3e04 	.word	0x028e3e04
    5190:	05010000 	.word	0x05010000
    5194:	000f7603 	.word	0x000f7603
    5198:	00a60520 	.word	0x00a60520
    519c:	250b0000 	.word	0x250b0000
    51a0:	04000025 	.word	0x04000025
    51a4:	0002653f 	.word	0x0002653f
    51a8:	03050100 	.word	0x03050100
    51ac:	20000f77 	.word	0x20000f77
    51b0:	00265b0b 	.word	0x00265b0b
    51b4:	8e400400 	.word	0x8e400400
    51b8:	01000002 	.word	0x01000002
    51bc:	0f780305 	.word	0x0f780305
    51c0:	c7082000 	.word	0xc7082000
    51c4:	c7000000 	.word	0xc7000000
    51c8:	09000002 	.word	0x09000002
    51cc:	000000e2 	.word	0x000000e2
    51d0:	800b0011 	.word	0x800b0011
    51d4:	04000026 	.word	0x04000026
    51d8:	0002d943 	.word	0x0002d943
    51dc:	03050100 	.word	0x03050100
    51e0:	20000fa0 	.word	0x20000fa0
    51e4:	0002b705 	.word	0x0002b705
    51e8:	00b10800 	.word	0x00b10800
    51ec:	02f40000 	.word	0x02f40000
    51f0:	e2090000 	.word	0xe2090000
    51f4:	06000000 	.word	0x06000000
    51f8:	0000e209 	.word	0x0000e209
    51fc:	0b001100 	.word	0x0b001100
    5200:	00002618 	.word	0x00002618
    5204:	03064504 	.word	0x03064504
    5208:	05010000 	.word	0x05010000
    520c:	000fc403 	.word	0x000fc403
    5210:	02de0520 	.word	0x02de0520
    5214:	320b0000 	.word	0x320b0000
    5218:	04000026 	.word	0x04000026
    521c:	00031d46 	.word	0x00031d46
    5220:	03050100 	.word	0x03050100
    5224:	20001042 	.word	0x20001042
    5228:	0000fc05 	.word	0x0000fc05
    522c:	22210b00 	.word	0x22210b00
    5230:	49040000 	.word	0x49040000
    5234:	00000265 	.word	0x00000265
    5238:	79030501 	.word	0x79030501
    523c:	0b20000f 	.word	0x0b20000f
    5240:	000023ba 	.word	0x000023ba
    5244:	02654a04 	.word	0x02654a04
    5248:	05010000 	.word	0x05010000
    524c:	000f7a03 	.word	0x000f7a03
    5250:	23630b20 	.word	0x23630b20
    5254:	4b040000 	.word	0x4b040000
    5258:	00000265 	.word	0x00000265
    525c:	7b030501 	.word	0x7b030501
    5260:	0820000f 	.word	0x0820000f
    5264:	00000062 	.word	0x00000062
    5268:	00000368 	.word	0x00000368
    526c:	0000e209 	.word	0x0000e209
    5270:	0b000100 	.word	0x0b000100
    5274:	00002667 	.word	0x00002667
    5278:	037a4e04 	.word	0x037a4e04
    527c:	05010000 	.word	0x05010000
    5280:	000f7c03 	.word	0x000f7c03
    5284:	03580520 	.word	0x03580520
    5288:	c00b0000 	.word	0xc00b0000
    528c:	04000025 	.word	0x04000025
    5290:	0003914f 	.word	0x0003914f
    5294:	03050100 	.word	0x03050100
    5298:	20000f84 	.word	0x20000f84
    529c:	00035805 	.word	0x00035805
    52a0:	25590b00 	.word	0x25590b00
    52a4:	50040000 	.word	0x50040000
    52a8:	000003a8 	.word	0x000003a8
    52ac:	8c030501 	.word	0x8c030501
    52b0:	0520000f 	.word	0x0520000f
    52b4:	00000358 	.word	0x00000358
    52b8:	0026470b 	.word	0x0026470b
    52bc:	bf510400 	.word	0xbf510400
    52c0:	01000003 	.word	0x01000003
    52c4:	0f940305 	.word	0x0f940305
    52c8:	58052000 	.word	0x58052000
    52cc:	00000003 	.word	0x00000003
    52d0:	000007c1 	.word	0x000007c1
    52d4:	12460002 	.word	0x12460002
    52d8:	01040000 	.word	0x01040000
    52dc:	000001fe 	.word	0x000001fe
    52e0:	0027ce01 	.word	0x0027ce01
    52e4:	00024900 	.word	0x00024900
    52e8:	004d1400 	.word	0x004d1400
    52ec:	00511808 	.word	0x00511808
    52f0:	00145808 	.word	0x00145808
    52f4:	06010200 	.word	0x06010200
    52f8:	0000049e 	.word	0x0000049e
    52fc:	001ddc03 	.word	0x001ddc03
    5300:	372e0200 	.word	0x372e0200
    5304:	02000000 	.word	0x02000000
    5308:	049c0801 	.word	0x049c0801
    530c:	d8030000 	.word	0xd8030000
    5310:	0200001e 	.word	0x0200001e
    5314:	00004939 	.word	0x00004939
    5318:	05020200 	.word	0x05020200
    531c:	000004ca 	.word	0x000004ca
    5320:	001ed703 	.word	0x001ed703
    5324:	5b3a0200 	.word	0x5b3a0200
    5328:	02000000 	.word	0x02000000
    532c:	01c50702 	.word	0x01c50702
    5330:	04020000 	.word	0x04020000
    5334:	00012205 	.word	0x00012205
    5338:	280a0300 	.word	0x280a0300
    533c:	54020000 	.word	0x54020000
    5340:	00000074 	.word	0x00000074
    5344:	30070402 	.word	0x30070402
    5348:	02000001 	.word	0x02000001
    534c:	011d0508 	.word	0x011d0508
    5350:	08020000 	.word	0x08020000
    5354:	00012b07 	.word	0x00012b07
    5358:	05040400 	.word	0x05040400
    535c:	00746e69 	.word	0x00746e69
    5360:	35070402 	.word	0x35070402
    5364:	05000001 	.word	0x05000001
    5368:	00363173 	.word	0x00363173
    536c:	00491803 	.word	0x00491803
    5370:	75050000 	.word	0x75050000
    5374:	03003233 	.word	0x03003233
    5378:	00007427 	.word	0x00007427
    537c:	31750500 	.word	0x31750500
    5380:	28030036 	.word	0x28030036
    5384:	0000005b 	.word	0x0000005b
    5388:	00387505 	.word	0x00387505
    538c:	00372903 	.word	0x00372903
    5390:	01060000 	.word	0x01060000
    5394:	00d73803 	.word	0x00d73803
    5398:	3c070000 	.word	0x3c070000
    539c:	00000014 	.word	0x00000014
    53a0:	00174507 	.word	0x00174507
    53a4:	03000100 	.word	0x03000100
    53a8:	00000f96 	.word	0x00000f96
    53ac:	00c23803 	.word	0x00c23803
    53b0:	e4030000 	.word	0xe4030000
    53b4:	0400001d 	.word	0x0400001d
    53b8:	00002c0f 	.word	0x00002c0f
    53bc:	1dd50300 	.word	0x1dd50300
    53c0:	11040000 	.word	0x11040000
    53c4:	00000050 	.word	0x00000050
    53c8:	001dd603 	.word	0x001dd603
    53cc:	3e120400 	.word	0x3e120400
    53d0:	03000000 	.word	0x03000000
    53d4:	000028b5 	.word	0x000028b5
    53d8:	00691304 	.word	0x00691304
    53dc:	01060000 	.word	0x01060000
    53e0:	01232205 	.word	0x01232205
    53e4:	79070000 	.word	0x79070000
    53e8:	00000028 	.word	0x00000028
    53ec:	00279107 	.word	0x00279107
    53f0:	03000100 	.word	0x03000100
    53f4:	0000274f 	.word	0x0000274f
    53f8:	010e2505 	.word	0x010e2505
    53fc:	04080000 	.word	0x04080000
    5400:	08010207 	.word	0x08010207
    5404:	000004a5 	.word	0x000004a5
    5408:	27000109 	.word	0x27000109
    540c:	99010000 	.word	0x99010000
    5410:	0000ad01 	.word	0x0000ad01
    5414:	004d1400 	.word	0x004d1400
    5418:	004d3e08 	.word	0x004d3e08
    541c:	975d0108 	.word	0x975d0108
    5420:	0a000001 	.word	0x0a000001
    5424:	000026d1 	.word	0x000026d1
    5428:	00ad9901 	.word	0x00ad9901
    542c:	23b80000 	.word	0x23b80000
    5430:	a40b0000 	.word	0xa40b0000
    5434:	01000028 	.word	0x01000028
    5438:	0000ad99 	.word	0x0000ad99
    543c:	0b510100 	.word	0x0b510100
    5440:	000024f4 	.word	0x000024f4
    5444:	00a29901 	.word	0x00a29901
    5448:	52010000 	.word	0x52010000
    544c:	0029170c 	.word	0x0029170c
    5450:	a29a0100 	.word	0xa29a0100
    5454:	0d000000 	.word	0x0d000000
    5458:	00001f12 	.word	0x00001f12
    545c:	00ad9f01 	.word	0x00ad9f01
    5460:	23cb0000 	.word	0x23cb0000
    5464:	0e000000 	.word	0x0e000000
    5468:	00291e01 	.word	0x00291e01
    546c:	01a80100 	.word	0x01a80100
    5470:	08004d40 	.word	0x08004d40
    5474:	08004d78 	.word	0x08004d78
    5478:	000023de 	.word	0x000023de
    547c:	000001d6 	.word	0x000001d6
    5480:	0027a00b 	.word	0x0027a00b
    5484:	d6a80100 	.word	0xd6a80100
    5488:	01000001 	.word	0x01000001
    548c:	290d0d50 	.word	0x290d0d50
    5490:	a9010000 	.word	0xa9010000
    5494:	000000f8 	.word	0x000000f8
    5498:	000023fd 	.word	0x000023fd
    549c:	0100690f 	.word	0x0100690f
    54a0:	000089aa 	.word	0x000089aa
    54a4:	04100000 	.word	0x04100000
    54a8:	000000ed 	.word	0x000000ed
    54ac:	26df0111 	.word	0x26df0111
    54b0:	0e010000 	.word	0x0e010000
    54b4:	4d780101 	.word	0x4d780101
    54b8:	4d900800 	.word	0x4d900800
    54bc:	5d010800 	.word	0x5d010800
    54c0:	00000205 	.word	0x00000205
    54c4:	0001b012 	.word	0x0001b012
    54c8:	00691300 	.word	0x00691300
    54cc:	89010f01 	.word	0x89010f01
    54d0:	00000000 	.word	0x00000000
    54d4:	b3011400 	.word	0xb3011400
    54d8:	01000027 	.word	0x01000027
    54dc:	a2010126 	.word	0xa2010126
    54e0:	90000000 	.word	0x90000000
    54e4:	a008004d 	.word	0xa008004d
    54e8:	0108004d 	.word	0x0108004d
    54ec:	0002315d 	.word	0x0002315d
    54f0:	64691500 	.word	0x64691500
    54f4:	01260100 	.word	0x01260100
    54f8:	00000089 	.word	0x00000089
    54fc:	0000241b 	.word	0x0000241b
    5500:	10011400 	.word	0x10011400
    5504:	01000027 	.word	0x01000027
    5508:	9701012a 	.word	0x9701012a
    550c:	a0000000 	.word	0xa0000000
    5510:	b008004d 	.word	0xb008004d
    5514:	0108004d 	.word	0x0108004d
    5518:	00025d5d 	.word	0x00025d5d
    551c:	64691500 	.word	0x64691500
    5520:	012a0100 	.word	0x012a0100
    5524:	00000089 	.word	0x00000089
    5528:	0000242e 	.word	0x0000242e
    552c:	3d011100 	.word	0x3d011100
    5530:	01000029 	.word	0x01000029
    5534:	b001012f 	.word	0xb001012f
    5538:	bc08004d 	.word	0xbc08004d
    553c:	0108004d 	.word	0x0108004d
    5540:	0002845d 	.word	0x0002845d
    5544:	29461600 	.word	0x29461600
    5548:	2f010000 	.word	0x2f010000
    554c:	00012301 	.word	0x00012301
    5550:	00500100 	.word	0x00500100
    5554:	27240117 	.word	0x27240117
    5558:	34010000 	.word	0x34010000
    555c:	0001d601 	.word	0x0001d601
    5560:	004dbc00 	.word	0x004dbc00
    5564:	004dc408 	.word	0x004dc408
    5568:	185d0108 	.word	0x185d0108
    556c:	0028bc01 	.word	0x0028bc01
    5570:	013b0100 	.word	0x013b0100
    5574:	08004dc4 	.word	0x08004dc4
    5578:	08004f10 	.word	0x08004f10
    557c:	00002441 	.word	0x00002441
    5580:	00000394 	.word	0x00000394
    5584:	00269f19 	.word	0x00269f19
    5588:	013d0100 	.word	0x013d0100
    558c:	00000089 	.word	0x00000089
    5590:	31195601 	.word	0x31195601
    5594:	01000029 	.word	0x01000029
    5598:	0394013e 	.word	0x0394013e
    559c:	91020000 	.word	0x91020000
    55a0:	26bf1956 	.word	0x26bf1956
    55a4:	3f010000 	.word	0x3f010000
    55a8:	0003a401 	.word	0x0003a401
    55ac:	b2910300 	.word	0xb2910300
    55b0:	26ab197f 	.word	0x26ab197f
    55b4:	40010000 	.word	0x40010000
    55b8:	0003a401 	.word	0x0003a401
    55bc:	8e910300 	.word	0x8e910300
    55c0:	6f6e1a7f 	.word	0x6f6e1a7f
    55c4:	42010077 	.word	0x42010077
    55c8:	0003b401 	.word	0x0003b401
    55cc:	00246d00 	.word	0x00246d00
    55d0:	01c81200 	.word	0x01c81200
    55d4:	691a0000 	.word	0x691a0000
    55d8:	01450100 	.word	0x01450100
    55dc:	00000089 	.word	0x00000089
    55e0:	000024a7 	.word	0x000024a7
    55e4:	0001e012 	.word	0x0001e012
    55e8:	28131b00 	.word	0x28131b00
    55ec:	47010000 	.word	0x47010000
    55f0:	0000d701 	.word	0x0000d701
    55f4:	0024d400 	.word	0x0024d400
    55f8:	4e0e1c00 	.word	0x4e0e1c00
    55fc:	4e680800 	.word	0x4e680800
    5600:	036f0800 	.word	0x036f0800
    5604:	8a1d0000 	.word	0x8a1d0000
    5608:	01000028 	.word	0x01000028
    560c:	00970155 	.word	0x00970155
    5610:	0a1b0000 	.word	0x0a1b0000
    5614:	01000027 	.word	0x01000027
    5618:	00890158 	.word	0x00890158
    561c:	25080000 	.word	0x25080000
    5620:	1b1d0000 	.word	0x1b1d0000
    5624:	01000027 	.word	0x01000027
    5628:	00a2015a 	.word	0x00a2015a
    562c:	371b0000 	.word	0x371b0000
    5630:	01000027 	.word	0x01000027
    5634:	0097015f 	.word	0x0097015f
    5638:	253c0000 	.word	0x253c0000
    563c:	12000000 	.word	0x12000000
    5640:	00000200 	.word	0x00000200
    5644:	0027aa1b 	.word	0x0027aa1b
    5648:	016f0100 	.word	0x016f0100
    564c:	00000097 	.word	0x00000097
    5650:	0000254f 	.word	0x0000254f
    5654:	00270a1d 	.word	0x00270a1d
    5658:	01780100 	.word	0x01780100
    565c:	000000ad 	.word	0x000000ad
    5660:	00000000 	.word	0x00000000
    5664:	0000b81e 	.word	0x0000b81e
    5668:	0003a400 	.word	0x0003a400
    566c:	012e1f00 	.word	0x012e1f00
    5670:	00110000 	.word	0x00110000
    5674:	0000ad1e 	.word	0x0000ad1e
    5678:	0003b400 	.word	0x0003b400
    567c:	012e1f00 	.word	0x012e1f00
    5680:	00110000 	.word	0x00110000
    5684:	0000a220 	.word	0x0000a220
    5688:	d7012100 	.word	0xd7012100
    568c:	01000028 	.word	0x01000028
    5690:	1001011b 	.word	0x1001011b
    5694:	5008004f 	.word	0x5008004f
    5698:	6208004f 	.word	0x6208004f
    569c:	03000025 	.word	0x03000025
    56a0:	15000004 	.word	0x15000004
    56a4:	01006469 	.word	0x01006469
    56a8:	00b8011a 	.word	0x00b8011a
    56ac:	25810000 	.word	0x25810000
    56b0:	8e220000 	.word	0x8e220000
    56b4:	01000028 	.word	0x01000028
    56b8:	0097011a 	.word	0x0097011a
    56bc:	259f0000 	.word	0x259f0000
    56c0:	0a220000 	.word	0x0a220000
    56c4:	01000027 	.word	0x01000027
    56c8:	00ad011a 	.word	0x00ad011a
    56cc:	25bd0000 	.word	0x25bd0000
    56d0:	21000000 	.word	0x21000000
    56d4:	0027f701 	.word	0x0027f701
    56d8:	01150100 	.word	0x01150100
    56dc:	004f5001 	.word	0x004f5001
    56e0:	004f6008 	.word	0x004f6008
    56e4:	0025db08 	.word	0x0025db08
    56e8:	00043d00 	.word	0x00043d00
    56ec:	64691500 	.word	0x64691500
    56f0:	01140100 	.word	0x01140100
    56f4:	000000b8 	.word	0x000000b8
    56f8:	00002606 	.word	0x00002606
    56fc:	00288e22 	.word	0x00288e22
    5700:	01140100 	.word	0x01140100
    5704:	00000097 	.word	0x00000097
    5708:	00002619 	.word	0x00002619
    570c:	7f012300 	.word	0x7f012300
    5710:	01000027 	.word	0x01000027
    5714:	004f6045 	.word	0x004f6045
    5718:	004f9c08 	.word	0x004f9c08
    571c:	00262c08 	.word	0x00262c08
    5720:	00048900 	.word	0x00048900
    5724:	28422400 	.word	0x28422400
    5728:	46010000 	.word	0x46010000
    572c:	00000489 	.word	0x00000489
    5730:	24569102 	.word	0x24569102
    5734:	0000232f 	.word	0x0000232f
    5738:	00e24701 	.word	0x00e24701
    573c:	55010000 	.word	0x55010000
    5740:	00277424 	.word	0x00277424
    5744:	e2480100 	.word	0xe2480100
    5748:	01000000 	.word	0x01000000
    574c:	00692556 	.word	0x00692556
    5750:	00894901 	.word	0x00894901
    5754:	54010000 	.word	0x54010000
    5758:	00e21e00 	.word	0x00e21e00
    575c:	04990000 	.word	0x04990000
    5760:	2e1f0000 	.word	0x2e1f0000
    5764:	11000001 	.word	0x11000001
    5768:	dd012300 	.word	0xdd012300
    576c:	01000027 	.word	0x01000027
    5770:	004f9c3b 	.word	0x004f9c3b
    5774:	004fc008 	.word	0x004fc008
    5778:	00265708 	.word	0x00265708
    577c:	0004bd00 	.word	0x0004bd00
    5780:	00692500 	.word	0x00692500
    5784:	00893c01 	.word	0x00893c01
    5788:	54010000 	.word	0x54010000
    578c:	60010e00 	.word	0x60010e00
    5790:	01000028 	.word	0x01000028
    5794:	4fc00165 	.word	0x4fc00165
    5798:	50440800 	.word	0x50440800
    579c:	26760800 	.word	0x26760800
    57a0:	052b0000 	.word	0x052b0000
    57a4:	f40a0000 	.word	0xf40a0000
    57a8:	01000024 	.word	0x01000024
    57ac:	0000ed64 	.word	0x0000ed64
    57b0:	0026a100 	.word	0x0026a100
    57b4:	27ed0a00 	.word	0x27ed0a00
    57b8:	64010000 	.word	0x64010000
    57bc:	000001d6 	.word	0x000001d6
    57c0:	000026cc 	.word	0x000026cc
    57c4:	001f120a 	.word	0x001f120a
    57c8:	d6640100 	.word	0xd6640100
    57cc:	f7000001 	.word	0xf7000001
    57d0:	25000026 	.word	0x25000026
    57d4:	66010069 	.word	0x66010069
    57d8:	00000089 	.word	0x00000089
    57dc:	17245401 	.word	0x17245401
    57e0:	01000029 	.word	0x01000029
    57e4:	0000ed67 	.word	0x0000ed67
    57e8:	0d560100 	.word	0x0d560100
    57ec:	00001544 	.word	0x00001544
    57f0:	01036801 	.word	0x01036801
    57f4:	27220000 	.word	0x27220000
    57f8:	26000000 	.word	0x26000000
    57fc:	0026f101 	.word	0x0026f101
    5800:	01c60100 	.word	0x01c60100
    5804:	00000089 	.word	0x00000089
    5808:	08005044 	.word	0x08005044
    580c:	08005100 	.word	0x08005100
    5810:	00002740 	.word	0x00002740
    5814:	000005b6 	.word	0x000005b6
    5818:	0024f40a 	.word	0x0024f40a
    581c:	edc50100 	.word	0xedc50100
    5820:	6b000000 	.word	0x6b000000
    5824:	0a000027 	.word	0x0a000027
    5828:	00002912 	.word	0x00002912
    582c:	05b6c501 	.word	0x05b6c501
    5830:	27940000 	.word	0x27940000
    5834:	5d0a0000 	.word	0x5d0a0000
    5838:	01000029 	.word	0x01000029
    583c:	0000e2c5 	.word	0x0000e2c5
    5840:	0027b200 	.word	0x0027b200
    5844:	02382700 	.word	0x02382700
    5848:	05a60000 	.word	0x05a60000
    584c:	69280000 	.word	0x69280000
    5850:	89ca0100 	.word	0x89ca0100
    5854:	db000000 	.word	0xdb000000
    5858:	0c000027 	.word	0x0c000027
    585c:	00002174 	.word	0x00002174
    5860:	0089cb01 	.word	0x0089cb01
    5864:	680d0000 	.word	0x680d0000
    5868:	01000027 	.word	0x01000027
    586c:	000089cb 	.word	0x000089cb
    5870:	0027f900 	.word	0x0027f900
    5874:	58120000 	.word	0x58120000
    5878:	0f000002 	.word	0x0f000002
    587c:	fd010069 	.word	0xfd010069
    5880:	00000089 	.word	0x00000089
    5884:	04100000 	.word	0x04100000
    5888:	000005bc 	.word	0x000005bc
    588c:	0000ed20 	.word	0x0000ed20
    5890:	4b012900 	.word	0x4b012900
    5894:	01000029 	.word	0x01000029
    5898:	00010109 	.word	0x00010109
    589c:	18080051 	.word	0x18080051
    58a0:	4e080051 	.word	0x4e080051
    58a4:	0c000028 	.word	0x0c000028
    58a8:	00000569 	.word	0x00000569
    58ac:	05e22a06 	.word	0x05e22a06
    58b0:	b82a0000 	.word	0xb82a0000
    58b4:	0c000000 	.word	0x0c000000
    58b8:	000002ce 	.word	0x000002ce
    58bc:	05f22806 	.word	0x05f22806
    58c0:	ad2a0000 	.word	0xad2a0000
    58c4:	0c000000 	.word	0x0c000000
    58c8:	0000042b 	.word	0x0000042b
    58cc:	05f22806 	.word	0x05f22806
    58d0:	b81e0000 	.word	0xb81e0000
    58d4:	13000000 	.word	0x13000000
    58d8:	2b000006 	.word	0x2b000006
    58dc:	0000012e 	.word	0x0000012e
    58e0:	0c0003ff 	.word	0x0c0003ff
    58e4:	000004af 	.word	0x000004af
    58e8:	061e2906 	.word	0x061e2906
    58ec:	022a0000 	.word	0x022a0000
    58f0:	2c000006 	.word	0x2c000006
    58f4:	0000064a 	.word	0x0000064a
    58f8:	05e24406 	.word	0x05e24406
    58fc:	2c000000 	.word	0x2c000000
    5900:	0000040e 	.word	0x0000040e
    5904:	05e24406 	.word	0x05e24406
    5908:	1e000000 	.word	0x1e000000
    590c:	000000b8 	.word	0x000000b8
    5910:	0000064b 	.word	0x0000064b
    5914:	00012e1f 	.word	0x00012e1f
    5918:	0c004000 	.word	0x0c004000
    591c:	000000ec 	.word	0x000000ec
    5920:	06564506 	.word	0x06564506
    5924:	3b2a0000 	.word	0x3b2a0000
    5928:	2c000006 	.word	0x2c000006
    592c:	00000619 	.word	0x00000619
    5930:	05f25806 	.word	0x05f25806
    5934:	2c000000 	.word	0x2c000000
    5938:	000000f9 	.word	0x000000f9
    593c:	05f25806 	.word	0x05f25806
    5940:	0c000000 	.word	0x0c000000
    5944:	0000032d 	.word	0x0000032d
    5948:	067e5906 	.word	0x067e5906
    594c:	022a0000 	.word	0x022a0000
    5950:	2d000006 	.word	0x2d000006
    5954:	0000214f 	.word	0x0000214f
    5958:	06902905 	.word	0x06902905
    595c:	01010000 	.word	0x01010000
    5960:	00048920 	.word	0x00048920
    5964:	00f81e00 	.word	0x00f81e00
    5968:	06a50000 	.word	0x06a50000
    596c:	2e1f0000 	.word	0x2e1f0000
    5970:	11000001 	.word	0x11000001
    5974:	26802d00 	.word	0x26802d00
    5978:	2b050000 	.word	0x2b050000
    597c:	000006b2 	.word	0x000006b2
    5980:	952a0101 	.word	0x952a0101
    5984:	1e000006 	.word	0x1e000006
    5988:	000000ed 	.word	0x000000ed
    598c:	000006c7 	.word	0x000006c7
    5990:	00012e1f 	.word	0x00012e1f
    5994:	2e001100 	.word	0x2e001100
    5998:	000028ff 	.word	0x000028ff
    599c:	06d92201 	.word	0x06d92201
    59a0:	05010000 	.word	0x05010000
    59a4:	007c5003 	.word	0x007c5003
    59a8:	06b72008 	.word	0x06b72008
    59ac:	ef2e0000 	.word	0xef2e0000
    59b0:	01000028 	.word	0x01000028
    59b4:	0005bc23 	.word	0x0005bc23
    59b8:	03050100 	.word	0x03050100
    59bc:	08007c74 	.word	0x08007c74
    59c0:	0027ed2e 	.word	0x0027ed2e
    59c4:	b7260100 	.word	0xb7260100
    59c8:	01000006 	.word	0x01000006
    59cc:	10560305 	.word	0x10560305
    59d0:	4f2e2000 	.word	0x4f2e2000
    59d4:	01000028 	.word	0x01000028
    59d8:	0006b727 	.word	0x0006b727
    59dc:	03050100 	.word	0x03050100
    59e0:	2000107a 	.word	0x2000107a
    59e4:	001f122e 	.word	0x001f122e
    59e8:	b7280100 	.word	0xb7280100
    59ec:	01000006 	.word	0x01000006
    59f0:	109e0305 	.word	0x109e0305
    59f4:	a02e2000 	.word	0xa02e2000
    59f8:	01000027 	.word	0x01000027
    59fc:	0006b729 	.word	0x0006b729
    5a00:	03050100 	.word	0x03050100
    5a04:	200010c2 	.word	0x200010c2
    5a08:	0000a21e 	.word	0x0000a21e
    5a0c:	00074800 	.word	0x00074800
    5a10:	012e1f00 	.word	0x012e1f00
    5a14:	00110000 	.word	0x00110000
    5a18:	0027592e 	.word	0x0027592e
    5a1c:	382b0100 	.word	0x382b0100
    5a20:	01000007 	.word	0x01000007
    5a24:	10e80305 	.word	0x10e80305
    5a28:	971e2000 	.word	0x971e2000
    5a2c:	6a000000 	.word	0x6a000000
    5a30:	1f000007 	.word	0x1f000007
    5a34:	0000012e 	.word	0x0000012e
    5a38:	cf2e0011 	.word	0xcf2e0011
    5a3c:	01000028 	.word	0x01000028
    5a40:	00075a2d 	.word	0x00075a2d
    5a44:	03050100 	.word	0x03050100
    5a48:	20001130 	.word	0x20001130
    5a4c:	0028952e 	.word	0x0028952e
    5a50:	5a2e0100 	.word	0x5a2e0100
    5a54:	01000007 	.word	0x01000007
    5a58:	11540305 	.word	0x11540305
    5a5c:	402e2000 	.word	0x402e2000
    5a60:	01000027 	.word	0x01000027
    5a64:	00075a2f 	.word	0x00075a2f
    5a68:	03050100 	.word	0x03050100
    5a6c:	20001178 	.word	0x20001178
    5a70:	0028382e 	.word	0x0028382e
    5a74:	a2310100 	.word	0xa2310100
    5a78:	01000000 	.word	0x01000000
    5a7c:	119c0305 	.word	0x119c0305
    5a80:	412e2000 	.word	0x412e2000
    5a84:	01000029 	.word	0x01000029
    5a88:	00012335 	.word	0x00012335
    5a8c:	03050100 	.word	0x03050100
    5a90:	20001054 	.word	0x20001054
    5a94:	00025800 	.word	0x00025800
    5a98:	f3000200 	.word	0xf3000200
    5a9c:	04000014 	.word	0x04000014
    5aa0:	0001fe01 	.word	0x0001fe01
    5aa4:	29b10100 	.word	0x29b10100
    5aa8:	02490000 	.word	0x02490000
    5aac:	51180000 	.word	0x51180000
    5ab0:	530c0800 	.word	0x530c0800
    5ab4:	16330800 	.word	0x16330800
    5ab8:	01020000 	.word	0x01020000
    5abc:	00049e06 	.word	0x00049e06
    5ac0:	1ddc0300 	.word	0x1ddc0300
    5ac4:	2e020000 	.word	0x2e020000
    5ac8:	00000037 	.word	0x00000037
    5acc:	9c080102 	.word	0x9c080102
    5ad0:	02000004 	.word	0x02000004
    5ad4:	04ca0502 	.word	0x04ca0502
    5ad8:	d7030000 	.word	0xd7030000
    5adc:	0200001e 	.word	0x0200001e
    5ae0:	0000503a 	.word	0x0000503a
    5ae4:	07020200 	.word	0x07020200
    5ae8:	000001c5 	.word	0x000001c5
    5aec:	22050402 	.word	0x22050402
    5af0:	02000001 	.word	0x02000001
    5af4:	01300704 	.word	0x01300704
    5af8:	08020000 	.word	0x08020000
    5afc:	00011d05 	.word	0x00011d05
    5b00:	07080200 	.word	0x07080200
    5b04:	0000012b 	.word	0x0000012b
    5b08:	69050404 	.word	0x69050404
    5b0c:	0200746e 	.word	0x0200746e
    5b10:	01350704 	.word	0x01350704
    5b14:	75050000 	.word	0x75050000
    5b18:	03003631 	.word	0x03003631
    5b1c:	00005028 	.word	0x00005028
    5b20:	38750500 	.word	0x38750500
    5b24:	37290300 	.word	0x37290300
    5b28:	03000000 	.word	0x03000000
    5b2c:	00001de4 	.word	0x00001de4
    5b30:	002c0f04 	.word	0x002c0f04
    5b34:	d5030000 	.word	0xd5030000
    5b38:	0400001d 	.word	0x0400001d
    5b3c:	00004511 	.word	0x00004511
    5b40:	07040600 	.word	0x07040600
    5b44:	29cb0107 	.word	0x29cb0107
    5b48:	41010000 	.word	0x41010000
    5b4c:	00511801 	.word	0x00511801
    5b50:	00512408 	.word	0x00512408
    5b54:	d45d0108 	.word	0xd45d0108
    5b58:	08000000 	.word	0x08000000
    5b5c:	000021e8 	.word	0x000021e8
    5b60:	00734001 	.word	0x00734001
    5b64:	50010000 	.word	0x50010000
    5b68:	7a010900 	.word	0x7a010900
    5b6c:	01000029 	.word	0x01000029
    5b70:	00007349 	.word	0x00007349
    5b74:	00512400 	.word	0x00512400
    5b78:	00513008 	.word	0x00513008
    5b7c:	095d0108 	.word	0x095d0108
    5b80:	0029c001 	.word	0x0029c001
    5b84:	73560100 	.word	0x73560100
    5b88:	30000000 	.word	0x30000000
    5b8c:	78080051 	.word	0x78080051
    5b90:	01080052 	.word	0x01080052
    5b94:	67010a5d 	.word	0x67010a5d
    5b98:	01000029 	.word	0x01000029
    5b9c:	007301d7 	.word	0x007301d7
    5ba0:	52780000 	.word	0x52780000
    5ba4:	52cc0800 	.word	0x52cc0800
    5ba8:	5d010800 	.word	0x5d010800
    5bac:	0000012b 	.word	0x0000012b
    5bb0:	00298c0b 	.word	0x00298c0b
    5bb4:	73d60100 	.word	0x73d60100
    5bb8:	79000000 	.word	0x79000000
    5bbc:	00000028 	.word	0x00000028
    5bc0:	29a7010c 	.word	0x29a7010c
    5bc4:	2f010000 	.word	0x2f010000
    5bc8:	080052cc 	.word	0x080052cc
    5bcc:	0800530c 	.word	0x0800530c
    5bd0:	000028ad 	.word	0x000028ad
    5bd4:	0000014f 	.word	0x0000014f
    5bd8:	0021740d 	.word	0x0021740d
    5bdc:	73310100 	.word	0x73310100
    5be0:	00000000 	.word	0x00000000
    5be4:	0005690d 	.word	0x0005690d
    5be8:	5a2a0500 	.word	0x5a2a0500
    5bec:	0e000001 	.word	0x0e000001
    5bf0:	0000008c 	.word	0x0000008c
    5bf4:	0002ce0d 	.word	0x0002ce0d
    5bf8:	6a280500 	.word	0x6a280500
    5bfc:	0e000001 	.word	0x0e000001
    5c00:	00000081 	.word	0x00000081
    5c04:	00042b0d 	.word	0x00042b0d
    5c08:	6a280500 	.word	0x6a280500
    5c0c:	0f000001 	.word	0x0f000001
    5c10:	0000008c 	.word	0x0000008c
    5c14:	0000018b 	.word	0x0000018b
    5c18:	0000ac10 	.word	0x0000ac10
    5c1c:	0003ff00 	.word	0x0003ff00
    5c20:	0004af0d 	.word	0x0004af0d
    5c24:	96290500 	.word	0x96290500
    5c28:	0e000001 	.word	0x0e000001
    5c2c:	0000017a 	.word	0x0000017a
    5c30:	00064a11 	.word	0x00064a11
    5c34:	5a440500 	.word	0x5a440500
    5c38:	00000001 	.word	0x00000001
    5c3c:	00040e11 	.word	0x00040e11
    5c40:	5a440500 	.word	0x5a440500
    5c44:	00000001 	.word	0x00000001
    5c48:	00008c0f 	.word	0x00008c0f
    5c4c:	0001c300 	.word	0x0001c300
    5c50:	00ac1200 	.word	0x00ac1200
    5c54:	00400000 	.word	0x00400000
    5c58:	0000ec0d 	.word	0x0000ec0d
    5c5c:	ce450500 	.word	0xce450500
    5c60:	0e000001 	.word	0x0e000001
    5c64:	000001b3 	.word	0x000001b3
    5c68:	00061911 	.word	0x00061911
    5c6c:	6a580500 	.word	0x6a580500
    5c70:	00000001 	.word	0x00000001
    5c74:	0000f911 	.word	0x0000f911
    5c78:	6a580500 	.word	0x6a580500
    5c7c:	00000001 	.word	0x00000001
    5c80:	00032d0d 	.word	0x00032d0d
    5c84:	f6590500 	.word	0xf6590500
    5c88:	0e000001 	.word	0x0e000001
    5c8c:	0000017a 	.word	0x0000017a
    5c90:	00299a13 	.word	0x00299a13
    5c94:	96290100 	.word	0x96290100
    5c98:	05000000 	.word	0x05000000
    5c9c:	0011a103 	.word	0x0011a103
    5ca0:	29dd1320 	.word	0x29dd1320
    5ca4:	2a010000 	.word	0x2a010000
    5ca8:	00000096 	.word	0x00000096
    5cac:	11a00305 	.word	0x11a00305
    5cb0:	e0142000 	.word	0xe0142000
    5cb4:	01000021 	.word	0x01000021
    5cb8:	00022a1c 	.word	0x00022a1c
    5cbc:	0e010100 	.word	0x0e010100
    5cc0:	00000096 	.word	0x00000096
    5cc4:	0021db14 	.word	0x0021db14
    5cc8:	2a1d0100 	.word	0x2a1d0100
    5ccc:	01000002 	.word	0x01000002
    5cd0:	25f61401 	.word	0x25f61401
    5cd4:	23010000 	.word	0x23010000
    5cd8:	00000249 	.word	0x00000249
    5cdc:	a10e0101 	.word	0xa10e0101
    5ce0:	14000000 	.word	0x14000000
    5ce4:	00002221 	.word	0x00002221
    5ce8:	00962601 	.word	0x00962601
    5cec:	01010000 	.word	0x01010000
    5cf0:	0003f500 	.word	0x0003f500
    5cf4:	16000200 	.word	0x16000200
    5cf8:	04000016 	.word	0x04000016
    5cfc:	0001fe01 	.word	0x0001fe01
    5d00:	2a550100 	.word	0x2a550100
    5d04:	02490000 	.word	0x02490000
    5d08:	530c0000 	.word	0x530c0000
    5d0c:	54aa0800 	.word	0x54aa0800
    5d10:	17430800 	.word	0x17430800
    5d14:	04020000 	.word	0x04020000
    5d18:	00012205 	.word	0x00012205
    5d1c:	05020200 	.word	0x05020200
    5d20:	000004ca 	.word	0x000004ca
    5d24:	9e060102 	.word	0x9e060102
    5d28:	02000004 	.word	0x02000004
    5d2c:	01300704 	.word	0x01300704
    5d30:	75030000 	.word	0x75030000
    5d34:	02003631 	.word	0x02003631
    5d38:	00004c28 	.word	0x00004c28
    5d3c:	07020200 	.word	0x07020200
    5d40:	000001c5 	.word	0x000001c5
    5d44:	00387503 	.word	0x00387503
    5d48:	005d2902 	.word	0x005d2902
    5d4c:	01020000 	.word	0x01020000
    5d50:	00049c08 	.word	0x00049c08
    5d54:	003a0400 	.word	0x003a0400
    5d58:	01050000 	.word	0x01050000
    5d5c:	007e3c02 	.word	0x007e3c02
    5d60:	70060000 	.word	0x70060000
    5d64:	0000002a 	.word	0x0000002a
    5d68:	00046e06 	.word	0x00046e06
    5d6c:	07000100 	.word	0x07000100
    5d70:	9d250350 	.word	0x9d250350
    5d74:	08000001 	.word	0x08000001
    5d78:	03005253 	.word	0x03005253
    5d7c:	00006426 	.word	0x00006426
    5d80:	00230200 	.word	0x00230200
    5d84:	31524308 	.word	0x31524308
    5d88:	64270300 	.word	0x64270300
    5d8c:	02000000 	.word	0x02000000
    5d90:	43080423 	.word	0x43080423
    5d94:	03003252 	.word	0x03003252
    5d98:	00006428 	.word	0x00006428
    5d9c:	08230200 	.word	0x08230200
    5da0:	002b1b09 	.word	0x002b1b09
    5da4:	64290300 	.word	0x64290300
    5da8:	02000000 	.word	0x02000000
    5dac:	21090c23 	.word	0x21090c23
    5db0:	0300002b 	.word	0x0300002b
    5db4:	0000642a 	.word	0x0000642a
    5db8:	10230200 	.word	0x10230200
    5dbc:	002a8a09 	.word	0x002a8a09
    5dc0:	642b0300 	.word	0x642b0300
    5dc4:	02000000 	.word	0x02000000
    5dc8:	90091423 	.word	0x90091423
    5dcc:	0300002a 	.word	0x0300002a
    5dd0:	0000642c 	.word	0x0000642c
    5dd4:	18230200 	.word	0x18230200
    5dd8:	002ab109 	.word	0x002ab109
    5ddc:	642d0300 	.word	0x642d0300
    5de0:	02000000 	.word	0x02000000
    5de4:	bf091c23 	.word	0xbf091c23
    5de8:	0300002a 	.word	0x0300002a
    5dec:	0000642e 	.word	0x0000642e
    5df0:	20230200 	.word	0x20230200
    5df4:	52544808 	.word	0x52544808
    5df8:	642f0300 	.word	0x642f0300
    5dfc:	02000000 	.word	0x02000000
    5e00:	4c082423 	.word	0x4c082423
    5e04:	03005254 	.word	0x03005254
    5e08:	00006430 	.word	0x00006430
    5e0c:	28230200 	.word	0x28230200
    5e10:	002aee09 	.word	0x002aee09
    5e14:	64310300 	.word	0x64310300
    5e18:	02000000 	.word	0x02000000
    5e1c:	f3092c23 	.word	0xf3092c23
    5e20:	0300002a 	.word	0x0300002a
    5e24:	00006432 	.word	0x00006432
    5e28:	30230200 	.word	0x30230200
    5e2c:	002af809 	.word	0x002af809
    5e30:	64330300 	.word	0x64330300
    5e34:	02000000 	.word	0x02000000
    5e38:	3a093423 	.word	0x3a093423
    5e3c:	0300002a 	.word	0x0300002a
    5e40:	00006434 	.word	0x00006434
    5e44:	38230200 	.word	0x38230200
    5e48:	002a7809 	.word	0x002a7809
    5e4c:	64350300 	.word	0x64350300
    5e50:	02000000 	.word	0x02000000
    5e54:	fc093c23 	.word	0xfc093c23
    5e58:	03000029 	.word	0x03000029
    5e5c:	00006436 	.word	0x00006436
    5e60:	40230200 	.word	0x40230200
    5e64:	002a0109 	.word	0x002a0109
    5e68:	64370300 	.word	0x64370300
    5e6c:	02000000 	.word	0x02000000
    5e70:	06094423 	.word	0x06094423
    5e74:	0300002a 	.word	0x0300002a
    5e78:	00006438 	.word	0x00006438
    5e7c:	48230200 	.word	0x48230200
    5e80:	00524408 	.word	0x00524408
    5e84:	00643903 	.word	0x00643903
    5e88:	23020000 	.word	0x23020000
    5e8c:	040a004c 	.word	0x040a004c
    5e90:	031c0b07 	.word	0x031c0b07
    5e94:	0213014f 	.word	0x0213014f
    5e98:	430c0000 	.word	0x430c0000
    5e9c:	03004c52 	.word	0x03004c52
    5ea0:	00640150 	.word	0x00640150
    5ea4:	23020000 	.word	0x23020000
    5ea8:	52430c00 	.word	0x52430c00
    5eac:	51030048 	.word	0x51030048
    5eb0:	00006401 	.word	0x00006401
    5eb4:	04230200 	.word	0x04230200
    5eb8:	5244490c 	.word	0x5244490c
    5ebc:	01520300 	.word	0x01520300
    5ec0:	00000064 	.word	0x00000064
    5ec4:	0c082302 	.word	0x0c082302
    5ec8:	0052444f 	.word	0x0052444f
    5ecc:	64015303 	.word	0x64015303
    5ed0:	02000000 	.word	0x02000000
    5ed4:	7d0d0c23 	.word	0x7d0d0c23
    5ed8:	0300002a 	.word	0x0300002a
    5edc:	00640154 	.word	0x00640154
    5ee0:	23020000 	.word	0x23020000
    5ee4:	52420c10 	.word	0x52420c10
    5ee8:	55030052 	.word	0x55030052
    5eec:	00006401 	.word	0x00006401
    5ef0:	14230200 	.word	0x14230200
    5ef4:	002b270d 	.word	0x002b270d
    5ef8:	01560300 	.word	0x01560300
    5efc:	00000064 	.word	0x00000064
    5f00:	00182302 	.word	0x00182302
    5f04:	0029e80e 	.word	0x0029e80e
    5f08:	01570300 	.word	0x01570300
    5f0c:	000001a0 	.word	0x000001a0
    5f10:	002a3f0f 	.word	0x002a3f0f
    5f14:	12040100 	.word	0x12040100
    5f18:	00000274 	.word	0x00000274
    5f1c:	002afd06 	.word	0x002afd06
    5f20:	b7060000 	.word	0xb7060000
    5f24:	0100002a 	.word	0x0100002a
    5f28:	002a2906 	.word	0x002a2906
    5f2c:	21060200 	.word	0x21060200
    5f30:	0300002a 	.word	0x0300002a
    5f34:	002a8206 	.word	0x002a8206
    5f38:	96060400 	.word	0x96060400
    5f3c:	0500002a 	.word	0x0500002a
    5f40:	002ad006 	.word	0x002ad006
    5f44:	d8060600 	.word	0xd8060600
    5f48:	0700002a 	.word	0x0700002a
    5f4c:	002b2c06 	.word	0x002b2c06
    5f50:	34060800 	.word	0x34060800
    5f54:	0900002b 	.word	0x0900002b
    5f58:	002a4d06 	.word	0x002a4d06
    5f5c:	68060a00 	.word	0x68060a00
    5f60:	0b00002a 	.word	0x0b00002a
    5f64:	2aa81000 	.word	0x2aa81000
    5f68:	1f040000 	.word	0x1f040000
    5f6c:	0000021f 	.word	0x0000021f
    5f70:	0001960f 	.word	0x0001960f
    5f74:	20040100 	.word	0x20040100
    5f78:	000002b6 	.word	0x000002b6
    5f7c:	0005e906 	.word	0x0005e906
    5f80:	db060000 	.word	0xdb060000
    5f84:	01000006 	.word	0x01000006
    5f88:	0000e406 	.word	0x0000e406
    5f8c:	a7060200 	.word	0xa7060200
    5f90:	03000001 	.word	0x03000001
    5f94:	00028706 	.word	0x00028706
    5f98:	96060400 	.word	0x96060400
    5f9c:	05000003 	.word	0x05000003
    5fa0:	0002b306 	.word	0x0002b306
    5fa4:	10000600 	.word	0x10000600
    5fa8:	00002ae5 	.word	0x00002ae5
    5fac:	027f2804 	.word	0x027f2804
    5fb0:	05110000 	.word	0x05110000
    5fb4:	0800002b 	.word	0x0800002b
    5fb8:	02ea7005 	.word	0x02ea7005
    5fbc:	e0090000 	.word	0xe0090000
    5fc0:	0500002a 	.word	0x0500002a
    5fc4:	0002ea71 	.word	0x0002ea71
    5fc8:	00230200 	.word	0x00230200
    5fcc:	6e697008 	.word	0x6e697008
    5fd0:	41720500 	.word	0x41720500
    5fd4:	02000000 	.word	0x02000000
    5fd8:	12000423 	.word	0x12000423
    5fdc:	00021304 	.word	0x00021304
    5fe0:	2b101000 	.word	0x2b101000
    5fe4:	73050000 	.word	0x73050000
    5fe8:	000002c1 	.word	0x000002c1
    5fec:	2a310113 	.word	0x2a310113
    5ff0:	1d010000 	.word	0x1d010000
    5ff4:	00530c01 	.word	0x00530c01
    5ff8:	00533808 	.word	0x00533808
    5ffc:	0028d808 	.word	0x0028d808
    6000:	00033300 	.word	0x00033300
    6004:	69701400 	.word	0x69701400
    6008:	1d01006e 	.word	0x1d01006e
    600c:	00000274 	.word	0x00000274
    6010:	00002903 	.word	0x00002903
    6014:	004b8c15 	.word	0x004b8c15
    6018:	531d0100 	.word	0x531d0100
    601c:	21000000 	.word	0x21000000
    6020:	00000029 	.word	0x00000029
    6024:	2ac50116 	.word	0x2ac50116
    6028:	26010000 	.word	0x26010000
    602c:	00004101 	.word	0x00004101
    6030:	00533800 	.word	0x00533800
    6034:	00542808 	.word	0x00542808
    6038:	00293f08 	.word	0x00293f08
    603c:	00037900 	.word	0x00037900
    6040:	2ae01500 	.word	0x2ae01500
    6044:	26010000 	.word	0x26010000
    6048:	000002b6 	.word	0x000002b6
    604c:	0000295e 	.word	0x0000295e
    6050:	0053de17 	.word	0x0053de17
    6054:	00541808 	.word	0x00541808
    6058:	19981808 	.word	0x19981808
    605c:	64010000 	.word	0x64010000
    6060:	00000041 	.word	0x00000041
    6064:	0000299d 	.word	0x0000299d
    6068:	01130000 	.word	0x01130000
    606c:	00002a0b 	.word	0x00002a0b
    6070:	28018901 	.word	0x28018901
    6074:	6a080054 	.word	0x6a080054
    6078:	bb080054 	.word	0xbb080054
    607c:	9e000029 	.word	0x9e000029
    6080:	19000003 	.word	0x19000003
    6084:	00002a48 	.word	0x00002a48
    6088:	00418a01 	.word	0x00418a01
    608c:	16000000 	.word	0x16000000
    6090:	0029f501 	.word	0x0029f501
    6094:	01790100 	.word	0x01790100
    6098:	00000041 	.word	0x00000041
    609c:	0800546c 	.word	0x0800546c
    60a0:	080054aa 	.word	0x080054aa
    60a4:	000029e6 	.word	0x000029e6
    60a8:	000003d6 	.word	0x000003d6
    60ac:	002ae015 	.word	0x002ae015
    60b0:	b6790100 	.word	0xb6790100
    60b4:	05000002 	.word	0x05000002
    60b8:	1900002a 	.word	0x1900002a
    60bc:	00001998 	.word	0x00001998
    60c0:	00417a01 	.word	0x00417a01
    60c4:	1a000000 	.word	0x1a000000
    60c8:	000002f0 	.word	0x000002f0
    60cc:	000003e6 	.word	0x000003e6
    60d0:	00019d1b 	.word	0x00019d1b
    60d4:	1c000b00 	.word	0x1c000b00
    60d8:	00002a9e 	.word	0x00002a9e
    60dc:	03d61001 	.word	0x03d61001
    60e0:	05010000 	.word	0x05010000
    60e4:	00000403 	.word	0x00000403
    60e8:	01c10020 	.word	0x01c10020
    60ec:	00020000 	.word	0x00020000
    60f0:	00001795 	.word	0x00001795
    60f4:	01fe0104 	.word	0x01fe0104
    60f8:	5b010000 	.word	0x5b010000
    60fc:	4900002b 	.word	0x4900002b
    6100:	ac000002 	.word	0xac000002
    6104:	d0080054 	.word	0xd0080054
    6108:	26080054 	.word	0x26080054
    610c:	02000018 	.word	0x02000018
    6110:	01220504 	.word	0x01220504
    6114:	02020000 	.word	0x02020000
    6118:	0004ca05 	.word	0x0004ca05
    611c:	06010200 	.word	0x06010200
    6120:	0000049e 	.word	0x0000049e
    6124:	30070402 	.word	0x30070402
    6128:	03000001 	.word	0x03000001
    612c:	00363175 	.word	0x00363175
    6130:	004c2802 	.word	0x004c2802
    6134:	02020000 	.word	0x02020000
    6138:	0001c507 	.word	0x0001c507
    613c:	38750300 	.word	0x38750300
    6140:	5d290200 	.word	0x5d290200
    6144:	02000000 	.word	0x02000000
    6148:	049c0801 	.word	0x049c0801
    614c:	3a040000 	.word	0x3a040000
    6150:	05000000 	.word	0x05000000
    6154:	7e3a0201 	.word	0x7e3a0201
    6158:	06000000 	.word	0x06000000
    615c:	00000ef2 	.word	0x00000ef2
    6160:	45530700 	.word	0x45530700
    6164:	00010054 	.word	0x00010054
    6168:	00028f08 	.word	0x00028f08
    616c:	0d040100 	.word	0x0d040100
    6170:	000000ae 	.word	0x000000ae
    6174:	00505507 	.word	0x00505507
    6178:	06450600 	.word	0x06450600
    617c:	06010000 	.word	0x06010000
    6180:	00000000 	.word	0x00000000
    6184:	055d0602 	.word	0x055d0602
    6188:	06030000 	.word	0x06030000
    618c:	00000401 	.word	0x00000401
    6190:	494d0704 	.word	0x494d0704
    6194:	00050043 	.word	0x00050043
    6198:	002b3c09 	.word	0x002b3c09
    619c:	7e140400 	.word	0x7e140400
    61a0:	0a000000 	.word	0x0a000000
    61a4:	1c0b0704 	.word	0x1c0b0704
    61a8:	2f014f03 	.word	0x2f014f03
    61ac:	0c000001 	.word	0x0c000001
    61b0:	004c5243 	.word	0x004c5243
    61b4:	64015003 	.word	0x64015003
    61b8:	02000000 	.word	0x02000000
    61bc:	430c0023 	.word	0x430c0023
    61c0:	03004852 	.word	0x03004852
    61c4:	00640151 	.word	0x00640151
    61c8:	23020000 	.word	0x23020000
    61cc:	44490c04 	.word	0x44490c04
    61d0:	52030052 	.word	0x52030052
    61d4:	00006401 	.word	0x00006401
    61d8:	08230200 	.word	0x08230200
    61dc:	52444f0c 	.word	0x52444f0c
    61e0:	01530300 	.word	0x01530300
    61e4:	00000064 	.word	0x00000064
    61e8:	0d0c2302 	.word	0x0d0c2302
    61ec:	00002a7d 	.word	0x00002a7d
    61f0:	64015403 	.word	0x64015403
    61f4:	02000000 	.word	0x02000000
    61f8:	420c1023 	.word	0x420c1023
    61fc:	03005252 	.word	0x03005252
    6200:	00640155 	.word	0x00640155
    6204:	23020000 	.word	0x23020000
    6208:	2b270d14 	.word	0x2b270d14
    620c:	56030000 	.word	0x56030000
    6210:	00006401 	.word	0x00006401
    6214:	18230200 	.word	0x18230200
    6218:	29e80e00 	.word	0x29e80e00
    621c:	57030000 	.word	0x57030000
    6220:	0000bc01 	.word	0x0000bc01
    6224:	2b050f00 	.word	0x2b050f00
    6228:	05080000 	.word	0x05080000
    622c:	00016470 	.word	0x00016470
    6230:	2ae01000 	.word	0x2ae01000
    6234:	71050000 	.word	0x71050000
    6238:	00000164 	.word	0x00000164
    623c:	11002302 	.word	0x11002302
    6240:	006e6970 	.word	0x006e6970
    6244:	00417205 	.word	0x00417205
    6248:	23020000 	.word	0x23020000
    624c:	04120004 	.word	0x04120004
    6250:	0000012f 	.word	0x0000012f
    6254:	002b1009 	.word	0x002b1009
    6258:	3b730500 	.word	0x3b730500
    625c:	13000001 	.word	0x13000001
    6260:	002b5001 	.word	0x002b5001
    6264:	01110100 	.word	0x01110100
    6268:	00000053 	.word	0x00000053
    626c:	080054ac 	.word	0x080054ac
    6270:	080054d0 	.word	0x080054d0
    6274:	00002a23 	.word	0x00002a23
    6278:	000001a2 	.word	0x000001a2
    627c:	002b7114 	.word	0x002b7114
    6280:	ae110100 	.word	0xae110100
    6284:	4e000000 	.word	0x4e000000
    6288:	0000002a 	.word	0x0000002a
    628c:	00016a15 	.word	0x00016a15
    6290:	0001b200 	.word	0x0001b200
    6294:	00b91600 	.word	0x00b91600
    6298:	00050000 	.word	0x00050000
    629c:	002b4517 	.word	0x002b4517
    62a0:	a20c0100 	.word	0xa20c0100
    62a4:	01000001 	.word	0x01000001
    62a8:	00640305 	.word	0x00640305
    62ac:	be002000 	.word	0xbe002000
    62b0:	02000001 	.word	0x02000001
    62b4:	0018c500 	.word	0x0018c500
    62b8:	fe010400 	.word	0xfe010400
    62bc:	01000001 	.word	0x01000001
    62c0:	00002b78 	.word	0x00002b78
    62c4:	00000249 	.word	0x00000249
    62c8:	080054d0 	.word	0x080054d0
    62cc:	080054fc 	.word	0x080054fc
    62d0:	000018d2 	.word	0x000018d2
    62d4:	22050402 	.word	0x22050402
    62d8:	02000001 	.word	0x02000001
    62dc:	04ca0502 	.word	0x04ca0502
    62e0:	01020000 	.word	0x01020000
    62e4:	00049e06 	.word	0x00049e06
    62e8:	07040200 	.word	0x07040200
    62ec:	00000130 	.word	0x00000130
    62f0:	36317503 	.word	0x36317503
    62f4:	4c280200 	.word	0x4c280200
    62f8:	02000000 	.word	0x02000000
    62fc:	01c50702 	.word	0x01c50702
    6300:	75030000 	.word	0x75030000
    6304:	29020038 	.word	0x29020038
    6308:	0000005d 	.word	0x0000005d
    630c:	9c080102 	.word	0x9c080102
    6310:	04000004 	.word	0x04000004
    6314:	0000003a 	.word	0x0000003a
    6318:	00052905 	.word	0x00052905
    631c:	0d040100 	.word	0x0d040100
    6320:	000000a0 	.word	0x000000a0
    6324:	0003ec06 	.word	0x0003ec06
    6328:	bb060000 	.word	0xbb060000
    632c:	01000014 	.word	0x01000014
    6330:	00006306 	.word	0x00006306
    6334:	aa060200 	.word	0xaa060200
    6338:	03000004 	.word	0x03000004
    633c:	44585407 	.word	0x44585407
    6340:	52070400 	.word	0x52070400
    6344:	05004458 	.word	0x05004458
    6348:	58554107 	.word	0x58554107
    634c:	08000600 	.word	0x08000600
    6350:	00002b8b 	.word	0x00002b8b
    6354:	00691504 	.word	0x00691504
    6358:	04090000 	.word	0x04090000
    635c:	031c0a07 	.word	0x031c0a07
    6360:	0121014f 	.word	0x0121014f
    6364:	430b0000 	.word	0x430b0000
    6368:	03004c52 	.word	0x03004c52
    636c:	00640150 	.word	0x00640150
    6370:	23020000 	.word	0x23020000
    6374:	52430b00 	.word	0x52430b00
    6378:	51030048 	.word	0x51030048
    637c:	00006401 	.word	0x00006401
    6380:	04230200 	.word	0x04230200
    6384:	5244490b 	.word	0x5244490b
    6388:	01520300 	.word	0x01520300
    638c:	00000064 	.word	0x00000064
    6390:	0b082302 	.word	0x0b082302
    6394:	0052444f 	.word	0x0052444f
    6398:	64015303 	.word	0x64015303
    639c:	02000000 	.word	0x02000000
    63a0:	7d0c0c23 	.word	0x7d0c0c23
    63a4:	0300002a 	.word	0x0300002a
    63a8:	00640154 	.word	0x00640154
    63ac:	23020000 	.word	0x23020000
    63b0:	52420b10 	.word	0x52420b10
    63b4:	55030052 	.word	0x55030052
    63b8:	00006401 	.word	0x00006401
    63bc:	14230200 	.word	0x14230200
    63c0:	002b270c 	.word	0x002b270c
    63c4:	01560300 	.word	0x01560300
    63c8:	00000064 	.word	0x00000064
    63cc:	00182302 	.word	0x00182302
    63d0:	0029e80d 	.word	0x0029e80d
    63d4:	01570300 	.word	0x01570300
    63d8:	000000ae 	.word	0x000000ae
    63dc:	002b050e 	.word	0x002b050e
    63e0:	70050800 	.word	0x70050800
    63e4:	00000156 	.word	0x00000156
    63e8:	002ae00f 	.word	0x002ae00f
    63ec:	56710500 	.word	0x56710500
    63f0:	02000001 	.word	0x02000001
    63f4:	70100023 	.word	0x70100023
    63f8:	05006e69 	.word	0x05006e69
    63fc:	00004172 	.word	0x00004172
    6400:	04230200 	.word	0x04230200
    6404:	21041100 	.word	0x21041100
    6408:	08000001 	.word	0x08000001
    640c:	00002b10 	.word	0x00002b10
    6410:	012d7305 	.word	0x012d7305
    6414:	01120000 	.word	0x01120000
    6418:	00002b91 	.word	0x00002b91
    641c:	d0011301 	.word	0xd0011301
    6420:	fc080054 	.word	0xfc080054
    6424:	61080054 	.word	0x61080054
    6428:	9f00002a 	.word	0x9f00002a
    642c:	13000001 	.word	0x13000001
    6430:	0064656c 	.word	0x0064656c
    6434:	00a01301 	.word	0x00a01301
    6438:	2a8c0000 	.word	0x2a8c0000
    643c:	8c140000 	.word	0x8c140000
    6440:	0100004b 	.word	0x0100004b
    6444:	00005313 	.word	0x00005313
    6448:	002aaa00 	.word	0x002aaa00
    644c:	5c150000 	.word	0x5c150000
    6450:	af000001 	.word	0xaf000001
    6454:	16000001 	.word	0x16000001
    6458:	000000ab 	.word	0x000000ab
    645c:	98170006 	.word	0x98170006
    6460:	0100002b 	.word	0x0100002b
    6464:	00019f0c 	.word	0x00019f0c
    6468:	03050100 	.word	0x03050100
    646c:	20000094 	.word	0x20000094
    6470:	00020d00 	.word	0x00020d00
    6474:	f5000200 	.word	0xf5000200
    6478:	04000019 	.word	0x04000019
    647c:	0001fe01 	.word	0x0001fe01
    6480:	2be70100 	.word	0x2be70100
    6484:	02490000 	.word	0x02490000
    6488:	54fc0000 	.word	0x54fc0000
    648c:	55460800 	.word	0x55460800
    6490:	19780800 	.word	0x19780800
    6494:	04020000 	.word	0x04020000
    6498:	00012205 	.word	0x00012205
    649c:	05020200 	.word	0x05020200
    64a0:	000004ca 	.word	0x000004ca
    64a4:	9e060102 	.word	0x9e060102
    64a8:	03000004 	.word	0x03000004
    64ac:	00323375 	.word	0x00323375
    64b0:	00452702 	.word	0x00452702
    64b4:	04020000 	.word	0x04020000
    64b8:	00013007 	.word	0x00013007
    64bc:	07020200 	.word	0x07020200
    64c0:	000001c5 	.word	0x000001c5
    64c4:	00387503 	.word	0x00387503
    64c8:	005d2902 	.word	0x005d2902
    64cc:	01020000 	.word	0x01020000
    64d0:	00049c08 	.word	0x00049c08
    64d4:	00450400 	.word	0x00450400
    64d8:	aa050000 	.word	0xaa050000
    64dc:	02000000 	.word	0x02000000
    64e0:	00fe0d04 	.word	0x00fe0d04
    64e4:	fa060000 	.word	0xfa060000
    64e8:	f2000003 	.word	0xf2000003
    64ec:	210601ee 	.word	0x210601ee
    64f0:	be000005 	.word	0xbe000005
    64f4:	a40601e1 	.word	0xa40601e1
    64f8:	be000005 	.word	0xbe000005
    64fc:	ac0601e1 	.word	0xac0601e1
    6500:	ea000002 	.word	0xea000002
    6504:	e10601d4 	.word	0xe10601d4
    6508:	f1000005 	.word	0xf1000005
    650c:	ad0601c8 	.word	0xad0601c8
    6510:	f1000006 	.word	0xf1000006
    6514:	070601c8 	.word	0x070601c8
    6518:	ce000004 	.word	0xce000004
    651c:	b80601bd 	.word	0xb80601bd
    6520:	fc000002 	.word	0xfc000002
    6524:	dc0601b2 	.word	0xdc0601b2
    6528:	f6000000 	.word	0xf6000000
    652c:	760601a8 	.word	0x760601a8
    6530:	f6000001 	.word	0xf6000001
    6534:	bf0601a8 	.word	0xbf0601a8
    6538:	b8000002 	.word	0xb8000002
    653c:	9f06019f 	.word	0x9f06019f
    6540:	bf000001 	.word	0xbf000001
    6544:	c6060196 	.word	0xc6060196
    6548:	bf000002 	.word	0xbf000002
    654c:	9e060196 	.word	0x9e060196
    6550:	86000002 	.word	0x86000002
    6554:	e006018e 	.word	0xe006018e
    6558:	89000002 	.word	0x89000002
    655c:	f2060186 	.word	0xf2060186
    6560:	89000003 	.word	0x89000003
    6564:	a5060186 	.word	0xa5060186
    6568:	c6000002 	.word	0xc6000002
    656c:	070000fe 	.word	0x070000fe
    6570:	00002baa 	.word	0x00002baa
    6574:	00692704 	.word	0x00692704
    6578:	04080000 	.word	0x04080000
    657c:	031c0907 	.word	0x031c0907
    6580:	017f014f 	.word	0x017f014f
    6584:	430a0000 	.word	0x430a0000
    6588:	03004c52 	.word	0x03004c52
    658c:	00640150 	.word	0x00640150
    6590:	23020000 	.word	0x23020000
    6594:	52430a00 	.word	0x52430a00
    6598:	51030048 	.word	0x51030048
    659c:	00006401 	.word	0x00006401
    65a0:	04230200 	.word	0x04230200
    65a4:	5244490a 	.word	0x5244490a
    65a8:	01520300 	.word	0x01520300
    65ac:	00000064 	.word	0x00000064
    65b0:	0a082302 	.word	0x0a082302
    65b4:	0052444f 	.word	0x0052444f
    65b8:	64015303 	.word	0x64015303
    65bc:	02000000 	.word	0x02000000
    65c0:	7d0b0c23 	.word	0x7d0b0c23
    65c4:	0300002a 	.word	0x0300002a
    65c8:	00640154 	.word	0x00640154
    65cc:	23020000 	.word	0x23020000
    65d0:	52420a10 	.word	0x52420a10
    65d4:	55030052 	.word	0x55030052
    65d8:	00006401 	.word	0x00006401
    65dc:	14230200 	.word	0x14230200
    65e0:	002b270b 	.word	0x002b270b
    65e4:	01560300 	.word	0x01560300
    65e8:	00000064 	.word	0x00000064
    65ec:	00182302 	.word	0x00182302
    65f0:	2be0010c 	.word	0x2be0010c
    65f4:	0e010000 	.word	0x0e010000
    65f8:	0054fc01 	.word	0x0054fc01
    65fc:	00553808 	.word	0x00553808
    6600:	002ac808 	.word	0x002ac808
    6604:	0001b700 	.word	0x0001b700
    6608:	2bb80d00 	.word	0x2bb80d00
    660c:	0e010000 	.word	0x0e010000
    6610:	0000003a 	.word	0x0000003a
    6614:	00002af3 	.word	0x00002af3
    6618:	002ba50d 	.word	0x002ba50d
    661c:	3a0e0100 	.word	0x3a0e0100
    6620:	06000000 	.word	0x06000000
    6624:	0000002b 	.word	0x0000002b
    6628:	2bc7010c 	.word	0x2bc7010c
    662c:	27010000 	.word	0x27010000
    6630:	00553801 	.word	0x00553801
    6634:	00554608 	.word	0x00554608
    6638:	002b2408 	.word	0x002b2408
    663c:	0001fe00 	.word	0x0001fe00
    6640:	2bb80d00 	.word	0x2bb80d00
    6644:	27010000 	.word	0x27010000
    6648:	0000003a 	.word	0x0000003a
    664c:	00002b4f 	.word	0x00002b4f
    6650:	002ba00d 	.word	0x002ba00d
    6654:	fe270100 	.word	0xfe270100
    6658:	62000000 	.word	0x62000000
    665c:	0d00002b 	.word	0x0d00002b
    6660:	00002bc0 	.word	0x00002bc0
    6664:	00532701 	.word	0x00532701
    6668:	2b750000 	.word	0x2b750000
    666c:	0e000000 	.word	0x0e000000
    6670:	00002bd0 	.word	0x00002bd0
    6674:	020b1c05 	.word	0x020b1c05
    6678:	01010000 	.word	0x01010000
    667c:	00003a04 	.word	0x00003a04
    6680:	02b00000 	.word	0x02b00000
    6684:	00020000 	.word	0x00020000
    6688:	00001ab8 	.word	0x00001ab8
    668c:	01fe0104 	.word	0x01fe0104
    6690:	1d010000 	.word	0x1d010000
    6694:	4900002c 	.word	0x4900002c
    6698:	48000002 	.word	0x48000002
    669c:	d8080055 	.word	0xd8080055
    66a0:	2a080057 	.word	0x2a080057
    66a4:	0200001a 	.word	0x0200001a
    66a8:	01220504 	.word	0x01220504
    66ac:	02020000 	.word	0x02020000
    66b0:	0004ca05 	.word	0x0004ca05
    66b4:	06010200 	.word	0x06010200
    66b8:	0000049e 	.word	0x0000049e
    66bc:	32337503 	.word	0x32337503
    66c0:	45270200 	.word	0x45270200
    66c4:	02000000 	.word	0x02000000
    66c8:	01300704 	.word	0x01300704
    66cc:	02020000 	.word	0x02020000
    66d0:	0001c507 	.word	0x0001c507
    66d4:	38750300 	.word	0x38750300
    66d8:	5d290200 	.word	0x5d290200
    66dc:	02000000 	.word	0x02000000
    66e0:	049c0801 	.word	0x049c0801
    66e4:	04040000 	.word	0x04040000
    66e8:	05290507 	.word	0x05290507
    66ec:	03010000 	.word	0x03010000
    66f0:	00009e0d 	.word	0x00009e0d
    66f4:	03ec0600 	.word	0x03ec0600
    66f8:	06000000 	.word	0x06000000
    66fc:	000014bb 	.word	0x000014bb
    6700:	00630601 	.word	0x00630601
    6704:	06020000 	.word	0x06020000
    6708:	000004aa 	.word	0x000004aa
    670c:	58540703 	.word	0x58540703
    6710:	07040044 	.word	0x07040044
    6714:	00445852 	.word	0x00445852
    6718:	55410705 	.word	0x55410705
    671c:	00060058 	.word	0x00060058
    6720:	2c870108 	.word	0x2c870108
    6724:	2e010000 	.word	0x2e010000
    6728:	00554801 	.word	0x00554801
    672c:	00558808 	.word	0x00558808
    6730:	c35d0108 	.word	0xc35d0108
    6734:	09000000 	.word	0x09000000
    6738:	00002bfa 	.word	0x00002bfa
    673c:	003a2e01 	.word	0x003a2e01
    6740:	50010000 	.word	0x50010000
    6744:	00010a00 	.word	0x00010a00
    6748:	0100002c 	.word	0x0100002c
    674c:	55880129 	.word	0x55880129
    6750:	559e0800 	.word	0x559e0800
    6754:	2b880800 	.word	0x2b880800
    6758:	00ec0000 	.word	0x00ec0000
    675c:	fa0b0000 	.word	0xfa0b0000
    6760:	0100002b 	.word	0x0100002b
    6764:	00003a29 	.word	0x00003a29
    6768:	002bb300 	.word	0x002bb300
    676c:	01080000 	.word	0x01080000
    6770:	00002cdc 	.word	0x00002cdc
    6774:	a0016701 	.word	0xa0016701
    6778:	c8080055 	.word	0xc8080055
    677c:	01080055 	.word	0x01080055
    6780:	0001115d 	.word	0x0001115d
    6784:	2bfa0900 	.word	0x2bfa0900
    6788:	67010000 	.word	0x67010000
    678c:	0000003a 	.word	0x0000003a
    6790:	08005001 	.word	0x08005001
    6794:	002ca501 	.word	0x002ca501
    6798:	017d0100 	.word	0x017d0100
    679c:	080055c8 	.word	0x080055c8
    67a0:	08005600 	.word	0x08005600
    67a4:	01365d01 	.word	0x01365d01
    67a8:	fa090000 	.word	0xfa090000
    67ac:	0100002b 	.word	0x0100002b
    67b0:	00003a7d 	.word	0x00003a7d
    67b4:	00500100 	.word	0x00500100
    67b8:	2cf30108 	.word	0x2cf30108
    67bc:	9c010000 	.word	0x9c010000
    67c0:	00560001 	.word	0x00560001
    67c4:	00563808 	.word	0x00563808
    67c8:	5b5d0108 	.word	0x5b5d0108
    67cc:	09000001 	.word	0x09000001
    67d0:	00002bfa 	.word	0x00002bfa
    67d4:	003a9c01 	.word	0x003a9c01
    67d8:	50010000 	.word	0x50010000
    67dc:	38010c00 	.word	0x38010c00
    67e0:	0100002c 	.word	0x0100002c
    67e4:	003a01bb 	.word	0x003a01bb
    67e8:	56380000 	.word	0x56380000
    67ec:	56500800 	.word	0x56500800
    67f0:	5d010800 	.word	0x5d010800
    67f4:	2c97010d 	.word	0x2c97010d
    67f8:	d1010000 	.word	0xd1010000
    67fc:	00565001 	.word	0x00565001
    6800:	00566008 	.word	0x00566008
    6804:	0e5d0108 	.word	0x0e5d0108
    6808:	002c0e01 	.word	0x002c0e01
    680c:	01d70100 	.word	0x01d70100
    6810:	08005660 	.word	0x08005660
    6814:	0800575c 	.word	0x0800575c
    6818:	00002bc6 	.word	0x00002bc6
    681c:	2c78010a 	.word	0x2c78010a
    6820:	4f010000 	.word	0x4f010000
    6824:	00575c01 	.word	0x00575c01
    6828:	00579408 	.word	0x00579408
    682c:	002be508 	.word	0x002be508
    6830:	0001c300 	.word	0x0001c300
    6834:	24050b00 	.word	0x24050b00
    6838:	4f010000 	.word	0x4f010000
    683c:	0000003a 	.word	0x0000003a
    6840:	00002c10 	.word	0x00002c10
    6844:	07010f00 	.word	0x07010f00
    6848:	0100002c 	.word	0x0100002c
    684c:	00003ac2 	.word	0x00003ac2
    6850:	00579400 	.word	0x00579400
    6854:	0057d808 	.word	0x0057d808
    6858:	002c2308 	.word	0x002c2308
    685c:	00020700 	.word	0x00020700
    6860:	736d1000 	.word	0x736d1000
    6864:	3ac30100 	.word	0x3ac30100
    6868:	01000000 	.word	0x01000000
    686c:	73751155 	.word	0x73751155
    6870:	3ac40100 	.word	0x3ac40100
    6874:	4e000000 	.word	0x4e000000
    6878:	1000002c 	.word	0x1000002c
    687c:	0032736d 	.word	0x0032736d
    6880:	003ac701 	.word	0x003ac701
    6884:	54010000 	.word	0x54010000
    6888:	2c551200 	.word	0x2c551200
    688c:	17010000 	.word	0x17010000
    6890:	00000219 	.word	0x00000219
    6894:	a8030501 	.word	0xa8030501
    6898:	13200011 	.word	0x13200011
    689c:	0000003a 	.word	0x0000003a
    68a0:	002c4212 	.word	0x002c4212
    68a4:	19180100 	.word	0x19180100
    68a8:	01000002 	.word	0x01000002
    68ac:	11ac0305 	.word	0x11ac0305
    68b0:	c8122000 	.word	0xc8122000
    68b4:	0100002c 	.word	0x0100002c
    68b8:	00021919 	.word	0x00021919
    68bc:	03050100 	.word	0x03050100
    68c0:	200011b0 	.word	0x200011b0
    68c4:	002c6412 	.word	0x002c6412
    68c8:	191a0100 	.word	0x191a0100
    68cc:	01000002 	.word	0x01000002
    68d0:	11b40305 	.word	0x11b40305
    68d4:	d0122000 	.word	0xd0122000
    68d8:	0100002b 	.word	0x0100002b
    68dc:	0002191b 	.word	0x0002191b
    68e0:	03050100 	.word	0x03050100
    68e4:	200011b8 	.word	0x200011b8
    68e8:	002d0512 	.word	0x002d0512
    68ec:	781c0100 	.word	0x781c0100
    68f0:	01000002 	.word	0x01000002
    68f4:	11bc0305 	.word	0x11bc0305
    68f8:	53132000 	.word	0x53132000
    68fc:	12000000 	.word	0x12000000
    6900:	00002c90 	.word	0x00002c90
    6904:	02191d01 	.word	0x02191d01
    6908:	05010000 	.word	0x05010000
    690c:	0011c003 	.word	0x0011c003
    6910:	2c8e1220 	.word	0x2c8e1220
    6914:	1e010000 	.word	0x1e010000
    6918:	00000219 	.word	0x00000219
    691c:	c4030501 	.word	0xc4030501
    6920:	12200011 	.word	0x12200011
    6924:	00002cb7 	.word	0x00002cb7
    6928:	02191f01 	.word	0x02191f01
    692c:	05010000 	.word	0x05010000
    6930:	0011a403 	.word	0x0011a403
    6934:	05a70020 	.word	0x05a70020
    6938:	00020000 	.word	0x00020000
    693c:	00001be8 	.word	0x00001be8
    6940:	01fe0104 	.word	0x01fe0104
    6944:	63010000 	.word	0x63010000
    6948:	4900002d 	.word	0x4900002d
    694c:	d8000002 	.word	0xd8000002
    6950:	2c080057 	.word	0x2c080057
    6954:	2e08005c 	.word	0x2e08005c
    6958:	0200001b 	.word	0x0200001b
    695c:	01220504 	.word	0x01220504
    6960:	02020000 	.word	0x02020000
    6964:	0004ca05 	.word	0x0004ca05
    6968:	06010200 	.word	0x06010200
    696c:	0000049e 	.word	0x0000049e
    6970:	32337503 	.word	0x32337503
    6974:	45270200 	.word	0x45270200
    6978:	02000000 	.word	0x02000000
    697c:	01300704 	.word	0x01300704
    6980:	75030000 	.word	0x75030000
    6984:	02003631 	.word	0x02003631
    6988:	00005728 	.word	0x00005728
    698c:	07020200 	.word	0x07020200
    6990:	000001c5 	.word	0x000001c5
    6994:	00387503 	.word	0x00387503
    6998:	00682902 	.word	0x00682902
    699c:	01020000 	.word	0x01020000
    69a0:	00049c08 	.word	0x00049c08
    69a4:	00450400 	.word	0x00450400
    69a8:	01050000 	.word	0x01050000
    69ac:	00893a02 	.word	0x00893a02
    69b0:	f2060000 	.word	0xf2060000
    69b4:	0000000e 	.word	0x0000000e
    69b8:	54455307 	.word	0x54455307
    69bc:	05000100 	.word	0x05000100
    69c0:	9e3c0201 	.word	0x9e3c0201
    69c4:	06000000 	.word	0x06000000
    69c8:	00002a70 	.word	0x00002a70
    69cc:	046e0600 	.word	0x046e0600
    69d0:	00010000 	.word	0x00010000
    69d4:	002f7108 	.word	0x002f7108
    69d8:	893c0200 	.word	0x893c0200
    69dc:	05000000 	.word	0x05000000
    69e0:	be3f0201 	.word	0xbe3f0201
    69e4:	06000000 	.word	0x06000000
    69e8:	00000506 	.word	0x00000506
    69ec:	04c20600 	.word	0x04c20600
    69f0:	00010000 	.word	0x00010000
    69f4:	002e1408 	.word	0x002e1408
    69f8:	a93f0200 	.word	0xa93f0200
    69fc:	09000000 	.word	0x09000000
    6a00:	e8250350 	.word	0xe8250350
    6a04:	0a000001 	.word	0x0a000001
    6a08:	03005253 	.word	0x03005253
    6a0c:	00006f26 	.word	0x00006f26
    6a10:	00230200 	.word	0x00230200
    6a14:	3152430a 	.word	0x3152430a
    6a18:	6f270300 	.word	0x6f270300
    6a1c:	02000000 	.word	0x02000000
    6a20:	430a0423 	.word	0x430a0423
    6a24:	03003252 	.word	0x03003252
    6a28:	00006f28 	.word	0x00006f28
    6a2c:	08230200 	.word	0x08230200
    6a30:	002b1b0b 	.word	0x002b1b0b
    6a34:	6f290300 	.word	0x6f290300
    6a38:	02000000 	.word	0x02000000
    6a3c:	210b0c23 	.word	0x210b0c23
    6a40:	0300002b 	.word	0x0300002b
    6a44:	00006f2a 	.word	0x00006f2a
    6a48:	10230200 	.word	0x10230200
    6a4c:	002a8a0b 	.word	0x002a8a0b
    6a50:	6f2b0300 	.word	0x6f2b0300
    6a54:	02000000 	.word	0x02000000
    6a58:	900b1423 	.word	0x900b1423
    6a5c:	0300002a 	.word	0x0300002a
    6a60:	00006f2c 	.word	0x00006f2c
    6a64:	18230200 	.word	0x18230200
    6a68:	002ab10b 	.word	0x002ab10b
    6a6c:	6f2d0300 	.word	0x6f2d0300
    6a70:	02000000 	.word	0x02000000
    6a74:	bf0b1c23 	.word	0xbf0b1c23
    6a78:	0300002a 	.word	0x0300002a
    6a7c:	00006f2e 	.word	0x00006f2e
    6a80:	20230200 	.word	0x20230200
    6a84:	5254480a 	.word	0x5254480a
    6a88:	6f2f0300 	.word	0x6f2f0300
    6a8c:	02000000 	.word	0x02000000
    6a90:	4c0a2423 	.word	0x4c0a2423
    6a94:	03005254 	.word	0x03005254
    6a98:	00006f30 	.word	0x00006f30
    6a9c:	28230200 	.word	0x28230200
    6aa0:	002aee0b 	.word	0x002aee0b
    6aa4:	6f310300 	.word	0x6f310300
    6aa8:	02000000 	.word	0x02000000
    6aac:	f30b2c23 	.word	0xf30b2c23
    6ab0:	0300002a 	.word	0x0300002a
    6ab4:	00006f32 	.word	0x00006f32
    6ab8:	30230200 	.word	0x30230200
    6abc:	002af80b 	.word	0x002af80b
    6ac0:	6f330300 	.word	0x6f330300
    6ac4:	02000000 	.word	0x02000000
    6ac8:	3a0b3423 	.word	0x3a0b3423
    6acc:	0300002a 	.word	0x0300002a
    6ad0:	00006f34 	.word	0x00006f34
    6ad4:	38230200 	.word	0x38230200
    6ad8:	002a780b 	.word	0x002a780b
    6adc:	6f350300 	.word	0x6f350300
    6ae0:	02000000 	.word	0x02000000
    6ae4:	fc0b3c23 	.word	0xfc0b3c23
    6ae8:	03000029 	.word	0x03000029
    6aec:	00006f36 	.word	0x00006f36
    6af0:	40230200 	.word	0x40230200
    6af4:	002a010b 	.word	0x002a010b
    6af8:	6f370300 	.word	0x6f370300
    6afc:	02000000 	.word	0x02000000
    6b00:	060b4423 	.word	0x060b4423
    6b04:	0300002a 	.word	0x0300002a
    6b08:	00006f38 	.word	0x00006f38
    6b0c:	48230200 	.word	0x48230200
    6b10:	0052440a 	.word	0x0052440a
    6b14:	006f3903 	.word	0x006f3903
    6b18:	23020000 	.word	0x23020000
    6b1c:	040c004c 	.word	0x040c004c
    6b20:	031c0d07 	.word	0x031c0d07
    6b24:	025e014f 	.word	0x025e014f
    6b28:	430e0000 	.word	0x430e0000
    6b2c:	03004c52 	.word	0x03004c52
    6b30:	006f0150 	.word	0x006f0150
    6b34:	23020000 	.word	0x23020000
    6b38:	52430e00 	.word	0x52430e00
    6b3c:	51030048 	.word	0x51030048
    6b40:	00006f01 	.word	0x00006f01
    6b44:	04230200 	.word	0x04230200
    6b48:	5244490e 	.word	0x5244490e
    6b4c:	01520300 	.word	0x01520300
    6b50:	0000006f 	.word	0x0000006f
    6b54:	0e082302 	.word	0x0e082302
    6b58:	0052444f 	.word	0x0052444f
    6b5c:	6f015303 	.word	0x6f015303
    6b60:	02000000 	.word	0x02000000
    6b64:	7d0f0c23 	.word	0x7d0f0c23
    6b68:	0300002a 	.word	0x0300002a
    6b6c:	006f0154 	.word	0x006f0154
    6b70:	23020000 	.word	0x23020000
    6b74:	52420e10 	.word	0x52420e10
    6b78:	55030052 	.word	0x55030052
    6b7c:	00006f01 	.word	0x00006f01
    6b80:	14230200 	.word	0x14230200
    6b84:	002b270f 	.word	0x002b270f
    6b88:	01560300 	.word	0x01560300
    6b8c:	0000006f 	.word	0x0000006f
    6b90:	00182302 	.word	0x00182302
    6b94:	23040105 	.word	0x23040105
    6b98:	00000279 	.word	0x00000279
    6b9c:	002e2006 	.word	0x002e2006
    6ba0:	3a060100 	.word	0x3a060100
    6ba4:	0200002e 	.word	0x0200002e
    6ba8:	002e9b06 	.word	0x002e9b06
    6bac:	08000300 	.word	0x08000300
    6bb0:	00002f5f 	.word	0x00002f5f
    6bb4:	025e2704 	.word	0x025e2704
    6bb8:	01050000 	.word	0x01050000
    6bbc:	02be2e04 	.word	0x02be2e04
    6bc0:	1b060000 	.word	0x1b060000
    6bc4:	0000002f 	.word	0x0000002f
    6bc8:	002fcc06 	.word	0x002fcc06
    6bcc:	8d060400 	.word	0x8d060400
    6bd0:	2800002e 	.word	0x2800002e
    6bd4:	002ef806 	.word	0x002ef806
    6bd8:	0600c800 	.word	0x0600c800
    6bdc:	00002dbd 	.word	0x00002dbd
    6be0:	2f920614 	.word	0x2f920614
    6be4:	06100000 	.word	0x06100000
    6be8:	00002fe2 	.word	0x00002fe2
    6bec:	2dce061c 	.word	0x2dce061c
    6bf0:	00180000 	.word	0x00180000
    6bf4:	002d5208 	.word	0x002d5208
    6bf8:	84360400 	.word	0x84360400
    6bfc:	09000002 	.word	0x09000002
    6c00:	fc3f0404 	.word	0xfc3f0404
    6c04:	0b000002 	.word	0x0b000002
    6c08:	00002d14 	.word	0x00002d14
    6c0c:	004c4004 	.word	0x004c4004
    6c10:	23020000 	.word	0x23020000
    6c14:	2d8f0b00 	.word	0x2d8f0b00
    6c18:	41040000 	.word	0x41040000
    6c1c:	00000279 	.word	0x00000279
    6c20:	0b022302 	.word	0x0b022302
    6c24:	00002ff2 	.word	0x00002ff2
    6c28:	02be4204 	.word	0x02be4204
    6c2c:	23020000 	.word	0x23020000
    6c30:	5d080003 	.word	0x5d080003
    6c34:	0400002e 	.word	0x0400002e
    6c38:	0002c943 	.word	0x0002c943
    6c3c:	05040900 	.word	0x05040900
    6c40:	0003481b 	.word	0x0003481b
    6c44:	2ed60b00 	.word	0x2ed60b00
    6c48:	1c050000 	.word	0x1c050000
    6c4c:	0000005e 	.word	0x0000005e
    6c50:	0b002302 	.word	0x0b002302
    6c54:	00002f3d 	.word	0x00002f3d
    6c58:	005e1d05 	.word	0x005e1d05
    6c5c:	23020000 	.word	0x23020000
    6c60:	2da20b01 	.word	0x2da20b01
    6c64:	1e050000 	.word	0x1e050000
    6c68:	0000005e 	.word	0x0000005e
    6c6c:	0b022302 	.word	0x0b022302
    6c70:	00002d2f 	.word	0x00002d2f
    6c74:	009e1f05 	.word	0x009e1f05
    6c78:	23020000 	.word	0x23020000
    6c7c:	81080003 	.word	0x81080003
    6c80:	0500002f 	.word	0x0500002f
    6c84:	00030720 	.word	0x00030720
    6c88:	06140900 	.word	0x06140900
    6c8c:	0003b01b 	.word	0x0003b01b
    6c90:	2e310b00 	.word	0x2e310b00
    6c94:	1c060000 	.word	0x1c060000
    6c98:	0000003a 	.word	0x0000003a
    6c9c:	0b002302 	.word	0x0b002302
    6ca0:	00002d7e 	.word	0x00002d7e
    6ca4:	009e1d06 	.word	0x009e1d06
    6ca8:	23020000 	.word	0x23020000
    6cac:	2ebf0b04 	.word	0x2ebf0b04
    6cb0:	1e060000 	.word	0x1e060000
    6cb4:	0000009e 	.word	0x0000009e
    6cb8:	0b052302 	.word	0x0b052302
    6cbc:	00002f06 	.word	0x00002f06
    6cc0:	003a1f06 	.word	0x003a1f06
    6cc4:	23020000 	.word	0x23020000
    6cc8:	2e7f0b08 	.word	0x2e7f0b08
    6ccc:	20060000 	.word	0x20060000
    6cd0:	0000003a 	.word	0x0000003a
    6cd4:	0b0c2302 	.word	0x0b0c2302
    6cd8:	00002e6e 	.word	0x00002e6e
    6cdc:	005e2106 	.word	0x005e2106
    6ce0:	23020000 	.word	0x23020000
    6ce4:	42080010 	.word	0x42080010
    6ce8:	0600002d 	.word	0x0600002d
    6cec:	00035322 	.word	0x00035322
    6cf0:	05080200 	.word	0x05080200
    6cf4:	0000011d 	.word	0x0000011d
    6cf8:	2b070802 	.word	0x2b070802
    6cfc:	10000001 	.word	0x10000001
    6d00:	6e690504 	.word	0x6e690504
    6d04:	04020074 	.word	0x04020074
    6d08:	00013507 	.word	0x00013507
    6d0c:	29011100 	.word	0x29011100
    6d10:	0100002f 	.word	0x0100002f
    6d14:	57d8014f 	.word	0x57d8014f
    6d18:	58180800 	.word	0x58180800
    6d1c:	2c610800 	.word	0x2c610800
    6d20:	03fd0000 	.word	0x03fd0000
    6d24:	08120000 	.word	0x08120000
    6d28:	0100001e 	.word	0x0100001e
    6d2c:	004c0150 	.word	0x004c0150
    6d30:	13000000 	.word	0x13000000
    6d34:	002fb601 	.word	0x002fb601
    6d38:	01360100 	.word	0x01360100
    6d3c:	00581801 	.word	0x00581801
    6d40:	00583c08 	.word	0x00583c08
    6d44:	002c8c08 	.word	0x002c8c08
    6d48:	e6011400 	.word	0xe6011400
    6d4c:	0100002e 	.word	0x0100002e
    6d50:	583c01f1 	.word	0x583c01f1
    6d54:	59240800 	.word	0x59240800
    6d58:	2cb70800 	.word	0x2cb70800
    6d5c:	043b0000 	.word	0x043b0000
    6d60:	1d150000 	.word	0x1d150000
    6d64:	0100002d 	.word	0x0100002d
    6d68:	0003b0f2 	.word	0x0003b0f2
    6d6c:	5c910200 	.word	0x5c910200
    6d70:	4a011400 	.word	0x4a011400
    6d74:	0100002e 	.word	0x0100002e
    6d78:	59240195 	.word	0x59240195
    6d7c:	5afc0800 	.word	0x5afc0800
    6d80:	2ce20800 	.word	0x2ce20800
    6d84:	04630000 	.word	0x04630000
    6d88:	a3150000 	.word	0xa3150000
    6d8c:	0100002f 	.word	0x0100002f
    6d90:	0002fc96 	.word	0x0002fc96
    6d94:	64910200 	.word	0x64910200
    6d98:	ef011400 	.word	0xef011400
    6d9c:	0100002d 	.word	0x0100002d
    6da0:	5afc016f 	.word	0x5afc016f
    6da4:	5b6a0800 	.word	0x5b6a0800
    6da8:	2d0d0800 	.word	0x2d0d0800
    6dac:	048b0000 	.word	0x048b0000
    6db0:	ac150000 	.word	0xac150000
    6db4:	0100002e 	.word	0x0100002e
    6db8:	00034870 	.word	0x00034870
    6dbc:	6c910200 	.word	0x6c910200
    6dc0:	02011400 	.word	0x02011400
    6dc4:	0100002e 	.word	0x0100002e
    6dc8:	5b6c012a 	.word	0x5b6c012a
    6dcc:	5c000800 	.word	0x5c000800
    6dd0:	2d380800 	.word	0x2d380800
    6dd4:	04b00000 	.word	0x04b00000
    6dd8:	de160000 	.word	0xde160000
    6ddc:	0100002d 	.word	0x0100002d
    6de0:	0000be2b 	.word	0x0000be2b
    6de4:	01170000 	.word	0x01170000
    6de8:	00002d9a 	.word	0x00002d9a
    6dec:	5c001101 	.word	0x5c001101
    6df0:	5c2c0800 	.word	0x5c2c0800
    6df4:	2d630800 	.word	0x2d630800
    6df8:	69150000 	.word	0x69150000
    6dfc:	07000005 	.word	0x07000005
    6e00:	0004d52a 	.word	0x0004d52a
    6e04:	c8030500 	.word	0xc8030500
    6e08:	04200011 	.word	0x04200011
    6e0c:	0000005e 	.word	0x0000005e
    6e10:	0002ce16 	.word	0x0002ce16
    6e14:	e5280700 	.word	0xe5280700
    6e18:	04000004 	.word	0x04000004
    6e1c:	0000004c 	.word	0x0000004c
    6e20:	00042b16 	.word	0x00042b16
    6e24:	e5280700 	.word	0xe5280700
    6e28:	18000004 	.word	0x18000004
    6e2c:	0000005e 	.word	0x0000005e
    6e30:	00000506 	.word	0x00000506
    6e34:	0001e819 	.word	0x0001e819
    6e38:	0003ff00 	.word	0x0003ff00
    6e3c:	0004af16 	.word	0x0004af16
    6e40:	11290700 	.word	0x11290700
    6e44:	04000005 	.word	0x04000005
    6e48:	000004f5 	.word	0x000004f5
    6e4c:	00064a1a 	.word	0x00064a1a
    6e50:	d5440700 	.word	0xd5440700
    6e54:	00000004 	.word	0x00000004
    6e58:	00040e1a 	.word	0x00040e1a
    6e5c:	d5440700 	.word	0xd5440700
    6e60:	00000004 	.word	0x00000004
    6e64:	00005e18 	.word	0x00005e18
    6e68:	00053e00 	.word	0x00053e00
    6e6c:	01e81b00 	.word	0x01e81b00
    6e70:	00400000 	.word	0x00400000
    6e74:	0000ec16 	.word	0x0000ec16
    6e78:	49450700 	.word	0x49450700
    6e7c:	04000005 	.word	0x04000005
    6e80:	0000052e 	.word	0x0000052e
    6e84:	0006191a 	.word	0x0006191a
    6e88:	e5580700 	.word	0xe5580700
    6e8c:	00000004 	.word	0x00000004
    6e90:	0000f91a 	.word	0x0000f91a
    6e94:	e5580700 	.word	0xe5580700
    6e98:	00000004 	.word	0x00000004
    6e9c:	00032d16 	.word	0x00032d16
    6ea0:	71590700 	.word	0x71590700
    6ea4:	04000005 	.word	0x04000005
    6ea8:	000004f5 	.word	0x000004f5
    6eac:	0006ce1c 	.word	0x0006ce1c
    6eb0:	3a140700 	.word	0x3a140700
    6eb4:	01000000 	.word	0x01000000
    6eb8:	00051c01 	.word	0x00051c01
    6ebc:	17070000 	.word	0x17070000
    6ec0:	0000003a 	.word	0x0000003a
    6ec4:	561c0101 	.word	0x561c0101
    6ec8:	07000000 	.word	0x07000000
    6ecc:	00003a1a 	.word	0x00003a1a
    6ed0:	1c010100 	.word	0x1c010100
    6ed4:	00002d05 	.word	0x00002d05
    6ed8:	04d52008 	.word	0x04d52008
    6edc:	01010000 	.word	0x01010000
    6ee0:	0007e900 	.word	0x0007e900
    6ee4:	69000200 	.word	0x69000200
    6ee8:	0400001d 	.word	0x0400001d
    6eec:	0001fe01 	.word	0x0001fe01
    6ef0:	31be0100 	.word	0x31be0100
    6ef4:	02490000 	.word	0x02490000
    6ef8:	5c2c0000 	.word	0x5c2c0000
    6efc:	62100800 	.word	0x62100800
    6f00:	1d1f0800 	.word	0x1d1f0800
    6f04:	04020000 	.word	0x04020000
    6f08:	00012205 	.word	0x00012205
    6f0c:	05020200 	.word	0x05020200
    6f10:	000004ca 	.word	0x000004ca
    6f14:	9e060102 	.word	0x9e060102
    6f18:	03000004 	.word	0x03000004
    6f1c:	00323375 	.word	0x00323375
    6f20:	00452702 	.word	0x00452702
    6f24:	04020000 	.word	0x04020000
    6f28:	00013007 	.word	0x00013007
    6f2c:	31750300 	.word	0x31750300
    6f30:	28020036 	.word	0x28020036
    6f34:	00000057 	.word	0x00000057
    6f38:	c5070202 	.word	0xc5070202
    6f3c:	03000001 	.word	0x03000001
    6f40:	02003875 	.word	0x02003875
    6f44:	00006829 	.word	0x00006829
    6f48:	08010200 	.word	0x08010200
    6f4c:	0000049c 	.word	0x0000049c
    6f50:	00004504 	.word	0x00004504
    6f54:	00570400 	.word	0x00570400
    6f58:	01050000 	.word	0x01050000
    6f5c:	008e3a02 	.word	0x008e3a02
    6f60:	f2060000 	.word	0xf2060000
    6f64:	0000000e 	.word	0x0000000e
    6f68:	54455307 	.word	0x54455307
    6f6c:	05000100 	.word	0x05000100
    6f70:	a33c0201 	.word	0xa33c0201
    6f74:	06000000 	.word	0x06000000
    6f78:	00002a70 	.word	0x00002a70
    6f7c:	046e0600 	.word	0x046e0600
    6f80:	00010000 	.word	0x00010000
    6f84:	09070408 	.word	0x09070408
    6f88:	014f031c 	.word	0x014f031c
    6f8c:	00000119 	.word	0x00000119
    6f90:	4c52430a 	.word	0x4c52430a
    6f94:	01500300 	.word	0x01500300
    6f98:	0000006f 	.word	0x0000006f
    6f9c:	0a002302 	.word	0x0a002302
    6fa0:	00485243 	.word	0x00485243
    6fa4:	6f015103 	.word	0x6f015103
    6fa8:	02000000 	.word	0x02000000
    6fac:	490a0423 	.word	0x490a0423
    6fb0:	03005244 	.word	0x03005244
    6fb4:	006f0152 	.word	0x006f0152
    6fb8:	23020000 	.word	0x23020000
    6fbc:	444f0a08 	.word	0x444f0a08
    6fc0:	53030052 	.word	0x53030052
    6fc4:	00006f01 	.word	0x00006f01
    6fc8:	0c230200 	.word	0x0c230200
    6fcc:	002a7d0b 	.word	0x002a7d0b
    6fd0:	01540300 	.word	0x01540300
    6fd4:	0000006f 	.word	0x0000006f
    6fd8:	0a102302 	.word	0x0a102302
    6fdc:	00525242 	.word	0x00525242
    6fe0:	6f015503 	.word	0x6f015503
    6fe4:	02000000 	.word	0x02000000
    6fe8:	270b1423 	.word	0x270b1423
    6fec:	0300002b 	.word	0x0300002b
    6ff0:	006f0156 	.word	0x006f0156
    6ff4:	23020000 	.word	0x23020000
    6ff8:	1c090018 	.word	0x1c090018
    6ffc:	f3023903 	.word	0xf3023903
    7000:	0a000001 	.word	0x0a000001
    7004:	03005253 	.word	0x03005253
    7008:	0074023a 	.word	0x0074023a
    700c:	23020000 	.word	0x23020000
    7010:	31d30b00 	.word	0x31d30b00
    7014:	3b030000 	.word	0x3b030000
    7018:	00004c02 	.word	0x00004c02
    701c:	02230200 	.word	0x02230200
    7020:	0052440a 	.word	0x0052440a
    7024:	74023c03 	.word	0x74023c03
    7028:	02000000 	.word	0x02000000
    702c:	930b0423 	.word	0x930b0423
    7030:	03000030 	.word	0x03000030
    7034:	004c023d 	.word	0x004c023d
    7038:	23020000 	.word	0x23020000
    703c:	52420a06 	.word	0x52420a06
    7040:	3e030052 	.word	0x3e030052
    7044:	00007402 	.word	0x00007402
    7048:	08230200 	.word	0x08230200
    704c:	0031dd0b 	.word	0x0031dd0b
    7050:	023f0300 	.word	0x023f0300
    7054:	0000004c 	.word	0x0000004c
    7058:	0a0a2302 	.word	0x0a0a2302
    705c:	00315243 	.word	0x00315243
    7060:	74024003 	.word	0x74024003
    7064:	02000000 	.word	0x02000000
    7068:	e70b0c23 	.word	0xe70b0c23
    706c:	03000031 	.word	0x03000031
    7070:	004c0241 	.word	0x004c0241
    7074:	23020000 	.word	0x23020000
    7078:	52430a0e 	.word	0x52430a0e
    707c:	42030032 	.word	0x42030032
    7080:	00007402 	.word	0x00007402
    7084:	10230200 	.word	0x10230200
    7088:	0031f10b 	.word	0x0031f10b
    708c:	02430300 	.word	0x02430300
    7090:	0000004c 	.word	0x0000004c
    7094:	0a122302 	.word	0x0a122302
    7098:	00335243 	.word	0x00335243
    709c:	74024403 	.word	0x74024403
    70a0:	02000000 	.word	0x02000000
    70a4:	fb0b1423 	.word	0xfb0b1423
    70a8:	03000031 	.word	0x03000031
    70ac:	004c0245 	.word	0x004c0245
    70b0:	23020000 	.word	0x23020000
    70b4:	31570b16 	.word	0x31570b16
    70b8:	46030000 	.word	0x46030000
    70bc:	00007402 	.word	0x00007402
    70c0:	18230200 	.word	0x18230200
    70c4:	0032050b 	.word	0x0032050b
    70c8:	02470300 	.word	0x02470300
    70cc:	0000004c 	.word	0x0000004c
    70d0:	001a2302 	.word	0x001a2302
    70d4:	1b04100c 	.word	0x1b04100c
    70d8:	00000250 	.word	0x00000250
    70dc:	0030db0d 	.word	0x0030db0d
    70e0:	3a1c0400 	.word	0x3a1c0400
    70e4:	02000000 	.word	0x02000000
    70e8:	ba0d0023 	.word	0xba0d0023
    70ec:	04000030 	.word	0x04000030
    70f0:	00004c1d 	.word	0x00004c1d
    70f4:	04230200 	.word	0x04230200
    70f8:	0030770d 	.word	0x0030770d
    70fc:	4c1e0400 	.word	0x4c1e0400
    7100:	02000000 	.word	0x02000000
    7104:	4a0d0623 	.word	0x4a0d0623
    7108:	04000031 	.word	0x04000031
    710c:	00004c1f 	.word	0x00004c1f
    7110:	08230200 	.word	0x08230200
    7114:	0031b30d 	.word	0x0031b30d
    7118:	4c200400 	.word	0x4c200400
    711c:	02000000 	.word	0x02000000
    7120:	990d0a23 	.word	0x990d0a23
    7124:	04000031 	.word	0x04000031
    7128:	00004c21 	.word	0x00004c21
    712c:	0c230200 	.word	0x0c230200
    7130:	324e0e00 	.word	0x324e0e00
    7134:	22040000 	.word	0x22040000
    7138:	000001f3 	.word	0x000001f3
    713c:	0005290f 	.word	0x0005290f
    7140:	0d070100 	.word	0x0d070100
    7144:	00000292 	.word	0x00000292
    7148:	0003ec06 	.word	0x0003ec06
    714c:	bb060000 	.word	0xbb060000
    7150:	01000014 	.word	0x01000014
    7154:	00006306 	.word	0x00006306
    7158:	aa060200 	.word	0xaa060200
    715c:	03000004 	.word	0x03000004
    7160:	44585407 	.word	0x44585407
    7164:	52070400 	.word	0x52070400
    7168:	05004458 	.word	0x05004458
    716c:	58554107 	.word	0x58554107
    7170:	10000600 	.word	0x10000600
    7174:	00320f01 	.word	0x00320f01
    7178:	019d0100 	.word	0x019d0100
    717c:	cb011101 	.word	0xcb011101
    7180:	01000030 	.word	0x01000030
    7184:	005e0146 	.word	0x005e0146
    7188:	5c2c0000 	.word	0x5c2c0000
    718c:	5c400800 	.word	0x5c400800
    7190:	5d010800 	.word	0x5d010800
    7194:	30f90112 	.word	0x30f90112
    7198:	5a010000 	.word	0x5a010000
    719c:	00005e01 	.word	0x00005e01
    71a0:	005c4000 	.word	0x005c4000
    71a4:	005c7c08 	.word	0x005c7c08
    71a8:	de5d0108 	.word	0xde5d0108
    71ac:	13000002 	.word	0x13000002
    71b0:	00004eb0 	.word	0x00004eb0
    71b4:	005e5e01 	.word	0x005e5e01
    71b8:	2d8e0000 	.word	0x2d8e0000
    71bc:	12000000 	.word	0x12000000
    71c0:	00309d01 	.word	0x00309d01
    71c4:	01680100 	.word	0x01680100
    71c8:	0000005e 	.word	0x0000005e
    71cc:	08005c7c 	.word	0x08005c7c
    71d0:	08005ca4 	.word	0x08005ca4
    71d4:	03095d01 	.word	0x03095d01
    71d8:	b0130000 	.word	0xb0130000
    71dc:	0100004e 	.word	0x0100004e
    71e0:	00005e6c 	.word	0x00005e6c
    71e4:	002dac00 	.word	0x002dac00
    71e8:	92140000 	.word	0x92140000
    71ec:	a4000002 	.word	0xa4000002
    71f0:	bc08005c 	.word	0xbc08005c
    71f4:	0108005c 	.word	0x0108005c
    71f8:	ea01125d 	.word	0xea01125d
    71fc:	01000030 	.word	0x01000030
    7200:	005e01a4 	.word	0x005e01a4
    7204:	5cbc0000 	.word	0x5cbc0000
    7208:	5d040800 	.word	0x5d040800
    720c:	5d010800 	.word	0x5d010800
    7210:	00000343 	.word	0x00000343
    7214:	00029215 	.word	0x00029215
    7218:	005cc800 	.word	0x005cc800
    721c:	005cd408 	.word	0x005cd408
    7220:	00a70108 	.word	0x00a70108
    7224:	32430116 	.word	0x32430116
    7228:	83010000 	.word	0x83010000
    722c:	005e0101 	.word	0x005e0101
    7230:	5d040000 	.word	0x5d040000
    7234:	5d580800 	.word	0x5d580800
    7238:	2dca0800 	.word	0x2dca0800
    723c:	03900000 	.word	0x03900000
    7240:	4f170000 	.word	0x4f170000
    7244:	01000030 	.word	0x01000030
    7248:	03900182 	.word	0x03900182
    724c:	2df50000 	.word	0x2df50000
    7250:	82170000 	.word	0x82170000
    7254:	01000031 	.word	0x01000031
    7258:	005e0182 	.word	0x005e0182
    725c:	2e130000 	.word	0x2e130000
    7260:	69180000 	.word	0x69180000
    7264:	01840100 	.word	0x01840100
    7268:	0000005e 	.word	0x0000005e
    726c:	00002e31 	.word	0x00002e31
    7270:	5e041900 	.word	0x5e041900
    7274:	1a000000 	.word	0x1a000000
    7278:	00315c01 	.word	0x00315c01
    727c:	01e70100 	.word	0x01e70100
    7280:	005d5801 	.word	0x005d5801
    7284:	005d8408 	.word	0x005d8408
    7288:	b95d0108 	.word	0xb95d0108
    728c:	1b000003 	.word	0x1b000003
    7290:	e9010069 	.word	0xe9010069
    7294:	00004c01 	.word	0x00004c01
    7298:	01160000 	.word	0x01160000
    729c:	00003177 	.word	0x00003177
    72a0:	01020701 	.word	0x01020701
    72a4:	0000005e 	.word	0x0000005e
    72a8:	08005d84 	.word	0x08005d84
    72ac:	08005de0 	.word	0x08005de0
    72b0:	00002e44 	.word	0x00002e44
    72b4:	00000406 	.word	0x00000406
    72b8:	00304f17 	.word	0x00304f17
    72bc:	02070100 	.word	0x02070100
    72c0:	00000390 	.word	0x00000390
    72c4:	00002e6f 	.word	0x00002e6f
    72c8:	00318217 	.word	0x00318217
    72cc:	02070100 	.word	0x02070100
    72d0:	0000005e 	.word	0x0000005e
    72d4:	00002e8d 	.word	0x00002e8d
    72d8:	01006918 	.word	0x01006918
    72dc:	005e0208 	.word	0x005e0208
    72e0:	2eab0000 	.word	0x2eab0000
    72e4:	1c000000 	.word	0x1c000000
    72e8:	00321f01 	.word	0x00321f01
    72ec:	021b0100 	.word	0x021b0100
    72f0:	00005e01 	.word	0x00005e01
    72f4:	005de000 	.word	0x005de000
    72f8:	005df408 	.word	0x005df408
    72fc:	1d5d0108 	.word	0x1d5d0108
    7300:	00301001 	.word	0x00301001
    7304:	02230100 	.word	0x02230100
    7308:	005df401 	.word	0x005df401
    730c:	005e6c08 	.word	0x005e6c08
    7310:	002ebe08 	.word	0x002ebe08
    7314:	00044700 	.word	0x00044700
    7318:	19981e00 	.word	0x19981e00
    731c:	24010000 	.word	0x24010000
    7320:	00005e02 	.word	0x00005e02
    7324:	00500100 	.word	0x00500100
    7328:	322f011d 	.word	0x322f011d
    732c:	16010000 	.word	0x16010000
    7330:	5e6c0102 	.word	0x5e6c0102
    7334:	5e7e0800 	.word	0x5e7e0800
    7338:	2ee90800 	.word	0x2ee90800
    733c:	04720000 	.word	0x04720000
    7340:	20170000 	.word	0x20170000
    7344:	01000031 	.word	0x01000031
    7348:	005e0216 	.word	0x005e0216
    734c:	2f140000 	.word	0x2f140000
    7350:	16000000 	.word	0x16000000
    7354:	00303601 	.word	0x00303601
    7358:	01f10100 	.word	0x01f10100
    735c:	00005e01 	.word	0x00005e01
    7360:	005e8000 	.word	0x005e8000
    7364:	005ed408 	.word	0x005ed408
    7368:	002f2708 	.word	0x002f2708
    736c:	0004bb00 	.word	0x0004bb00
    7370:	304f1700 	.word	0x304f1700
    7374:	f1010000 	.word	0xf1010000
    7378:	00039001 	.word	0x00039001
    737c:	002f4600 	.word	0x002f4600
    7380:	31821700 	.word	0x31821700
    7384:	f1010000 	.word	0xf1010000
    7388:	00005e01 	.word	0x00005e01
    738c:	002f6400 	.word	0x002f6400
    7390:	00691b00 	.word	0x00691b00
    7394:	5e01f201 	.word	0x5e01f201
    7398:	00000000 	.word	0x00000000
    739c:	3041011f 	.word	0x3041011f
    73a0:	e1010000 	.word	0xe1010000
    73a4:	5ed40101 	.word	0x5ed40101
    73a8:	5ee80800 	.word	0x5ee80800
    73ac:	2f820800 	.word	0x2f820800
    73b0:	011f0000 	.word	0x011f0000
    73b4:	00003107 	.word	0x00003107
    73b8:	01016801 	.word	0x01016801
    73bc:	08005ee8 	.word	0x08005ee8
    73c0:	08005f0c 	.word	0x08005f0c
    73c4:	00002fad 	.word	0x00002fad
    73c8:	30ac0120 	.word	0x30ac0120
    73cc:	38010000 	.word	0x38010000
    73d0:	005f0c01 	.word	0x005f0c01
    73d4:	005f2008 	.word	0x005f2008
    73d8:	002fd808 	.word	0x002fd808
    73dc:	6a011600 	.word	0x6a011600
    73e0:	01000031 	.word	0x01000031
    73e4:	5e0101c5 	.word	0x5e0101c5
    73e8:	20000000 	.word	0x20000000
    73ec:	8008005f 	.word	0x8008005f
    73f0:	0308005f 	.word	0x0308005f
    73f4:	3a000030 	.word	0x3a000030
    73f8:	17000005 	.word	0x17000005
    73fc:	00001c26 	.word	0x00001c26
    7400:	3a01c501 	.word	0x3a01c501
    7404:	2e000000 	.word	0x2e000000
    7408:	1e000030 	.word	0x1e000030
    740c:	00002ffc 	.word	0x00002ffc
    7410:	5001c601 	.word	0x5001c601
    7414:	02000002 	.word	0x02000002
    7418:	16006091 	.word	0x16006091
    741c:	00313d01 	.word	0x00313d01
    7420:	01480100 	.word	0x01480100
    7424:	00005e01 	.word	0x00005e01
    7428:	005f8000 	.word	0x005f8000
    742c:	005ff008 	.word	0x005ff008
    7430:	00304c08 	.word	0x00304c08
    7434:	00057800 	.word	0x00057800
    7438:	1c261700 	.word	0x1c261700
    743c:	47010000 	.word	0x47010000
    7440:	00003a01 	.word	0x00003a01
    7444:	00307700 	.word	0x00307700
    7448:	2ffc1e00 	.word	0x2ffc1e00
    744c:	49010000 	.word	0x49010000
    7450:	00025001 	.word	0x00025001
    7454:	60910200 	.word	0x60910200
    7458:	8c012100 	.word	0x8c012100
    745c:	01000031 	.word	0x01000031
    7460:	005e011a 	.word	0x005e011a
    7464:	5ff00000 	.word	0x5ff00000
    7468:	60500800 	.word	0x60500800
    746c:	30950800 	.word	0x30950800
    7470:	05b30000 	.word	0x05b30000
    7474:	26220000 	.word	0x26220000
    7478:	0100001c 	.word	0x0100001c
    747c:	00003a19 	.word	0x00003a19
    7480:	0030c000 	.word	0x0030c000
    7484:	2ffc2300 	.word	0x2ffc2300
    7488:	1b010000 	.word	0x1b010000
    748c:	00000250 	.word	0x00000250
    7490:	00609102 	.word	0x00609102
    7494:	312b011d 	.word	0x312b011d
    7498:	96010000 	.word	0x96010000
    749c:	60500101 	.word	0x60500101
    74a0:	60e00800 	.word	0x60e00800
    74a4:	30de0800 	.word	0x30de0800
    74a8:	05dc0000 	.word	0x05dc0000
    74ac:	981e0000 	.word	0x981e0000
    74b0:	01000019 	.word	0x01000019
    74b4:	005e0197 	.word	0x005e0197
    74b8:	54010000 	.word	0x54010000
    74bc:	15011600 	.word	0x15011600
    74c0:	01000031 	.word	0x01000031
    74c4:	5e010172 	.word	0x5e010172
    74c8:	e0000000 	.word	0xe0000000
    74cc:	20080060 	.word	0x20080060
    74d0:	fd080061 	.word	0xfd080061
    74d4:	25000030 	.word	0x25000030
    74d8:	17000006 	.word	0x17000006
    74dc:	0000304f 	.word	0x0000304f
    74e0:	90017101 	.word	0x90017101
    74e4:	1c000003 	.word	0x1c000003
    74e8:	17000031 	.word	0x17000031
    74ec:	00003182 	.word	0x00003182
    74f0:	5e017101 	.word	0x5e017101
    74f4:	3a000000 	.word	0x3a000000
    74f8:	1b000031 	.word	0x1b000031
    74fc:	73010069 	.word	0x73010069
    7500:	00005e01 	.word	0x00005e01
    7504:	01240000 	.word	0x01240000
    7508:	00003069 	.word	0x00003069
    750c:	20017301 	.word	0x20017301
    7510:	c0080061 	.word	0xc0080061
    7514:	58080061 	.word	0x58080061
    7518:	4c000031 	.word	0x4c000031
    751c:	23000006 	.word	0x23000006
    7520:	00001998 	.word	0x00001998
    7524:	005e7401 	.word	0x005e7401
    7528:	54010000 	.word	0x54010000
    752c:	57012000 	.word	0x57012000
    7530:	01000030 	.word	0x01000030
    7534:	61c001b2 	.word	0x61c001b2
    7538:	61cc0800 	.word	0x61cc0800
    753c:	31770800 	.word	0x31770800
    7540:	01240000 	.word	0x01240000
    7544:	00003086 	.word	0x00003086
    7548:	cc014f01 	.word	0xcc014f01
    754c:	fc080061 	.word	0xfc080061
    7550:	a2080061 	.word	0xa2080061
    7554:	8a000031 	.word	0x8a000031
    7558:	22000006 	.word	0x22000006
    755c:	00003260 	.word	0x00003260
    7560:	005e4e01 	.word	0x005e4e01
    7564:	31c10000 	.word	0x31c10000
    7568:	24000000 	.word	0x24000000
    756c:	00302201 	.word	0x00302201
    7570:	013f0100 	.word	0x013f0100
    7574:	080061fc 	.word	0x080061fc
    7578:	08006210 	.word	0x08006210
    757c:	000031df 	.word	0x000031df
    7580:	000006b3 	.word	0x000006b3
    7584:	00312022 	.word	0x00312022
    7588:	5e3e0100 	.word	0x5e3e0100
    758c:	0a000000 	.word	0x0a000000
    7590:	00000032 	.word	0x00000032
    7594:	00056923 	.word	0x00056923
    7598:	c42a0500 	.word	0xc42a0500
    759c:	05000006 	.word	0x05000006
    75a0:	0015d003 	.word	0x0015d003
    75a4:	005e0420 	.word	0x005e0420
    75a8:	ce230000 	.word	0xce230000
    75ac:	05000002 	.word	0x05000002
    75b0:	0006da28 	.word	0x0006da28
    75b4:	d2030500 	.word	0xd2030500
    75b8:	04200015 	.word	0x04200015
    75bc:	0000004c 	.word	0x0000004c
    75c0:	00042b23 	.word	0x00042b23
    75c4:	da280500 	.word	0xda280500
    75c8:	05000006 	.word	0x05000006
    75cc:	0015d403 	.word	0x0015d403
    75d0:	005e2520 	.word	0x005e2520
    75d4:	07010000 	.word	0x07010000
    75d8:	a3260000 	.word	0xa3260000
    75dc:	ff000000 	.word	0xff000000
    75e0:	af230003 	.word	0xaf230003
    75e4:	05000004 	.word	0x05000004
    75e8:	00071229 	.word	0x00071229
    75ec:	d0030500 	.word	0xd0030500
    75f0:	04200011 	.word	0x04200011
    75f4:	000006f0 	.word	0x000006f0
    75f8:	00064a23 	.word	0x00064a23
    75fc:	c4440500 	.word	0xc4440500
    7600:	05000006 	.word	0x05000006
    7604:	0011ce03 	.word	0x0011ce03
    7608:	040e2320 	.word	0x040e2320
    760c:	44050000 	.word	0x44050000
    7610:	000006c4 	.word	0x000006c4
    7614:	11cf0305 	.word	0x11cf0305
    7618:	5e252000 	.word	0x5e252000
    761c:	49000000 	.word	0x49000000
    7620:	27000007 	.word	0x27000007
    7624:	000000a3 	.word	0x000000a3
    7628:	ec230040 	.word	0xec230040
    762c:	05000000 	.word	0x05000000
    7630:	00075a45 	.word	0x00075a45
    7634:	d6030500 	.word	0xd6030500
    7638:	04200015 	.word	0x04200015
    763c:	00000739 	.word	0x00000739
    7640:	00061923 	.word	0x00061923
    7644:	da580500 	.word	0xda580500
    7648:	05000006 	.word	0x05000006
    764c:	0011ca03 	.word	0x0011ca03
    7650:	00f92320 	.word	0x00f92320
    7654:	58050000 	.word	0x58050000
    7658:	000006da 	.word	0x000006da
    765c:	11cc0305 	.word	0x11cc0305
    7660:	2d232000 	.word	0x2d232000
    7664:	05000003 	.word	0x05000003
    7668:	00079259 	.word	0x00079259
    766c:	17030500 	.word	0x17030500
    7670:	04200016 	.word	0x04200016
    7674:	000006f0 	.word	0x000006f0
    7678:	0006ce28 	.word	0x0006ce28
    767c:	3a0e0100 	.word	0x3a0e0100
    7680:	01000000 	.word	0x01000000
    7684:	00cc0305 	.word	0x00cc0305
    7688:	05282000 	.word	0x05282000
    768c:	01000000 	.word	0x01000000
    7690:	00003a11 	.word	0x00003a11
    7694:	03050100 	.word	0x03050100
    7698:	200000d0 	.word	0x200000d0
    769c:	00005628 	.word	0x00005628
    76a0:	3a140100 	.word	0x3a140100
    76a4:	01000000 	.word	0x01000000
    76a8:	00d40305 	.word	0x00d40305
    76ac:	c8292000 	.word	0xc8292000
    76b0:	0600002c 	.word	0x0600002c
    76b4:	0007da1a 	.word	0x0007da1a
    76b8:	04010100 	.word	0x04010100
    76bc:	0000003a 	.word	0x0000003a
    76c0:	002c6429 	.word	0x002c6429
    76c4:	da1b0600 	.word	0xda1b0600
    76c8:	01000007 	.word	0x01000007
    76cc:	0b1b0001 	.word	0x0b1b0001
    76d0:	00020000 	.word	0x00020000
    76d4:	00001fe9 	.word	0x00001fe9
    76d8:	01fe0104 	.word	0x01fe0104
    76dc:	e1010000 	.word	0xe1010000
    76e0:	49000032 	.word	0x49000032
    76e4:	10000002 	.word	0x10000002
    76e8:	a4080062 	.word	0xa4080062
    76ec:	2b080065 	.word	0x2b080065
    76f0:	0200001f 	.word	0x0200001f
    76f4:	01220504 	.word	0x01220504
    76f8:	02020000 	.word	0x02020000
    76fc:	0004ca05 	.word	0x0004ca05
    7700:	06010200 	.word	0x06010200
    7704:	0000049e 	.word	0x0000049e
    7708:	32337503 	.word	0x32337503
    770c:	45270200 	.word	0x45270200
    7710:	02000000 	.word	0x02000000
    7714:	01300704 	.word	0x01300704
    7718:	75030000 	.word	0x75030000
    771c:	02003631 	.word	0x02003631
    7720:	00005728 	.word	0x00005728
    7724:	07020200 	.word	0x07020200
    7728:	000001c5 	.word	0x000001c5
    772c:	00387503 	.word	0x00387503
    7730:	00682902 	.word	0x00682902
    7734:	01020000 	.word	0x01020000
    7738:	00049c08 	.word	0x00049c08
    773c:	00450400 	.word	0x00450400
    7740:	01050000 	.word	0x01050000
    7744:	00893a02 	.word	0x00893a02
    7748:	f2060000 	.word	0xf2060000
    774c:	0000000e 	.word	0x0000000e
    7750:	54455307 	.word	0x54455307
    7754:	08000100 	.word	0x08000100
    7758:	0000440a 	.word	0x0000440a
    775c:	00743a02 	.word	0x00743a02
    7760:	04080000 	.word	0x04080000
    7764:	02000042 	.word	0x02000042
    7768:	0000743a 	.word	0x0000743a
    776c:	02010500 	.word	0x02010500
    7770:	0000b43c 	.word	0x0000b43c
    7774:	2a700600 	.word	0x2a700600
    7778:	06000000 	.word	0x06000000
    777c:	0000046e 	.word	0x0000046e
    7780:	71080001 	.word	0x71080001
    7784:	0200002f 	.word	0x0200002f
    7788:	00009f3c 	.word	0x00009f3c
    778c:	03500900 	.word	0x03500900
    7790:	0001de25 	.word	0x0001de25
    7794:	52530a00 	.word	0x52530a00
    7798:	6f260300 	.word	0x6f260300
    779c:	02000000 	.word	0x02000000
    77a0:	430a0023 	.word	0x430a0023
    77a4:	03003152 	.word	0x03003152
    77a8:	00006f27 	.word	0x00006f27
    77ac:	04230200 	.word	0x04230200
    77b0:	3252430a 	.word	0x3252430a
    77b4:	6f280300 	.word	0x6f280300
    77b8:	02000000 	.word	0x02000000
    77bc:	1b0b0823 	.word	0x1b0b0823
    77c0:	0300002b 	.word	0x0300002b
    77c4:	00006f29 	.word	0x00006f29
    77c8:	0c230200 	.word	0x0c230200
    77cc:	002b210b 	.word	0x002b210b
    77d0:	6f2a0300 	.word	0x6f2a0300
    77d4:	02000000 	.word	0x02000000
    77d8:	8a0b1023 	.word	0x8a0b1023
    77dc:	0300002a 	.word	0x0300002a
    77e0:	00006f2b 	.word	0x00006f2b
    77e4:	14230200 	.word	0x14230200
    77e8:	002a900b 	.word	0x002a900b
    77ec:	6f2c0300 	.word	0x6f2c0300
    77f0:	02000000 	.word	0x02000000
    77f4:	b10b1823 	.word	0xb10b1823
    77f8:	0300002a 	.word	0x0300002a
    77fc:	00006f2d 	.word	0x00006f2d
    7800:	1c230200 	.word	0x1c230200
    7804:	002abf0b 	.word	0x002abf0b
    7808:	6f2e0300 	.word	0x6f2e0300
    780c:	02000000 	.word	0x02000000
    7810:	480a2023 	.word	0x480a2023
    7814:	03005254 	.word	0x03005254
    7818:	00006f2f 	.word	0x00006f2f
    781c:	24230200 	.word	0x24230200
    7820:	52544c0a 	.word	0x52544c0a
    7824:	6f300300 	.word	0x6f300300
    7828:	02000000 	.word	0x02000000
    782c:	ee0b2823 	.word	0xee0b2823
    7830:	0300002a 	.word	0x0300002a
    7834:	00006f31 	.word	0x00006f31
    7838:	2c230200 	.word	0x2c230200
    783c:	002af30b 	.word	0x002af30b
    7840:	6f320300 	.word	0x6f320300
    7844:	02000000 	.word	0x02000000
    7848:	f80b3023 	.word	0xf80b3023
    784c:	0300002a 	.word	0x0300002a
    7850:	00006f33 	.word	0x00006f33
    7854:	34230200 	.word	0x34230200
    7858:	002a3a0b 	.word	0x002a3a0b
    785c:	6f340300 	.word	0x6f340300
    7860:	02000000 	.word	0x02000000
    7864:	780b3823 	.word	0x780b3823
    7868:	0300002a 	.word	0x0300002a
    786c:	00006f35 	.word	0x00006f35
    7870:	3c230200 	.word	0x3c230200
    7874:	0029fc0b 	.word	0x0029fc0b
    7878:	6f360300 	.word	0x6f360300
    787c:	02000000 	.word	0x02000000
    7880:	010b4023 	.word	0x010b4023
    7884:	0300002a 	.word	0x0300002a
    7888:	00006f37 	.word	0x00006f37
    788c:	44230200 	.word	0x44230200
    7890:	002a060b 	.word	0x002a060b
    7894:	6f380300 	.word	0x6f380300
    7898:	02000000 	.word	0x02000000
    789c:	440a4823 	.word	0x440a4823
    78a0:	39030052 	.word	0x39030052
    78a4:	0000006f 	.word	0x0000006f
    78a8:	004c2302 	.word	0x004c2302
    78ac:	00368a08 	.word	0x00368a08
    78b0:	bf3a0300 	.word	0xbf3a0300
    78b4:	0c000000 	.word	0x0c000000
    78b8:	14090704 	.word	0x14090704
    78bc:	02491b04 	.word	0x02491b04
    78c0:	310b0000 	.word	0x310b0000
    78c4:	0400002e 	.word	0x0400002e
    78c8:	00003a1c 	.word	0x00003a1c
    78cc:	00230200 	.word	0x00230200
    78d0:	002d7e0b 	.word	0x002d7e0b
    78d4:	b41d0400 	.word	0xb41d0400
    78d8:	02000000 	.word	0x02000000
    78dc:	bf0b0423 	.word	0xbf0b0423
    78e0:	0400002e 	.word	0x0400002e
    78e4:	0000b41e 	.word	0x0000b41e
    78e8:	05230200 	.word	0x05230200
    78ec:	002f060b 	.word	0x002f060b
    78f0:	3a1f0400 	.word	0x3a1f0400
    78f4:	02000000 	.word	0x02000000
    78f8:	7f0b0823 	.word	0x7f0b0823
    78fc:	0400002e 	.word	0x0400002e
    7900:	00003a20 	.word	0x00003a20
    7904:	0c230200 	.word	0x0c230200
    7908:	002e6e0b 	.word	0x002e6e0b
    790c:	5e210400 	.word	0x5e210400
    7910:	02000000 	.word	0x02000000
    7914:	08001023 	.word	0x08001023
    7918:	00002d42 	.word	0x00002d42
    791c:	01ec2204 	.word	0x01ec2204
    7920:	010d0000 	.word	0x010d0000
    7924:	00003696 	.word	0x00003696
    7928:	1001af01 	.word	0x1001af01
    792c:	58080062 	.word	0x58080062
    7930:	01080062 	.word	0x01080062
    7934:	0002a05d 	.word	0x0002a05d
    7938:	32690e00 	.word	0x32690e00
    793c:	ae010000 	.word	0xae010000
    7940:	000002a0 	.word	0x000002a0
    7944:	120e5001 	.word	0x120e5001
    7948:	01000033 	.word	0x01000033
    794c:	0002a6ae 	.word	0x0002a6ae
    7950:	0f510100 	.word	0x0f510100
    7954:	0000326e 	.word	0x0000326e
    7958:	003ab001 	.word	0x003ab001
    795c:	32280000 	.word	0x32280000
    7960:	3e100000 	.word	0x3e100000
    7964:	01000035 	.word	0x01000035
    7968:	00005eb1 	.word	0x00005eb1
    796c:	04110000 	.word	0x04110000
    7970:	000001de 	.word	0x000001de
    7974:	02490411 	.word	0x02490411
    7978:	010d0000 	.word	0x010d0000
    797c:	000035e8 	.word	0x000035e8
    7980:	5801ec01 	.word	0x5801ec01
    7984:	6a080062 	.word	0x6a080062
    7988:	01080062 	.word	0x01080062
    798c:	0002d15d 	.word	0x0002d15d
    7990:	33120e00 	.word	0x33120e00
    7994:	eb010000 	.word	0xeb010000
    7998:	000002a6 	.word	0x000002a6
    799c:	12005001 	.word	0x12005001
    79a0:	00330a01 	.word	0x00330a01
    79a4:	010b0100 	.word	0x010b0100
    79a8:	00626c01 	.word	0x00626c01
    79ac:	00628008 	.word	0x00628008
    79b0:	065d0108 	.word	0x065d0108
    79b4:	13000003 	.word	0x13000003
    79b8:	00003269 	.word	0x00003269
    79bc:	a0010a01 	.word	0xa0010a01
    79c0:	01000002 	.word	0x01000002
    79c4:	33811350 	.word	0x33811350
    79c8:	0a010000 	.word	0x0a010000
    79cc:	0000b401 	.word	0x0000b401
    79d0:	00510100 	.word	0x00510100
    79d4:	36b90112 	.word	0x36b90112
    79d8:	27010000 	.word	0x27010000
    79dc:	62800101 	.word	0x62800101
    79e0:	62940800 	.word	0x62940800
    79e4:	5d010800 	.word	0x5d010800
    79e8:	0000033b 	.word	0x0000033b
    79ec:	00326913 	.word	0x00326913
    79f0:	01260100 	.word	0x01260100
    79f4:	000002a0 	.word	0x000002a0
    79f8:	81135001 	.word	0x81135001
    79fc:	01000033 	.word	0x01000033
    7a00:	00b40126 	.word	0x00b40126
    7a04:	51010000 	.word	0x51010000
    7a08:	8c011200 	.word	0x8c011200
    7a0c:	01000032 	.word	0x01000032
    7a10:	94010148 	.word	0x94010148
    7a14:	aa080062 	.word	0xaa080062
    7a18:	01080062 	.word	0x01080062
    7a1c:	00038e5d 	.word	0x00038e5d
    7a20:	32691300 	.word	0x32691300
    7a24:	47010000 	.word	0x47010000
    7a28:	0002a001 	.word	0x0002a001
    7a2c:	14500100 	.word	0x14500100
    7a30:	0000367c 	.word	0x0000367c
    7a34:	4c014701 	.word	0x4c014701
    7a38:	5c000000 	.word	0x5c000000
    7a3c:	13000032 	.word	0x13000032
    7a40:	00003381 	.word	0x00003381
    7a44:	b4014701 	.word	0xb4014701
    7a48:	01000000 	.word	0x01000000
    7a4c:	36831552 	.word	0x36831552
    7a50:	49010000 	.word	0x49010000
    7a54:	00005e01 	.word	0x00005e01
    7a58:	00510100 	.word	0x00510100
    7a5c:	36670112 	.word	0x36670112
    7a60:	67010000 	.word	0x67010000
    7a64:	62ac0101 	.word	0x62ac0101
    7a68:	62b60800 	.word	0x62b60800
    7a6c:	5d010800 	.word	0x5d010800
    7a70:	000003b5 	.word	0x000003b5
    7a74:	00326913 	.word	0x00326913
    7a78:	01660100 	.word	0x01660100
    7a7c:	000002a0 	.word	0x000002a0
    7a80:	16005001 	.word	0x16005001
    7a84:	00335a01 	.word	0x00335a01
    7a88:	01770100 	.word	0x01770100
    7a8c:	00008901 	.word	0x00008901
    7a90:	0062b800 	.word	0x0062b800
    7a94:	0062c208 	.word	0x0062c208
    7a98:	ee5d0108 	.word	0xee5d0108
    7a9c:	14000003 	.word	0x14000003
    7aa0:	00003269 	.word	0x00003269
    7aa4:	a0017601 	.word	0xa0017601
    7aa8:	6f000002 	.word	0x6f000002
    7aac:	17000032 	.word	0x17000032
    7ab0:	00003567 	.word	0x00003567
    7ab4:	89017801 	.word	0x89017801
    7ab8:	00000000 	.word	0x00000000
    7abc:	35290112 	.word	0x35290112
    7ac0:	95010000 	.word	0x95010000
    7ac4:	62c40101 	.word	0x62c40101
    7ac8:	62ce0800 	.word	0x62ce0800
    7acc:	5d010800 	.word	0x5d010800
    7ad0:	00000415 	.word	0x00000415
    7ad4:	00326913 	.word	0x00326913
    7ad8:	01940100 	.word	0x01940100
    7adc:	000002a0 	.word	0x000002a0
    7ae0:	16005001 	.word	0x16005001
    7ae4:	00354e01 	.word	0x00354e01
    7ae8:	01a50100 	.word	0x01a50100
    7aec:	00008901 	.word	0x00008901
    7af0:	0062d000 	.word	0x0062d000
    7af4:	0062da08 	.word	0x0062da08
    7af8:	4e5d0108 	.word	0x4e5d0108
    7afc:	14000004 	.word	0x14000004
    7b00:	00003269 	.word	0x00003269
    7b04:	a001a401 	.word	0xa001a401
    7b08:	82000002 	.word	0x82000002
    7b0c:	17000032 	.word	0x17000032
    7b10:	00003567 	.word	0x00003567
    7b14:	8901a601 	.word	0x8901a601
    7b18:	00000000 	.word	0x00000000
    7b1c:	35710112 	.word	0x35710112
    7b20:	c5010000 	.word	0xc5010000
    7b24:	62dc0101 	.word	0x62dc0101
    7b28:	62f00800 	.word	0x62f00800
    7b2c:	5d010800 	.word	0x5d010800
    7b30:	00000483 	.word	0x00000483
    7b34:	00326913 	.word	0x00326913
    7b38:	01c40100 	.word	0x01c40100
    7b3c:	000002a0 	.word	0x000002a0
    7b40:	81135001 	.word	0x81135001
    7b44:	01000033 	.word	0x01000033
    7b48:	00b401c4 	.word	0x00b401c4
    7b4c:	51010000 	.word	0x51010000
    7b50:	56011600 	.word	0x56011600
    7b54:	01000034 	.word	0x01000034
    7b58:	890101e0 	.word	0x890101e0
    7b5c:	f0000000 	.word	0xf0000000
    7b60:	fa080062 	.word	0xfa080062
    7b64:	01080062 	.word	0x01080062
    7b68:	0004bc5d 	.word	0x0004bc5d
    7b6c:	32691400 	.word	0x32691400
    7b70:	df010000 	.word	0xdf010000
    7b74:	0002a001 	.word	0x0002a001
    7b78:	00329500 	.word	0x00329500
    7b7c:	35671700 	.word	0x35671700
    7b80:	e1010000 	.word	0xe1010000
    7b84:	00008901 	.word	0x00008901
    7b88:	01120000 	.word	0x01120000
    7b8c:	000033e4 	.word	0x000033e4
    7b90:	01020101 	.word	0x01020101
    7b94:	080062fc 	.word	0x080062fc
    7b98:	0800630c 	.word	0x0800630c
    7b9c:	050d5d01 	.word	0x050d5d01
    7ba0:	69130000 	.word	0x69130000
    7ba4:	01000032 	.word	0x01000032
    7ba8:	02a00200 	.word	0x02a00200
    7bac:	50010000 	.word	0x50010000
    7bb0:	00330314 	.word	0x00330314
    7bb4:	02000100 	.word	0x02000100
    7bb8:	0000005e 	.word	0x0000005e
    7bbc:	000032a8 	.word	0x000032a8
    7bc0:	00326e15 	.word	0x00326e15
    7bc4:	02020100 	.word	0x02020100
    7bc8:	0000003a 	.word	0x0000003a
    7bcc:	3e175301 	.word	0x3e175301
    7bd0:	01000035 	.word	0x01000035
    7bd4:	003a0203 	.word	0x003a0203
    7bd8:	12000000 	.word	0x12000000
    7bdc:	00365701 	.word	0x00365701
    7be0:	02200100 	.word	0x02200100
    7be4:	00630c01 	.word	0x00630c01
    7be8:	00632008 	.word	0x00632008
    7bec:	425d0108 	.word	0x425d0108
    7bf0:	13000005 	.word	0x13000005
    7bf4:	00003269 	.word	0x00003269
    7bf8:	a0021f01 	.word	0xa0021f01
    7bfc:	01000002 	.word	0x01000002
    7c00:	33811350 	.word	0x33811350
    7c04:	1f010000 	.word	0x1f010000
    7c08:	0000b402 	.word	0x0000b402
    7c0c:	00510100 	.word	0x00510100
    7c10:	33b00118 	.word	0x33b00118
    7c14:	5b010000 	.word	0x5b010000
    7c18:	63200102 	.word	0x63200102
    7c1c:	63b60800 	.word	0x63b60800
    7c20:	32bb0800 	.word	0x32bb0800
    7c24:	05b70000 	.word	0x05b70000
    7c28:	69130000 	.word	0x69130000
    7c2c:	01000032 	.word	0x01000032
    7c30:	02a0025a 	.word	0x02a0025a
    7c34:	50010000 	.word	0x50010000
    7c38:	00351d14 	.word	0x00351d14
    7c3c:	025a0100 	.word	0x025a0100
    7c40:	0000005e 	.word	0x0000005e
    7c44:	000032da 	.word	0x000032da
    7c48:	00342114 	.word	0x00342114
    7c4c:	025a0100 	.word	0x025a0100
    7c50:	0000005e 	.word	0x0000005e
    7c54:	0000330e 	.word	0x0000330e
    7c58:	0035d914 	.word	0x0035d914
    7c5c:	025a0100 	.word	0x025a0100
    7c60:	0000005e 	.word	0x0000005e
    7c64:	0000332c 	.word	0x0000332c
    7c68:	00326e19 	.word	0x00326e19
    7c6c:	025c0100 	.word	0x025c0100
    7c70:	0000003a 	.word	0x0000003a
    7c74:	0000334a 	.word	0x0000334a
    7c78:	00353e17 	.word	0x00353e17
    7c7c:	025c0100 	.word	0x025c0100
    7c80:	0000003a 	.word	0x0000003a
    7c84:	3e011200 	.word	0x3e011200
    7c88:	01000034 	.word	0x01000034
    7c8c:	b80102c0 	.word	0xb80102c0
    7c90:	cc080063 	.word	0xcc080063
    7c94:	01080063 	.word	0x01080063
    7c98:	0005ec5d 	.word	0x0005ec5d
    7c9c:	32691300 	.word	0x32691300
    7ca0:	bf010000 	.word	0xbf010000
    7ca4:	0002a002 	.word	0x0002a002
    7ca8:	13500100 	.word	0x13500100
    7cac:	00003381 	.word	0x00003381
    7cb0:	b402bf01 	.word	0xb402bf01
    7cb4:	01000000 	.word	0x01000000
    7cb8:	01160051 	.word	0x01160051
    7cbc:	00003403 	.word	0x00003403
    7cc0:	0102d901 	.word	0x0102d901
    7cc4:	0000004c 	.word	0x0000004c
    7cc8:	080063cc 	.word	0x080063cc
    7ccc:	080063d2 	.word	0x080063d2
    7cd0:	06195d01 	.word	0x06195d01
    7cd4:	69140000 	.word	0x69140000
    7cd8:	01000032 	.word	0x01000032
    7cdc:	02a002d8 	.word	0x02a002d8
    7ce0:	33680000 	.word	0x33680000
    7ce4:	1a000000 	.word	0x1a000000
    7ce8:	0036c401 	.word	0x0036c401
    7cec:	02e80100 	.word	0x02e80100
    7cf0:	00003a01 	.word	0x00003a01
    7cf4:	0063d400 	.word	0x0063d400
    7cf8:	0063e008 	.word	0x0063e008
    7cfc:	125d0108 	.word	0x125d0108
    7d00:	00342601 	.word	0x00342601
    7d04:	02f90100 	.word	0x02f90100
    7d08:	0063e001 	.word	0x0063e001
    7d0c:	0063f408 	.word	0x0063f408
    7d10:	665d0108 	.word	0x665d0108
    7d14:	13000006 	.word	0x13000006
    7d18:	00003269 	.word	0x00003269
    7d1c:	a002f801 	.word	0xa002f801
    7d20:	01000002 	.word	0x01000002
    7d24:	33811350 	.word	0x33811350
    7d28:	f8010000 	.word	0xf8010000
    7d2c:	0000b402 	.word	0x0000b402
    7d30:	00510100 	.word	0x00510100
    7d34:	34b60112 	.word	0x34b60112
    7d38:	16010000 	.word	0x16010000
    7d3c:	63f40103 	.word	0x63f40103
    7d40:	64080800 	.word	0x64080800
    7d44:	5d010800 	.word	0x5d010800
    7d48:	0000069b 	.word	0x0000069b
    7d4c:	00326913 	.word	0x00326913
    7d50:	03150100 	.word	0x03150100
    7d54:	000002a0 	.word	0x000002a0
    7d58:	81135001 	.word	0x81135001
    7d5c:	01000033 	.word	0x01000033
    7d60:	00b40315 	.word	0x00b40315
    7d64:	51010000 	.word	0x51010000
    7d68:	ce011200 	.word	0xce011200
    7d6c:	01000034 	.word	0x01000034
    7d70:	0801034e 	.word	0x0801034e
    7d74:	14080064 	.word	0x14080064
    7d78:	01080064 	.word	0x01080064
    7d7c:	0006e25d 	.word	0x0006e25d
    7d80:	32691300 	.word	0x32691300
    7d84:	4d010000 	.word	0x4d010000
    7d88:	0002a003 	.word	0x0002a003
    7d8c:	14500100 	.word	0x14500100
    7d90:	0000369f 	.word	0x0000369f
    7d94:	3a034d01 	.word	0x3a034d01
    7d98:	7b000000 	.word	0x7b000000
    7d9c:	19000033 	.word	0x19000033
    7da0:	0000341a 	.word	0x0000341a
    7da4:	3a034f01 	.word	0x3a034f01
    7da8:	8e000000 	.word	0x8e000000
    7dac:	00000033 	.word	0x00000033
    7db0:	34960112 	.word	0x34960112
    7db4:	6b010000 	.word	0x6b010000
    7db8:	64140103 	.word	0x64140103
    7dbc:	64280800 	.word	0x64280800
    7dc0:	5d010800 	.word	0x5d010800
    7dc4:	00000717 	.word	0x00000717
    7dc8:	00326913 	.word	0x00326913
    7dcc:	036a0100 	.word	0x036a0100
    7dd0:	000002a0 	.word	0x000002a0
    7dd4:	81135001 	.word	0x81135001
    7dd8:	01000033 	.word	0x01000033
    7ddc:	00b4036a 	.word	0x00b4036a
    7de0:	51010000 	.word	0x51010000
    7de4:	f7011200 	.word	0xf7011200
    7de8:	01000035 	.word	0x01000035
    7dec:	28010388 	.word	0x28010388
    7df0:	3c080064 	.word	0x3c080064
    7df4:	01080064 	.word	0x01080064
    7df8:	00074c5d 	.word	0x00074c5d
    7dfc:	32691300 	.word	0x32691300
    7e00:	87010000 	.word	0x87010000
    7e04:	0002a003 	.word	0x0002a003
    7e08:	13500100 	.word	0x13500100
    7e0c:	00003381 	.word	0x00003381
    7e10:	b4038701 	.word	0xb4038701
    7e14:	01000000 	.word	0x01000000
    7e18:	01160051 	.word	0x01160051
    7e1c:	00003299 	.word	0x00003299
    7e20:	0103a301 	.word	0x0103a301
    7e24:	00000089 	.word	0x00000089
    7e28:	0800643c 	.word	0x0800643c
    7e2c:	08006446 	.word	0x08006446
    7e30:	07855d01 	.word	0x07855d01
    7e34:	69140000 	.word	0x69140000
    7e38:	01000032 	.word	0x01000032
    7e3c:	02a003a2 	.word	0x02a003a2
    7e40:	33ac0000 	.word	0x33ac0000
    7e44:	67170000 	.word	0x67170000
    7e48:	01000035 	.word	0x01000035
    7e4c:	008903a4 	.word	0x008903a4
    7e50:	18000000 	.word	0x18000000
    7e54:	0035bf01 	.word	0x0035bf01
    7e58:	03e30100 	.word	0x03e30100
    7e5c:	00644801 	.word	0x00644801
    7e60:	0064aa08 	.word	0x0064aa08
    7e64:	0033bf08 	.word	0x0033bf08
    7e68:	00080600 	.word	0x00080600
    7e6c:	32691300 	.word	0x32691300
    7e70:	e2010000 	.word	0xe2010000
    7e74:	0002a003 	.word	0x0002a003
    7e78:	14500100 	.word	0x14500100
    7e7c:	0000351d 	.word	0x0000351d
    7e80:	5e03e201 	.word	0x5e03e201
    7e84:	de000000 	.word	0xde000000
    7e88:	14000033 	.word	0x14000033
    7e8c:	00003421 	.word	0x00003421
    7e90:	5e03e201 	.word	0x5e03e201
    7e94:	12000000 	.word	0x12000000
    7e98:	14000034 	.word	0x14000034
    7e9c:	000035d9 	.word	0x000035d9
    7ea0:	5e03e201 	.word	0x5e03e201
    7ea4:	30000000 	.word	0x30000000
    7ea8:	19000034 	.word	0x19000034
    7eac:	0000326e 	.word	0x0000326e
    7eb0:	3a03e401 	.word	0x3a03e401
    7eb4:	4e000000 	.word	0x4e000000
    7eb8:	17000034 	.word	0x17000034
    7ebc:	0000353e 	.word	0x0000353e
    7ec0:	3a03e401 	.word	0x3a03e401
    7ec4:	17000000 	.word	0x17000000
    7ec8:	00003546 	.word	0x00003546
    7ecc:	3a03e401 	.word	0x3a03e401
    7ed0:	00000000 	.word	0x00000000
    7ed4:	358a0112 	.word	0x358a0112
    7ed8:	27010000 	.word	0x27010000
    7edc:	64ac0104 	.word	0x64ac0104
    7ee0:	64bc0800 	.word	0x64bc0800
    7ee4:	5d010800 	.word	0x5d010800
    7ee8:	00000857 	.word	0x00000857
    7eec:	00326913 	.word	0x00326913
    7ef0:	04260100 	.word	0x04260100
    7ef4:	000002a0 	.word	0x000002a0
    7ef8:	67145001 	.word	0x67145001
    7efc:	01000018 	.word	0x01000018
    7f00:	005e0426 	.word	0x005e0426
    7f04:	34770000 	.word	0x34770000
    7f08:	6e150000 	.word	0x6e150000
    7f0c:	01000032 	.word	0x01000032
    7f10:	003a0428 	.word	0x003a0428
    7f14:	53010000 	.word	0x53010000
    7f18:	00353e17 	.word	0x00353e17
    7f1c:	04290100 	.word	0x04290100
    7f20:	0000003a 	.word	0x0000003a
    7f24:	75011800 	.word	0x75011800
    7f28:	01000034 	.word	0x01000034
    7f2c:	bc01044b 	.word	0xbc01044b
    7f30:	c4080064 	.word	0xc4080064
    7f34:	8a080064 	.word	0x8a080064
    7f38:	9e000034 	.word	0x9e000034
    7f3c:	14000008 	.word	0x14000008
    7f40:	00003269 	.word	0x00003269
    7f44:	a0044a01 	.word	0xa0044a01
    7f48:	a9000002 	.word	0xa9000002
    7f4c:	13000034 	.word	0x13000034
    7f50:	00003618 	.word	0x00003618
    7f54:	5e044a01 	.word	0x5e044a01
    7f58:	01000000 	.word	0x01000000
    7f5c:	0ede1351 	.word	0x0ede1351
    7f60:	4a010000 	.word	0x4a010000
    7f64:	00004c04 	.word	0x00004c04
    7f68:	00520100 	.word	0x00520100
    7f6c:	34fe011b 	.word	0x34fe011b
    7f70:	63010000 	.word	0x63010000
    7f74:	004c0104 	.word	0x004c0104
    7f78:	64c40000 	.word	0x64c40000
    7f7c:	64d20800 	.word	0x64d20800
    7f80:	34bc0800 	.word	0x34bc0800
    7f84:	08db0000 	.word	0x08db0000
    7f88:	69140000 	.word	0x69140000
    7f8c:	01000032 	.word	0x01000032
    7f90:	02a00462 	.word	0x02a00462
    7f94:	34db0000 	.word	0x34db0000
    7f98:	18130000 	.word	0x18130000
    7f9c:	01000036 	.word	0x01000036
    7fa0:	005e0462 	.word	0x005e0462
    7fa4:	51010000 	.word	0x51010000
    7fa8:	76011200 	.word	0x76011200
    7fac:	01000032 	.word	0x01000032
    7fb0:	d4010485 	.word	0xd4010485
    7fb4:	e4080064 	.word	0xe4080064
    7fb8:	01080064 	.word	0x01080064
    7fbc:	0009225d 	.word	0x0009225d
    7fc0:	32691300 	.word	0x32691300
    7fc4:	84010000 	.word	0x84010000
    7fc8:	0002a004 	.word	0x0002a004
    7fcc:	14500100 	.word	0x14500100
    7fd0:	000035ac 	.word	0x000035ac
    7fd4:	3a048401 	.word	0x3a048401
    7fd8:	ee000000 	.word	0xee000000
    7fdc:	19000034 	.word	0x19000034
    7fe0:	0000341a 	.word	0x0000341a
    7fe4:	3a048601 	.word	0x3a048601
    7fe8:	01000000 	.word	0x01000000
    7fec:	00000035 	.word	0x00000035
    7ff0:	33210112 	.word	0x33210112
    7ff4:	a3010000 	.word	0xa3010000
    7ff8:	64e40104 	.word	0x64e40104
    7ffc:	64ea0800 	.word	0x64ea0800
    8000:	5d010800 	.word	0x5d010800
    8004:	00000965 	.word	0x00000965
    8008:	00326913 	.word	0x00326913
    800c:	04a10100 	.word	0x04a10100
    8010:	000002a0 	.word	0x000002a0
    8014:	d6135001 	.word	0xd6135001
    8018:	01000033 	.word	0x01000033
    801c:	004c04a1 	.word	0x004c04a1
    8020:	51010000 	.word	0x51010000
    8024:	0034f113 	.word	0x0034f113
    8028:	04a20100 	.word	0x04a20100
    802c:	0000004c 	.word	0x0000004c
    8030:	12005201 	.word	0x12005201
    8034:	00338a01 	.word	0x00338a01
    8038:	04cc0100 	.word	0x04cc0100
    803c:	0064ec01 	.word	0x0064ec01
    8040:	0064f808 	.word	0x0064f808
    8044:	ac5d0108 	.word	0xac5d0108
    8048:	13000009 	.word	0x13000009
    804c:	00003269 	.word	0x00003269
    8050:	a004cb01 	.word	0xa004cb01
    8054:	01000002 	.word	0x01000002
    8058:	351d1450 	.word	0x351d1450
    805c:	cb010000 	.word	0xcb010000
    8060:	00005e04 	.word	0x00005e04
    8064:	00351f00 	.word	0x00351f00
    8068:	341a1900 	.word	0x341a1900
    806c:	cd010000 	.word	0xcd010000
    8070:	00003a04 	.word	0x00003a04
    8074:	00353200 	.word	0x00353200
    8078:	01120000 	.word	0x01120000
    807c:	0000363e 	.word	0x0000363e
    8080:	0104e601 	.word	0x0104e601
    8084:	080064f8 	.word	0x080064f8
    8088:	08006514 	.word	0x08006514
    808c:	09d35d01 	.word	0x09d35d01
    8090:	81130000 	.word	0x81130000
    8094:	01000033 	.word	0x01000033
    8098:	00b404e5 	.word	0x00b404e5
    809c:	50010000 	.word	0x50010000
    80a0:	2c011600 	.word	0x2c011600
    80a4:	01000036 	.word	0x01000036
    80a8:	89010505 	.word	0x89010505
    80ac:	14000000 	.word	0x14000000
    80b0:	20080065 	.word	0x20080065
    80b4:	01080065 	.word	0x01080065
    80b8:	000a1a5d 	.word	0x000a1a5d
    80bc:	32691400 	.word	0x32691400
    80c0:	04010000 	.word	0x04010000
    80c4:	0002a005 	.word	0x0002a005
    80c8:	00355000 	.word	0x00355000
    80cc:	33781300 	.word	0x33781300
    80d0:	04010000 	.word	0x04010000
    80d4:	00005e05 	.word	0x00005e05
    80d8:	17510100 	.word	0x17510100
    80dc:	00003567 	.word	0x00003567
    80e0:	89050601 	.word	0x89050601
    80e4:	00000000 	.word	0x00000000
    80e8:	32c30112 	.word	0x32c30112
    80ec:	2b010000 	.word	0x2b010000
    80f0:	65200105 	.word	0x65200105
    80f4:	65280800 	.word	0x65280800
    80f8:	5d010800 	.word	0x5d010800
    80fc:	00000a51 	.word	0x00000a51
    8100:	00326913 	.word	0x00326913
    8104:	052a0100 	.word	0x052a0100
    8108:	000002a0 	.word	0x000002a0
    810c:	78145001 	.word	0x78145001
    8110:	01000033 	.word	0x01000033
    8114:	005e052a 	.word	0x005e052a
    8118:	35630000 	.word	0x35630000
    811c:	16000000 	.word	0x16000000
    8120:	0032d101 	.word	0x0032d101
    8124:	05410100 	.word	0x05410100
    8128:	00009401 	.word	0x00009401
    812c:	00652800 	.word	0x00652800
    8130:	00654208 	.word	0x00654208
    8134:	b65d0108 	.word	0xb65d0108
    8138:	1400000a 	.word	0x1400000a
    813c:	00003269 	.word	0x00003269
    8140:	a0054001 	.word	0xa0054001
    8144:	76000002 	.word	0x76000002
    8148:	14000035 	.word	0x14000035
    814c:	0000367c 	.word	0x0000367c
    8150:	4c054001 	.word	0x4c054001
    8154:	94000000 	.word	0x94000000
    8158:	19000035 	.word	0x19000035
    815c:	00003567 	.word	0x00003567
    8160:	94054201 	.word	0x94054201
    8164:	b2000000 	.word	0xb2000000
    8168:	17000035 	.word	0x17000035
    816c:	00003683 	.word	0x00003683
    8170:	3a054301 	.word	0x3a054301
    8174:	17000000 	.word	0x17000000
    8178:	000033c9 	.word	0x000033c9
    817c:	3a054301 	.word	0x3a054301
    8180:	00000000 	.word	0x00000000
    8184:	33440112 	.word	0x33440112
    8188:	6c010000 	.word	0x6c010000
    818c:	65440105 	.word	0x65440105
    8190:	654c0800 	.word	0x654c0800
    8194:	5d010800 	.word	0x5d010800
    8198:	00000af9 	.word	0x00000af9
    819c:	00326913 	.word	0x00326913
    81a0:	056b0100 	.word	0x056b0100
    81a4:	000002a0 	.word	0x000002a0
    81a8:	7c145001 	.word	0x7c145001
    81ac:	01000036 	.word	0x01000036
    81b0:	004c056b 	.word	0x004c056b
    81b4:	35d00000 	.word	0x35d00000
    81b8:	83170000 	.word	0x83170000
    81bc:	01000036 	.word	0x01000036
    81c0:	005e056d 	.word	0x005e056d
    81c4:	1c000000 	.word	0x1c000000
    81c8:	00348b01 	.word	0x00348b01
    81cc:	01830100 	.word	0x01830100
    81d0:	0800654c 	.word	0x0800654c
    81d4:	080065a4 	.word	0x080065a4
    81d8:	000035e3 	.word	0x000035e3
    81dc:	0032691d 	.word	0x0032691d
    81e0:	a0820100 	.word	0xa0820100
    81e4:	0e000002 	.word	0x0e000002
    81e8:	00000036 	.word	0x00000036
    81ec:	00073600 	.word	0x00073600
    81f0:	ab000200 	.word	0xab000200
    81f4:	04000021 	.word	0x04000021
    81f8:	0001fe01 	.word	0x0001fe01
    81fc:	38650100 	.word	0x38650100
    8200:	02490000 	.word	0x02490000
    8204:	65a40000 	.word	0x65a40000
    8208:	6acc0800 	.word	0x6acc0800
    820c:	213c0800 	.word	0x213c0800
    8210:	04020000 	.word	0x04020000
    8214:	00012205 	.word	0x00012205
    8218:	05020200 	.word	0x05020200
    821c:	000004ca 	.word	0x000004ca
    8220:	9e060102 	.word	0x9e060102
    8224:	03000004 	.word	0x03000004
    8228:	00323375 	.word	0x00323375
    822c:	00452702 	.word	0x00452702
    8230:	04020000 	.word	0x04020000
    8234:	00013007 	.word	0x00013007
    8238:	31750300 	.word	0x31750300
    823c:	28020036 	.word	0x28020036
    8240:	00000057 	.word	0x00000057
    8244:	c5070202 	.word	0xc5070202
    8248:	03000001 	.word	0x03000001
    824c:	02003875 	.word	0x02003875
    8250:	00006829 	.word	0x00006829
    8254:	08010200 	.word	0x08010200
    8258:	0000049c 	.word	0x0000049c
    825c:	00004504 	.word	0x00004504
    8260:	00570400 	.word	0x00570400
    8264:	01050000 	.word	0x01050000
    8268:	008e3a02 	.word	0x008e3a02
    826c:	f2060000 	.word	0xf2060000
    8270:	0000000e 	.word	0x0000000e
    8274:	54455307 	.word	0x54455307
    8278:	08000100 	.word	0x08000100
    827c:	0000440a 	.word	0x0000440a
    8280:	00793a02 	.word	0x00793a02
    8284:	01050000 	.word	0x01050000
    8288:	00ae3c02 	.word	0x00ae3c02
    828c:	70060000 	.word	0x70060000
    8290:	0000002a 	.word	0x0000002a
    8294:	00046e06 	.word	0x00046e06
    8298:	08000100 	.word	0x08000100
    829c:	00002f71 	.word	0x00002f71
    82a0:	00993c02 	.word	0x00993c02
    82a4:	04090000 	.word	0x04090000
    82a8:	03240a07 	.word	0x03240a07
    82ac:	014a010d 	.word	0x014a010d
    82b0:	410b0000 	.word	0x410b0000
    82b4:	03005243 	.word	0x03005243
    82b8:	006f010e 	.word	0x006f010e
    82bc:	23020000 	.word	0x23020000
    82c0:	37f00c00 	.word	0x37f00c00
    82c4:	0f030000 	.word	0x0f030000
    82c8:	00006f01 	.word	0x00006f01
    82cc:	04230200 	.word	0x04230200
    82d0:	0037ed0c 	.word	0x0037ed0c
    82d4:	01100300 	.word	0x01100300
    82d8:	0000006f 	.word	0x0000006f
    82dc:	0b082302 	.word	0x0b082302
    82e0:	03005253 	.word	0x03005253
    82e4:	006f0111 	.word	0x006f0111
    82e8:	23020000 	.word	0x23020000
    82ec:	52430b0c 	.word	0x52430b0c
    82f0:	01120300 	.word	0x01120300
    82f4:	0000006f 	.word	0x0000006f
    82f8:	0b102302 	.word	0x0b102302
    82fc:	03005241 	.word	0x03005241
    8300:	006f0113 	.word	0x006f0113
    8304:	23020000 	.word	0x23020000
    8308:	3a2c0c14 	.word	0x3a2c0c14
    830c:	14030000 	.word	0x14030000
    8310:	00006f01 	.word	0x00006f01
    8314:	18230200 	.word	0x18230200
    8318:	52424f0b 	.word	0x52424f0b
    831c:	01150300 	.word	0x01150300
    8320:	0000006f 	.word	0x0000006f
    8324:	0c1c2302 	.word	0x0c1c2302
    8328:	00003783 	.word	0x00003783
    832c:	6f011603 	.word	0x6f011603
    8330:	02000000 	.word	0x02000000
    8334:	0a002023 	.word	0x0a002023
    8338:	011a0310 	.word	0x011a0310
    833c:	000001cc 	.word	0x000001cc
    8340:	5044520b 	.word	0x5044520b
    8344:	011b0300 	.word	0x011b0300
    8348:	00000074 	.word	0x00000074
    834c:	0c002302 	.word	0x0c002302
    8350:	000039f4 	.word	0x000039f4
    8354:	74011c03 	.word	0x74011c03
    8358:	02000000 	.word	0x02000000
    835c:	f90c0223 	.word	0xf90c0223
    8360:	03000039 	.word	0x03000039
    8364:	0074011d 	.word	0x0074011d
    8368:	23020000 	.word	0x23020000
    836c:	39ff0c04 	.word	0x39ff0c04
    8370:	1e030000 	.word	0x1e030000
    8374:	00007401 	.word	0x00007401
    8378:	06230200 	.word	0x06230200
    837c:	0037b60c 	.word	0x0037b60c
    8380:	011f0300 	.word	0x011f0300
    8384:	00000074 	.word	0x00000074
    8388:	0c082302 	.word	0x0c082302
    838c:	000037bb 	.word	0x000037bb
    8390:	74012003 	.word	0x74012003
    8394:	02000000 	.word	0x02000000
    8398:	c00c0a23 	.word	0xc00c0a23
    839c:	03000037 	.word	0x03000037
    83a0:	00740121 	.word	0x00740121
    83a4:	23020000 	.word	0x23020000
    83a8:	37c50c0c 	.word	0x37c50c0c
    83ac:	22030000 	.word	0x22030000
    83b0:	00007401 	.word	0x00007401
    83b4:	0e230200 	.word	0x0e230200
    83b8:	04010500 	.word	0x04010500
    83bc:	0001f31d 	.word	0x0001f31d
    83c0:	38d40600 	.word	0x38d40600
    83c4:	06010000 	.word	0x06010000
    83c8:	00003841 	.word	0x00003841
    83cc:	37310602 	.word	0x37310602
    83d0:	06030000 	.word	0x06030000
    83d4:	000038c5 	.word	0x000038c5
    83d8:	38e90604 	.word	0x38e90604
    83dc:	00050000 	.word	0x00050000
    83e0:	0037a908 	.word	0x0037a908
    83e4:	cc230400 	.word	0xcc230400
    83e8:	0d000001 	.word	0x0d000001
    83ec:	00394901 	.word	0x00394901
    83f0:	03400100 	.word	0x03400100
    83f4:	0001f301 	.word	0x0001f301
    83f8:	021e0100 	.word	0x021e0100
    83fc:	280e0000 	.word	0x280e0000
    8400:	01000038 	.word	0x01000038
    8404:	01f30341 	.word	0x01f30341
    8408:	0f000000 	.word	0x0f000000
    840c:	0000377d 	.word	0x0000377d
    8410:	01038601 	.word	0x01038601
    8414:	00023701 	.word	0x00023701
    8418:	00691000 	.word	0x00691000
    841c:	6f038701 	.word	0x6f038701
    8420:	00000000 	.word	0x00000000
    8424:	39750111 	.word	0x39750111
    8428:	57010000 	.word	0x57010000
    842c:	0065a401 	.word	0x0065a401
    8430:	0065bc08 	.word	0x0065bc08
    8434:	5e5d0108 	.word	0x5e5d0108
    8438:	12000002 	.word	0x12000002
    843c:	00003751 	.word	0x00003751
    8440:	003a5601 	.word	0x003a5601
    8444:	362d0000 	.word	0x362d0000
    8448:	11000000 	.word	0x11000000
    844c:	00398601 	.word	0x00398601
    8450:	016b0100 	.word	0x016b0100
    8454:	080065bc 	.word	0x080065bc
    8458:	080065d4 	.word	0x080065d4
    845c:	02855d01 	.word	0x02855d01
    8460:	33120000 	.word	0x33120000
    8464:	01000039 	.word	0x01000039
    8468:	00003a6a 	.word	0x00003a6a
    846c:	00364000 	.word	0x00364000
    8470:	01110000 	.word	0x01110000
    8474:	00003889 	.word	0x00003889
    8478:	d4017f01 	.word	0xd4017f01
    847c:	ec080065 	.word	0xec080065
    8480:	01080065 	.word	0x01080065
    8484:	0002ac5d 	.word	0x0002ac5d
    8488:	3a501200 	.word	0x3a501200
    848c:	7e010000 	.word	0x7e010000
    8490:	0000003a 	.word	0x0000003a
    8494:	00003653 	.word	0x00003653
    8498:	88011300 	.word	0x88011300
    849c:	01000037 	.word	0x01000037
    84a0:	65ec0191 	.word	0x65ec0191
    84a4:	66040800 	.word	0x66040800
    84a8:	5d010800 	.word	0x5d010800
    84ac:	38500113 	.word	0x38500113
    84b0:	9f010000 	.word	0x9f010000
    84b4:	00660401 	.word	0x00660401
    84b8:	00661408 	.word	0x00661408
    84bc:	145d0108 	.word	0x145d0108
    84c0:	0039bb01 	.word	0x0039bb01
    84c4:	02970100 	.word	0x02970100
    84c8:	00003a01 	.word	0x00003a01
    84cc:	00661400 	.word	0x00661400
    84d0:	00662008 	.word	0x00662008
    84d4:	145d0108 	.word	0x145d0108
    84d8:	0037ca01 	.word	0x0037ca01
    84dc:	02a40100 	.word	0x02a40100
    84e0:	00003a01 	.word	0x00003a01
    84e4:	00662000 	.word	0x00662000
    84e8:	00662c08 	.word	0x00662c08
    84ec:	155d0108 	.word	0x155d0108
    84f0:	0038ff01 	.word	0x0038ff01
    84f4:	02b20100 	.word	0x02b20100
    84f8:	00008e01 	.word	0x00008e01
    84fc:	00662c00 	.word	0x00662c00
    8500:	00663c08 	.word	0x00663c08
    8504:	2b5d0108 	.word	0x2b5d0108
    8508:	0e000003 	.word	0x0e000003
    850c:	00003723 	.word	0x00003723
    8510:	8e02b301 	.word	0x8e02b301
    8514:	00000000 	.word	0x00000000
    8518:	375f0115 	.word	0x375f0115
    851c:	c8010000 	.word	0xc8010000
    8520:	008e0102 	.word	0x008e0102
    8524:	663c0000 	.word	0x663c0000
    8528:	664c0800 	.word	0x664c0800
    852c:	5d010800 	.word	0x5d010800
    8530:	00000354 	.word	0x00000354
    8534:	0035670e 	.word	0x0035670e
    8538:	02c90100 	.word	0x02c90100
    853c:	0000008e 	.word	0x0000008e
    8540:	e3011600 	.word	0xe3011600
    8544:	01000036 	.word	0x01000036
    8548:	4c0102e3 	.word	0x4c0102e3
    854c:	68080066 	.word	0x68080066
    8550:	01080066 	.word	0x01080066
    8554:	0003895d 	.word	0x0003895d
    8558:	3a111700 	.word	0x3a111700
    855c:	e2010000 	.word	0xe2010000
    8560:	00004c02 	.word	0x00004c02
    8564:	17500100 	.word	0x17500100
    8568:	00003381 	.word	0x00003381
    856c:	ae02e201 	.word	0xae02e201
    8570:	01000000 	.word	0x01000000
    8574:	01150051 	.word	0x01150051
    8578:	000038a1 	.word	0x000038a1
    857c:	01030201 	.word	0x01030201
    8580:	0000008e 	.word	0x0000008e
    8584:	08006668 	.word	0x08006668
    8588:	08006688 	.word	0x08006688
    858c:	03c65d01 	.word	0x03c65d01
    8590:	e9180000 	.word	0xe9180000
    8594:	01000039 	.word	0x01000039
    8598:	004c0301 	.word	0x004c0301
    859c:	36660000 	.word	0x36660000
    85a0:	67190000 	.word	0x67190000
    85a4:	01000035 	.word	0x01000035
    85a8:	008e0303 	.word	0x008e0303
    85ac:	36840000 	.word	0x36840000
    85b0:	16000000 	.word	0x16000000
    85b4:	0038b501 	.word	0x0038b501
    85b8:	032f0100 	.word	0x032f0100
    85bc:	00668801 	.word	0x00668801
    85c0:	00669408 	.word	0x00669408
    85c4:	ed5d0108 	.word	0xed5d0108
    85c8:	17000003 	.word	0x17000003
    85cc:	000039e9 	.word	0x000039e9
    85d0:	4c032e01 	.word	0x4c032e01
    85d4:	01000000 	.word	0x01000000
    85d8:	fe1a0050 	.word	0xfe1a0050
    85dc:	94000001 	.word	0x94000001
    85e0:	c0080066 	.word	0xc0080066
    85e4:	01080066 	.word	0x01080066
    85e8:	00040a5d 	.word	0x00040a5d
    85ec:	02111b00 	.word	0x02111b00
    85f0:	36a20000 	.word	0x36a20000
    85f4:	1c000000 	.word	0x1c000000
    85f8:	003a3501 	.word	0x003a3501
    85fc:	03670100 	.word	0x03670100
    8600:	0001f301 	.word	0x0001f301
    8604:	0066c000 	.word	0x0066c000
    8608:	00675408 	.word	0x00675408
    860c:	0036cb08 	.word	0x0036cb08
    8610:	00049d00 	.word	0x00049d00
    8614:	38f71800 	.word	0x38f71800
    8618:	66010000 	.word	0x66010000
    861c:	00003a03 	.word	0x00003a03
    8620:	0036f600 	.word	0x0036f600
    8624:	22b61900 	.word	0x22b61900
    8628:	68010000 	.word	0x68010000
    862c:	0001f303 	.word	0x0001f303
    8630:	00371400 	.word	0x00371400
    8634:	01fe1d00 	.word	0x01fe1d00
    8638:	02700000 	.word	0x02700000
    863c:	6b010000 	.word	0x6b010000
    8640:	00046403 	.word	0x00046403
    8644:	02901e00 	.word	0x02901e00
    8648:	111f0000 	.word	0x111f0000
    864c:	00000002 	.word	0x00000002
    8650:	021e1d00 	.word	0x021e1d00
    8654:	02b00000 	.word	0x02b00000
    8658:	70010000 	.word	0x70010000
    865c:	00048403 	.word	0x00048403
    8660:	02c81e00 	.word	0x02c81e00
    8664:	2c1b0000 	.word	0x2c1b0000
    8668:	3d000002 	.word	0x3d000002
    866c:	00000037 	.word	0x00000037
    8670:	01fe2000 	.word	0x01fe2000
    8674:	02e00000 	.word	0x02e00000
    8678:	71010000 	.word	0x71010000
    867c:	02f81e03 	.word	0x02f81e03
    8680:	111f0000 	.word	0x111f0000
    8684:	00000002 	.word	0x00000002
    8688:	011c0000 	.word	0x011c0000
    868c:	000037f5 	.word	0x000037f5
    8690:	01026b01 	.word	0x01026b01
    8694:	000001f3 	.word	0x000001f3
    8698:	08006754 	.word	0x08006754
    869c:	080067b0 	.word	0x080067b0
    86a0:	0000378d 	.word	0x0000378d
    86a4:	000004fc 	.word	0x000004fc
    86a8:	0036f218 	.word	0x0036f218
    86ac:	026a0100 	.word	0x026a0100
    86b0:	0000004c 	.word	0x0000004c
    86b4:	000037b8 	.word	0x000037b8
    86b8:	00370418 	.word	0x00370418
    86bc:	026a0100 	.word	0x026a0100
    86c0:	0000004c 	.word	0x0000004c
    86c4:	000037d6 	.word	0x000037d6
    86c8:	00392018 	.word	0x00392018
    86cc:	026a0100 	.word	0x026a0100
    86d0:	0000004c 	.word	0x0000004c
    86d4:	000037f4 	.word	0x000037f4
    86d8:	0022b619 	.word	0x0022b619
    86dc:	026c0100 	.word	0x026c0100
    86e0:	000001f3 	.word	0x000001f3
    86e4:	00003812 	.word	0x00003812
    86e8:	10011c00 	.word	0x10011c00
    86ec:	01000038 	.word	0x01000038
    86f0:	f301021a 	.word	0xf301021a
    86f4:	b0000001 	.word	0xb0000001
    86f8:	4c080067 	.word	0x4c080067
    86fc:	30080068 	.word	0x30080068
    8700:	3b000038 	.word	0x3b000038
    8704:	18000005 	.word	0x18000005
    8708:	00003381 	.word	0x00003381
    870c:	ae021901 	.word	0xae021901
    8710:	5b000000 	.word	0x5b000000
    8714:	19000038 	.word	0x19000038
    8718:	000022b6 	.word	0x000022b6
    871c:	f3021b01 	.word	0xf3021b01
    8720:	79000001 	.word	0x79000001
    8724:	00000038 	.word	0x00000038
    8728:	3959011c 	.word	0x3959011c
    872c:	cb010000 	.word	0xcb010000
    8730:	01f30101 	.word	0x01f30101
    8734:	684c0000 	.word	0x684c0000
    8738:	690c0800 	.word	0x690c0800
    873c:	38a20800 	.word	0x38a20800
    8740:	05ba0000 	.word	0x05ba0000
    8744:	05180000 	.word	0x05180000
    8748:	0100003a 	.word	0x0100003a
    874c:	003a01ca 	.word	0x003a01ca
    8750:	38c10000 	.word	0x38c10000
    8754:	29190000 	.word	0x29190000
    8758:	01000039 	.word	0x01000039
    875c:	004c01cc 	.word	0x004c01cc
    8760:	38df0000 	.word	0x38df0000
    8764:	df190000 	.word	0xdf190000
    8768:	01000038 	.word	0x01000038
    876c:	004c01cc 	.word	0x004c01cc
    8770:	391e0000 	.word	0x391e0000
    8774:	fa190000 	.word	0xfa190000
    8778:	01000036 	.word	0x01000036
    877c:	004c01cc 	.word	0x004c01cc
    8780:	393c0000 	.word	0x393c0000
    8784:	5b190000 	.word	0x5b190000
    8788:	01000038 	.word	0x01000038
    878c:	004c01cc 	.word	0x004c01cc
    8790:	395a0000 	.word	0x395a0000
    8794:	b6190000 	.word	0xb6190000
    8798:	01000022 	.word	0x01000022
    879c:	01f301ce 	.word	0x01f301ce
    87a0:	39780000 	.word	0x39780000
    87a4:	1c000000 	.word	0x1c000000
    87a8:	00399f01 	.word	0x00399f01
    87ac:	019a0100 	.word	0x019a0100
    87b0:	0001f301 	.word	0x0001f301
    87b4:	00690c00 	.word	0x00690c00
    87b8:	00695008 	.word	0x00695008
    87bc:	0039b708 	.word	0x0039b708
    87c0:	00060900 	.word	0x00060900
    87c4:	488a1800 	.word	0x488a1800
    87c8:	99010000 	.word	0x99010000
    87cc:	00003a01 	.word	0x00003a01
    87d0:	0039d600 	.word	0x0039d600
    87d4:	392e1800 	.word	0x392e1800
    87d8:	99010000 	.word	0x99010000
    87dc:	00005e01 	.word	0x00005e01
    87e0:	0039f400 	.word	0x0039f400
    87e4:	22b61900 	.word	0x22b61900
    87e8:	9b010000 	.word	0x9b010000
    87ec:	0001f301 	.word	0x0001f301
    87f0:	003a1200 	.word	0x003a1200
    87f4:	011c0000 	.word	0x011c0000
    87f8:	000039d3 	.word	0x000039d3
    87fc:	01017201 	.word	0x01017201
    8800:	000001f3 	.word	0x000001f3
    8804:	08006950 	.word	0x08006950
    8808:	08006988 	.word	0x08006988
    880c:	00003a30 	.word	0x00003a30
    8810:	00000658 	.word	0x00000658
    8814:	00488a18 	.word	0x00488a18
    8818:	01710100 	.word	0x01710100
    881c:	0000003a 	.word	0x0000003a
    8820:	00003a4f 	.word	0x00003a4f
    8824:	00392e18 	.word	0x00392e18
    8828:	01710100 	.word	0x01710100
    882c:	0000004c 	.word	0x0000004c
    8830:	00003a6d 	.word	0x00003a6d
    8834:	0022b619 	.word	0x0022b619
    8838:	01730100 	.word	0x01730100
    883c:	000001f3 	.word	0x000001f3
    8840:	00003a8b 	.word	0x00003a8b
    8844:	1a011c00 	.word	0x1a011c00
    8848:	0100003a 	.word	0x0100003a
    884c:	f3010137 	.word	0xf3010137
    8850:	88000001 	.word	0x88000001
    8854:	d0080069 	.word	0xd0080069
    8858:	a9080069 	.word	0xa9080069
    885c:	a700003a 	.word	0xa700003a
    8860:	18000006 	.word	0x18000006
    8864:	0000488a 	.word	0x0000488a
    8868:	3a013601 	.word	0x3a013601
    886c:	c8000000 	.word	0xc8000000
    8870:	1800003a 	.word	0x1800003a
    8874:	0000392e 	.word	0x0000392e
    8878:	3a013601 	.word	0x3a013601
    887c:	e6000000 	.word	0xe6000000
    8880:	1900003a 	.word	0x1900003a
    8884:	000022b6 	.word	0x000022b6
    8888:	f3013801 	.word	0xf3013801
    888c:	04000001 	.word	0x04000001
    8890:	0000003b 	.word	0x0000003b
    8894:	370c0121 	.word	0x370c0121
    8898:	f8010000 	.word	0xf8010000
    889c:	0001f301 	.word	0x0001f301
    88a0:	0069d000 	.word	0x0069d000
    88a4:	006a4808 	.word	0x006a4808
    88a8:	003b2d08 	.word	0x003b2d08
    88ac:	0006d400 	.word	0x0006d400
    88b0:	22b62200 	.word	0x22b62200
    88b4:	f9010000 	.word	0xf9010000
    88b8:	000001f3 	.word	0x000001f3
    88bc:	00003b4c 	.word	0x00003b4c
    88c0:	95012100 	.word	0x95012100
    88c4:	01000037 	.word	0x01000037
    88c8:	01f301d5 	.word	0x01f301d5
    88cc:	6a480000 	.word	0x6a480000
    88d0:	6a840800 	.word	0x6a840800
    88d4:	3b750800 	.word	0x3b750800
    88d8:	07010000 	.word	0x07010000
    88dc:	b6220000 	.word	0xb6220000
    88e0:	01000022 	.word	0x01000022
    88e4:	0001f3d6 	.word	0x0001f3d6
    88e8:	003b9400 	.word	0x003b9400
    88ec:	01230000 	.word	0x01230000
    88f0:	00003741 	.word	0x00003741
    88f4:	f301ae01 	.word	0xf301ae01
    88f8:	84000001 	.word	0x84000001
    88fc:	cc08006a 	.word	0xcc08006a
    8900:	b208006a 	.word	0xb208006a
    8904:	1200003b 	.word	0x1200003b
    8908:	00003834 	.word	0x00003834
    890c:	003aad01 	.word	0x003aad01
    8910:	3bdd0000 	.word	0x3bdd0000
    8914:	b6220000 	.word	0xb6220000
    8918:	01000022 	.word	0x01000022
    891c:	0001f3af 	.word	0x0001f3af
    8920:	003bfb00 	.word	0x003bfb00
    8924:	44000000 	.word	0x44000000
    8928:	02000006 	.word	0x02000006
    892c:	0023c700 	.word	0x0023c700
    8930:	fe010400 	.word	0xfe010400
    8934:	01000001 	.word	0x01000001
    8938:	00003ae9 	.word	0x00003ae9
    893c:	00000249 	.word	0x00000249
    8940:	08006acc 	.word	0x08006acc
    8944:	08006d54 	.word	0x08006d54
    8948:	0000235f 	.word	0x0000235f
    894c:	22050402 	.word	0x22050402
    8950:	02000001 	.word	0x02000001
    8954:	04ca0502 	.word	0x04ca0502
    8958:	01020000 	.word	0x01020000
    895c:	00049e06 	.word	0x00049e06
    8960:	33750300 	.word	0x33750300
    8964:	27020032 	.word	0x27020032
    8968:	00000045 	.word	0x00000045
    896c:	30070402 	.word	0x30070402
    8970:	03000001 	.word	0x03000001
    8974:	00363175 	.word	0x00363175
    8978:	00572802 	.word	0x00572802
    897c:	02020000 	.word	0x02020000
    8980:	0001c507 	.word	0x0001c507
    8984:	38750300 	.word	0x38750300
    8988:	68290200 	.word	0x68290200
    898c:	02000000 	.word	0x02000000
    8990:	049c0801 	.word	0x049c0801
    8994:	45040000 	.word	0x45040000
    8998:	05000000 	.word	0x05000000
    899c:	893c0201 	.word	0x893c0201
    89a0:	06000000 	.word	0x06000000
    89a4:	00002a70 	.word	0x00002a70
    89a8:	046e0600 	.word	0x046e0600
    89ac:	00010000 	.word	0x00010000
    89b0:	002f7107 	.word	0x002f7107
    89b4:	743c0200 	.word	0x743c0200
    89b8:	08000000 	.word	0x08000000
    89bc:	1c090704 	.word	0x1c090704
    89c0:	0a014f03 	.word	0x0a014f03
    89c4:	0a000001 	.word	0x0a000001
    89c8:	004c5243 	.word	0x004c5243
    89cc:	6f015003 	.word	0x6f015003
    89d0:	02000000 	.word	0x02000000
    89d4:	430a0023 	.word	0x430a0023
    89d8:	03004852 	.word	0x03004852
    89dc:	006f0151 	.word	0x006f0151
    89e0:	23020000 	.word	0x23020000
    89e4:	44490a04 	.word	0x44490a04
    89e8:	52030052 	.word	0x52030052
    89ec:	00006f01 	.word	0x00006f01
    89f0:	08230200 	.word	0x08230200
    89f4:	52444f0a 	.word	0x52444f0a
    89f8:	01530300 	.word	0x01530300
    89fc:	0000006f 	.word	0x0000006f
    8a00:	0b0c2302 	.word	0x0b0c2302
    8a04:	00002a7d 	.word	0x00002a7d
    8a08:	6f015403 	.word	0x6f015403
    8a0c:	02000000 	.word	0x02000000
    8a10:	420a1023 	.word	0x420a1023
    8a14:	03005252 	.word	0x03005252
    8a18:	006f0155 	.word	0x006f0155
    8a1c:	23020000 	.word	0x23020000
    8a20:	2b270b14 	.word	0x2b270b14
    8a24:	56030000 	.word	0x56030000
    8a28:	00006f01 	.word	0x00006f01
    8a2c:	18230200 	.word	0x18230200
    8a30:	29e80c00 	.word	0x29e80c00
    8a34:	57030000 	.word	0x57030000
    8a38:	00009701 	.word	0x00009701
    8a3c:	03180900 	.word	0x03180900
    8a40:	014d015a 	.word	0x014d015a
    8a44:	300b0000 	.word	0x300b0000
    8a48:	0300003c 	.word	0x0300003c
    8a4c:	006f015b 	.word	0x006f015b
    8a50:	23020000 	.word	0x23020000
    8a54:	3c150b00 	.word	0x3c150b00
    8a58:	5c030000 	.word	0x5c030000
    8a5c:	00006f01 	.word	0x00006f01
    8a60:	04230200 	.word	0x04230200
    8a64:	003ae20b 	.word	0x003ae20b
    8a68:	015d0300 	.word	0x015d0300
    8a6c:	0000015d 	.word	0x0000015d
    8a70:	00082302 	.word	0x00082302
    8a74:	0000450d 	.word	0x0000450d
    8a78:	00015d00 	.word	0x00015d00
    8a7c:	00940e00 	.word	0x00940e00
    8a80:	00030000 	.word	0x00030000
    8a84:	00014d04 	.word	0x00014d04
    8a88:	04010500 	.word	0x04010500
    8a8c:	00017d23 	.word	0x00017d23
    8a90:	2e200600 	.word	0x2e200600
    8a94:	06010000 	.word	0x06010000
    8a98:	00002e3a 	.word	0x00002e3a
    8a9c:	2e9b0602 	.word	0x2e9b0602
    8aa0:	00030000 	.word	0x00030000
    8aa4:	002f5f07 	.word	0x002f5f07
    8aa8:	62270400 	.word	0x62270400
    8aac:	05000001 	.word	0x05000001
    8ab0:	c22e0401 	.word	0xc22e0401
    8ab4:	06000001 	.word	0x06000001
    8ab8:	00002f1b 	.word	0x00002f1b
    8abc:	2fcc0600 	.word	0x2fcc0600
    8ac0:	06040000 	.word	0x06040000
    8ac4:	00002e8d 	.word	0x00002e8d
    8ac8:	2ef80628 	.word	0x2ef80628
    8acc:	00c80000 	.word	0x00c80000
    8ad0:	002dbd06 	.word	0x002dbd06
    8ad4:	92061400 	.word	0x92061400
    8ad8:	1000002f 	.word	0x1000002f
    8adc:	002fe206 	.word	0x002fe206
    8ae0:	ce061c00 	.word	0xce061c00
    8ae4:	1800002d 	.word	0x1800002d
    8ae8:	2d520700 	.word	0x2d520700
    8aec:	36040000 	.word	0x36040000
    8af0:	00000188 	.word	0x00000188
    8af4:	3f04040f 	.word	0x3f04040f
    8af8:	00000200 	.word	0x00000200
    8afc:	002d1410 	.word	0x002d1410
    8b00:	4c400400 	.word	0x4c400400
    8b04:	02000000 	.word	0x02000000
    8b08:	8f100023 	.word	0x8f100023
    8b0c:	0400002d 	.word	0x0400002d
    8b10:	00017d41 	.word	0x00017d41
    8b14:	02230200 	.word	0x02230200
    8b18:	002ff210 	.word	0x002ff210
    8b1c:	c2420400 	.word	0xc2420400
    8b20:	02000001 	.word	0x02000001
    8b24:	07000323 	.word	0x07000323
    8b28:	00002e5d 	.word	0x00002e5d
    8b2c:	01cd4304 	.word	0x01cd4304
    8b30:	01050000 	.word	0x01050000
    8b34:	02204704 	.word	0x02204704
    8b38:	b3060000 	.word	0xb3060000
    8b3c:	0000003a 	.word	0x0000003a
    8b40:	003a6c06 	.word	0x003a6c06
    8b44:	07000100 	.word	0x07000100
    8b48:	00003c0b 	.word	0x00003c0b
    8b4c:	020b4904 	.word	0x020b4904
    8b50:	01110000 	.word	0x01110000
    8b54:	00003ad8 	.word	0x00003ad8
    8b58:	cc017d01 	.word	0xcc017d01
    8b5c:	7208006a 	.word	0x7208006a
    8b60:	1908006b 	.word	0x1908006b
    8b64:	af00003c 	.word	0xaf00003c
    8b68:	12000002 	.word	0x12000002
    8b6c:	00003c1a 	.word	0x00003c1a
    8b70:	02af7c01 	.word	0x02af7c01
    8b74:	50010000 	.word	0x50010000
    8b78:	003c2013 	.word	0x003c2013
    8b7c:	b57c0100 	.word	0xb57c0100
    8b80:	44000002 	.word	0x44000002
    8b84:	1400003c 	.word	0x1400003c
    8b88:	00003b7f 	.word	0x00003b7f
    8b8c:	003a7e01 	.word	0x003a7e01
    8b90:	57010000 	.word	0x57010000
    8b94:	003bdc14 	.word	0x003bdc14
    8b98:	3a7e0100 	.word	0x3a7e0100
    8b9c:	01000000 	.word	0x01000000
    8ba0:	3a65145c 	.word	0x3a65145c
    8ba4:	7e010000 	.word	0x7e010000
    8ba8:	0000003a 	.word	0x0000003a
    8bac:	70155101 	.word	0x70155101
    8bb0:	0100736f 	.word	0x0100736f
    8bb4:	00003a7e 	.word	0x00003a7e
    8bb8:	003c6d00 	.word	0x003c6d00
    8bbc:	341a1400 	.word	0x341a1400
    8bc0:	7f010000 	.word	0x7f010000
    8bc4:	0000003a 	.word	0x0000003a
    8bc8:	0c165401 	.word	0x0c165401
    8bcc:	0100003b 	.word	0x0100003b
    8bd0:	00003a7f 	.word	0x00003a7f
    8bd4:	04170000 	.word	0x04170000
    8bd8:	0000010a 	.word	0x0000010a
    8bdc:	02000417 	.word	0x02000417
    8be0:	01180000 	.word	0x01180000
    8be4:	00003a9c 	.word	0x00003a9c
    8be8:	7401e601 	.word	0x7401e601
    8bec:	8408006b 	.word	0x8408006b
    8bf0:	0108006b 	.word	0x0108006b
    8bf4:	0002e05d 	.word	0x0002e05d
    8bf8:	3c201200 	.word	0x3c201200
    8bfc:	e5010000 	.word	0xe5010000
    8c00:	000002b5 	.word	0x000002b5
    8c04:	19005001 	.word	0x19005001
    8c08:	003b5201 	.word	0x003b5201
    8c0c:	01f70100 	.word	0x01f70100
    8c10:	0000005e 	.word	0x0000005e
    8c14:	08006b84 	.word	0x08006b84
    8c18:	08006b90 	.word	0x08006b90
    8c1c:	03235d01 	.word	0x03235d01
    8c20:	1a130000 	.word	0x1a130000
    8c24:	0100003c 	.word	0x0100003c
    8c28:	0002aff6 	.word	0x0002aff6
    8c2c:	003ca100 	.word	0x003ca100
    8c30:	2d141200 	.word	0x2d141200
    8c34:	f6010000 	.word	0xf6010000
    8c38:	0000004c 	.word	0x0000004c
    8c3c:	67165101 	.word	0x67165101
    8c40:	01000035 	.word	0x01000035
    8c44:	00005ef8 	.word	0x00005ef8
    8c48:	011a0000 	.word	0x011a0000
    8c4c:	00003bae 	.word	0x00003bae
    8c50:	01011101 	.word	0x01011101
    8c54:	0000004c 	.word	0x0000004c
    8c58:	08006b90 	.word	0x08006b90
    8c5c:	08006b96 	.word	0x08006b96
    8c60:	03505d01 	.word	0x03505d01
    8c64:	1a1b0000 	.word	0x1a1b0000
    8c68:	0100003c 	.word	0x0100003c
    8c6c:	02af0110 	.word	0x02af0110
    8c70:	3cb40000 	.word	0x3cb40000
    8c74:	1a000000 	.word	0x1a000000
    8c78:	003c3501 	.word	0x003c3501
    8c7c:	01220100 	.word	0x01220100
    8c80:	00005e01 	.word	0x00005e01
    8c84:	006b9800 	.word	0x006b9800
    8c88:	006ba408 	.word	0x006ba408
    8c8c:	975d0108 	.word	0x975d0108
    8c90:	1b000003 	.word	0x1b000003
    8c94:	00003c1a 	.word	0x00003c1a
    8c98:	af012101 	.word	0xaf012101
    8c9c:	c7000002 	.word	0xc7000002
    8ca0:	1c00003c 	.word	0x1c00003c
    8ca4:	00002d14 	.word	0x00002d14
    8ca8:	4c012101 	.word	0x4c012101
    8cac:	01000000 	.word	0x01000000
    8cb0:	35671d51 	.word	0x35671d51
    8cb4:	23010000 	.word	0x23010000
    8cb8:	00005e01 	.word	0x00005e01
    8cbc:	011a0000 	.word	0x011a0000
    8cc0:	00003a74 	.word	0x00003a74
    8cc4:	01013c01 	.word	0x01013c01
    8cc8:	0000004c 	.word	0x0000004c
    8ccc:	08006ba4 	.word	0x08006ba4
    8cd0:	08006baa 	.word	0x08006baa
    8cd4:	03c45d01 	.word	0x03c45d01
    8cd8:	1a1b0000 	.word	0x1a1b0000
    8cdc:	0100003c 	.word	0x0100003c
    8ce0:	02af013b 	.word	0x02af013b
    8ce4:	3cda0000 	.word	0x3cda0000
    8ce8:	1e000000 	.word	0x1e000000
    8cec:	003acb01 	.word	0x003acb01
    8cf0:	014e0100 	.word	0x014e0100
    8cf4:	006bac01 	.word	0x006bac01
    8cf8:	006bb008 	.word	0x006bb008
    8cfc:	f95d0108 	.word	0xf95d0108
    8d00:	1c000003 	.word	0x1c000003
    8d04:	00003c1a 	.word	0x00003c1a
    8d08:	af014d01 	.word	0xaf014d01
    8d0c:	01000002 	.word	0x01000002
    8d10:	2d141c50 	.word	0x2d141c50
    8d14:	4d010000 	.word	0x4d010000
    8d18:	00004c01 	.word	0x00004c01
    8d1c:	00510100 	.word	0x00510100
    8d20:	3b68011e 	.word	0x3b68011e
    8d24:	61010000 	.word	0x61010000
    8d28:	6bb00101 	.word	0x6bb00101
    8d2c:	6bb40800 	.word	0x6bb40800
    8d30:	5d010800 	.word	0x5d010800
    8d34:	0000042e 	.word	0x0000042e
    8d38:	003c1a1c 	.word	0x003c1a1c
    8d3c:	01600100 	.word	0x01600100
    8d40:	000002af 	.word	0x000002af
    8d44:	141c5001 	.word	0x141c5001
    8d48:	0100002d 	.word	0x0100002d
    8d4c:	004c0160 	.word	0x004c0160
    8d50:	51010000 	.word	0x51010000
    8d54:	bd011e00 	.word	0xbd011e00
    8d58:	0100003a 	.word	0x0100003a
    8d5c:	b4010177 	.word	0xb4010177
    8d60:	be08006b 	.word	0xbe08006b
    8d64:	0108006b 	.word	0x0108006b
    8d68:	0004715d 	.word	0x0004715d
    8d6c:	3c1a1c00 	.word	0x3c1a1c00
    8d70:	76010000 	.word	0x76010000
    8d74:	0002af01 	.word	0x0002af01
    8d78:	1c500100 	.word	0x1c500100
    8d7c:	00002d14 	.word	0x00002d14
    8d80:	4c017601 	.word	0x4c017601
    8d84:	01000000 	.word	0x01000000
    8d88:	3aac1c51 	.word	0x3aac1c51
    8d8c:	76010000 	.word	0x76010000
    8d90:	00022001 	.word	0x00022001
    8d94:	00520100 	.word	0x00520100
    8d98:	3be7011e 	.word	0x3be7011e
    8d9c:	91010000 	.word	0x91010000
    8da0:	6bc00101 	.word	0x6bc00101
    8da4:	6bc40800 	.word	0x6bc40800
    8da8:	5d010800 	.word	0x5d010800
    8dac:	000004a6 	.word	0x000004a6
    8db0:	003c1a1c 	.word	0x003c1a1c
    8db4:	01900100 	.word	0x01900100
    8db8:	000002af 	.word	0x000002af
    8dbc:	771c5001 	.word	0x771c5001
    8dc0:	0100003b 	.word	0x0100003b
    8dc4:	004c0190 	.word	0x004c0190
    8dc8:	51010000 	.word	0x51010000
    8dcc:	c9011e00 	.word	0xc9011e00
    8dd0:	0100003b 	.word	0x0100003b
    8dd4:	c40101a3 	.word	0xc40101a3
    8dd8:	d408006b 	.word	0xd408006b
    8ddc:	0108006b 	.word	0x0108006b
    8de0:	0004e95d 	.word	0x0004e95d
    8de4:	3c1a1c00 	.word	0x3c1a1c00
    8de8:	a2010000 	.word	0xa2010000
    8dec:	0002af01 	.word	0x0002af01
    8df0:	1c500100 	.word	0x1c500100
    8df4:	00002d14 	.word	0x00002d14
    8df8:	4c01a201 	.word	0x4c01a201
    8dfc:	01000000 	.word	0x01000000
    8e00:	6d741f51 	.word	0x6d741f51
    8e04:	a4010070 	.word	0xa4010070
    8e08:	00003a01 	.word	0x00003a01
    8e0c:	00530100 	.word	0x00530100
    8e10:	3b30011e 	.word	0x3b30011e
    8e14:	c4010000 	.word	0xc4010000
    8e18:	6bd40101 	.word	0x6bd40101
    8e1c:	6bf40800 	.word	0x6bf40800
    8e20:	5d010800 	.word	0x5d010800
    8e24:	00000530 	.word	0x00000530
    8e28:	003b141c 	.word	0x003b141c
    8e2c:	01c30100 	.word	0x01c30100
    8e30:	0000005e 	.word	0x0000005e
    8e34:	9f1b5001 	.word	0x9f1b5001
    8e38:	0100003b 	.word	0x0100003b
    8e3c:	005e01c3 	.word	0x005e01c3
    8e40:	3ced0000 	.word	0x3ced0000
    8e44:	1a200000 	.word	0x1a200000
    8e48:	01000034 	.word	0x01000034
    8e4c:	003a01c5 	.word	0x003a01c5
    8e50:	3d000000 	.word	0x3d000000
    8e54:	1e000000 	.word	0x1e000000
    8e58:	003a8801 	.word	0x003a8801
    8e5c:	01dd0100 	.word	0x01dd0100
    8e60:	006bf401 	.word	0x006bf401
    8e64:	006c0008 	.word	0x006c0008
    8e68:	575d0108 	.word	0x575d0108
    8e6c:	1c000005 	.word	0x1c000005
    8e70:	00003381 	.word	0x00003381
    8e74:	8901dc01 	.word	0x8901dc01
    8e78:	01000000 	.word	0x01000000
    8e7c:	01210050 	.word	0x01210050
    8e80:	00003b8b 	.word	0x00003b8b
    8e84:	01020801 	.word	0x01020801
    8e88:	08006c00 	.word	0x08006c00
    8e8c:	08006c60 	.word	0x08006c60
    8e90:	00003d3f 	.word	0x00003d3f
    8e94:	000005c6 	.word	0x000005c6
    8e98:	003b471c 	.word	0x003b471c
    8e9c:	02070100 	.word	0x02070100
    8ea0:	0000003a 	.word	0x0000003a
    8ea4:	811b5001 	.word	0x811b5001
    8ea8:	01000033 	.word	0x01000033
    8eac:	00890207 	.word	0x00890207
    8eb0:	3d5e0000 	.word	0x3d5e0000
    8eb4:	741f0000 	.word	0x741f0000
    8eb8:	0100706d 	.word	0x0100706d
    8ebc:	003a0209 	.word	0x003a0209
    8ec0:	54010000 	.word	0x54010000
    8ec4:	003bf21d 	.word	0x003bf21d
    8ec8:	02090100 	.word	0x02090100
    8ecc:	0000003a 	.word	0x0000003a
    8ed0:	00341a20 	.word	0x00341a20
    8ed4:	02090100 	.word	0x02090100
    8ed8:	0000003a 	.word	0x0000003a
    8edc:	00003d7c 	.word	0x00003d7c
    8ee0:	003bc11d 	.word	0x003bc11d
    8ee4:	02090100 	.word	0x02090100
    8ee8:	0000003a 	.word	0x0000003a
    8eec:	f7012100 	.word	0xf7012100
    8ef0:	0100003b 	.word	0x0100003b
    8ef4:	6001023a 	.word	0x6001023a
    8ef8:	9408006c 	.word	0x9408006c
    8efc:	bb08006c 	.word	0xbb08006c
    8f00:	0d00003d 	.word	0x0d00003d
    8f04:	1b000006 	.word	0x1b000006
    8f08:	00003b14 	.word	0x00003b14
    8f0c:	5e023901 	.word	0x5e023901
    8f10:	da000000 	.word	0xda000000
    8f14:	1b00003d 	.word	0x1b00003d
    8f18:	00003b9f 	.word	0x00003b9f
    8f1c:	5e023901 	.word	0x5e023901
    8f20:	ed000000 	.word	0xed000000
    8f24:	2200003d 	.word	0x2200003d
    8f28:	00706d74 	.word	0x00706d74
    8f2c:	3a023b01 	.word	0x3a023b01
    8f30:	00000000 	.word	0x00000000
    8f34:	3c4c0123 	.word	0x3c4c0123
    8f38:	6c010000 	.word	0x6c010000
    8f3c:	006c9401 	.word	0x006c9401
    8f40:	006cac08 	.word	0x006cac08
    8f44:	003e0008 	.word	0x003e0008
    8f48:	24012400 	.word	0x24012400
    8f4c:	0100003b 	.word	0x0100003b
    8f50:	6cac0134 	.word	0x6cac0134
    8f54:	6d540800 	.word	0x6d540800
    8f58:	3e2b0800 	.word	0x3e2b0800
    8f5c:	1a130000 	.word	0x1a130000
    8f60:	0100003c 	.word	0x0100003c
    8f64:	0002af33 	.word	0x0002af33
    8f68:	003e5600 	.word	0x003e5600
    8f6c:	e3000000 	.word	0xe3000000
    8f70:	02000008 	.word	0x02000008
    8f74:	0025ec00 	.word	0x0025ec00
    8f78:	fe010400 	.word	0xfe010400
    8f7c:	01000001 	.word	0x01000001
    8f80:	00003d4f 	.word	0x00003d4f
    8f84:	00000249 	.word	0x00000249
    8f88:	08006d54 	.word	0x08006d54
    8f8c:	080070d8 	.word	0x080070d8
    8f90:	000024d7 	.word	0x000024d7
    8f94:	22050402 	.word	0x22050402
    8f98:	02000001 	.word	0x02000001
    8f9c:	04ca0502 	.word	0x04ca0502
    8fa0:	01020000 	.word	0x01020000
    8fa4:	00049e06 	.word	0x00049e06
    8fa8:	33750300 	.word	0x33750300
    8fac:	27020032 	.word	0x27020032
    8fb0:	00000045 	.word	0x00000045
    8fb4:	30070402 	.word	0x30070402
    8fb8:	03000001 	.word	0x03000001
    8fbc:	00363175 	.word	0x00363175
    8fc0:	00572802 	.word	0x00572802
    8fc4:	02020000 	.word	0x02020000
    8fc8:	0001c507 	.word	0x0001c507
    8fcc:	38750300 	.word	0x38750300
    8fd0:	68290200 	.word	0x68290200
    8fd4:	02000000 	.word	0x02000000
    8fd8:	049c0801 	.word	0x049c0801
    8fdc:	45040000 	.word	0x45040000
    8fe0:	05000000 	.word	0x05000000
    8fe4:	0000006f 	.word	0x0000006f
    8fe8:	3a020106 	.word	0x3a020106
    8fec:	0000008e 	.word	0x0000008e
    8ff0:	000ef207 	.word	0x000ef207
    8ff4:	53080000 	.word	0x53080000
    8ff8:	01005445 	.word	0x01005445
    8ffc:	42040900 	.word	0x42040900
    9000:	3a020000 	.word	0x3a020000
    9004:	00000079 	.word	0x00000079
    9008:	3c020106 	.word	0x3c020106
    900c:	000000ae 	.word	0x000000ae
    9010:	002a7007 	.word	0x002a7007
    9014:	6e070000 	.word	0x6e070000
    9018:	01000004 	.word	0x01000004
    901c:	2f710900 	.word	0x2f710900
    9020:	3c020000 	.word	0x3c020000
    9024:	00000099 	.word	0x00000099
    9028:	0b07040a 	.word	0x0b07040a
    902c:	8203033c 	.word	0x8203033c
    9030:	00017501 	.word	0x00017501
    9034:	3f470c00 	.word	0x3f470c00
    9038:	83030000 	.word	0x83030000
    903c:	00018501 	.word	0x00018501
    9040:	00230200 	.word	0x00230200
    9044:	0031d30c 	.word	0x0031d30c
    9048:	01840300 	.word	0x01840300
    904c:	0000018a 	.word	0x0000018a
    9050:	0c082302 	.word	0x0c082302
    9054:	00003f0b 	.word	0x00003f0b
    9058:	9a018503 	.word	0x9a018503
    905c:	03000001 	.word	0x03000001
    9060:	0c018023 	.word	0x0c018023
    9064:	00003dd7 	.word	0x00003dd7
    9068:	8a018603 	.word	0x8a018603
    906c:	03000001 	.word	0x03000001
    9070:	0c018823 	.word	0x0c018823
    9074:	00003f21 	.word	0x00003f21
    9078:	9f018703 	.word	0x9f018703
    907c:	03000001 	.word	0x03000001
    9080:	0c028023 	.word	0x0c028023
    9084:	000031dd 	.word	0x000031dd
    9088:	8a018803 	.word	0x8a018803
    908c:	03000001 	.word	0x03000001
    9090:	0c028823 	.word	0x0c028823
    9094:	00003e97 	.word	0x00003e97
    9098:	a4018903 	.word	0xa4018903
    909c:	03000001 	.word	0x03000001
    90a0:	0c038023 	.word	0x0c038023
    90a4:	000031e7 	.word	0x000031e7
    90a8:	8a018a03 	.word	0x8a018a03
    90ac:	03000001 	.word	0x03000001
    90b0:	0c038823 	.word	0x0c038823
    90b4:	00003c5c 	.word	0x00003c5c
    90b8:	a9018b03 	.word	0xa9018b03
    90bc:	03000001 	.word	0x03000001
    90c0:	0c048023 	.word	0x0c048023
    90c4:	000031f1 	.word	0x000031f1
    90c8:	ae018c03 	.word	0xae018c03
    90cc:	03000001 	.word	0x03000001
    90d0:	0d048823 	.word	0x0d048823
    90d4:	00525049 	.word	0x00525049
    90d8:	ce018d03 	.word	0xce018d03
    90dc:	03000001 	.word	0x03000001
    90e0:	00068023 	.word	0x00068023
    90e4:	0000450e 	.word	0x0000450e
    90e8:	00018500 	.word	0x00018500
    90ec:	00b90f00 	.word	0x00b90f00
    90f0:	00010000 	.word	0x00010000
    90f4:	00017504 	.word	0x00017504
    90f8:	003a0e00 	.word	0x003a0e00
    90fc:	019a0000 	.word	0x019a0000
    9100:	b90f0000 	.word	0xb90f0000
    9104:	1d000000 	.word	0x1d000000
    9108:	01750400 	.word	0x01750400
    910c:	75040000 	.word	0x75040000
    9110:	04000001 	.word	0x04000001
    9114:	00000175 	.word	0x00000175
    9118:	00017504 	.word	0x00017504
    911c:	003a0e00 	.word	0x003a0e00
    9120:	01be0000 	.word	0x01be0000
    9124:	b90f0000 	.word	0xb90f0000
    9128:	3d000000 	.word	0x3d000000
    912c:	00450e00 	.word	0x00450e00
    9130:	01ce0000 	.word	0x01ce0000
    9134:	b90f0000 	.word	0xb90f0000
    9138:	0e000000 	.word	0x0e000000
    913c:	01be0400 	.word	0x01be0400
    9140:	40100000 	.word	0x40100000
    9144:	af019103 	.word	0xaf019103
    9148:	0c000002 	.word	0x0c000002
    914c:	00003d7a 	.word	0x00003d7a
    9150:	74019203 	.word	0x74019203
    9154:	02000000 	.word	0x02000000
    9158:	d20c0023 	.word	0xd20c0023
    915c:	0300003d 	.word	0x0300003d
    9160:	006f0193 	.word	0x006f0193
    9164:	23020000 	.word	0x23020000
    9168:	3f1c0c04 	.word	0x3f1c0c04
    916c:	94030000 	.word	0x94030000
    9170:	00006f01 	.word	0x00006f01
    9174:	08230200 	.word	0x08230200
    9178:	003e7d0c 	.word	0x003e7d0c
    917c:	01950300 	.word	0x01950300
    9180:	0000006f 	.word	0x0000006f
    9184:	0d0c2302 	.word	0x0d0c2302
    9188:	00524353 	.word	0x00524353
    918c:	6f019603 	.word	0x6f019603
    9190:	02000000 	.word	0x02000000
    9194:	430d1023 	.word	0x430d1023
    9198:	03005243 	.word	0x03005243
    919c:	006f0197 	.word	0x006f0197
    91a0:	23020000 	.word	0x23020000
    91a4:	3ea60c14 	.word	0x3ea60c14
    91a8:	98030000 	.word	0x98030000
    91ac:	0002bf01 	.word	0x0002bf01
    91b0:	18230200 	.word	0x18230200
    91b4:	003eab0c 	.word	0x003eab0c
    91b8:	01990300 	.word	0x01990300
    91bc:	0000006f 	.word	0x0000006f
    91c0:	0c242302 	.word	0x0c242302
    91c4:	00003e58 	.word	0x00003e58
    91c8:	6f019a03 	.word	0x6f019a03
    91cc:	02000000 	.word	0x02000000
    91d0:	2b0c2823 	.word	0x2b0c2823
    91d4:	0300003f 	.word	0x0300003f
    91d8:	006f019b 	.word	0x006f019b
    91dc:	23020000 	.word	0x23020000
    91e0:	3f260c2c 	.word	0x3f260c2c
    91e4:	9c030000 	.word	0x9c030000
    91e8:	00006f01 	.word	0x00006f01
    91ec:	30230200 	.word	0x30230200
    91f0:	003ec10c 	.word	0x003ec10c
    91f4:	019d0300 	.word	0x019d0300
    91f8:	0000006f 	.word	0x0000006f
    91fc:	0c342302 	.word	0x0c342302
    9200:	00003e2f 	.word	0x00003e2f
    9204:	6f019e03 	.word	0x6f019e03
    9208:	02000000 	.word	0x02000000
    920c:	420c3823 	.word	0x420c3823
    9210:	0300003f 	.word	0x0300003f
    9214:	006f019f 	.word	0x006f019f
    9218:	23020000 	.word	0x23020000
    921c:	450e003c 	.word	0x450e003c
    9220:	bf000000 	.word	0xbf000000
    9224:	0f000002 	.word	0x0f000002
    9228:	000000b9 	.word	0x000000b9
    922c:	af040002 	.word	0xaf040002
    9230:	11000002 	.word	0x11000002
    9234:	051b0404 	.word	0x051b0404
    9238:	12000003 	.word	0x12000003
    923c:	00002ed6 	.word	0x00002ed6
    9240:	005e1c04 	.word	0x005e1c04
    9244:	23020000 	.word	0x23020000
    9248:	2f3d1200 	.word	0x2f3d1200
    924c:	1d040000 	.word	0x1d040000
    9250:	0000005e 	.word	0x0000005e
    9254:	12012302 	.word	0x12012302
    9258:	00002da2 	.word	0x00002da2
    925c:	005e1e04 	.word	0x005e1e04
    9260:	23020000 	.word	0x23020000
    9264:	2d2f1202 	.word	0x2d2f1202
    9268:	1f040000 	.word	0x1f040000
    926c:	000000ae 	.word	0x000000ae
    9270:	00032302 	.word	0x00032302
    9274:	002f8109 	.word	0x002f8109
    9278:	c4200400 	.word	0xc4200400
    927c:	13000002 	.word	0x13000002
    9280:	00407801 	.word	0x00407801
    9284:	01250100 	.word	0x01250100
    9288:	08006d54 	.word	0x08006d54
    928c:	08006d88 	.word	0x08006d88
    9290:	03355d01 	.word	0x03355d01
    9294:	8a140000 	.word	0x8a140000
    9298:	0100001a 	.word	0x0100001a
    929c:	00003a26 	.word	0x00003a26
    92a0:	00520100 	.word	0x00520100
    92a4:	40050113 	.word	0x40050113
    92a8:	3c010000 	.word	0x3c010000
    92ac:	006d8801 	.word	0x006d8801
    92b0:	006db808 	.word	0x006db808
    92b4:	585d0108 	.word	0x585d0108
    92b8:	15000003 	.word	0x15000003
    92bc:	00001a8a 	.word	0x00001a8a
    92c0:	003a3d01 	.word	0x003a3d01
    92c4:	13000000 	.word	0x13000000
    92c8:	00408401 	.word	0x00408401
    92cc:	01620100 	.word	0x01620100
    92d0:	08006db8 	.word	0x08006db8
    92d4:	08006dcc 	.word	0x08006dcc
    92d8:	037f5d01 	.word	0x037f5d01
    92dc:	80160000 	.word	0x80160000
    92e0:	0100003d 	.word	0x0100003d
    92e4:	00003a61 	.word	0x00003a61
    92e8:	003e7500 	.word	0x003e7500
    92ec:	01170000 	.word	0x01170000
    92f0:	00003e9c 	.word	0x00003e9c
    92f4:	cc017501 	.word	0xcc017501
    92f8:	4808006d 	.word	0x4808006d
    92fc:	8808006e 	.word	0x8808006e
    9300:	eb00003e 	.word	0xeb00003e
    9304:	16000003 	.word	0x16000003
    9308:	00003c80 	.word	0x00003c80
    930c:	03eb7401 	.word	0x03eb7401
    9310:	3ea70000 	.word	0x3ea70000
    9314:	10180000 	.word	0x10180000
    9318:	0100003f 	.word	0x0100003f
    931c:	00003a76 	.word	0x00003a76
    9320:	003ec500 	.word	0x003ec500
    9324:	341a1800 	.word	0x341a1800
    9328:	76010000 	.word	0x76010000
    932c:	0000003a 	.word	0x0000003a
    9330:	00003eee 	.word	0x00003eee
    9334:	003bc118 	.word	0x003bc118
    9338:	3a760100 	.word	0x3a760100
    933c:	0c000000 	.word	0x0c000000
    9340:	1500003f 	.word	0x1500003f
    9344:	00003d08 	.word	0x00003d08
    9348:	003a7701 	.word	0x003a7701
    934c:	c7150000 	.word	0xc7150000
    9350:	0100003e 	.word	0x0100003e
    9354:	00003a77 	.word	0x00003a77
    9358:	04190000 	.word	0x04190000
    935c:	00000305 	.word	0x00000305
    9360:	3efb0113 	.word	0x3efb0113
    9364:	a9010000 	.word	0xa9010000
    9368:	006e4801 	.word	0x006e4801
    936c:	006e5408 	.word	0x006e5408
    9370:	165d0108 	.word	0x165d0108
    9374:	1a000004 	.word	0x1a000004
    9378:	00003c80 	.word	0x00003c80
    937c:	03eba801 	.word	0x03eba801
    9380:	50010000 	.word	0x50010000
    9384:	90011b00 	.word	0x90011b00
    9388:	0100003c 	.word	0x0100003c
    938c:	4c010106 	.word	0x4c010106
    9390:	54000000 	.word	0x54000000
    9394:	6c08006e 	.word	0x6c08006e
    9398:	0108006e 	.word	0x0108006e
    939c:	e2011c5d 	.word	0xe2011c5d
    93a0:	0100003f 	.word	0x0100003f
    93a4:	8e010113 	.word	0x8e010113
    93a8:	6c000000 	.word	0x6c000000
    93ac:	9008006e 	.word	0x9008006e
    93b0:	0108006e 	.word	0x0108006e
    93b4:	0004755d 	.word	0x0004755d
    93b8:	2ed61d00 	.word	0x2ed61d00
    93bc:	12010000 	.word	0x12010000
    93c0:	00005e01 	.word	0x00005e01
    93c4:	003f1f00 	.word	0x003f1f00
    93c8:	409d1e00 	.word	0x409d1e00
    93cc:	14010000 	.word	0x14010000
    93d0:	00008e01 	.word	0x00008e01
    93d4:	6d741f00 	.word	0x6d741f00
    93d8:	15010070 	.word	0x15010070
    93dc:	00003a01 	.word	0x00003a01
    93e0:	00520100 	.word	0x00520100
    93e4:	3e340120 	.word	0x3e340120
    93e8:	2f010000 	.word	0x2f010000
    93ec:	6e900101 	.word	0x6e900101
    93f0:	6e9c0800 	.word	0x6e9c0800
    93f4:	5d010800 	.word	0x5d010800
    93f8:	0000049c 	.word	0x0000049c
    93fc:	002ed621 	.word	0x002ed621
    9400:	012e0100 	.word	0x012e0100
    9404:	0000005e 	.word	0x0000005e
    9408:	20005001 	.word	0x20005001
    940c:	003c6101 	.word	0x003c6101
    9410:	013e0100 	.word	0x013e0100
    9414:	006e9c01 	.word	0x006e9c01
    9418:	006eb408 	.word	0x006eb408
    941c:	c55d0108 	.word	0xc55d0108
    9420:	1d000004 	.word	0x1d000004
    9424:	00002ed6 	.word	0x00002ed6
    9428:	5e013d01 	.word	0x5e013d01
    942c:	32000000 	.word	0x32000000
    9430:	0000003f 	.word	0x0000003f
    9434:	3da7011b 	.word	0x3da7011b
    9438:	4e010000 	.word	0x4e010000
    943c:	004c0101 	.word	0x004c0101
    9440:	6eb40000 	.word	0x6eb40000
    9444:	6ec40800 	.word	0x6ec40800
    9448:	5d010800 	.word	0x5d010800
    944c:	4056011c 	.word	0x4056011c
    9450:	5b010000 	.word	0x5b010000
    9454:	008e0101 	.word	0x008e0101
    9458:	6ec40000 	.word	0x6ec40000
    945c:	6ee80800 	.word	0x6ee80800
    9460:	5d010800 	.word	0x5d010800
    9464:	00000524 	.word	0x00000524
    9468:	002ed61d 	.word	0x002ed61d
    946c:	015a0100 	.word	0x015a0100
    9470:	0000005e 	.word	0x0000005e
    9474:	00003f45 	.word	0x00003f45
    9478:	00402d1e 	.word	0x00402d1e
    947c:	015c0100 	.word	0x015c0100
    9480:	0000008e 	.word	0x0000008e
    9484:	706d741f 	.word	0x706d741f
    9488:	015d0100 	.word	0x015d0100
    948c:	0000003a 	.word	0x0000003a
    9490:	1b005201 	.word	0x1b005201
    9494:	003d7201 	.word	0x003d7201
    9498:	01780100 	.word	0x01780100
    949c:	00003a01 	.word	0x00003a01
    94a0:	006ee800 	.word	0x006ee800
    94a4:	006ef408 	.word	0x006ef408
    94a8:	205d0108 	.word	0x205d0108
    94ac:	003e8301 	.word	0x003e8301
    94b0:	018a0100 	.word	0x018a0100
    94b4:	006ef401 	.word	0x006ef401
    94b8:	006f0808 	.word	0x006f0808
    94bc:	735d0108 	.word	0x735d0108
    94c0:	21000005 	.word	0x21000005
    94c4:	00004020 	.word	0x00004020
    94c8:	3a018901 	.word	0x3a018901
    94cc:	01000000 	.word	0x01000000
    94d0:	0ede1d50 	.word	0x0ede1d50
    94d4:	89010000 	.word	0x89010000
    94d8:	00003a01 	.word	0x00003a01
    94dc:	003f5800 	.word	0x003f5800
    94e0:	01220000 	.word	0x01220000
    94e4:	00003cef 	.word	0x00003cef
    94e8:	01019a01 	.word	0x01019a01
    94ec:	08006f08 	.word	0x08006f08
    94f0:	08006f18 	.word	0x08006f18
    94f4:	01225d01 	.word	0x01225d01
    94f8:	00003de0 	.word	0x00003de0
    94fc:	0101a601 	.word	0x0101a601
    9500:	08006f18 	.word	0x08006f18
    9504:	08006f28 	.word	0x08006f28
    9508:	01205d01 	.word	0x01205d01
    950c:	00003ee7 	.word	0x00003ee7
    9510:	0101b901 	.word	0x0101b901
    9514:	08006f28 	.word	0x08006f28
    9518:	08006f44 	.word	0x08006f44
    951c:	05d05d01 	.word	0x05d05d01
    9520:	49210000 	.word	0x49210000
    9524:	01000040 	.word	0x01000040
    9528:	005e01b8 	.word	0x005e01b8
    952c:	50010000 	.word	0x50010000
    9530:	00338121 	.word	0x00338121
    9534:	01b80100 	.word	0x01b80100
    9538:	000000ae 	.word	0x000000ae
    953c:	20005101 	.word	0x20005101
    9540:	003ece01 	.word	0x003ece01
    9544:	01d70100 	.word	0x01d70100
    9548:	006f4401 	.word	0x006f4401
    954c:	006f6c08 	.word	0x006f6c08
    9550:	155d0108 	.word	0x155d0108
    9554:	1d000006 	.word	0x1d000006
    9558:	00003dc4 	.word	0x00003dc4
    955c:	3a01d601 	.word	0x3a01d601
    9560:	6b000000 	.word	0x6b000000
    9564:	2100003f 	.word	0x2100003f
    9568:	00003381 	.word	0x00003381
    956c:	ae01d601 	.word	0xae01d601
    9570:	01000000 	.word	0x01000000
    9574:	341a2351 	.word	0x341a2351
    9578:	d8010000 	.word	0xd8010000
    957c:	00003a01 	.word	0x00003a01
    9580:	00500100 	.word	0x00500100
    9584:	3d2e0124 	.word	0x3d2e0124
    9588:	00010000 	.word	0x00010000
    958c:	6f6c0102 	.word	0x6f6c0102
    9590:	6fc40800 	.word	0x6fc40800
    9594:	3f7e0800 	.word	0x3f7e0800
    9598:	06980000 	.word	0x06980000
    959c:	c41d0000 	.word	0xc41d0000
    95a0:	0100003d 	.word	0x0100003d
    95a4:	003a01fe 	.word	0x003a01fe
    95a8:	3f9d0000 	.word	0x3f9d0000
    95ac:	c21d0000 	.word	0xc21d0000
    95b0:	0100003f 	.word	0x0100003f
    95b4:	005e01fe 	.word	0x005e01fe
    95b8:	3fb00000 	.word	0x3fb00000
    95bc:	c61d0000 	.word	0xc61d0000
    95c0:	0100003c 	.word	0x0100003c
    95c4:	005e01ff 	.word	0x005e01ff
    95c8:	3fc30000 	.word	0x3fc30000
    95cc:	f2250000 	.word	0xf2250000
    95d0:	0100003b 	.word	0x0100003b
    95d4:	003a0201 	.word	0x003a0201
    95d8:	3fd60000 	.word	0x3fd60000
    95dc:	681e0000 	.word	0x681e0000
    95e0:	0100003f 	.word	0x0100003f
    95e4:	003a0201 	.word	0x003a0201
    95e8:	3d1e0000 	.word	0x3d1e0000
    95ec:	01000040 	.word	0x01000040
    95f0:	003a0201 	.word	0x003a0201
    95f4:	10250000 	.word	0x10250000
    95f8:	0100003f 	.word	0x0100003f
    95fc:	003a0202 	.word	0x003a0202
    9600:	3fe90000 	.word	0x3fe90000
    9604:	1c000000 	.word	0x1c000000
    9608:	003f6d01 	.word	0x003f6d01
    960c:	02290100 	.word	0x02290100
    9610:	00008e01 	.word	0x00008e01
    9614:	006fc400 	.word	0x006fc400
    9618:	006fe408 	.word	0x006fe408
    961c:	ed5d0108 	.word	0xed5d0108
    9620:	1d000006 	.word	0x1d000006
    9624:	00003dc4 	.word	0x00003dc4
    9628:	3a022801 	.word	0x3a022801
    962c:	12000000 	.word	0x12000000
    9630:	1e000040 	.word	0x1e000040
    9634:	00003567 	.word	0x00003567
    9638:	8e022a01 	.word	0x8e022a01
    963c:	26000000 	.word	0x26000000
    9640:	00706d74 	.word	0x00706d74
    9644:	3a022b01 	.word	0x3a022b01
    9648:	25000000 	.word	0x25000000
    964c:	00003e51 	.word	0x00003e51
    9650:	3a022b01 	.word	0x3a022b01
    9654:	25000000 	.word	0x25000000
    9658:	00000040 	.word	0x00000040
    965c:	3e5d0120 	.word	0x3e5d0120
    9660:	4f010000 	.word	0x4f010000
    9664:	6fe40102 	.word	0x6fe40102
    9668:	6ffc0800 	.word	0x6ffc0800
    966c:	5d010800 	.word	0x5d010800
    9670:	00000722 	.word	0x00000722
    9674:	003dc41d 	.word	0x003dc41d
    9678:	024e0100 	.word	0x024e0100
    967c:	0000003a 	.word	0x0000003a
    9680:	00004043 	.word	0x00004043
    9684:	706d7426 	.word	0x706d7426
    9688:	02500100 	.word	0x02500100
    968c:	0000003a 	.word	0x0000003a
    9690:	93012000 	.word	0x93012000
    9694:	0100003f 	.word	0x0100003f
    9698:	fc010267 	.word	0xfc010267
    969c:	1408006f 	.word	0x1408006f
    96a0:	01080070 	.word	0x01080070
    96a4:	0007575d 	.word	0x0007575d
    96a8:	3dc41d00 	.word	0x3dc41d00
    96ac:	66010000 	.word	0x66010000
    96b0:	00003a02 	.word	0x00003a02
    96b4:	00405600 	.word	0x00405600
    96b8:	6d742600 	.word	0x6d742600
    96bc:	68010070 	.word	0x68010070
    96c0:	00003a02 	.word	0x00003a02
    96c4:	011c0000 	.word	0x011c0000
    96c8:	00003df7 	.word	0x00003df7
    96cc:	01028501 	.word	0x01028501
    96d0:	0000008e 	.word	0x0000008e
    96d4:	08007014 	.word	0x08007014
    96d8:	08007034 	.word	0x08007034
    96dc:	07aa5d01 	.word	0x07aa5d01
    96e0:	c41d0000 	.word	0xc41d0000
    96e4:	0100003d 	.word	0x0100003d
    96e8:	003a0284 	.word	0x003a0284
    96ec:	40690000 	.word	0x40690000
    96f0:	671e0000 	.word	0x671e0000
    96f4:	01000035 	.word	0x01000035
    96f8:	008e0286 	.word	0x008e0286
    96fc:	74260000 	.word	0x74260000
    9700:	0100706d 	.word	0x0100706d
    9704:	003a0288 	.word	0x003a0288
    9708:	51230000 	.word	0x51230000
    970c:	0100003e 	.word	0x0100003e
    9710:	003a0288 	.word	0x003a0288
    9714:	53010000 	.word	0x53010000
    9718:	4c011c00 	.word	0x4c011c00
    971c:	0100003f 	.word	0x0100003f
    9720:	3a0102ad 	.word	0x3a0102ad
    9724:	34000000 	.word	0x34000000
    9728:	78080070 	.word	0x78080070
    972c:	01080070 	.word	0x01080070
    9730:	0008075d 	.word	0x0008075d
    9734:	3dc41d00 	.word	0x3dc41d00
    9738:	ac010000 	.word	0xac010000
    973c:	00003a02 	.word	0x00003a02
    9740:	00407c00 	.word	0x00407c00
    9744:	3fb52500 	.word	0x3fb52500
    9748:	ae010000 	.word	0xae010000
    974c:	00003a02 	.word	0x00003a02
    9750:	0040a500 	.word	0x0040a500
    9754:	341a2500 	.word	0x341a2500
    9758:	af010000 	.word	0xaf010000
    975c:	00003a02 	.word	0x00003a02
    9760:	0040ce00 	.word	0x0040ce00
    9764:	3e512500 	.word	0x3e512500
    9768:	af010000 	.word	0xaf010000
    976c:	00003a02 	.word	0x00003a02
    9770:	0040f700 	.word	0x0040f700
    9774:	011c0000 	.word	0x011c0000
    9778:	00003cb1 	.word	0x00003cb1
    977c:	0102db01 	.word	0x0102db01
    9780:	0000003a 	.word	0x0000003a
    9784:	08007078 	.word	0x08007078
    9788:	0800708c 	.word	0x0800708c
    978c:	08505d01 	.word	0x08505d01
    9790:	c41d0000 	.word	0xc41d0000
    9794:	0100003d 	.word	0x0100003d
    9798:	003a02da 	.word	0x003a02da
    979c:	41150000 	.word	0x41150000
    97a0:	21250000 	.word	0x21250000
    97a4:	0100003d 	.word	0x0100003d
    97a8:	003a02dc 	.word	0x003a02dc
    97ac:	41280000 	.word	0x41280000
    97b0:	74260000 	.word	0x74260000
    97b4:	0100706d 	.word	0x0100706d
    97b8:	003a02dd 	.word	0x003a02dd
    97bc:	27000000 	.word	0x27000000
    97c0:	003eb101 	.word	0x003eb101
    97c4:	01fa0100 	.word	0x01fa0100
    97c8:	0000003a 	.word	0x0000003a
    97cc:	0800708c 	.word	0x0800708c
    97d0:	08007098 	.word	0x08007098
    97d4:	0000413b 	.word	0x0000413b
    97d8:	3e1c0117 	.word	0x3e1c0117
    97dc:	eb010000 	.word	0xeb010000
    97e0:	00709801 	.word	0x00709801
    97e4:	0070a608 	.word	0x0070a608
    97e8:	00416608 	.word	0x00416608
    97ec:	00089200 	.word	0x00089200
    97f0:	40141600 	.word	0x40141600
    97f4:	ea010000 	.word	0xea010000
    97f8:	0000003a 	.word	0x0000003a
    97fc:	00004191 	.word	0x00004191
    9800:	93012800 	.word	0x93012800
    9804:	0100003d 	.word	0x0100003d
    9808:	70a801dd 	.word	0x70a801dd
    980c:	70b40800 	.word	0x70b40800
    9810:	41a40800 	.word	0x41a40800
    9814:	01280000 	.word	0x01280000
    9818:	00003f30 	.word	0x00003f30
    981c:	b401d101 	.word	0xb401d101
    9820:	c0080070 	.word	0xc0080070
    9824:	cf080070 	.word	0xcf080070
    9828:	28000041 	.word	0x28000041
    982c:	003d0f01 	.word	0x003d0f01
    9830:	01c50100 	.word	0x01c50100
    9834:	080070c0 	.word	0x080070c0
    9838:	080070cc 	.word	0x080070cc
    983c:	000041fa 	.word	0x000041fa
    9840:	3cdf0128 	.word	0x3cdf0128
    9844:	b9010000 	.word	0xb9010000
    9848:	0070cc01 	.word	0x0070cc01
    984c:	0070d808 	.word	0x0070d808
    9850:	00422508 	.word	0x00422508
    9854:	02430000 	.word	0x02430000
    9858:	00020000 	.word	0x00020000
    985c:	00002845 	.word	0x00002845
    9860:	01fe0104 	.word	0x01fe0104
    9864:	0b010000 	.word	0x0b010000
    9868:	49000041 	.word	0x49000041
    986c:	d8000002 	.word	0xd8000002
    9870:	b8080070 	.word	0xb8080070
    9874:	81080071 	.word	0x81080071
    9878:	02000026 	.word	0x02000026
    987c:	01220504 	.word	0x01220504
    9880:	02020000 	.word	0x02020000
    9884:	0004ca05 	.word	0x0004ca05
    9888:	06010200 	.word	0x06010200
    988c:	0000049e 	.word	0x0000049e
    9890:	32337503 	.word	0x32337503
    9894:	45270200 	.word	0x45270200
    9898:	02000000 	.word	0x02000000
    989c:	01300704 	.word	0x01300704
    98a0:	02020000 	.word	0x02020000
    98a4:	0001c507 	.word	0x0001c507
    98a8:	38750300 	.word	0x38750300
    98ac:	5d290200 	.word	0x5d290200
    98b0:	02000000 	.word	0x02000000
    98b4:	049c0801 	.word	0x049c0801
    98b8:	45040000 	.word	0x45040000
    98bc:	05000000 	.word	0x05000000
    98c0:	7e3a0201 	.word	0x7e3a0201
    98c4:	06000000 	.word	0x06000000
    98c8:	00000ef2 	.word	0x00000ef2
    98cc:	45530700 	.word	0x45530700
    98d0:	00010054 	.word	0x00010054
    98d4:	00440a08 	.word	0x00440a08
    98d8:	693a0200 	.word	0x693a0200
    98dc:	05000000 	.word	0x05000000
    98e0:	9e3c0201 	.word	0x9e3c0201
    98e4:	06000000 	.word	0x06000000
    98e8:	00002a70 	.word	0x00002a70
    98ec:	046e0600 	.word	0x046e0600
    98f0:	00010000 	.word	0x00010000
    98f4:	002f7108 	.word	0x002f7108
    98f8:	893c0200 	.word	0x893c0200
    98fc:	09000000 	.word	0x09000000
    9900:	080a0704 	.word	0x080a0704
    9904:	d301a403 	.word	0xd301a403
    9908:	0b000000 	.word	0x0b000000
    990c:	03005243 	.word	0x03005243
    9910:	006401a5 	.word	0x006401a5
    9914:	23020000 	.word	0x23020000
    9918:	53430b00 	.word	0x53430b00
    991c:	a6030052 	.word	0xa6030052
    9920:	00006401 	.word	0x00006401
    9924:	04230200 	.word	0x04230200
    9928:	72010c00 	.word	0x72010c00
    992c:	01000041 	.word	0x01000041
    9930:	70d80152 	.word	0x70d80152
    9934:	70e40800 	.word	0x70e40800
    9938:	5d010800 	.word	0x5d010800
    993c:	000000f8 	.word	0x000000f8
    9940:	0033810d 	.word	0x0033810d
    9944:	9e510100 	.word	0x9e510100
    9948:	01000000 	.word	0x01000000
    994c:	010c0050 	.word	0x010c0050
    9950:	00004100 	.word	0x00004100
    9954:	e4016201 	.word	0xe4016201
    9958:	f0080070 	.word	0xf0080070
    995c:	01080070 	.word	0x01080070
    9960:	00011d5d 	.word	0x00011d5d
    9964:	33810d00 	.word	0x33810d00
    9968:	61010000 	.word	0x61010000
    996c:	0000009e 	.word	0x0000009e
    9970:	0c005001 	.word	0x0c005001
    9974:	00412d01 	.word	0x00412d01
    9978:	017b0100 	.word	0x017b0100
    997c:	080070f0 	.word	0x080070f0
    9980:	08007104 	.word	0x08007104
    9984:	01535d01 	.word	0x01535d01
    9988:	ea0e0000 	.word	0xea0e0000
    998c:	01000040 	.word	0x01000040
    9990:	00003a7a 	.word	0x00003a7a
    9994:	00425000 	.word	0x00425000
    9998:	341a0f00 	.word	0x341a0f00
    999c:	7c010000 	.word	0x7c010000
    99a0:	0000003a 	.word	0x0000003a
    99a4:	00004263 	.word	0x00004263
    99a8:	86010c00 	.word	0x86010c00
    99ac:	01000041 	.word	0x01000041
    99b0:	71040196 	.word	0x71040196
    99b4:	71100800 	.word	0x71100800
    99b8:	5d010800 	.word	0x5d010800
    99bc:	00000178 	.word	0x00000178
    99c0:	0033810d 	.word	0x0033810d
    99c4:	9e950100 	.word	0x9e950100
    99c8:	01000000 	.word	0x01000000
    99cc:	01100050 	.word	0x01100050
    99d0:	00004140 	.word	0x00004140
    99d4:	7e01f301 	.word	0x7e01f301
    99d8:	10000000 	.word	0x10000000
    99dc:	24080071 	.word	0x24080071
    99e0:	01080071 	.word	0x01080071
    99e4:	0001ae5d 	.word	0x0001ae5d
    99e8:	40f70e00 	.word	0x40f70e00
    99ec:	f2010000 	.word	0xf2010000
    99f0:	0000003a 	.word	0x0000003a
    99f4:	00004281 	.word	0x00004281
    99f8:	00356711 	.word	0x00356711
    99fc:	7ef40100 	.word	0x7ef40100
    9a00:	00000000 	.word	0x00000000
    9a04:	40c30112 	.word	0x40c30112
    9a08:	11010000 	.word	0x11010000
    9a0c:	71240101 	.word	0x71240101
    9a10:	71340800 	.word	0x71340800
    9a14:	5d010800 	.word	0x5d010800
    9a18:	000001d5 	.word	0x000001d5
    9a1c:	0040f713 	.word	0x0040f713
    9a20:	01100100 	.word	0x01100100
    9a24:	0000003a 	.word	0x0000003a
    9a28:	14005001 	.word	0x14005001
    9a2c:	0040ae01 	.word	0x0040ae01
    9a30:	01d90100 	.word	0x01d90100
    9a34:	08007134 	.word	0x08007134
    9a38:	08007168 	.word	0x08007168
    9a3c:	00004294 	.word	0x00004294
    9a40:	41520115 	.word	0x41520115
    9a44:	ae010000 	.word	0xae010000
    9a48:	00716801 	.word	0x00716801
    9a4c:	0071a008 	.word	0x0071a008
    9a50:	0042bf08 	.word	0x0042bf08
    9a54:	00023100 	.word	0x00023100
    9a58:	40dc0e00 	.word	0x40dc0e00
    9a5c:	ad010000 	.word	0xad010000
    9a60:	0000003a 	.word	0x0000003a
    9a64:	000042ea 	.word	0x000042ea
    9a68:	0041640e 	.word	0x0041640e
    9a6c:	53ad0100 	.word	0x53ad0100
    9a70:	fd000000 	.word	0xfd000000
    9a74:	0f000042 	.word	0x0f000042
    9a78:	0000341a 	.word	0x0000341a
    9a7c:	003aaf01 	.word	0x003aaf01
    9a80:	431b0000 	.word	0x431b0000
    9a84:	14000000 	.word	0x14000000
    9a88:	0040d101 	.word	0x0040d101
    9a8c:	01440100 	.word	0x01440100
    9a90:	080071a0 	.word	0x080071a0
    9a94:	080071b8 	.word	0x080071b8
    9a98:	00004344 	.word	0x00004344
    9a9c:	0008b900 	.word	0x0008b900
    9aa0:	85000200 	.word	0x85000200
    9aa4:	04000029 	.word	0x04000029
    9aa8:	0001fe01 	.word	0x0001fe01
    9aac:	45040100 	.word	0x45040100
    9ab0:	02490000 	.word	0x02490000
    9ab4:	71b80000 	.word	0x71b80000
    9ab8:	755c0800 	.word	0x755c0800
    9abc:	27570800 	.word	0x27570800
    9ac0:	04020000 	.word	0x04020000
    9ac4:	00012205 	.word	0x00012205
    9ac8:	05020200 	.word	0x05020200
    9acc:	000004ca 	.word	0x000004ca
    9ad0:	9e060102 	.word	0x9e060102
    9ad4:	03000004 	.word	0x03000004
    9ad8:	00323375 	.word	0x00323375
    9adc:	00452702 	.word	0x00452702
    9ae0:	04020000 	.word	0x04020000
    9ae4:	00013007 	.word	0x00013007
    9ae8:	07020200 	.word	0x07020200
    9aec:	000001c5 	.word	0x000001c5
    9af0:	00387503 	.word	0x00387503
    9af4:	005d2902 	.word	0x005d2902
    9af8:	01020000 	.word	0x01020000
    9afc:	00049c08 	.word	0x00049c08
    9b00:	00450400 	.word	0x00450400
    9b04:	01050000 	.word	0x01050000
    9b08:	007e3a02 	.word	0x007e3a02
    9b0c:	f2060000 	.word	0xf2060000
    9b10:	0000000e 	.word	0x0000000e
    9b14:	54455307 	.word	0x54455307
    9b18:	08000100 	.word	0x08000100
    9b1c:	0000440a 	.word	0x0000440a
    9b20:	00693a02 	.word	0x00693a02
    9b24:	04080000 	.word	0x04080000
    9b28:	02000042 	.word	0x02000042
    9b2c:	0000693a 	.word	0x0000693a
    9b30:	02010500 	.word	0x02010500
    9b34:	0000a93c 	.word	0x0000a93c
    9b38:	2a700600 	.word	0x2a700600
    9b3c:	06000000 	.word	0x06000000
    9b40:	0000046e 	.word	0x0000046e
    9b44:	71080001 	.word	0x71080001
    9b48:	0200002f 	.word	0x0200002f
    9b4c:	0000943c 	.word	0x0000943c
    9b50:	02010500 	.word	0x02010500
    9b54:	0000c93f 	.word	0x0000c93f
    9b58:	05060600 	.word	0x05060600
    9b5c:	06000000 	.word	0x06000000
    9b60:	000004c2 	.word	0x000004c2
    9b64:	14080001 	.word	0x14080001
    9b68:	0200002e 	.word	0x0200002e
    9b6c:	0000b43f 	.word	0x0000b43f
    9b70:	07040900 	.word	0x07040900
    9b74:	ab03280a 	.word	0xab03280a
    9b78:	00017601 	.word	0x00017601
    9b7c:	52430b00 	.word	0x52430b00
    9b80:	01ac0300 	.word	0x01ac0300
    9b84:	00000064 	.word	0x00000064
    9b88:	0c002302 	.word	0x0c002302
    9b8c:	00004269 	.word	0x00004269
    9b90:	6401ad03 	.word	0x6401ad03
    9b94:	02000000 	.word	0x02000000
    9b98:	430b0423 	.word	0x430b0423
    9b9c:	03005249 	.word	0x03005249
    9ba0:	006401ae 	.word	0x006401ae
    9ba4:	23020000 	.word	0x23020000
    9ba8:	43280c08 	.word	0x43280c08
    9bac:	af030000 	.word	0xaf030000
    9bb0:	00006401 	.word	0x00006401
    9bb4:	0c230200 	.word	0x0c230200
    9bb8:	0041a50c 	.word	0x0041a50c
    9bbc:	01b00300 	.word	0x01b00300
    9bc0:	00000064 	.word	0x00000064
    9bc4:	0c102302 	.word	0x0c102302
    9bc8:	0000434a 	.word	0x0000434a
    9bcc:	6401b103 	.word	0x6401b103
    9bd0:	02000000 	.word	0x02000000
    9bd4:	820c1423 	.word	0x820c1423
    9bd8:	03000043 	.word	0x03000043
    9bdc:	006401b2 	.word	0x006401b2
    9be0:	23020000 	.word	0x23020000
    9be4:	427d0c18 	.word	0x427d0c18
    9be8:	b3030000 	.word	0xb3030000
    9bec:	00006401 	.word	0x00006401
    9bf0:	1c230200 	.word	0x1c230200
    9bf4:	00420d0c 	.word	0x00420d0c
    9bf8:	01b40300 	.word	0x01b40300
    9bfc:	00000064 	.word	0x00000064
    9c00:	0b202302 	.word	0x0b202302
    9c04:	00525343 	.word	0x00525343
    9c08:	6401b503 	.word	0x6401b503
    9c0c:	02000000 	.word	0x02000000
    9c10:	0d002423 	.word	0x0d002423
    9c14:	c51a0414 	.word	0xc51a0414
    9c18:	0e000001 	.word	0x0e000001
    9c1c:	0000445a 	.word	0x0000445a
    9c20:	003a1b04 	.word	0x003a1b04
    9c24:	23020000 	.word	0x23020000
    9c28:	426e0e00 	.word	0x426e0e00
    9c2c:	1c040000 	.word	0x1c040000
    9c30:	0000003a 	.word	0x0000003a
    9c34:	0e042302 	.word	0x0e042302
    9c38:	000044c3 	.word	0x000044c3
    9c3c:	003a1d04 	.word	0x003a1d04
    9c40:	23020000 	.word	0x23020000
    9c44:	44760e08 	.word	0x44760e08
    9c48:	1e040000 	.word	0x1e040000
    9c4c:	0000003a 	.word	0x0000003a
    9c50:	0e0c2302 	.word	0x0e0c2302
    9c54:	000043ca 	.word	0x000043ca
    9c58:	003a1f04 	.word	0x003a1f04
    9c5c:	23020000 	.word	0x23020000
    9c60:	36080010 	.word	0x36080010
    9c64:	04000042 	.word	0x04000042
    9c68:	00017620 	.word	0x00017620
    9c6c:	03010f00 	.word	0x03010f00
    9c70:	01000044 	.word	0x01000044
    9c74:	7e0103de 	.word	0x7e0103de
    9c78:	01000000 	.word	0x01000000
    9c7c:	00000214 	.word	0x00000214
    9c80:	0043db10 	.word	0x0043db10
    9c84:	03dd0100 	.word	0x03dd0100
    9c88:	00000053 	.word	0x00000053
    9c8c:	706d7411 	.word	0x706d7411
    9c90:	03df0100 	.word	0x03df0100
    9c94:	0000003a 	.word	0x0000003a
    9c98:	00436112 	.word	0x00436112
    9c9c:	03e00100 	.word	0x03e00100
    9ca0:	0000003a 	.word	0x0000003a
    9ca4:	00356712 	.word	0x00356712
    9ca8:	03e10100 	.word	0x03e10100
    9cac:	0000007e 	.word	0x0000007e
    9cb0:	99011300 	.word	0x99011300
    9cb4:	01000042 	.word	0x01000042
    9cb8:	71b8017d 	.word	0x71b8017d
    9cbc:	71f80800 	.word	0x71f80800
    9cc0:	5d010800 	.word	0x5d010800
    9cc4:	444c0114 	.word	0x444c0114
    9cc8:	a0010000 	.word	0xa0010000
    9ccc:	0071f801 	.word	0x0071f801
    9cd0:	00722c08 	.word	0x00722c08
    9cd4:	4c5d0108 	.word	0x4c5d0108
    9cd8:	15000002 	.word	0x15000002
    9cdc:	000044aa 	.word	0x000044aa
    9ce0:	003a9f01 	.word	0x003a9f01
    9ce4:	50010000 	.word	0x50010000
    9ce8:	a4011600 	.word	0xa4011600
    9cec:	01000042 	.word	0x01000042
    9cf0:	00c901c7 	.word	0x00c901c7
    9cf4:	722c0000 	.word	0x722c0000
    9cf8:	725c0800 	.word	0x725c0800
    9cfc:	43630800 	.word	0x43630800
    9d00:	02f10000 	.word	0x02f10000
    9d04:	8a170000 	.word	0x8a170000
    9d08:	01000043 	.word	0x01000043
    9d0c:	000064c8 	.word	0x000064c8
    9d10:	00438200 	.word	0x00438200
    9d14:	22b61800 	.word	0x22b61800
    9d18:	c9010000 	.word	0xc9010000
    9d1c:	000000c9 	.word	0x000000c9
    9d20:	00444218 	.word	0x00444218
    9d24:	7eca0100 	.word	0x7eca0100
    9d28:	19000000 	.word	0x19000000
    9d2c:	000001d0 	.word	0x000001d0
    9d30:	08007230 	.word	0x08007230
    9d34:	00000318 	.word	0x00000318
    9d38:	02becf01 	.word	0x02becf01
    9d3c:	e31a0000 	.word	0xe31a0000
    9d40:	1b000001 	.word	0x1b000001
    9d44:	00000330 	.word	0x00000330
    9d48:	0001ef1c 	.word	0x0001ef1c
    9d4c:	01fb1d00 	.word	0x01fb1d00
    9d50:	52010000 	.word	0x52010000
    9d54:	0002071c 	.word	0x0002071c
    9d58:	1e000000 	.word	0x1e000000
    9d5c:	000001d0 	.word	0x000001d0
    9d60:	0800724a 	.word	0x0800724a
    9d64:	08007254 	.word	0x08007254
    9d68:	e31ad401 	.word	0xe31ad401
    9d6c:	1f000001 	.word	0x1f000001
    9d70:	0800724a 	.word	0x0800724a
    9d74:	08007254 	.word	0x08007254
    9d78:	0001ef1c 	.word	0x0001ef1c
    9d7c:	01fb2000 	.word	0x01fb2000
    9d80:	43ad0000 	.word	0x43ad0000
    9d84:	071c0000 	.word	0x071c0000
    9d88:	00000002 	.word	0x00000002
    9d8c:	01140000 	.word	0x01140000
    9d90:	000043ac 	.word	0x000043ac
    9d94:	5c01ea01 	.word	0x5c01ea01
    9d98:	70080072 	.word	0x70080072
    9d9c:	01080072 	.word	0x01080072
    9da0:	0003235d 	.word	0x0003235d
    9da4:	43b61500 	.word	0x43b61500
    9da8:	e9010000 	.word	0xe9010000
    9dac:	00000053 	.word	0x00000053
    9db0:	1a215001 	.word	0x1a215001
    9db4:	01000034 	.word	0x01000034
    9db8:	00003aeb 	.word	0x00003aeb
    9dbc:	00530100 	.word	0x00530100
    9dc0:	455e0122 	.word	0x455e0122
    9dc4:	07010000 	.word	0x07010000
    9dc8:	72700101 	.word	0x72700101
    9dcc:	727c0800 	.word	0x727c0800
    9dd0:	5d010800 	.word	0x5d010800
    9dd4:	0000034a 	.word	0x0000034a
    9dd8:	00338123 	.word	0x00338123
    9ddc:	01060100 	.word	0x01060100
    9de0:	000000a9 	.word	0x000000a9
    9de4:	22005001 	.word	0x22005001
    9de8:	0042e201 	.word	0x0042e201
    9dec:	01200100 	.word	0x01200100
    9df0:	00727c01 	.word	0x00727c01
    9df4:	00729008 	.word	0x00729008
    9df8:	915d0108 	.word	0x915d0108
    9dfc:	24000003 	.word	0x24000003
    9e00:	000043e4 	.word	0x000043e4
    9e04:	3a011f01 	.word	0x3a011f01
    9e08:	c0000000 	.word	0xc0000000
    9e0c:	23000043 	.word	0x23000043
    9e10:	00004248 	.word	0x00004248
    9e14:	3a011f01 	.word	0x3a011f01
    9e18:	01000000 	.word	0x01000000
    9e1c:	341a2551 	.word	0x341a2551
    9e20:	21010000 	.word	0x21010000
    9e24:	00003a01 	.word	0x00003a01
    9e28:	0043d300 	.word	0x0043d300
    9e2c:	01220000 	.word	0x01220000
    9e30:	0000422b 	.word	0x0000422b
    9e34:	01013d01 	.word	0x01013d01
    9e38:	08007290 	.word	0x08007290
    9e3c:	0800729c 	.word	0x0800729c
    9e40:	03b85d01 	.word	0x03b85d01
    9e44:	81230000 	.word	0x81230000
    9e48:	01000033 	.word	0x01000033
    9e4c:	00a9013c 	.word	0x00a9013c
    9e50:	50010000 	.word	0x50010000
    9e54:	f2012200 	.word	0xf2012200
    9e58:	01000043 	.word	0x01000043
    9e5c:	9c010150 	.word	0x9c010150
    9e60:	b0080072 	.word	0xb0080072
    9e64:	01080072 	.word	0x01080072
    9e68:	0003f15d 	.word	0x0003f15d
    9e6c:	44b22400 	.word	0x44b22400
    9e70:	4f010000 	.word	0x4f010000
    9e74:	00003a01 	.word	0x00003a01
    9e78:	0043f100 	.word	0x0043f100
    9e7c:	341a2500 	.word	0x341a2500
    9e80:	51010000 	.word	0x51010000
    9e84:	00003a01 	.word	0x00003a01
    9e88:	00440400 	.word	0x00440400
    9e8c:	01260000 	.word	0x01260000
    9e90:	00004314 	.word	0x00004314
    9e94:	01016e01 	.word	0x01016e01
    9e98:	00000053 	.word	0x00000053
    9e9c:	080072b0 	.word	0x080072b0
    9ea0:	080072c0 	.word	0x080072c0
    9ea4:	01225d01 	.word	0x01225d01
    9ea8:	0000454f 	.word	0x0000454f
    9eac:	01018501 	.word	0x01018501
    9eb0:	080072c0 	.word	0x080072c0
    9eb4:	080072d4 	.word	0x080072d4
    9eb8:	04425d01 	.word	0x04425d01
    9ebc:	37240000 	.word	0x37240000
    9ec0:	01000044 	.word	0x01000044
    9ec4:	003a0184 	.word	0x003a0184
    9ec8:	44220000 	.word	0x44220000
    9ecc:	1a250000 	.word	0x1a250000
    9ed0:	01000034 	.word	0x01000034
    9ed4:	003a0186 	.word	0x003a0186
    9ed8:	44350000 	.word	0x44350000
    9edc:	22000000 	.word	0x22000000
    9ee0:	00435101 	.word	0x00435101
    9ee4:	01a60100 	.word	0x01a60100
    9ee8:	0072d401 	.word	0x0072d401
    9eec:	0072e808 	.word	0x0072e808
    9ef0:	7b5d0108 	.word	0x7b5d0108
    9ef4:	24000004 	.word	0x24000004
    9ef8:	000041ae 	.word	0x000041ae
    9efc:	3a01a501 	.word	0x3a01a501
    9f00:	53000000 	.word	0x53000000
    9f04:	25000044 	.word	0x25000044
    9f08:	0000341a 	.word	0x0000341a
    9f0c:	3a01a701 	.word	0x3a01a701
    9f10:	66000000 	.word	0x66000000
    9f14:	00000044 	.word	0x00000044
    9f18:	45860122 	.word	0x45860122
    9f1c:	c7010000 	.word	0xc7010000
    9f20:	72e80101 	.word	0x72e80101
    9f24:	72fc0800 	.word	0x72fc0800
    9f28:	5d010800 	.word	0x5d010800
    9f2c:	000004b0 	.word	0x000004b0
    9f30:	0041ae23 	.word	0x0041ae23
    9f34:	01c60100 	.word	0x01c60100
    9f38:	0000003a 	.word	0x0000003a
    9f3c:	1a275001 	.word	0x1a275001
    9f40:	01000034 	.word	0x01000034
    9f44:	003a01c8 	.word	0x003a01c8
    9f48:	53010000 	.word	0x53010000
    9f4c:	86012200 	.word	0x86012200
    9f50:	01000044 	.word	0x01000044
    9f54:	fc0101ea 	.word	0xfc0101ea
    9f58:	18080072 	.word	0x18080072
    9f5c:	01080073 	.word	0x01080073
    9f60:	0004e55d 	.word	0x0004e55d
    9f64:	45712300 	.word	0x45712300
    9f68:	e9010000 	.word	0xe9010000
    9f6c:	00005301 	.word	0x00005301
    9f70:	23500100 	.word	0x23500100
    9f74:	00003381 	.word	0x00003381
    9f78:	a901e901 	.word	0xa901e901
    9f7c:	01000000 	.word	0x01000000
    9f80:	01220051 	.word	0x01220051
    9f84:	000042f8 	.word	0x000042f8
    9f88:	01020901 	.word	0x01020901
    9f8c:	08007318 	.word	0x08007318
    9f90:	08007324 	.word	0x08007324
    9f94:	050c5d01 	.word	0x050c5d01
    9f98:	26230000 	.word	0x26230000
    9f9c:	01000044 	.word	0x01000044
    9fa0:	003a0208 	.word	0x003a0208
    9fa4:	50010000 	.word	0x50010000
    9fa8:	b7012200 	.word	0xb7012200
    9fac:	01000041 	.word	0x01000041
    9fb0:	2401021e 	.word	0x2401021e
    9fb4:	38080073 	.word	0x38080073
    9fb8:	01080073 	.word	0x01080073
    9fbc:	0005455d 	.word	0x0005455d
    9fc0:	42212400 	.word	0x42212400
    9fc4:	1d010000 	.word	0x1d010000
    9fc8:	00003a02 	.word	0x00003a02
    9fcc:	00448400 	.word	0x00448400
    9fd0:	341a2500 	.word	0x341a2500
    9fd4:	1f010000 	.word	0x1f010000
    9fd8:	00003a02 	.word	0x00003a02
    9fdc:	00449700 	.word	0x00449700
    9fe0:	01220000 	.word	0x01220000
    9fe4:	000044d3 	.word	0x000044d3
    9fe8:	01023d01 	.word	0x01023d01
    9fec:	08007338 	.word	0x08007338
    9ff0:	08007358 	.word	0x08007358
    9ff4:	056c5d01 	.word	0x056c5d01
    9ff8:	f5230000 	.word	0xf5230000
    9ffc:	01000041 	.word	0x01000041
    a000:	0053023c 	.word	0x0053023c
    a004:	50010000 	.word	0x50010000
    a008:	09012200 	.word	0x09012200
    a00c:	01000043 	.word	0x01000043
    a010:	58010264 	.word	0x58010264
    a014:	64080073 	.word	0x64080073
    a018:	01080073 	.word	0x01080073
    a01c:	0005935d 	.word	0x0005935d
    a020:	33812300 	.word	0x33812300
    a024:	63010000 	.word	0x63010000
    a028:	0000a902 	.word	0x0000a902
    a02c:	00500100 	.word	0x00500100
    a030:	44150122 	.word	0x44150122
    a034:	7a010000 	.word	0x7a010000
    a038:	73640102 	.word	0x73640102
    a03c:	73740800 	.word	0x73740800
    a040:	5d010800 	.word	0x5d010800
    a044:	000005bc 	.word	0x000005bc
    a048:	0042ba24 	.word	0x0042ba24
    a04c:	02790100 	.word	0x02790100
    a050:	0000003a 	.word	0x0000003a
    a054:	000044b5 	.word	0x000044b5
    a058:	26012200 	.word	0x26012200
    a05c:	01000045 	.word	0x01000045
    a060:	7401028d 	.word	0x7401028d
    a064:	80080073 	.word	0x80080073
    a068:	01080073 	.word	0x01080073
    a06c:	0005e35d 	.word	0x0005e35d
    a070:	33812300 	.word	0x33812300
    a074:	8c010000 	.word	0x8c010000
    a078:	0000a902 	.word	0x0000a902
    a07c:	00500100 	.word	0x00500100
    a080:	44f20122 	.word	0x44f20122
    a084:	9d010000 	.word	0x9d010000
    a088:	73800102 	.word	0x73800102
    a08c:	74380800 	.word	0x74380800
    a090:	5d010800 	.word	0x5d010800
    a094:	00000644 	.word	0x00000644
    a098:	00446b24 	.word	0x00446b24
    a09c:	029c0100 	.word	0x029c0100
    a0a0:	00000644 	.word	0x00000644
    a0a4:	000044c8 	.word	0x000044c8
    a0a8:	706d7428 	.word	0x706d7428
    a0ac:	029e0100 	.word	0x029e0100
    a0b0:	0000003a 	.word	0x0000003a
    a0b4:	000044e6 	.word	0x000044e6
    a0b8:	0042f025 	.word	0x0042f025
    a0bc:	029e0100 	.word	0x029e0100
    a0c0:	0000003a 	.word	0x0000003a
    a0c4:	0000451a 	.word	0x0000451a
    a0c8:	00434012 	.word	0x00434012
    a0cc:	029e0100 	.word	0x029e0100
    a0d0:	0000003a 	.word	0x0000003a
    a0d4:	00428512 	.word	0x00428512
    a0d8:	029e0100 	.word	0x029e0100
    a0dc:	0000003a 	.word	0x0000003a
    a0e0:	c5042900 	.word	0xc5042900
    a0e4:	22000001 	.word	0x22000001
    a0e8:	00425301 	.word	0x00425301
    a0ec:	03010100 	.word	0x03010100
    a0f0:	00743801 	.word	0x00743801
    a0f4:	00745408 	.word	0x00745408
    a0f8:	7f5d0108 	.word	0x7f5d0108
    a0fc:	23000006 	.word	0x23000006
    a100:	00004578 	.word	0x00004578
    a104:	3a030001 	.word	0x3a030001
    a108:	01000000 	.word	0x01000000
    a10c:	33812350 	.word	0x33812350
    a110:	00010000 	.word	0x00010000
    a114:	0000a903 	.word	0x0000a903
    a118:	00510100 	.word	0x00510100
    a11c:	44930122 	.word	0x44930122
    a120:	22010000 	.word	0x22010000
    a124:	74540103 	.word	0x74540103
    a128:	74700800 	.word	0x74700800
    a12c:	5d010800 	.word	0x5d010800
    a130:	000006b4 	.word	0x000006b4
    a134:	00421223 	.word	0x00421223
    a138:	03210100 	.word	0x03210100
    a13c:	0000003a 	.word	0x0000003a
    a140:	81235001 	.word	0x81235001
    a144:	01000033 	.word	0x01000033
    a148:	00a90321 	.word	0x00a90321
    a14c:	51010000 	.word	0x51010000
    a150:	6b012200 	.word	0x6b012200
    a154:	01000043 	.word	0x01000043
    a158:	70010344 	.word	0x70010344
    a15c:	8c080074 	.word	0x8c080074
    a160:	01080074 	.word	0x01080074
    a164:	0006e95d 	.word	0x0006e95d
    a168:	43312300 	.word	0x43312300
    a16c:	43010000 	.word	0x43010000
    a170:	00003a03 	.word	0x00003a03
    a174:	23500100 	.word	0x23500100
    a178:	00003381 	.word	0x00003381
    a17c:	a9034301 	.word	0xa9034301
    a180:	01000000 	.word	0x01000000
    a184:	01220051 	.word	0x01220051
    a188:	000041de 	.word	0x000041de
    a18c:	01036401 	.word	0x01036401
    a190:	0800748c 	.word	0x0800748c
    a194:	080074a8 	.word	0x080074a8
    a198:	071e5d01 	.word	0x071e5d01
    a19c:	12230000 	.word	0x12230000
    a1a0:	01000042 	.word	0x01000042
    a1a4:	003a0363 	.word	0x003a0363
    a1a8:	50010000 	.word	0x50010000
    a1ac:	00338123 	.word	0x00338123
    a1b0:	03630100 	.word	0x03630100
    a1b4:	000000a9 	.word	0x000000a9
    a1b8:	22005101 	.word	0x22005101
    a1bc:	0042cb01 	.word	0x0042cb01
    a1c0:	03850100 	.word	0x03850100
    a1c4:	0074a801 	.word	0x0074a801
    a1c8:	0074c408 	.word	0x0074c408
    a1cc:	535d0108 	.word	0x535d0108
    a1d0:	23000007 	.word	0x23000007
    a1d4:	00004331 	.word	0x00004331
    a1d8:	3a038401 	.word	0x3a038401
    a1dc:	01000000 	.word	0x01000000
    a1e0:	33812350 	.word	0x33812350
    a1e4:	84010000 	.word	0x84010000
    a1e8:	0000a903 	.word	0x0000a903
    a1ec:	00510100 	.word	0x00510100
    a1f0:	43990122 	.word	0x43990122
    a1f4:	9d010000 	.word	0x9d010000
    a1f8:	74c40103 	.word	0x74c40103
    a1fc:	74d00800 	.word	0x74d00800
    a200:	5d010800 	.word	0x5d010800
    a204:	0000077a 	.word	0x0000077a
    a208:	00338123 	.word	0x00338123
    a20c:	039c0100 	.word	0x039c0100
    a210:	000000a9 	.word	0x000000a9
    a214:	22005001 	.word	0x22005001
    a218:	00453401 	.word	0x00453401
    a21c:	03ad0100 	.word	0x03ad0100
    a220:	0074d001 	.word	0x0074d001
    a224:	0074dc08 	.word	0x0074dc08
    a228:	a15d0108 	.word	0xa15d0108
    a22c:	23000007 	.word	0x23000007
    a230:	00003381 	.word	0x00003381
    a234:	a903ac01 	.word	0xa903ac01
    a238:	01000000 	.word	0x01000000
    a23c:	01220050 	.word	0x01220050
    a240:	0000428b 	.word	0x0000428b
    a244:	0103c201 	.word	0x0103c201
    a248:	080074dc 	.word	0x080074dc
    a24c:	080074e8 	.word	0x080074e8
    a250:	07c85d01 	.word	0x07c85d01
    a254:	69230000 	.word	0x69230000
    a258:	01000045 	.word	0x01000045
    a25c:	005303c1 	.word	0x005303c1
    a260:	50010000 	.word	0x50010000
    a264:	01d02a00 	.word	0x01d02a00
    a268:	74e80000 	.word	0x74e80000
    a26c:	752c0800 	.word	0x752c0800
    a270:	5d010800 	.word	0x5d010800
    a274:	000007fc 	.word	0x000007fc
    a278:	0001e32b 	.word	0x0001e32b
    a27c:	00453800 	.word	0x00453800
    a280:	01ef2000 	.word	0x01ef2000
    a284:	454b0000 	.word	0x454b0000
    a288:	fb200000 	.word	0xfb200000
    a28c:	74000001 	.word	0x74000001
    a290:	1c000045 	.word	0x1c000045
    a294:	00000207 	.word	0x00000207
    a298:	97012c00 	.word	0x97012c00
    a29c:	01000041 	.word	0x01000041
    a2a0:	2c010411 	.word	0x2c010411
    a2a4:	3c080075 	.word	0x3c080075
    a2a8:	01080075 	.word	0x01080075
    a2ac:	fd012d5d 	.word	0xfd012d5d
    a2b0:	01000041 	.word	0x01000041
    a2b4:	89010425 	.word	0x89010425
    a2b8:	3c000000 	.word	0x3c000000
    a2bc:	50080075 	.word	0x50080075
    a2c0:	01080075 	.word	0x01080075
    a2c4:	0008495d 	.word	0x0008495d
    a2c8:	45712400 	.word	0x45712400
    a2cc:	24010000 	.word	0x24010000
    a2d0:	00005304 	.word	0x00005304
    a2d4:	00459d00 	.word	0x00459d00
    a2d8:	35671200 	.word	0x35671200
    a2dc:	26010000 	.word	0x26010000
    a2e0:	00008904 	.word	0x00008904
    a2e4:	01220000 	.word	0x01220000
    a2e8:	000041c8 	.word	0x000041c8
    a2ec:	01044801 	.word	0x01044801
    a2f0:	08007550 	.word	0x08007550
    a2f4:	0800755c 	.word	0x0800755c
    a2f8:	08705d01 	.word	0x08705d01
    a2fc:	71230000 	.word	0x71230000
    a300:	01000045 	.word	0x01000045
    a304:	00530447 	.word	0x00530447
    a308:	50010000 	.word	0x50010000
    a30c:	005d2e00 	.word	0x005d2e00
    a310:	08800000 	.word	0x08800000
    a314:	d42f0000 	.word	0xd42f0000
    a318:	0f000000 	.word	0x0f000000
    a31c:	44e12100 	.word	0x44e12100
    a320:	6f010000 	.word	0x6f010000
    a324:	00000891 	.word	0x00000891
    a328:	7c760305 	.word	0x7c760305
    a32c:	70300800 	.word	0x70300800
    a330:	2e000008 	.word	0x2e000008
    a334:	0000005d 	.word	0x0000005d
    a338:	000008a6 	.word	0x000008a6
    a33c:	0000d42f 	.word	0x0000d42f
    a340:	21000300 	.word	0x21000300
    a344:	00004596 	.word	0x00004596
    a348:	08b77001 	.word	0x08b77001
    a34c:	03050000 	.word	0x03050000
    a350:	08007c86 	.word	0x08007c86
    a354:	00089630 	.word	0x00089630
    a358:	01eb0000 	.word	0x01eb0000
    a35c:	00020000 	.word	0x00020000
    a360:	00002c20 	.word	0x00002c20
    a364:	01fe0104 	.word	0x01fe0104
    a368:	f2010000 	.word	0xf2010000
    a36c:	49000045 	.word	0x49000045
    a370:	5c000002 	.word	0x5c000002
    a374:	00080075 	.word	0x00080075
    a378:	0f080076 	.word	0x0f080076
    a37c:	02000029 	.word	0x02000029
    a380:	01220504 	.word	0x01220504
    a384:	02020000 	.word	0x02020000
    a388:	0004ca05 	.word	0x0004ca05
    a38c:	06010200 	.word	0x06010200
    a390:	0000049e 	.word	0x0000049e
    a394:	32337503 	.word	0x32337503
    a398:	45270200 	.word	0x45270200
    a39c:	02000000 	.word	0x02000000
    a3a0:	01300704 	.word	0x01300704
    a3a4:	02020000 	.word	0x02020000
    a3a8:	0001c507 	.word	0x0001c507
    a3ac:	38750300 	.word	0x38750300
    a3b0:	5d290200 	.word	0x5d290200
    a3b4:	02000000 	.word	0x02000000
    a3b8:	049c0801 	.word	0x049c0801
    a3bc:	45040000 	.word	0x45040000
    a3c0:	05000000 	.word	0x05000000
    a3c4:	00000064 	.word	0x00000064
    a3c8:	3a020106 	.word	0x3a020106
    a3cc:	00000083 	.word	0x00000083
    a3d0:	000ef207 	.word	0x000ef207
    a3d4:	53080000 	.word	0x53080000
    a3d8:	01005445 	.word	0x01005445
    a3dc:	440a0900 	.word	0x440a0900
    a3e0:	3a020000 	.word	0x3a020000
    a3e4:	0000006e 	.word	0x0000006e
    a3e8:	3c020106 	.word	0x3c020106
    a3ec:	000000a3 	.word	0x000000a3
    a3f0:	002a7007 	.word	0x002a7007
    a3f4:	6e070000 	.word	0x6e070000
    a3f8:	01000004 	.word	0x01000004
    a3fc:	2f710900 	.word	0x2f710900
    a400:	3c020000 	.word	0x3c020000
    a404:	0000008e 	.word	0x0000008e
    a408:	0b07040a 	.word	0x0b07040a
    a40c:	02030310 	.word	0x02030310
    a410:	000000f7 	.word	0x000000f7
    a414:	0046180c 	.word	0x0046180c
    a418:	02040300 	.word	0x02040300
    a41c:	00000064 	.word	0x00000064
    a420:	0c002302 	.word	0x0c002302
    a424:	00001d16 	.word	0x00001d16
    a428:	64020503 	.word	0x64020503
    a42c:	02000000 	.word	0x02000000
    a430:	560d0423 	.word	0x560d0423
    a434:	03004c41 	.word	0x03004c41
    a438:	00640206 	.word	0x00640206
    a43c:	23020000 	.word	0x23020000
    a440:	45ec0c08 	.word	0x45ec0c08
    a444:	07030000 	.word	0x07030000
    a448:	00006902 	.word	0x00006902
    a44c:	0c230200 	.word	0x0c230200
    a450:	40010e00 	.word	0x40010e00
    a454:	01000046 	.word	0x01000046
    a458:	755c012c 	.word	0x755c012c
    a45c:	75780800 	.word	0x75780800
    a460:	5d010800 	.word	0x5d010800
    a464:	0000011c 	.word	0x0000011c
    a468:	0046580f 	.word	0x0046580f
    a46c:	3a2b0100 	.word	0x3a2b0100
    a470:	01000000 	.word	0x01000000
    a474:	010e0050 	.word	0x010e0050
    a478:	000045b7 	.word	0x000045b7
    a47c:	78014301 	.word	0x78014301
    a480:	84080075 	.word	0x84080075
    a484:	01080075 	.word	0x01080075
    a488:	0001415d 	.word	0x0001415d
    a48c:	45c20f00 	.word	0x45c20f00
    a490:	42010000 	.word	0x42010000
    a494:	0000003a 	.word	0x0000003a
    a498:	0e005001 	.word	0x0e005001
    a49c:	00461d01 	.word	0x00461d01
    a4a0:	01560100 	.word	0x01560100
    a4a4:	08007584 	.word	0x08007584
    a4a8:	080075b0 	.word	0x080075b0
    a4ac:	01665d01 	.word	0x01665d01
    a4b0:	300f0000 	.word	0x300f0000
    a4b4:	01000046 	.word	0x01000046
    a4b8:	00003a55 	.word	0x00003a55
    a4bc:	00500100 	.word	0x00500100
    a4c0:	466a010e 	.word	0x466a010e
    a4c4:	71010000 	.word	0x71010000
    a4c8:	0075b001 	.word	0x0075b001
    a4cc:	0075cc08 	.word	0x0075cc08
    a4d0:	8b5d0108 	.word	0x8b5d0108
    a4d4:	0f000001 	.word	0x0f000001
    a4d8:	00003381 	.word	0x00003381
    a4dc:	00a37001 	.word	0x00a37001
    a4e0:	50010000 	.word	0x50010000
    a4e4:	a4011000 	.word	0xa4011000
    a4e8:	01000045 	.word	0x01000045
    a4ec:	003a0187 	.word	0x003a0187
    a4f0:	75cc0000 	.word	0x75cc0000
    a4f4:	75d80800 	.word	0x75d80800
    a4f8:	5d010800 	.word	0x5d010800
    a4fc:	45c90111 	.word	0x45c90111
    a500:	97010000 	.word	0x97010000
    a504:	00008301 	.word	0x00008301
    a508:	0075d800 	.word	0x0075d800
    a50c:	00760008 	.word	0x00760008
    a510:	125d0108 	.word	0x125d0108
    a514:	000045df 	.word	0x000045df
    a518:	00539601 	.word	0x00539601
    a51c:	45b00000 	.word	0x45b00000
    a520:	61130000 	.word	0x61130000
    a524:	01000043 	.word	0x01000043
    a528:	00003a98 	.word	0x00003a98
    a52c:	0045ce00 	.word	0x0045ce00
    a530:	6d741400 	.word	0x6d741400
    a534:	98010070 	.word	0x98010070
    a538:	0000003a 	.word	0x0000003a
    a53c:	00356715 	.word	0x00356715
    a540:	83990100 	.word	0x83990100
    a544:	00000000 	.word	0x00000000
    a548:	00094c00 	.word	0x00094c00
    a54c:	46000200 	.word	0x46000200
    a550:	0400002d 	.word	0x0400002d
    a554:	0001fe01 	.word	0x0001fe01
    a558:	49a10100 	.word	0x49a10100
    a55c:	02490000 	.word	0x02490000
    a560:	76000000 	.word	0x76000000
    a564:	79bc0800 	.word	0x79bc0800
    a568:	29cc0800 	.word	0x29cc0800
    a56c:	04020000 	.word	0x04020000
    a570:	00012205 	.word	0x00012205
    a574:	05020200 	.word	0x05020200
    a578:	000004ca 	.word	0x000004ca
    a57c:	9e060102 	.word	0x9e060102
    a580:	03000004 	.word	0x03000004
    a584:	00323375 	.word	0x00323375
    a588:	00452702 	.word	0x00452702
    a58c:	04020000 	.word	0x04020000
    a590:	00013007 	.word	0x00013007
    a594:	31750300 	.word	0x31750300
    a598:	28020036 	.word	0x28020036
    a59c:	00000057 	.word	0x00000057
    a5a0:	c5070202 	.word	0xc5070202
    a5a4:	03000001 	.word	0x03000001
    a5a8:	02003875 	.word	0x02003875
    a5ac:	00006829 	.word	0x00006829
    a5b0:	08010200 	.word	0x08010200
    a5b4:	0000049c 	.word	0x0000049c
    a5b8:	00005704 	.word	0x00005704
    a5bc:	02010500 	.word	0x02010500
    a5c0:	0000893a 	.word	0x0000893a
    a5c4:	0ef20600 	.word	0x0ef20600
    a5c8:	07000000 	.word	0x07000000
    a5cc:	00544553 	.word	0x00544553
    a5d0:	0a080001 	.word	0x0a080001
    a5d4:	02000044 	.word	0x02000044
    a5d8:	0000743a 	.word	0x0000743a
    a5dc:	42040800 	.word	0x42040800
    a5e0:	3a020000 	.word	0x3a020000
    a5e4:	00000074 	.word	0x00000074
    a5e8:	3c020105 	.word	0x3c020105
    a5ec:	000000b4 	.word	0x000000b4
    a5f0:	002a7006 	.word	0x002a7006
    a5f4:	6e060000 	.word	0x6e060000
    a5f8:	01000004 	.word	0x01000004
    a5fc:	2f710800 	.word	0x2f710800
    a600:	3c020000 	.word	0x3c020000
    a604:	0000009f 	.word	0x0000009f
    a608:	0a070409 	.word	0x0a070409
    a60c:	0239031c 	.word	0x0239031c
    a610:	0000019c 	.word	0x0000019c
    a614:	0052530b 	.word	0x0052530b
    a618:	6f023a03 	.word	0x6f023a03
    a61c:	02000000 	.word	0x02000000
    a620:	d30c0023 	.word	0xd30c0023
    a624:	03000031 	.word	0x03000031
    a628:	004c023b 	.word	0x004c023b
    a62c:	23020000 	.word	0x23020000
    a630:	52440b02 	.word	0x52440b02
    a634:	023c0300 	.word	0x023c0300
    a638:	0000006f 	.word	0x0000006f
    a63c:	0c042302 	.word	0x0c042302
    a640:	00003093 	.word	0x00003093
    a644:	4c023d03 	.word	0x4c023d03
    a648:	02000000 	.word	0x02000000
    a64c:	420b0623 	.word	0x420b0623
    a650:	03005252 	.word	0x03005252
    a654:	006f023e 	.word	0x006f023e
    a658:	23020000 	.word	0x23020000
    a65c:	31dd0c08 	.word	0x31dd0c08
    a660:	3f030000 	.word	0x3f030000
    a664:	00004c02 	.word	0x00004c02
    a668:	0a230200 	.word	0x0a230200
    a66c:	3152430b 	.word	0x3152430b
    a670:	02400300 	.word	0x02400300
    a674:	0000006f 	.word	0x0000006f
    a678:	0c0c2302 	.word	0x0c0c2302
    a67c:	000031e7 	.word	0x000031e7
    a680:	4c024103 	.word	0x4c024103
    a684:	02000000 	.word	0x02000000
    a688:	430b0e23 	.word	0x430b0e23
    a68c:	03003252 	.word	0x03003252
    a690:	006f0242 	.word	0x006f0242
    a694:	23020000 	.word	0x23020000
    a698:	31f10c10 	.word	0x31f10c10
    a69c:	43030000 	.word	0x43030000
    a6a0:	00004c02 	.word	0x00004c02
    a6a4:	12230200 	.word	0x12230200
    a6a8:	3352430b 	.word	0x3352430b
    a6ac:	02440300 	.word	0x02440300
    a6b0:	0000006f 	.word	0x0000006f
    a6b4:	0c142302 	.word	0x0c142302
    a6b8:	000031fb 	.word	0x000031fb
    a6bc:	4c024503 	.word	0x4c024503
    a6c0:	02000000 	.word	0x02000000
    a6c4:	570c1623 	.word	0x570c1623
    a6c8:	03000031 	.word	0x03000031
    a6cc:	006f0246 	.word	0x006f0246
    a6d0:	23020000 	.word	0x23020000
    a6d4:	32050c18 	.word	0x32050c18
    a6d8:	47030000 	.word	0x47030000
    a6dc:	00004c02 	.word	0x00004c02
    a6e0:	1a230200 	.word	0x1a230200
    a6e4:	46ce0d00 	.word	0x46ce0d00
    a6e8:	48030000 	.word	0x48030000
    a6ec:	0000c202 	.word	0x0000c202
    a6f0:	04100e00 	.word	0x04100e00
    a6f4:	0002051b 	.word	0x0002051b
    a6f8:	30db0f00 	.word	0x30db0f00
    a6fc:	1c040000 	.word	0x1c040000
    a700:	0000003a 	.word	0x0000003a
    a704:	0f002302 	.word	0x0f002302
    a708:	000030ba 	.word	0x000030ba
    a70c:	004c1d04 	.word	0x004c1d04
    a710:	23020000 	.word	0x23020000
    a714:	30770f04 	.word	0x30770f04
    a718:	1e040000 	.word	0x1e040000
    a71c:	0000004c 	.word	0x0000004c
    a720:	0f062302 	.word	0x0f062302
    a724:	0000314a 	.word	0x0000314a
    a728:	004c1f04 	.word	0x004c1f04
    a72c:	23020000 	.word	0x23020000
    a730:	31b30f08 	.word	0x31b30f08
    a734:	20040000 	.word	0x20040000
    a738:	0000004c 	.word	0x0000004c
    a73c:	0f0a2302 	.word	0x0f0a2302
    a740:	00003199 	.word	0x00003199
    a744:	004c2104 	.word	0x004c2104
    a748:	23020000 	.word	0x23020000
    a74c:	4e08000c 	.word	0x4e08000c
    a750:	04000032 	.word	0x04000032
    a754:	0001a822 	.word	0x0001a822
    a758:	04080e00 	.word	0x04080e00
    a75c:	00025126 	.word	0x00025126
    a760:	48cc0f00 	.word	0x48cc0f00
    a764:	27040000 	.word	0x27040000
    a768:	0000004c 	.word	0x0000004c
    a76c:	0f002302 	.word	0x0f002302
    a770:	00004996 	.word	0x00004996
    a774:	004c2804 	.word	0x004c2804
    a778:	23020000 	.word	0x23020000
    a77c:	468a0f02 	.word	0x468a0f02
    a780:	29040000 	.word	0x29040000
    a784:	0000004c 	.word	0x0000004c
    a788:	0f042302 	.word	0x0f042302
    a78c:	0000473a 	.word	0x0000473a
    a790:	004c2a04 	.word	0x004c2a04
    a794:	23020000 	.word	0x23020000
    a798:	dc080006 	.word	0xdc080006
    a79c:	04000046 	.word	0x04000046
    a7a0:	0002102b 	.word	0x0002102b
    a7a4:	05140e00 	.word	0x05140e00
    a7a8:	0002ab1a 	.word	0x0002ab1a
    a7ac:	445a0f00 	.word	0x445a0f00
    a7b0:	1b050000 	.word	0x1b050000
    a7b4:	0000003a 	.word	0x0000003a
    a7b8:	0f002302 	.word	0x0f002302
    a7bc:	0000426e 	.word	0x0000426e
    a7c0:	003a1c05 	.word	0x003a1c05
    a7c4:	23020000 	.word	0x23020000
    a7c8:	44c30f04 	.word	0x44c30f04
    a7cc:	1d050000 	.word	0x1d050000
    a7d0:	0000003a 	.word	0x0000003a
    a7d4:	0f082302 	.word	0x0f082302
    a7d8:	00004476 	.word	0x00004476
    a7dc:	003a1e05 	.word	0x003a1e05
    a7e0:	23020000 	.word	0x23020000
    a7e4:	43ca0f0c 	.word	0x43ca0f0c
    a7e8:	1f050000 	.word	0x1f050000
    a7ec:	0000003a 	.word	0x0000003a
    a7f0:	00102302 	.word	0x00102302
    a7f4:	00423608 	.word	0x00423608
    a7f8:	5c200500 	.word	0x5c200500
    a7fc:	10000002 	.word	0x10000002
    a800:	0049ce01 	.word	0x0049ce01
    a804:	01e90100 	.word	0x01e90100
    a808:	08007600 	.word	0x08007600
    a80c:	0800761e 	.word	0x0800761e
    a810:	02db5d01 	.word	0x02db5d01
    a814:	73110000 	.word	0x73110000
    a818:	01000048 	.word	0x01000048
    a81c:	0002dbe8 	.word	0x0002dbe8
    a820:	00500100 	.word	0x00500100
    a824:	02050412 	.word	0x02050412
    a828:	01130000 	.word	0x01130000
    a82c:	00004951 	.word	0x00004951
    a830:	01010001 	.word	0x01010001
    a834:	08007620 	.word	0x08007620
    a838:	08007648 	.word	0x08007648
    a83c:	03245d01 	.word	0x03245d01
    a840:	59110000 	.word	0x59110000
    a844:	01000048 	.word	0x01000048
    a848:	000324ff 	.word	0x000324ff
    a84c:	14500100 	.word	0x14500100
    a850:	000047c1 	.word	0x000047c1
    a854:	032aff01 	.word	0x032aff01
    a858:	45ec0000 	.word	0x45ec0000
    a85c:	1a150000 	.word	0x1a150000
    a860:	01000034 	.word	0x01000034
    a864:	003a0101 	.word	0x003a0101
    a868:	52010000 	.word	0x52010000
    a86c:	9c041200 	.word	0x9c041200
    a870:	12000001 	.word	0x12000001
    a874:	00025104 	.word	0x00025104
    a878:	e4011300 	.word	0xe4011300
    a87c:	01000047 	.word	0x01000047
    a880:	48010124 	.word	0x48010124
    a884:	56080076 	.word	0x56080076
    a888:	01080076 	.word	0x01080076
    a88c:	0003575d 	.word	0x0003575d
    a890:	47c11600 	.word	0x47c11600
    a894:	23010000 	.word	0x23010000
    a898:	00032a01 	.word	0x00032a01
    a89c:	00500100 	.word	0x00500100
    a8a0:	46f30113 	.word	0x46f30113
    a8a4:	38010000 	.word	0x38010000
    a8a8:	76580101 	.word	0x76580101
    a8ac:	76720800 	.word	0x76720800
    a8b0:	5d010800 	.word	0x5d010800
    a8b4:	0000038c 	.word	0x0000038c
    a8b8:	00485916 	.word	0x00485916
    a8bc:	01370100 	.word	0x01370100
    a8c0:	00000324 	.word	0x00000324
    a8c4:	81165001 	.word	0x81165001
    a8c8:	01000033 	.word	0x01000033
    a8cc:	00b40137 	.word	0x00b40137
    a8d0:	51010000 	.word	0x51010000
    a8d4:	4a011700 	.word	0x4a011700
    a8d8:	01000048 	.word	0x01000048
    a8dc:	74010163 	.word	0x74010163
    a8e0:	b2080076 	.word	0xb2080076
    a8e4:	ff080076 	.word	0xff080076
    a8e8:	0d000045 	.word	0x0d000045
    a8ec:	18000004 	.word	0x18000004
    a8f0:	00004859 	.word	0x00004859
    a8f4:	24016201 	.word	0x24016201
    a8f8:	1e000003 	.word	0x1e000003
    a8fc:	18000046 	.word	0x18000046
    a900:	00004948 	.word	0x00004948
    a904:	4c016201 	.word	0x4c016201
    a908:	31000000 	.word	0x31000000
    a90c:	16000046 	.word	0x16000046
    a910:	00003381 	.word	0x00003381
    a914:	b4016201 	.word	0xb4016201
    a918:	01000000 	.word	0x01000000
    a91c:	49c51552 	.word	0x49c51552
    a920:	64010000 	.word	0x64010000
    a924:	00003a01 	.word	0x00003a01
    a928:	195c0100 	.word	0x195c0100
    a92c:	00004893 	.word	0x00004893
    a930:	3a016401 	.word	0x3a016401
    a934:	15000000 	.word	0x15000000
    a938:	00003683 	.word	0x00003683
    a93c:	3a016401 	.word	0x3a016401
    a940:	01000000 	.word	0x01000000
    a944:	47fa1a51 	.word	0x47fa1a51
    a948:	65010000 	.word	0x65010000
    a94c:	00003a01 	.word	0x00003a01
    a950:	00464f00 	.word	0x00464f00
    a954:	01130000 	.word	0x01130000
    a958:	0000472d 	.word	0x0000472d
    a95c:	01019e01 	.word	0x01019e01
    a960:	080076b4 	.word	0x080076b4
    a964:	080076cc 	.word	0x080076cc
    a968:	04505d01 	.word	0x04505d01
    a96c:	59160000 	.word	0x59160000
    a970:	01000048 	.word	0x01000048
    a974:	0324019d 	.word	0x0324019d
    a978:	50010000 	.word	0x50010000
    a97c:	0047d716 	.word	0x0047d716
    a980:	019d0100 	.word	0x019d0100
    a984:	0000004c 	.word	0x0000004c
    a988:	81165101 	.word	0x81165101
    a98c:	01000033 	.word	0x01000033
    a990:	00b4019d 	.word	0x00b4019d
    a994:	52010000 	.word	0x52010000
    a998:	16011300 	.word	0x16011300
    a99c:	01000048 	.word	0x01000048
    a9a0:	cc0101bd 	.word	0xcc0101bd
    a9a4:	e2080076 	.word	0xe2080076
    a9a8:	01080076 	.word	0x01080076
    a9ac:	0004855d 	.word	0x0004855d
    a9b0:	48591600 	.word	0x48591600
    a9b4:	bc010000 	.word	0xbc010000
    a9b8:	00032401 	.word	0x00032401
    a9bc:	16500100 	.word	0x16500100
    a9c0:	00004884 	.word	0x00004884
    a9c4:	5e01bc01 	.word	0x5e01bc01
    a9c8:	01000000 	.word	0x01000000
    a9cc:	01130051 	.word	0x01130051
    a9d0:	00004961 	.word	0x00004961
    a9d4:	0101d601 	.word	0x0101d601
    a9d8:	080076e4 	.word	0x080076e4
    a9dc:	080076fa 	.word	0x080076fa
    a9e0:	04bc5d01 	.word	0x04bc5d01
    a9e4:	59160000 	.word	0x59160000
    a9e8:	01000048 	.word	0x01000048
    a9ec:	032401d5 	.word	0x032401d5
    a9f0:	50010000 	.word	0x50010000
    a9f4:	00472018 	.word	0x00472018
    a9f8:	01d50100 	.word	0x01d50100
    a9fc:	0000004c 	.word	0x0000004c
    aa00:	00004678 	.word	0x00004678
    aa04:	d8011300 	.word	0xd8011300
    aa08:	01000048 	.word	0x01000048
    aa0c:	fc0101eb 	.word	0xfc0101eb
    aa10:	16080076 	.word	0x16080076
    aa14:	01080077 	.word	0x01080077
    aa18:	0004f15d 	.word	0x0004f15d
    aa1c:	48591600 	.word	0x48591600
    aa20:	ea010000 	.word	0xea010000
    aa24:	00032401 	.word	0x00032401
    aa28:	16500100 	.word	0x16500100
    aa2c:	00003381 	.word	0x00003381
    aa30:	b401ea01 	.word	0xb401ea01
    aa34:	01000000 	.word	0x01000000
    aa38:	01130051 	.word	0x01130051
    aa3c:	00004788 	.word	0x00004788
    aa40:	01020b01 	.word	0x01020b01
    aa44:	08007718 	.word	0x08007718
    aa48:	0800772e 	.word	0x0800772e
    aa4c:	05285d01 	.word	0x05285d01
    aa50:	59160000 	.word	0x59160000
    aa54:	01000048 	.word	0x01000048
    aa58:	0324020a 	.word	0x0324020a
    aa5c:	50010000 	.word	0x50010000
    aa60:	0046b318 	.word	0x0046b318
    aa64:	020a0100 	.word	0x020a0100
    aa68:	0000004c 	.word	0x0000004c
    aa6c:	0000468b 	.word	0x0000468b
    aa70:	fe011300 	.word	0xfe011300
    aa74:	01000048 	.word	0x01000048
    aa78:	30010220 	.word	0x30010220
    aa7c:	4a080077 	.word	0x4a080077
    aa80:	01080077 	.word	0x01080077
    aa84:	00055d5d 	.word	0x00055d5d
    aa88:	48591600 	.word	0x48591600
    aa8c:	1f010000 	.word	0x1f010000
    aa90:	00032402 	.word	0x00032402
    aa94:	16500100 	.word	0x16500100
    aa98:	00003381 	.word	0x00003381
    aa9c:	b4021f01 	.word	0xb4021f01
    aaa0:	01000000 	.word	0x01000000
    aaa4:	01130051 	.word	0x01130051
    aaa8:	000046fd 	.word	0x000046fd
    aaac:	01023c01 	.word	0x01023c01
    aab0:	0800774c 	.word	0x0800774c
    aab4:	08007754 	.word	0x08007754
    aab8:	05945d01 	.word	0x05945d01
    aabc:	59160000 	.word	0x59160000
    aac0:	01000048 	.word	0x01000048
    aac4:	0324023b 	.word	0x0324023b
    aac8:	50010000 	.word	0x50010000
    aacc:	00392e18 	.word	0x00392e18
    aad0:	023b0100 	.word	0x023b0100
    aad4:	0000004c 	.word	0x0000004c
    aad8:	0000469e 	.word	0x0000469e
    aadc:	74011b00 	.word	0x74011b00
    aae0:	01000049 	.word	0x01000049
    aae4:	4c01024f 	.word	0x4c01024f
    aae8:	54000000 	.word	0x54000000
    aaec:	5c080077 	.word	0x5c080077
    aaf0:	01080077 	.word	0x01080077
    aaf4:	0005c15d 	.word	0x0005c15d
    aaf8:	48591800 	.word	0x48591800
    aafc:	4e010000 	.word	0x4e010000
    ab00:	00032402 	.word	0x00032402
    ab04:	0046b100 	.word	0x0046b100
    ab08:	01130000 	.word	0x01130000
    ab0c:	0000483a 	.word	0x0000483a
    ab10:	01026101 	.word	0x01026101
    ab14:	0800775c 	.word	0x0800775c
    ab18:	08007768 	.word	0x08007768
    ab1c:	05e85d01 	.word	0x05e85d01
    ab20:	59160000 	.word	0x59160000
    ab24:	01000048 	.word	0x01000048
    ab28:	03240260 	.word	0x03240260
    ab2c:	50010000 	.word	0x50010000
    ab30:	27011300 	.word	0x27011300
    ab34:	01000048 	.word	0x01000048
    ab38:	68010274 	.word	0x68010274
    ab3c:	7a080077 	.word	0x7a080077
    ab40:	01080077 	.word	0x01080077
    ab44:	00061d5d 	.word	0x00061d5d
    ab48:	48591600 	.word	0x48591600
    ab4c:	73010000 	.word	0x73010000
    ab50:	00032402 	.word	0x00032402
    ab54:	16500100 	.word	0x16500100
    ab58:	00004778 	.word	0x00004778
    ab5c:	5e027301 	.word	0x5e027301
    ab60:	01000000 	.word	0x01000000
    ab64:	01130051 	.word	0x01130051
    ab68:	00004695 	.word	0x00004695
    ab6c:	01028a01 	.word	0x01028a01
    ab70:	0800777c 	.word	0x0800777c
    ab74:	0800778e 	.word	0x0800778e
    ab78:	06525d01 	.word	0x06525d01
    ab7c:	59160000 	.word	0x59160000
    ab80:	01000048 	.word	0x01000048
    ab84:	03240289 	.word	0x03240289
    ab88:	50010000 	.word	0x50010000
    ab8c:	00498616 	.word	0x00498616
    ab90:	02890100 	.word	0x02890100
    ab94:	0000005e 	.word	0x0000005e
    ab98:	13005101 	.word	0x13005101
    ab9c:	00486001 	.word	0x00486001
    aba0:	02a00100 	.word	0x02a00100
    aba4:	00779001 	.word	0x00779001
    aba8:	0077aa08 	.word	0x0077aa08
    abac:	875d0108 	.word	0x875d0108
    abb0:	16000006 	.word	0x16000006
    abb4:	00004859 	.word	0x00004859
    abb8:	24029f01 	.word	0x24029f01
    abbc:	01000003 	.word	0x01000003
    abc0:	33811650 	.word	0x33811650
    abc4:	9f010000 	.word	0x9f010000
    abc8:	0000b402 	.word	0x0000b402
    abcc:	00510100 	.word	0x00510100
    abd0:	491d0113 	.word	0x491d0113
    abd4:	bd010000 	.word	0xbd010000
    abd8:	77ac0102 	.word	0x77ac0102
    abdc:	77c60800 	.word	0x77c60800
    abe0:	5d010800 	.word	0x5d010800
    abe4:	000006bc 	.word	0x000006bc
    abe8:	00485916 	.word	0x00485916
    abec:	02bc0100 	.word	0x02bc0100
    abf0:	00000324 	.word	0x00000324
    abf4:	81165001 	.word	0x81165001
    abf8:	01000033 	.word	0x01000033
    abfc:	00b402bc 	.word	0x00b402bc
    ac00:	51010000 	.word	0x51010000
    ac04:	0c011300 	.word	0x0c011300
    ac08:	01000047 	.word	0x01000047
    ac0c:	c80102da 	.word	0xc80102da
    ac10:	e2080077 	.word	0xe2080077
    ac14:	01080077 	.word	0x01080077
    ac18:	0006f15d 	.word	0x0006f15d
    ac1c:	48591600 	.word	0x48591600
    ac20:	d9010000 	.word	0xd9010000
    ac24:	00032402 	.word	0x00032402
    ac28:	16500100 	.word	0x16500100
    ac2c:	00003381 	.word	0x00003381
    ac30:	b402d901 	.word	0xb402d901
    ac34:	01000000 	.word	0x01000000
    ac38:	01130051 	.word	0x01130051
    ac3c:	000048bb 	.word	0x000048bb
    ac40:	0102f901 	.word	0x0102f901
    ac44:	080077e4 	.word	0x080077e4
    ac48:	080077fa 	.word	0x080077fa
    ac4c:	07285d01 	.word	0x07285d01
    ac50:	59160000 	.word	0x59160000
    ac54:	01000048 	.word	0x01000048
    ac58:	032402f8 	.word	0x032402f8
    ac5c:	50010000 	.word	0x50010000
    ac60:	00474818 	.word	0x00474818
    ac64:	02f80100 	.word	0x02f80100
    ac68:	0000004c 	.word	0x0000004c
    ac6c:	000046c4 	.word	0x000046c4
    ac70:	f0011300 	.word	0xf0011300
    ac74:	01000048 	.word	0x01000048
    ac78:	fc01030e 	.word	0xfc01030e
    ac7c:	16080077 	.word	0x16080077
    ac80:	01080078 	.word	0x01080078
    ac84:	00075d5d 	.word	0x00075d5d
    ac88:	48591600 	.word	0x48591600
    ac8c:	0d010000 	.word	0x0d010000
    ac90:	00032403 	.word	0x00032403
    ac94:	16500100 	.word	0x16500100
    ac98:	00003381 	.word	0x00003381
    ac9c:	b4030d01 	.word	0xb4030d01
    aca0:	01000000 	.word	0x01000000
    aca4:	011b0051 	.word	0x011b0051
    aca8:	00004934 	.word	0x00004934
    acac:	01033601 	.word	0x01033601
    acb0:	00000089 	.word	0x00000089
    acb4:	08007818 	.word	0x08007818
    acb8:	08007824 	.word	0x08007824
    acbc:	07a45d01 	.word	0x07a45d01
    acc0:	59180000 	.word	0x59180000
    acc4:	01000048 	.word	0x01000048
    acc8:	03240335 	.word	0x03240335
    accc:	46d70000 	.word	0x46d70000
    acd0:	a9160000 	.word	0xa9160000
    acd4:	01000047 	.word	0x01000047
    acd8:	004c0335 	.word	0x004c0335
    acdc:	51010000 	.word	0x51010000
    ace0:	00356719 	.word	0x00356719
    ace4:	03370100 	.word	0x03370100
    ace8:	00000089 	.word	0x00000089
    acec:	99011300 	.word	0x99011300
    acf0:	01000048 	.word	0x01000048
    acf4:	2401036a 	.word	0x2401036a
    acf8:	2e080078 	.word	0x2e080078
    acfc:	01080078 	.word	0x01080078
    ad00:	0007db5d 	.word	0x0007db5d
    ad04:	48591600 	.word	0x48591600
    ad08:	69010000 	.word	0x69010000
    ad0c:	00032403 	.word	0x00032403
    ad10:	18500100 	.word	0x18500100
    ad14:	000047a9 	.word	0x000047a9
    ad18:	4c036901 	.word	0x4c036901
    ad1c:	ea000000 	.word	0xea000000
    ad20:	00000046 	.word	0x00000046
    ad24:	48a9011b 	.word	0x48a9011b
    ad28:	8b010000 	.word	0x8b010000
    ad2c:	00940103 	.word	0x00940103
    ad30:	78300000 	.word	0x78300000
    ad34:	787a0800 	.word	0x787a0800
    ad38:	5d010800 	.word	0x5d010800
    ad3c:	00000852 	.word	0x00000852
    ad40:	00485918 	.word	0x00485918
    ad44:	038a0100 	.word	0x038a0100
    ad48:	00000324 	.word	0x00000324
    ad4c:	000046fd 	.word	0x000046fd
    ad50:	00494818 	.word	0x00494818
    ad54:	038a0100 	.word	0x038a0100
    ad58:	0000004c 	.word	0x0000004c
    ad5c:	00004710 	.word	0x00004710
    ad60:	00489215 	.word	0x00489215
    ad64:	038c0100 	.word	0x038c0100
    ad68:	0000003a 	.word	0x0000003a
    ad6c:	831a5201 	.word	0x831a5201
    ad70:	01000036 	.word	0x01000036
    ad74:	003a038c 	.word	0x003a038c
    ad78:	47390000 	.word	0x47390000
    ad7c:	c51a0000 	.word	0xc51a0000
    ad80:	01000049 	.word	0x01000049
    ad84:	003a038c 	.word	0x003a038c
    ad88:	47570000 	.word	0x47570000
    ad8c:	67190000 	.word	0x67190000
    ad90:	01000035 	.word	0x01000035
    ad94:	0094038d 	.word	0x0094038d
    ad98:	13000000 	.word	0x13000000
    ad9c:	00476001 	.word	0x00476001
    ada0:	03db0100 	.word	0x03db0100
    ada4:	00787c01 	.word	0x00787c01
    ada8:	00788c08 	.word	0x00788c08
    adac:	a15d0108 	.word	0xa15d0108
    adb0:	16000008 	.word	0x16000008
    adb4:	00004859 	.word	0x00004859
    adb8:	2403da01 	.word	0x2403da01
    adbc:	01000003 	.word	0x01000003
    adc0:	49481850 	.word	0x49481850
    adc4:	da010000 	.word	0xda010000
    adc8:	00004c03 	.word	0x00004c03
    adcc:	00476a00 	.word	0x00476a00
    add0:	48921900 	.word	0x48921900
    add4:	dc010000 	.word	0xdc010000
    add8:	00004c03 	.word	0x00004c03
    addc:	36831900 	.word	0x36831900
    ade0:	dc010000 	.word	0xdc010000
    ade4:	00004c03 	.word	0x00004c03
    ade8:	011c0000 	.word	0x011c0000
    adec:	000046a8 	.word	0x000046a8
    adf0:	8c018d01 	.word	0x8c018d01
    adf4:	28080078 	.word	0x28080078
    adf8:	7d080079 	.word	0x7d080079
    adfc:	2a000047 	.word	0x2a000047
    ae00:	14000009 	.word	0x14000009
    ae04:	00004859 	.word	0x00004859
    ae08:	03248c01 	.word	0x03248c01
    ae0c:	47a80000 	.word	0x47a80000
    ae10:	73140000 	.word	0x73140000
    ae14:	01000048 	.word	0x01000048
    ae18:	0002db8c 	.word	0x0002db8c
    ae1c:	0047c700 	.word	0x0047c700
    ae20:	341a1d00 	.word	0x341a1d00
    ae24:	8e010000 	.word	0x8e010000
    ae28:	0000003a 	.word	0x0000003a
    ae2c:	000047e5 	.word	0x000047e5
    ae30:	0047571d 	.word	0x0047571d
    ae34:	3a8e0100 	.word	0x3a8e0100
    ae38:	0e000000 	.word	0x0e000000
    ae3c:	1e000048 	.word	0x1e000048
    ae40:	0000467b 	.word	0x0000467b
    ae44:	003a8f01 	.word	0x003a8f01
    ae48:	51010000 	.word	0x51010000
    ae4c:	00490b1f 	.word	0x00490b1f
    ae50:	3a900100 	.word	0x3a900100
    ae54:	1e000000 	.word	0x1e000000
    ae58:	000047fa 	.word	0x000047fa
    ae5c:	003a9101 	.word	0x003a9101
    ae60:	54010000 	.word	0x54010000
    ae64:	0048051e 	.word	0x0048051e
    ae68:	ab920100 	.word	0xab920100
    ae6c:	02000002 	.word	0x02000002
    ae70:	20005c91 	.word	0x20005c91
    ae74:	0047b401 	.word	0x0047b401
    ae78:	015b0100 	.word	0x015b0100
    ae7c:	08007928 	.word	0x08007928
    ae80:	080079bc 	.word	0x080079bc
    ae84:	00004821 	.word	0x00004821
    ae88:	00485914 	.word	0x00485914
    ae8c:	245a0100 	.word	0x245a0100
    ae90:	4c000003 	.word	0x4c000003
    ae94:	00000048 	.word	0x00000048
    ae98:	00008600 	.word	0x00008600
    ae9c:	27000200 	.word	0x27000200
    aea0:	0400002f 	.word	0x0400002f
    aea4:	002bca01 	.word	0x002bca01
    aea8:	0079bc00 	.word	0x0079bc00
    aeac:	007a2a08 	.word	0x007a2a08
    aeb0:	6d747308 	.word	0x6d747308
    aeb4:	31663233 	.word	0x31663233
    aeb8:	6c5f7830 	.word	0x6c5f7830
    aebc:	732f6269 	.word	0x732f6269
    aec0:	632f6372 	.word	0x632f6372
    aec4:	6574726f 	.word	0x6574726f
    aec8:	5f336d78 	.word	0x5f336d78
    aecc:	7263616d 	.word	0x7263616d
    aed0:	00732e6f 	.word	0x00732e6f
    aed4:	555c3a43 	.word	0x555c3a43
    aed8:	73726573 	.word	0x73726573
    aedc:	736e695c 	.word	0x736e695c
    aee0:	6c6c6174 	.word	0x6c6c6174
    aee4:	6f72705c 	.word	0x6f72705c
    aee8:	746b656a 	.word	0x746b656a
    aeec:	6568545c 	.word	0x6568545c
    aef0:	5f736973 	.word	0x5f736973
    aef4:	6c6f6942 	.word	0x6c6f6942
    aef8:	5c64696f 	.word	0x5c64696f
    aefc:	616d7568 	.word	0x616d7568
    af00:	64696f6e 	.word	0x64696f6e
    af04:	635f635f 	.word	0x635f635f
    af08:	72746e6f 	.word	0x72746e6f
    af0c:	656c6c6f 	.word	0x656c6c6f
    af10:	4e470072 	.word	0x4e470072
    af14:	53412055 	.word	0x53412055
    af18:	312e3220 	.word	0x312e3220
    af1c:	30352e38 	.word	0x30352e38
    af20:	02800100 	.word	0x02800100
    af24:	02000001 	.word	0x02000001
    af28:	002f3b00 	.word	0x002f3b00
    af2c:	fe010400 	.word	0xfe010400
    af30:	01000001 	.word	0x01000001
    af34:	00004a19 	.word	0x00004a19
    af38:	00000249 	.word	0x00000249
    af3c:	08007a2c 	.word	0x08007a2c
    af40:	08007a80 	.word	0x08007a80
    af44:	00002c6e 	.word	0x00002c6e
    af48:	22050402 	.word	0x22050402
    af4c:	02000001 	.word	0x02000001
    af50:	04ca0502 	.word	0x04ca0502
    af54:	01020000 	.word	0x01020000
    af58:	00049e06 	.word	0x00049e06
    af5c:	07040200 	.word	0x07040200
    af60:	00000130 	.word	0x00000130
    af64:	c5070202 	.word	0xc5070202
    af68:	02000001 	.word	0x02000001
    af6c:	049c0801 	.word	0x049c0801
    af70:	04030000 	.word	0x04030000
    af74:	ee010407 	.word	0xee010407
    af78:	01000049 	.word	0x01000049
    af7c:	7a2c0192 	.word	0x7a2c0192
    af80:	7a800800 	.word	0x7a800800
    af84:	486b0800 	.word	0x486b0800
    af88:	00860000 	.word	0x00860000
    af8c:	4b050000 	.word	0x4b050000
    af90:	0100004a 	.word	0x0100004a
    af94:	00008693 	.word	0x00008693
    af98:	49fc0600 	.word	0x49fc0600
    af9c:	93010000 	.word	0x93010000
    afa0:	00000086 	.word	0x00000086
    afa4:	0000488a 	.word	0x0000488a
    afa8:	3a040700 	.word	0x3a040700
    afac:	08000000 	.word	0x08000000
    afb0:	00004a04 	.word	0x00004a04
    afb4:	003a1901 	.word	0x003a1901
    afb8:	01010000 	.word	0x01010000
    afbc:	0049e708 	.word	0x0049e708
    afc0:	3a1b0100 	.word	0x3a1b0100
    afc4:	01000000 	.word	0x01000000
    afc8:	4a120801 	.word	0x4a120801
    afcc:	1d010000 	.word	0x1d010000
    afd0:	0000003a 	.word	0x0000003a
    afd4:	52080101 	.word	0x52080101
    afd8:	0100004a 	.word	0x0100004a
    afdc:	00003a20 	.word	0x00003a20
    afe0:	08010100 	.word	0x08010100
    afe4:	00004a0c 	.word	0x00004a0c
    afe8:	003a2201 	.word	0x003a2201
    afec:	01010000 	.word	0x01010000
    aff0:	0049df09 	.word	0x0049df09
    aff4:	01250100 	.word	0x01250100
    aff8:	00e80a01 	.word	0x00e80a01
    affc:	00e60000 	.word	0x00e60000
    b000:	4f0b0000 	.word	0x4f0b0000
    b004:	4c000000 	.word	0x4c000000
    b008:	07010c00 	.word	0x07010c00
    b00c:	0000e604 	.word	0x0000e604
    b010:	4a3e0d00 	.word	0x4a3e0d00
    b014:	39010000 	.word	0x39010000
    b018:	00000100 	.word	0x00000100
    b01c:	00030501 	.word	0x00030501
    b020:	0e080030 	.word	0x0e080030
    b024:	000000d6 	.word	0x000000d6
    b028:	0000c100 	.word	0x0000c100
    b02c:	f0000200 	.word	0xf0000200
    b030:	0400002f 	.word	0x0400002f
    b034:	0001fe01 	.word	0x0001fe01
    b038:	4a8f0100 	.word	0x4a8f0100
    b03c:	4a580000 	.word	0x4a580000
	...
    b048:	2ccc0000 	.word	0x2ccc0000
    b04c:	04020000 	.word	0x04020000
    b050:	00013507 	.word	0x00013507
    b054:	06010200 	.word	0x06010200
    b058:	0000049e 	.word	0x0000049e
    b05c:	9c080102 	.word	0x9c080102
    b060:	02000004 	.word	0x02000004
    b064:	04ca0502 	.word	0x04ca0502
    b068:	02020000 	.word	0x02020000
    b06c:	0001c507 	.word	0x0001c507
    b070:	05040300 	.word	0x05040300
    b074:	00746e69 	.word	0x00746e69
    b078:	1d050802 	.word	0x1d050802
    b07c:	02000001 	.word	0x02000001
    b080:	012b0708 	.word	0x012b0708
    b084:	04020000 	.word	0x04020000
    b088:	00012205 	.word	0x00012205
    b08c:	07040400 	.word	0x07040400
    b090:	30070402 	.word	0x30070402
    b094:	05000001 	.word	0x05000001
    b098:	6e040601 	.word	0x6e040601
    b09c:	02000000 	.word	0x02000000
    b0a0:	04a50801 	.word	0x04a50801
    b0a4:	d9070000 	.word	0xd9070000
    b0a8:	0100004a 	.word	0x0100004a
    b0ac:	009c0602 	.word	0x009c0602
    b0b0:	e8080000 	.word	0xe8080000
    b0b4:	0000004a 	.word	0x0000004a
    b0b8:	004acd08 	.word	0x004acd08
    b0bc:	c4080100 	.word	0xc4080100
    b0c0:	0200004a 	.word	0x0200004a
    b0c4:	ed010900 	.word	0xed010900
    b0c8:	0100004a 	.word	0x0100004a
    b0cc:	00480140 	.word	0x00480140
	...
    b0d8:	489d0000 	.word	0x489d0000
    b0dc:	660a0000 	.word	0x660a0000
    b0e0:	3d01006e 	.word	0x3d01006e
    b0e4:	00000070 	.word	0x00000070
    b0e8:	000048c8 	.word	0x000048c8
    b0ec:	09360000 	.word	0x09360000
    b0f0:	00020000 	.word	0x00020000
    b0f4:	00003071 	.word	0x00003071
    b0f8:	01fe0104 	.word	0x01fe0104
    b0fc:	00010000 	.word	0x00010000
    b100:	5800004b 	.word	0x5800004b
    b104:	8000004a 	.word	0x8000004a
    b108:	b008007a 	.word	0xb008007a
    b10c:	4008007a 	.word	0x4008007a
    b110:	0200002d 	.word	0x0200002d
    b114:	01350704 	.word	0x01350704
    b118:	01020000 	.word	0x01020000
    b11c:	00049e06 	.word	0x00049e06
    b120:	08010200 	.word	0x08010200
    b124:	0000049c 	.word	0x0000049c
    b128:	ca050202 	.word	0xca050202
    b12c:	02000004 	.word	0x02000004
    b130:	01c50702 	.word	0x01c50702
    b134:	04030000 	.word	0x04030000
    b138:	746e6905 	.word	0x746e6905
    b13c:	05080200 	.word	0x05080200
    b140:	0000011d 	.word	0x0000011d
    b144:	2b070802 	.word	0x2b070802
    b148:	04000001 	.word	0x04000001
    b14c:	00004cff 	.word	0x00004cff
    b150:	00480702 	.word	0x00480702
    b154:	04020000 	.word	0x04020000
    b158:	00012205 	.word	0x00012205
    b15c:	4dae0400 	.word	0x4dae0400
    b160:	2c030000 	.word	0x2c030000
    b164:	00000068 	.word	0x00000068
    b168:	004ca705 	.word	0x004ca705
    b16c:	01630400 	.word	0x01630400
    b170:	00000025 	.word	0x00000025
    b174:	47030406 	.word	0x47030406
    b178:	000000a5 	.word	0x000000a5
    b17c:	004ca107 	.word	0x004ca107
    b180:	7a480300 	.word	0x7a480300
    b184:	07000000 	.word	0x07000000
    b188:	00004c5b 	.word	0x00004c5b
    b18c:	00a54903 	.word	0x00a54903
    b190:	08000000 	.word	0x08000000
    b194:	00000033 	.word	0x00000033
    b198:	000000b5 	.word	0x000000b5
    b19c:	0000b509 	.word	0x0000b509
    b1a0:	0a000300 	.word	0x0a000300
    b1a4:	080b0704 	.word	0x080b0704
    b1a8:	00dd4403 	.word	0x00dd4403
    b1ac:	980c0000 	.word	0x980c0000
    b1b0:	0300004d 	.word	0x0300004d
    b1b4:	00004845 	.word	0x00004845
    b1b8:	00230200 	.word	0x00230200
    b1bc:	004da00c 	.word	0x004da00c
    b1c0:	864a0300 	.word	0x864a0300
    b1c4:	02000000 	.word	0x02000000
    b1c8:	04000423 	.word	0x04000423
    b1cc:	00004d34 	.word	0x00004d34
    b1d0:	00b84b03 	.word	0x00b84b03
    b1d4:	2d040000 	.word	0x2d040000
    b1d8:	0300004c 	.word	0x0300004c
    b1dc:	00005d4f 	.word	0x00005d4f
    b1e0:	04040d00 	.word	0x04040d00
    b1e4:	00004de1 	.word	0x00004de1
    b1e8:	01001505 	.word	0x01001505
    b1ec:	04020000 	.word	0x04020000
    b1f0:	00013007 	.word	0x00013007
    b1f4:	4c3e0e00 	.word	0x4c3e0e00
    b1f8:	05180000 	.word	0x05180000
    b1fc:	0001662d 	.word	0x0001662d
    b200:	4d4c0c00 	.word	0x4d4c0c00
    b204:	2e050000 	.word	0x2e050000
    b208:	00000166 	.word	0x00000166
    b20c:	0f002302 	.word	0x0f002302
    b210:	05006b5f 	.word	0x05006b5f
    b214:	0000482f 	.word	0x0000482f
    b218:	04230200 	.word	0x04230200
    b21c:	004d830c 	.word	0x004d830c
    b220:	482f0500 	.word	0x482f0500
    b224:	02000000 	.word	0x02000000
    b228:	270c0823 	.word	0x270c0823
    b22c:	0500004c 	.word	0x0500004c
    b230:	0000482f 	.word	0x0000482f
    b234:	0c230200 	.word	0x0c230200
    b238:	004e2d0c 	.word	0x004e2d0c
    b23c:	482f0500 	.word	0x482f0500
    b240:	02000000 	.word	0x02000000
    b244:	5f0f1023 	.word	0x5f0f1023
    b248:	30050078 	.word	0x30050078
    b24c:	0000016c 	.word	0x0000016c
    b250:	00142302 	.word	0x00142302
    b254:	01070410 	.word	0x01070410
    b258:	f5080000 	.word	0xf5080000
    b25c:	7c000000 	.word	0x7c000000
    b260:	09000001 	.word	0x09000001
    b264:	000000b5 	.word	0x000000b5
    b268:	560e0000 	.word	0x560e0000
    b26c:	2400004c 	.word	0x2400004c
    b270:	02073505 	.word	0x02073505
    b274:	920c0000 	.word	0x920c0000
    b278:	0500004b 	.word	0x0500004b
    b27c:	00004836 	.word	0x00004836
    b280:	00230200 	.word	0x00230200
    b284:	004dbd0c 	.word	0x004dbd0c
    b288:	48370500 	.word	0x48370500
    b28c:	02000000 	.word	0x02000000
    b290:	a70c0423 	.word	0xa70c0423
    b294:	0500004b 	.word	0x0500004b
    b298:	00004838 	.word	0x00004838
    b29c:	08230200 	.word	0x08230200
    b2a0:	004e9f0c 	.word	0x004e9f0c
    b2a4:	48390500 	.word	0x48390500
    b2a8:	02000000 	.word	0x02000000
    b2ac:	d20c0c23 	.word	0xd20c0c23
    b2b0:	0500004c 	.word	0x0500004c
    b2b4:	0000483a 	.word	0x0000483a
    b2b8:	10230200 	.word	0x10230200
    b2bc:	004cc10c 	.word	0x004cc10c
    b2c0:	483b0500 	.word	0x483b0500
    b2c4:	02000000 	.word	0x02000000
    b2c8:	320c1423 	.word	0x320c1423
    b2cc:	0500004e 	.word	0x0500004e
    b2d0:	0000483c 	.word	0x0000483c
    b2d4:	18230200 	.word	0x18230200
    b2d8:	004d160c 	.word	0x004d160c
    b2dc:	483d0500 	.word	0x483d0500
    b2e0:	02000000 	.word	0x02000000
    b2e4:	6d0c1c23 	.word	0x6d0c1c23
    b2e8:	0500004e 	.word	0x0500004e
    b2ec:	0000483e 	.word	0x0000483e
    b2f0:	20230200 	.word	0x20230200
    b2f4:	4bb61100 	.word	0x4bb61100
    b2f8:	01080000 	.word	0x01080000
    b2fc:	02504705 	.word	0x02504705
    b300:	1a0c0000 	.word	0x1a0c0000
    b304:	0500004c 	.word	0x0500004c
    b308:	00025048 	.word	0x00025048
    b30c:	00230200 	.word	0x00230200
    b310:	004af40c 	.word	0x004af40c
    b314:	50490500 	.word	0x50490500
    b318:	03000002 	.word	0x03000002
    b31c:	0c018023 	.word	0x0c018023
    b320:	00004dd3 	.word	0x00004dd3
    b324:	00f54b05 	.word	0x00f54b05
    b328:	23030000 	.word	0x23030000
    b32c:	db0c0280 	.word	0xdb0c0280
    b330:	0500004b 	.word	0x0500004b
    b334:	0000f54e 	.word	0x0000f54e
    b338:	84230300 	.word	0x84230300
    b33c:	f3080002 	.word	0xf3080002
    b340:	60000000 	.word	0x60000000
    b344:	09000002 	.word	0x09000002
    b348:	000000b5 	.word	0x000000b5
    b34c:	ec11001f 	.word	0xec11001f
    b350:	9000004a 	.word	0x9000004a
    b354:	a7590501 	.word	0xa7590501
    b358:	0c000002 	.word	0x0c000002
    b35c:	00004d4c 	.word	0x00004d4c
    b360:	02a75a05 	.word	0x02a75a05
    b364:	23020000 	.word	0x23020000
    b368:	4d640c00 	.word	0x4d640c00
    b36c:	5b050000 	.word	0x5b050000
    b370:	00000048 	.word	0x00000048
    b374:	0c042302 	.word	0x0c042302
    b378:	00004c22 	.word	0x00004c22
    b37c:	02ad5d05 	.word	0x02ad5d05
    b380:	23020000 	.word	0x23020000
    b384:	4bb60c08 	.word	0x4bb60c08
    b388:	5e050000 	.word	0x5e050000
    b38c:	00000207 	.word	0x00000207
    b390:	01882303 	.word	0x01882303
    b394:	60041000 	.word	0x60041000
    b398:	08000002 	.word	0x08000002
    b39c:	000002bf 	.word	0x000002bf
    b3a0:	000002bd 	.word	0x000002bd
    b3a4:	0000b509 	.word	0x0000b509
    b3a8:	12001f00 	.word	0x12001f00
    b3ac:	bd041001 	.word	0xbd041001
    b3b0:	0e000002 	.word	0x0e000002
    b3b4:	00004d20 	.word	0x00004d20
    b3b8:	ee690508 	.word	0xee690508
    b3bc:	0c000002 	.word	0x0c000002
    b3c0:	00004ba1 	.word	0x00004ba1
    b3c4:	02ee6a05 	.word	0x02ee6a05
    b3c8:	23020000 	.word	0x23020000
    b3cc:	4b330c00 	.word	0x4b330c00
    b3d0:	6b050000 	.word	0x6b050000
    b3d4:	00000048 	.word	0x00000048
    b3d8:	00042302 	.word	0x00042302
    b3dc:	00330410 	.word	0x00330410
    b3e0:	3f0e0000 	.word	0x3f0e0000
    b3e4:	5c00004d 	.word	0x5c00004d
    b3e8:	0432a905 	.word	0x0432a905
    b3ec:	5f0f0000 	.word	0x5f0f0000
    b3f0:	aa050070 	.word	0xaa050070
    b3f4:	000002ee 	.word	0x000002ee
    b3f8:	0f002302 	.word	0x0f002302
    b3fc:	0500725f 	.word	0x0500725f
    b400:	000048ab 	.word	0x000048ab
    b404:	04230200 	.word	0x04230200
    b408:	00775f0f 	.word	0x00775f0f
    b40c:	0048ac05 	.word	0x0048ac05
    b410:	23020000 	.word	0x23020000
    b414:	4bd40c08 	.word	0x4bd40c08
    b418:	ad050000 	.word	0xad050000
    b41c:	0000003a 	.word	0x0000003a
    b420:	0c0c2302 	.word	0x0c0c2302
    b424:	00004c72 	.word	0x00004c72
    b428:	003aae05 	.word	0x003aae05
    b42c:	23020000 	.word	0x23020000
    b430:	625f0f0e 	.word	0x625f0f0e
    b434:	af050066 	.word	0xaf050066
    b438:	000002c5 	.word	0x000002c5
    b43c:	0c102302 	.word	0x0c102302
    b440:	00004b6c 	.word	0x00004b6c
    b444:	0048b005 	.word	0x0048b005
    b448:	23020000 	.word	0x23020000
    b44c:	4bc40c18 	.word	0x4bc40c18
    b450:	b7050000 	.word	0xb7050000
    b454:	000000f3 	.word	0x000000f3
    b458:	0c1c2302 	.word	0x0c1c2302
    b45c:	00004c46 	.word	0x00004c46
    b460:	05c1b905 	.word	0x05c1b905
    b464:	23020000 	.word	0x23020000
    b468:	4cba0c20 	.word	0x4cba0c20
    b46c:	bb050000 	.word	0xbb050000
    b470:	000005f1 	.word	0x000005f1
    b474:	0c242302 	.word	0x0c242302
    b478:	00004da8 	.word	0x00004da8
    b47c:	0616bd05 	.word	0x0616bd05
    b480:	23020000 	.word	0x23020000
    b484:	310e0c28 	.word	0x310e0c28
    b488:	be050000 	.word	0xbe050000
    b48c:	00000631 	.word	0x00000631
    b490:	0f2c2302 	.word	0x0f2c2302
    b494:	0062755f 	.word	0x0062755f
    b498:	02c5c105 	.word	0x02c5c105
    b49c:	23020000 	.word	0x23020000
    b4a0:	755f0f30 	.word	0x755f0f30
    b4a4:	c2050070 	.word	0xc2050070
    b4a8:	000002ee 	.word	0x000002ee
    b4ac:	0f382302 	.word	0x0f382302
    b4b0:	0072755f 	.word	0x0072755f
    b4b4:	0048c305 	.word	0x0048c305
    b4b8:	23020000 	.word	0x23020000
    b4bc:	4b9b0c3c 	.word	0x4b9b0c3c
    b4c0:	c6050000 	.word	0xc6050000
    b4c4:	00000637 	.word	0x00000637
    b4c8:	0c402302 	.word	0x0c402302
    b4cc:	00004e5f 	.word	0x00004e5f
    b4d0:	0647c705 	.word	0x0647c705
    b4d4:	23020000 	.word	0x23020000
    b4d8:	6c5f0f43 	.word	0x6c5f0f43
    b4dc:	ca050062 	.word	0xca050062
    b4e0:	000002c5 	.word	0x000002c5
    b4e4:	0c442302 	.word	0x0c442302
    b4e8:	00004bea 	.word	0x00004bea
    b4ec:	0048cd05 	.word	0x0048cd05
    b4f0:	23020000 	.word	0x23020000
    b4f4:	288d0c4c 	.word	0x288d0c4c
    b4f8:	ce050000 	.word	0xce050000
    b4fc:	00000048 	.word	0x00000048
    b500:	0c502302 	.word	0x0c502302
    b504:	00004eaf 	.word	0x00004eaf
    b508:	0451d105 	.word	0x0451d105
    b50c:	23020000 	.word	0x23020000
    b510:	4cae0c54 	.word	0x4cae0c54
    b514:	d5050000 	.word	0xd5050000
    b518:	000000e8 	.word	0x000000e8
    b51c:	00582302 	.word	0x00582302
    b520:	00480113 	.word	0x00480113
    b524:	04510000 	.word	0x04510000
    b528:	51140000 	.word	0x51140000
    b52c:	14000004 	.word	0x14000004
    b530:	000000f3 	.word	0x000000f3
    b534:	0005b414 	.word	0x0005b414
    b538:	00481400 	.word	0x00481400
    b53c:	10000000 	.word	0x10000000
    b540:	00045704 	.word	0x00045704
    b544:	4d8b1100 	.word	0x4d8b1100
    b548:	04000000 	.word	0x04000000
    b54c:	05b42505 	.word	0x05b42505
    b550:	b6150000 	.word	0xb6150000
    b554:	0500004d 	.word	0x0500004d
    b558:	00480241 	.word	0x00480241
    b55c:	23020000 	.word	0x23020000
    b560:	4be31500 	.word	0x4be31500
    b564:	46050000 	.word	0x46050000
    b568:	0006a402 	.word	0x0006a402
    b56c:	04230200 	.word	0x04230200
    b570:	004c6215 	.word	0x004c6215
    b574:	02460500 	.word	0x02460500
    b578:	000006a4 	.word	0x000006a4
    b57c:	15082302 	.word	0x15082302
    b580:	00004c36 	.word	0x00004c36
    b584:	a4024605 	.word	0xa4024605
    b588:	02000006 	.word	0x02000006
    b58c:	5f150c23 	.word	0x5f150c23
    b590:	0500004d 	.word	0x0500004d
    b594:	00480248 	.word	0x00480248
    b598:	23020000 	.word	0x23020000
    b59c:	4b411510 	.word	0x4b411510
    b5a0:	49050000 	.word	0x49050000
    b5a4:	0008af02 	.word	0x0008af02
    b5a8:	14230200 	.word	0x14230200
    b5ac:	004e0915 	.word	0x004e0915
    b5b0:	024b0500 	.word	0x024b0500
    b5b4:	00000048 	.word	0x00000048
    b5b8:	15302302 	.word	0x15302302
    b5bc:	00004d69 	.word	0x00004d69
    b5c0:	e6024c05 	.word	0xe6024c05
    b5c4:	02000005 	.word	0x02000005
    b5c8:	db153423 	.word	0xdb153423
    b5cc:	0500004c 	.word	0x0500004c
    b5d0:	0048024e 	.word	0x0048024e
    b5d4:	23020000 	.word	0x23020000
    b5d8:	4d791538 	.word	0x4d791538
    b5dc:	50050000 	.word	0x50050000
    b5e0:	0008cb02 	.word	0x0008cb02
    b5e4:	3c230200 	.word	0x3c230200
    b5e8:	001db915 	.word	0x001db915
    b5ec:	02530500 	.word	0x02530500
    b5f0:	00000166 	.word	0x00000166
    b5f4:	15402302 	.word	0x15402302
    b5f8:	00004c4c 	.word	0x00004c4c
    b5fc:	48025405 	.word	0x48025405
    b600:	02000000 	.word	0x02000000
    b604:	9a154423 	.word	0x9a154423
    b608:	0500004e 	.word	0x0500004e
    b60c:	01660255 	.word	0x01660255
    b610:	23020000 	.word	0x23020000
    b614:	4cf51548 	.word	0x4cf51548
    b618:	56050000 	.word	0x56050000
    b61c:	0008d102 	.word	0x0008d102
    b620:	4c230200 	.word	0x4c230200
    b624:	004c6a15 	.word	0x004c6a15
    b628:	02590500 	.word	0x02590500
    b62c:	00000048 	.word	0x00000048
    b630:	15502302 	.word	0x15502302
    b634:	00004bf3 	.word	0x00004bf3
    b638:	b4025a05 	.word	0xb4025a05
    b63c:	02000005 	.word	0x02000005
    b640:	11155423 	.word	0x11155423
    b644:	0500004d 	.word	0x0500004d
    b648:	088d027c 	.word	0x088d027c
    b64c:	23020000 	.word	0x23020000
    b650:	4aec1558 	.word	0x4aec1558
    b654:	7f050000 	.word	0x7f050000
    b658:	0002a702 	.word	0x0002a702
    b65c:	c8230300 	.word	0xc8230300
    b660:	4c7f1502 	.word	0x4c7f1502
    b664:	80050000 	.word	0x80050000
    b668:	00026002 	.word	0x00026002
    b66c:	cc230300 	.word	0xcc230300
    b670:	4e551502 	.word	0x4e551502
    b674:	83050000 	.word	0x83050000
    b678:	0008e302 	.word	0x0008e302
    b67c:	dc230300 	.word	0xdc230300
    b680:	4bcc1505 	.word	0x4bcc1505
    b684:	88050000 	.word	0x88050000
    b688:	00066302 	.word	0x00066302
    b68c:	e0230300 	.word	0xe0230300
    b690:	4bb11505 	.word	0x4bb11505
    b694:	89050000 	.word	0x89050000
    b698:	0008ef02 	.word	0x0008ef02
    b69c:	ec230300 	.word	0xec230300
    b6a0:	04100005 	.word	0x04100005
    b6a4:	000005ba 	.word	0x000005ba
    b6a8:	a5080102 	.word	0xa5080102
    b6ac:	10000004 	.word	0x10000004
    b6b0:	00043204 	.word	0x00043204
    b6b4:	48011300 	.word	0x48011300
    b6b8:	e6000000 	.word	0xe6000000
    b6bc:	14000005 	.word	0x14000005
    b6c0:	00000451 	.word	0x00000451
    b6c4:	0000f314 	.word	0x0000f314
    b6c8:	05e61400 	.word	0x05e61400
    b6cc:	48140000 	.word	0x48140000
    b6d0:	00000000 	.word	0x00000000
    b6d4:	05ec0410 	.word	0x05ec0410
    b6d8:	ba160000 	.word	0xba160000
    b6dc:	10000005 	.word	0x10000005
    b6e0:	0005c704 	.word	0x0005c704
    b6e4:	6f011300 	.word	0x6f011300
    b6e8:	16000000 	.word	0x16000000
    b6ec:	14000006 	.word	0x14000006
    b6f0:	00000451 	.word	0x00000451
    b6f4:	0000f314 	.word	0x0000f314
    b6f8:	006f1400 	.word	0x006f1400
    b6fc:	48140000 	.word	0x48140000
    b700:	00000000 	.word	0x00000000
    b704:	05f70410 	.word	0x05f70410
    b708:	01130000 	.word	0x01130000
    b70c:	00000048 	.word	0x00000048
    b710:	00000631 	.word	0x00000631
    b714:	00045114 	.word	0x00045114
    b718:	00f31400 	.word	0x00f31400
    b71c:	10000000 	.word	0x10000000
    b720:	00061c04 	.word	0x00061c04
    b724:	00330800 	.word	0x00330800
    b728:	06470000 	.word	0x06470000
    b72c:	b5090000 	.word	0xb5090000
    b730:	02000000 	.word	0x02000000
    b734:	00330800 	.word	0x00330800
    b738:	06570000 	.word	0x06570000
    b73c:	b5090000 	.word	0xb5090000
    b740:	00000000 	.word	0x00000000
    b744:	4d2d0500 	.word	0x4d2d0500
    b748:	0e050000 	.word	0x0e050000
    b74c:	0002f401 	.word	0x0002f401
    b750:	4e3c1700 	.word	0x4e3c1700
    b754:	050c0000 	.word	0x050c0000
    b758:	069e0113 	.word	0x069e0113
    b75c:	4c150000 	.word	0x4c150000
    b760:	0500004d 	.word	0x0500004d
    b764:	069e0114 	.word	0x069e0114
    b768:	23020000 	.word	0x23020000
    b76c:	4c781500 	.word	0x4c781500
    b770:	15050000 	.word	0x15050000
    b774:	00004801 	.word	0x00004801
    b778:	04230200 	.word	0x04230200
    b77c:	004d2715 	.word	0x004d2715
    b780:	01160500 	.word	0x01160500
    b784:	000006a4 	.word	0x000006a4
    b788:	00082302 	.word	0x00082302
    b78c:	06630410 	.word	0x06630410
    b790:	04100000 	.word	0x04100000
    b794:	00000657 	.word	0x00000657
    b798:	004b3917 	.word	0x004b3917
    b79c:	2e050e00 	.word	0x2e050e00
    b7a0:	0006e501 	.word	0x0006e501
    b7a4:	4d921500 	.word	0x4d921500
    b7a8:	2f050000 	.word	0x2f050000
    b7ac:	0006e501 	.word	0x0006e501
    b7b0:	00230200 	.word	0x00230200
    b7b4:	004cb415 	.word	0x004cb415
    b7b8:	01300500 	.word	0x01300500
    b7bc:	000006e5 	.word	0x000006e5
    b7c0:	15062302 	.word	0x15062302
    b7c4:	00004ddc 	.word	0x00004ddc
    b7c8:	41013105 	.word	0x41013105
    b7cc:	02000000 	.word	0x02000000
    b7d0:	08000c23 	.word	0x08000c23
    b7d4:	00000041 	.word	0x00000041
    b7d8:	000006f5 	.word	0x000006f5
    b7dc:	0000b509 	.word	0x0000b509
    b7e0:	18000200 	.word	0x18000200
    b7e4:	025f05d0 	.word	0x025f05d0
    b7e8:	00000815 	.word	0x00000815
    b7ec:	004e2015 	.word	0x004e2015
    b7f0:	02600500 	.word	0x02600500
    b7f4:	00000025 	.word	0x00000025
    b7f8:	15002302 	.word	0x15002302
    b7fc:	00004dc6 	.word	0x00004dc6
    b800:	b4026105 	.word	0xb4026105
    b804:	02000005 	.word	0x02000005
    b808:	94150423 	.word	0x94150423
    b80c:	0500004c 	.word	0x0500004c
    b810:	08150262 	.word	0x08150262
    b814:	23020000 	.word	0x23020000
    b818:	4e781508 	.word	0x4e781508
    b81c:	63050000 	.word	0x63050000
    b820:	00017c02 	.word	0x00017c02
    b824:	24230200 	.word	0x24230200
    b828:	004ce615 	.word	0x004ce615
    b82c:	02640500 	.word	0x02640500
    b830:	00000048 	.word	0x00000048
    b834:	15482302 	.word	0x15482302
    b838:	00004d47 	.word	0x00004d47
    b83c:	56026505 	.word	0x56026505
    b840:	02000000 	.word	0x02000000
    b844:	87155023 	.word	0x87155023
    b848:	0500004e 	.word	0x0500004e
    b84c:	06aa0266 	.word	0x06aa0266
    b850:	23020000 	.word	0x23020000
    b854:	4d521558 	.word	0x4d521558
    b858:	67050000 	.word	0x67050000
    b85c:	0000dd02 	.word	0x0000dd02
    b860:	68230200 	.word	0x68230200
    b864:	004e8c15 	.word	0x004e8c15
    b868:	02680500 	.word	0x02680500
    b86c:	000000dd 	.word	0x000000dd
    b870:	15702302 	.word	0x15702302
    b874:	00004b84 	.word	0x00004b84
    b878:	dd026905 	.word	0xdd026905
    b87c:	02000000 	.word	0x02000000
    b880:	4b157823 	.word	0x4b157823
    b884:	0500004e 	.word	0x0500004e
    b888:	0825026a 	.word	0x0825026a
    b88c:	23030000 	.word	0x23030000
    b890:	88150180 	.word	0x88150180
    b894:	0500004c 	.word	0x0500004c
    b898:	0835026b 	.word	0x0835026b
    b89c:	23030000 	.word	0x23030000
    b8a0:	e9150188 	.word	0xe9150188
    b8a4:	0500004d 	.word	0x0500004d
    b8a8:	0048026c 	.word	0x0048026c
    b8ac:	23030000 	.word	0x23030000
    b8b0:	0c1501a0 	.word	0x0c1501a0
    b8b4:	0500004c 	.word	0x0500004c
    b8b8:	00dd026d 	.word	0x00dd026d
    b8bc:	23030000 	.word	0x23030000
    b8c0:	751501a4 	.word	0x751501a4
    b8c4:	0500004b 	.word	0x0500004b
    b8c8:	00dd026e 	.word	0x00dd026e
    b8cc:	23030000 	.word	0x23030000
    b8d0:	fb1501ac 	.word	0xfb1501ac
    b8d4:	0500004b 	.word	0x0500004b
    b8d8:	00dd026f 	.word	0x00dd026f
    b8dc:	23030000 	.word	0x23030000
    b8e0:	4c1501b4 	.word	0x4c1501b4
    b8e4:	0500004b 	.word	0x0500004b
    b8e8:	00dd0270 	.word	0x00dd0270
    b8ec:	23030000 	.word	0x23030000
    b8f0:	5b1501bc 	.word	0x5b1501bc
    b8f4:	0500004b 	.word	0x0500004b
    b8f8:	00dd0271 	.word	0x00dd0271
    b8fc:	23030000 	.word	0x23030000
    b900:	080001c4 	.word	0x080001c4
    b904:	000005ba 	.word	0x000005ba
    b908:	00000825 	.word	0x00000825
    b90c:	0000b509 	.word	0x0000b509
    b910:	08001900 	.word	0x08001900
    b914:	000005ba 	.word	0x000005ba
    b918:	00000835 	.word	0x00000835
    b91c:	0000b509 	.word	0x0000b509
    b920:	08000700 	.word	0x08000700
    b924:	000005ba 	.word	0x000005ba
    b928:	00000845 	.word	0x00000845
    b92c:	0000b509 	.word	0x0000b509
    b930:	18001700 	.word	0x18001700
    b934:	027705f0 	.word	0x027705f0
    b938:	0000086d 	.word	0x0000086d
    b93c:	004ccb15 	.word	0x004ccb15
    b940:	02790500 	.word	0x02790500
    b944:	0000086d 	.word	0x0000086d
    b948:	15002302 	.word	0x15002302
    b94c:	00004e42 	.word	0x00004e42
    b950:	7d027a05 	.word	0x7d027a05
    b954:	02000008 	.word	0x02000008
    b958:	08007823 	.word	0x08007823
    b95c:	000002ee 	.word	0x000002ee
    b960:	0000087d 	.word	0x0000087d
    b964:	0000b509 	.word	0x0000b509
    b968:	08001d00 	.word	0x08001d00
    b96c:	00000025 	.word	0x00000025
    b970:	0000088d 	.word	0x0000088d
    b974:	0000b509 	.word	0x0000b509
    b978:	19001d00 	.word	0x19001d00
    b97c:	025d05f0 	.word	0x025d05f0
    b980:	000008af 	.word	0x000008af
    b984:	004d8b1a 	.word	0x004d8b1a
    b988:	02720500 	.word	0x02720500
    b98c:	000006f5 	.word	0x000006f5
    b990:	004e651a 	.word	0x004e651a
    b994:	027b0500 	.word	0x027b0500
    b998:	00000845 	.word	0x00000845
    b99c:	05ba0800 	.word	0x05ba0800
    b9a0:	08bf0000 	.word	0x08bf0000
    b9a4:	b5090000 	.word	0xb5090000
    b9a8:	18000000 	.word	0x18000000
    b9ac:	cb011b00 	.word	0xcb011b00
    b9b0:	14000008 	.word	0x14000008
    b9b4:	00000451 	.word	0x00000451
    b9b8:	bf041000 	.word	0xbf041000
    b9bc:	10000008 	.word	0x10000008
    b9c0:	00016604 	.word	0x00016604
    b9c4:	e3011b00 	.word	0xe3011b00
    b9c8:	14000008 	.word	0x14000008
    b9cc:	00000048 	.word	0x00000048
    b9d0:	e9041000 	.word	0xe9041000
    b9d4:	10000008 	.word	0x10000008
    b9d8:	0008d704 	.word	0x0008d704
    b9dc:	06570800 	.word	0x06570800
    b9e0:	08ff0000 	.word	0x08ff0000
    b9e4:	b5090000 	.word	0xb5090000
    b9e8:	02000000 	.word	0x02000000
    b9ec:	99011c00 	.word	0x99011c00
    b9f0:	01000002 	.word	0x01000002
    b9f4:	7a80013c 	.word	0x7a80013c
    b9f8:	7ab00800 	.word	0x7ab00800
    b9fc:	5d010800 	.word	0x5d010800
    ba00:	00000926 	.word	0x00000926
    ba04:	004e1b1d 	.word	0x004e1b1d
    ba08:	483a0100 	.word	0x483a0100
    ba0c:	e6000000 	.word	0xe6000000
    ba10:	00000048 	.word	0x00000048
    ba14:	004df61e 	.word	0x004df61e
    ba18:	03280500 	.word	0x03280500
    ba1c:	00000934 	.word	0x00000934
    ba20:	51160101 	.word	0x51160101
    ba24:	00000004 	.word	0x00000004
    ba28:	00000936 	.word	0x00000936
    ba2c:	31e80002 	.word	0x31e80002
    ba30:	01040000 	.word	0x01040000
    ba34:	000001fe 	.word	0x000001fe
    ba38:	004eb501 	.word	0x004eb501
    ba3c:	004ee900 	.word	0x004ee900
	...
    ba48:	002e2f00 	.word	0x002e2f00
    ba4c:	06010200 	.word	0x06010200
    ba50:	0000049e 	.word	0x0000049e
    ba54:	9c080102 	.word	0x9c080102
    ba58:	02000004 	.word	0x02000004
    ba5c:	04ca0502 	.word	0x04ca0502
    ba60:	02020000 	.word	0x02020000
    ba64:	0001c507 	.word	0x0001c507
    ba68:	05040300 	.word	0x05040300
    ba6c:	00746e69 	.word	0x00746e69
    ba70:	35070402 	.word	0x35070402
    ba74:	02000001 	.word	0x02000001
    ba78:	011d0508 	.word	0x011d0508
    ba7c:	08020000 	.word	0x08020000
    ba80:	00012b07 	.word	0x00012b07
    ba84:	4cff0400 	.word	0x4cff0400
    ba88:	07010000 	.word	0x07010000
    ba8c:	00000041 	.word	0x00000041
    ba90:	22050402 	.word	0x22050402
    ba94:	04000001 	.word	0x04000001
    ba98:	00004dae 	.word	0x00004dae
    ba9c:	00682c02 	.word	0x00682c02
    baa0:	a7050000 	.word	0xa7050000
    baa4:	0300004c 	.word	0x0300004c
    baa8:	00480163 	.word	0x00480163
    baac:	04060000 	.word	0x04060000
    bab0:	00a54702 	.word	0x00a54702
    bab4:	a1070000 	.word	0xa1070000
    bab8:	0200004c 	.word	0x0200004c
    babc:	00007a48 	.word	0x00007a48
    bac0:	4c5b0700 	.word	0x4c5b0700
    bac4:	49020000 	.word	0x49020000
    bac8:	000000a5 	.word	0x000000a5
    bacc:	002c0800 	.word	0x002c0800
    bad0:	00b50000 	.word	0x00b50000
    bad4:	b5090000 	.word	0xb5090000
    bad8:	03000000 	.word	0x03000000
    badc:	07040a00 	.word	0x07040a00
    bae0:	4402080b 	.word	0x4402080b
    bae4:	000000dd 	.word	0x000000dd
    bae8:	004d980c 	.word	0x004d980c
    baec:	41450200 	.word	0x41450200
    baf0:	02000000 	.word	0x02000000
    baf4:	a00c0023 	.word	0xa00c0023
    baf8:	0200004d 	.word	0x0200004d
    bafc:	0000864a 	.word	0x0000864a
    bb00:	04230200 	.word	0x04230200
    bb04:	4d340400 	.word	0x4d340400
    bb08:	4b020000 	.word	0x4b020000
    bb0c:	000000b8 	.word	0x000000b8
    bb10:	004c2d04 	.word	0x004c2d04
    bb14:	5d4f0200 	.word	0x5d4f0200
    bb18:	0d000000 	.word	0x0d000000
    bb1c:	4de10404 	.word	0x4de10404
    bb20:	15040000 	.word	0x15040000
    bb24:	00000100 	.word	0x00000100
    bb28:	30070402 	.word	0x30070402
    bb2c:	0e000001 	.word	0x0e000001
    bb30:	00004c3e 	.word	0x00004c3e
    bb34:	662d0418 	.word	0x662d0418
    bb38:	0c000001 	.word	0x0c000001
    bb3c:	00004d4c 	.word	0x00004d4c
    bb40:	01662e04 	.word	0x01662e04
    bb44:	23020000 	.word	0x23020000
    bb48:	6b5f0f00 	.word	0x6b5f0f00
    bb4c:	412f0400 	.word	0x412f0400
    bb50:	02000000 	.word	0x02000000
    bb54:	830c0423 	.word	0x830c0423
    bb58:	0400004d 	.word	0x0400004d
    bb5c:	0000412f 	.word	0x0000412f
    bb60:	08230200 	.word	0x08230200
    bb64:	004c270c 	.word	0x004c270c
    bb68:	412f0400 	.word	0x412f0400
    bb6c:	02000000 	.word	0x02000000
    bb70:	2d0c0c23 	.word	0x2d0c0c23
    bb74:	0400004e 	.word	0x0400004e
    bb78:	0000412f 	.word	0x0000412f
    bb7c:	10230200 	.word	0x10230200
    bb80:	00785f0f 	.word	0x00785f0f
    bb84:	016c3004 	.word	0x016c3004
    bb88:	23020000 	.word	0x23020000
    bb8c:	04100014 	.word	0x04100014
    bb90:	00000107 	.word	0x00000107
    bb94:	0000f508 	.word	0x0000f508
    bb98:	00017c00 	.word	0x00017c00
    bb9c:	00b50900 	.word	0x00b50900
    bba0:	00000000 	.word	0x00000000
    bba4:	004c560e 	.word	0x004c560e
    bba8:	35042400 	.word	0x35042400
    bbac:	00000207 	.word	0x00000207
    bbb0:	004b920c 	.word	0x004b920c
    bbb4:	41360400 	.word	0x41360400
    bbb8:	02000000 	.word	0x02000000
    bbbc:	bd0c0023 	.word	0xbd0c0023
    bbc0:	0400004d 	.word	0x0400004d
    bbc4:	00004137 	.word	0x00004137
    bbc8:	04230200 	.word	0x04230200
    bbcc:	004ba70c 	.word	0x004ba70c
    bbd0:	41380400 	.word	0x41380400
    bbd4:	02000000 	.word	0x02000000
    bbd8:	9f0c0823 	.word	0x9f0c0823
    bbdc:	0400004e 	.word	0x0400004e
    bbe0:	00004139 	.word	0x00004139
    bbe4:	0c230200 	.word	0x0c230200
    bbe8:	004cd20c 	.word	0x004cd20c
    bbec:	413a0400 	.word	0x413a0400
    bbf0:	02000000 	.word	0x02000000
    bbf4:	c10c1023 	.word	0xc10c1023
    bbf8:	0400004c 	.word	0x0400004c
    bbfc:	0000413b 	.word	0x0000413b
    bc00:	14230200 	.word	0x14230200
    bc04:	004e320c 	.word	0x004e320c
    bc08:	413c0400 	.word	0x413c0400
    bc0c:	02000000 	.word	0x02000000
    bc10:	160c1823 	.word	0x160c1823
    bc14:	0400004d 	.word	0x0400004d
    bc18:	0000413d 	.word	0x0000413d
    bc1c:	1c230200 	.word	0x1c230200
    bc20:	004e6d0c 	.word	0x004e6d0c
    bc24:	413e0400 	.word	0x413e0400
    bc28:	02000000 	.word	0x02000000
    bc2c:	11002023 	.word	0x11002023
    bc30:	00004bb6 	.word	0x00004bb6
    bc34:	47040108 	.word	0x47040108
    bc38:	00000250 	.word	0x00000250
    bc3c:	004c1a0c 	.word	0x004c1a0c
    bc40:	50480400 	.word	0x50480400
    bc44:	02000002 	.word	0x02000002
    bc48:	f40c0023 	.word	0xf40c0023
    bc4c:	0400004a 	.word	0x0400004a
    bc50:	00025049 	.word	0x00025049
    bc54:	80230300 	.word	0x80230300
    bc58:	4dd30c01 	.word	0x4dd30c01
    bc5c:	4b040000 	.word	0x4b040000
    bc60:	000000f5 	.word	0x000000f5
    bc64:	02802303 	.word	0x02802303
    bc68:	004bdb0c 	.word	0x004bdb0c
    bc6c:	f54e0400 	.word	0xf54e0400
    bc70:	03000000 	.word	0x03000000
    bc74:	00028423 	.word	0x00028423
    bc78:	0000f308 	.word	0x0000f308
    bc7c:	00026000 	.word	0x00026000
    bc80:	00b50900 	.word	0x00b50900
    bc84:	001f0000 	.word	0x001f0000
    bc88:	004aec11 	.word	0x004aec11
    bc8c:	04019000 	.word	0x04019000
    bc90:	0002a759 	.word	0x0002a759
    bc94:	4d4c0c00 	.word	0x4d4c0c00
    bc98:	5a040000 	.word	0x5a040000
    bc9c:	000002a7 	.word	0x000002a7
    bca0:	0c002302 	.word	0x0c002302
    bca4:	00004d64 	.word	0x00004d64
    bca8:	00415b04 	.word	0x00415b04
    bcac:	23020000 	.word	0x23020000
    bcb0:	4c220c04 	.word	0x4c220c04
    bcb4:	5d040000 	.word	0x5d040000
    bcb8:	000002ad 	.word	0x000002ad
    bcbc:	0c082302 	.word	0x0c082302
    bcc0:	00004bb6 	.word	0x00004bb6
    bcc4:	02075e04 	.word	0x02075e04
    bcc8:	23030000 	.word	0x23030000
    bccc:	10000188 	.word	0x10000188
    bcd0:	00026004 	.word	0x00026004
    bcd4:	02bf0800 	.word	0x02bf0800
    bcd8:	02bd0000 	.word	0x02bd0000
    bcdc:	b5090000 	.word	0xb5090000
    bce0:	1f000000 	.word	0x1f000000
    bce4:	10011200 	.word	0x10011200
    bce8:	0002bd04 	.word	0x0002bd04
    bcec:	4d200e00 	.word	0x4d200e00
    bcf0:	04080000 	.word	0x04080000
    bcf4:	0002ee69 	.word	0x0002ee69
    bcf8:	4ba10c00 	.word	0x4ba10c00
    bcfc:	6a040000 	.word	0x6a040000
    bd00:	000002ee 	.word	0x000002ee
    bd04:	0c002302 	.word	0x0c002302
    bd08:	00004b33 	.word	0x00004b33
    bd0c:	00416b04 	.word	0x00416b04
    bd10:	23020000 	.word	0x23020000
    bd14:	04100004 	.word	0x04100004
    bd18:	0000002c 	.word	0x0000002c
    bd1c:	004d3f0e 	.word	0x004d3f0e
    bd20:	a9045c00 	.word	0xa9045c00
    bd24:	00000432 	.word	0x00000432
    bd28:	00705f0f 	.word	0x00705f0f
    bd2c:	02eeaa04 	.word	0x02eeaa04
    bd30:	23020000 	.word	0x23020000
    bd34:	725f0f00 	.word	0x725f0f00
    bd38:	41ab0400 	.word	0x41ab0400
    bd3c:	02000000 	.word	0x02000000
    bd40:	5f0f0423 	.word	0x5f0f0423
    bd44:	ac040077 	.word	0xac040077
    bd48:	00000041 	.word	0x00000041
    bd4c:	0c082302 	.word	0x0c082302
    bd50:	00004bd4 	.word	0x00004bd4
    bd54:	0033ad04 	.word	0x0033ad04
    bd58:	23020000 	.word	0x23020000
    bd5c:	4c720c0c 	.word	0x4c720c0c
    bd60:	ae040000 	.word	0xae040000
    bd64:	00000033 	.word	0x00000033
    bd68:	0f0e2302 	.word	0x0f0e2302
    bd6c:	0066625f 	.word	0x0066625f
    bd70:	02c5af04 	.word	0x02c5af04
    bd74:	23020000 	.word	0x23020000
    bd78:	4b6c0c10 	.word	0x4b6c0c10
    bd7c:	b0040000 	.word	0xb0040000
    bd80:	00000041 	.word	0x00000041
    bd84:	0c182302 	.word	0x0c182302
    bd88:	00004bc4 	.word	0x00004bc4
    bd8c:	00f3b704 	.word	0x00f3b704
    bd90:	23020000 	.word	0x23020000
    bd94:	4c460c1c 	.word	0x4c460c1c
    bd98:	b9040000 	.word	0xb9040000
    bd9c:	000005c1 	.word	0x000005c1
    bda0:	0c202302 	.word	0x0c202302
    bda4:	00004cba 	.word	0x00004cba
    bda8:	05f1bb04 	.word	0x05f1bb04
    bdac:	23020000 	.word	0x23020000
    bdb0:	4da80c24 	.word	0x4da80c24
    bdb4:	bd040000 	.word	0xbd040000
    bdb8:	00000616 	.word	0x00000616
    bdbc:	0c282302 	.word	0x0c282302
    bdc0:	0000310e 	.word	0x0000310e
    bdc4:	0631be04 	.word	0x0631be04
    bdc8:	23020000 	.word	0x23020000
    bdcc:	755f0f2c 	.word	0x755f0f2c
    bdd0:	c1040062 	.word	0xc1040062
    bdd4:	000002c5 	.word	0x000002c5
    bdd8:	0f302302 	.word	0x0f302302
    bddc:	0070755f 	.word	0x0070755f
    bde0:	02eec204 	.word	0x02eec204
    bde4:	23020000 	.word	0x23020000
    bde8:	755f0f38 	.word	0x755f0f38
    bdec:	c3040072 	.word	0xc3040072
    bdf0:	00000041 	.word	0x00000041
    bdf4:	0c3c2302 	.word	0x0c3c2302
    bdf8:	00004b9b 	.word	0x00004b9b
    bdfc:	0637c604 	.word	0x0637c604
    be00:	23020000 	.word	0x23020000
    be04:	4e5f0c40 	.word	0x4e5f0c40
    be08:	c7040000 	.word	0xc7040000
    be0c:	00000647 	.word	0x00000647
    be10:	0f432302 	.word	0x0f432302
    be14:	00626c5f 	.word	0x00626c5f
    be18:	02c5ca04 	.word	0x02c5ca04
    be1c:	23020000 	.word	0x23020000
    be20:	4bea0c44 	.word	0x4bea0c44
    be24:	cd040000 	.word	0xcd040000
    be28:	00000041 	.word	0x00000041
    be2c:	0c4c2302 	.word	0x0c4c2302
    be30:	0000288d 	.word	0x0000288d
    be34:	0041ce04 	.word	0x0041ce04
    be38:	23020000 	.word	0x23020000
    be3c:	4eaf0c50 	.word	0x4eaf0c50
    be40:	d1040000 	.word	0xd1040000
    be44:	00000451 	.word	0x00000451
    be48:	0c542302 	.word	0x0c542302
    be4c:	00004cae 	.word	0x00004cae
    be50:	00e8d504 	.word	0x00e8d504
    be54:	23020000 	.word	0x23020000
    be58:	01130058 	.word	0x01130058
    be5c:	00000041 	.word	0x00000041
    be60:	00000451 	.word	0x00000451
    be64:	00045114 	.word	0x00045114
    be68:	00f31400 	.word	0x00f31400
    be6c:	b4140000 	.word	0xb4140000
    be70:	14000005 	.word	0x14000005
    be74:	00000041 	.word	0x00000041
    be78:	57041000 	.word	0x57041000
    be7c:	11000004 	.word	0x11000004
    be80:	00004d8b 	.word	0x00004d8b
    be84:	25040400 	.word	0x25040400
    be88:	000005b4 	.word	0x000005b4
    be8c:	004db615 	.word	0x004db615
    be90:	02410400 	.word	0x02410400
    be94:	00000041 	.word	0x00000041
    be98:	15002302 	.word	0x15002302
    be9c:	00004be3 	.word	0x00004be3
    bea0:	a4024604 	.word	0xa4024604
    bea4:	02000006 	.word	0x02000006
    bea8:	62150423 	.word	0x62150423
    beac:	0400004c 	.word	0x0400004c
    beb0:	06a40246 	.word	0x06a40246
    beb4:	23020000 	.word	0x23020000
    beb8:	4c361508 	.word	0x4c361508
    bebc:	46040000 	.word	0x46040000
    bec0:	0006a402 	.word	0x0006a402
    bec4:	0c230200 	.word	0x0c230200
    bec8:	004d5f15 	.word	0x004d5f15
    becc:	02480400 	.word	0x02480400
    bed0:	00000041 	.word	0x00000041
    bed4:	15102302 	.word	0x15102302
    bed8:	00004b41 	.word	0x00004b41
    bedc:	af024904 	.word	0xaf024904
    bee0:	02000008 	.word	0x02000008
    bee4:	09151423 	.word	0x09151423
    bee8:	0400004e 	.word	0x0400004e
    beec:	0041024b 	.word	0x0041024b
    bef0:	23020000 	.word	0x23020000
    bef4:	4d691530 	.word	0x4d691530
    bef8:	4c040000 	.word	0x4c040000
    befc:	0005e602 	.word	0x0005e602
    bf00:	34230200 	.word	0x34230200
    bf04:	004cdb15 	.word	0x004cdb15
    bf08:	024e0400 	.word	0x024e0400
    bf0c:	00000041 	.word	0x00000041
    bf10:	15382302 	.word	0x15382302
    bf14:	00004d79 	.word	0x00004d79
    bf18:	cb025004 	.word	0xcb025004
    bf1c:	02000008 	.word	0x02000008
    bf20:	b9153c23 	.word	0xb9153c23
    bf24:	0400001d 	.word	0x0400001d
    bf28:	01660253 	.word	0x01660253
    bf2c:	23020000 	.word	0x23020000
    bf30:	4c4c1540 	.word	0x4c4c1540
    bf34:	54040000 	.word	0x54040000
    bf38:	00004102 	.word	0x00004102
    bf3c:	44230200 	.word	0x44230200
    bf40:	004e9a15 	.word	0x004e9a15
    bf44:	02550400 	.word	0x02550400
    bf48:	00000166 	.word	0x00000166
    bf4c:	15482302 	.word	0x15482302
    bf50:	00004cf5 	.word	0x00004cf5
    bf54:	d1025604 	.word	0xd1025604
    bf58:	02000008 	.word	0x02000008
    bf5c:	6a154c23 	.word	0x6a154c23
    bf60:	0400004c 	.word	0x0400004c
    bf64:	00410259 	.word	0x00410259
    bf68:	23020000 	.word	0x23020000
    bf6c:	4bf31550 	.word	0x4bf31550
    bf70:	5a040000 	.word	0x5a040000
    bf74:	0005b402 	.word	0x0005b402
    bf78:	54230200 	.word	0x54230200
    bf7c:	004d1115 	.word	0x004d1115
    bf80:	027c0400 	.word	0x027c0400
    bf84:	0000088d 	.word	0x0000088d
    bf88:	15582302 	.word	0x15582302
    bf8c:	00004aec 	.word	0x00004aec
    bf90:	a7027f04 	.word	0xa7027f04
    bf94:	03000002 	.word	0x03000002
    bf98:	1502c823 	.word	0x1502c823
    bf9c:	00004c7f 	.word	0x00004c7f
    bfa0:	60028004 	.word	0x60028004
    bfa4:	03000002 	.word	0x03000002
    bfa8:	1502cc23 	.word	0x1502cc23
    bfac:	00004e55 	.word	0x00004e55
    bfb0:	e3028304 	.word	0xe3028304
    bfb4:	03000008 	.word	0x03000008
    bfb8:	1505dc23 	.word	0x1505dc23
    bfbc:	00004bcc 	.word	0x00004bcc
    bfc0:	63028804 	.word	0x63028804
    bfc4:	03000006 	.word	0x03000006
    bfc8:	1505e023 	.word	0x1505e023
    bfcc:	00004bb1 	.word	0x00004bb1
    bfd0:	ef028904 	.word	0xef028904
    bfd4:	03000008 	.word	0x03000008
    bfd8:	0005ec23 	.word	0x0005ec23
    bfdc:	05ba0410 	.word	0x05ba0410
    bfe0:	01020000 	.word	0x01020000
    bfe4:	0004a508 	.word	0x0004a508
    bfe8:	32041000 	.word	0x32041000
    bfec:	13000004 	.word	0x13000004
    bff0:	00004101 	.word	0x00004101
    bff4:	0005e600 	.word	0x0005e600
    bff8:	04511400 	.word	0x04511400
    bffc:	f3140000 	.word	0xf3140000
    c000:	14000000 	.word	0x14000000
    c004:	000005e6 	.word	0x000005e6
    c008:	00004114 	.word	0x00004114
    c00c:	04100000 	.word	0x04100000
    c010:	000005ec 	.word	0x000005ec
    c014:	0005ba16 	.word	0x0005ba16
    c018:	c7041000 	.word	0xc7041000
    c01c:	13000005 	.word	0x13000005
    c020:	00006f01 	.word	0x00006f01
    c024:	00061600 	.word	0x00061600
    c028:	04511400 	.word	0x04511400
    c02c:	f3140000 	.word	0xf3140000
    c030:	14000000 	.word	0x14000000
    c034:	0000006f 	.word	0x0000006f
    c038:	00004114 	.word	0x00004114
    c03c:	04100000 	.word	0x04100000
    c040:	000005f7 	.word	0x000005f7
    c044:	00410113 	.word	0x00410113
    c048:	06310000 	.word	0x06310000
    c04c:	51140000 	.word	0x51140000
    c050:	14000004 	.word	0x14000004
    c054:	000000f3 	.word	0x000000f3
    c058:	1c041000 	.word	0x1c041000
    c05c:	08000006 	.word	0x08000006
    c060:	0000002c 	.word	0x0000002c
    c064:	00000647 	.word	0x00000647
    c068:	0000b509 	.word	0x0000b509
    c06c:	08000200 	.word	0x08000200
    c070:	0000002c 	.word	0x0000002c
    c074:	00000657 	.word	0x00000657
    c078:	0000b509 	.word	0x0000b509
    c07c:	05000000 	.word	0x05000000
    c080:	00004d2d 	.word	0x00004d2d
    c084:	f4010e04 	.word	0xf4010e04
    c088:	17000002 	.word	0x17000002
    c08c:	00004e3c 	.word	0x00004e3c
    c090:	0113040c 	.word	0x0113040c
    c094:	0000069e 	.word	0x0000069e
    c098:	004d4c15 	.word	0x004d4c15
    c09c:	01140400 	.word	0x01140400
    c0a0:	0000069e 	.word	0x0000069e
    c0a4:	15002302 	.word	0x15002302
    c0a8:	00004c78 	.word	0x00004c78
    c0ac:	41011504 	.word	0x41011504
    c0b0:	02000000 	.word	0x02000000
    c0b4:	27150423 	.word	0x27150423
    c0b8:	0400004d 	.word	0x0400004d
    c0bc:	06a40116 	.word	0x06a40116
    c0c0:	23020000 	.word	0x23020000
    c0c4:	04100008 	.word	0x04100008
    c0c8:	00000663 	.word	0x00000663
    c0cc:	06570410 	.word	0x06570410
    c0d0:	39170000 	.word	0x39170000
    c0d4:	0e00004b 	.word	0x0e00004b
    c0d8:	e5012e04 	.word	0xe5012e04
    c0dc:	15000006 	.word	0x15000006
    c0e0:	00004d92 	.word	0x00004d92
    c0e4:	e5012f04 	.word	0xe5012f04
    c0e8:	02000006 	.word	0x02000006
    c0ec:	b4150023 	.word	0xb4150023
    c0f0:	0400004c 	.word	0x0400004c
    c0f4:	06e50130 	.word	0x06e50130
    c0f8:	23020000 	.word	0x23020000
    c0fc:	4ddc1506 	.word	0x4ddc1506
    c100:	31040000 	.word	0x31040000
    c104:	00003a01 	.word	0x00003a01
    c108:	0c230200 	.word	0x0c230200
    c10c:	003a0800 	.word	0x003a0800
    c110:	06f50000 	.word	0x06f50000
    c114:	b5090000 	.word	0xb5090000
    c118:	02000000 	.word	0x02000000
    c11c:	04d01800 	.word	0x04d01800
    c120:	0815025f 	.word	0x0815025f
    c124:	20150000 	.word	0x20150000
    c128:	0400004e 	.word	0x0400004e
    c12c:	00480260 	.word	0x00480260
    c130:	23020000 	.word	0x23020000
    c134:	4dc61500 	.word	0x4dc61500
    c138:	61040000 	.word	0x61040000
    c13c:	0005b402 	.word	0x0005b402
    c140:	04230200 	.word	0x04230200
    c144:	004c9415 	.word	0x004c9415
    c148:	02620400 	.word	0x02620400
    c14c:	00000815 	.word	0x00000815
    c150:	15082302 	.word	0x15082302
    c154:	00004e78 	.word	0x00004e78
    c158:	7c026304 	.word	0x7c026304
    c15c:	02000001 	.word	0x02000001
    c160:	e6152423 	.word	0xe6152423
    c164:	0400004c 	.word	0x0400004c
    c168:	00410264 	.word	0x00410264
    c16c:	23020000 	.word	0x23020000
    c170:	4d471548 	.word	0x4d471548
    c174:	65040000 	.word	0x65040000
    c178:	00005602 	.word	0x00005602
    c17c:	50230200 	.word	0x50230200
    c180:	004e8715 	.word	0x004e8715
    c184:	02660400 	.word	0x02660400
    c188:	000006aa 	.word	0x000006aa
    c18c:	15582302 	.word	0x15582302
    c190:	00004d52 	.word	0x00004d52
    c194:	dd026704 	.word	0xdd026704
    c198:	02000000 	.word	0x02000000
    c19c:	8c156823 	.word	0x8c156823
    c1a0:	0400004e 	.word	0x0400004e
    c1a4:	00dd0268 	.word	0x00dd0268
    c1a8:	23020000 	.word	0x23020000
    c1ac:	4b841570 	.word	0x4b841570
    c1b0:	69040000 	.word	0x69040000
    c1b4:	0000dd02 	.word	0x0000dd02
    c1b8:	78230200 	.word	0x78230200
    c1bc:	004e4b15 	.word	0x004e4b15
    c1c0:	026a0400 	.word	0x026a0400
    c1c4:	00000825 	.word	0x00000825
    c1c8:	01802303 	.word	0x01802303
    c1cc:	004c8815 	.word	0x004c8815
    c1d0:	026b0400 	.word	0x026b0400
    c1d4:	00000835 	.word	0x00000835
    c1d8:	01882303 	.word	0x01882303
    c1dc:	004de915 	.word	0x004de915
    c1e0:	026c0400 	.word	0x026c0400
    c1e4:	00000041 	.word	0x00000041
    c1e8:	01a02303 	.word	0x01a02303
    c1ec:	004c0c15 	.word	0x004c0c15
    c1f0:	026d0400 	.word	0x026d0400
    c1f4:	000000dd 	.word	0x000000dd
    c1f8:	01a42303 	.word	0x01a42303
    c1fc:	004b7515 	.word	0x004b7515
    c200:	026e0400 	.word	0x026e0400
    c204:	000000dd 	.word	0x000000dd
    c208:	01ac2303 	.word	0x01ac2303
    c20c:	004bfb15 	.word	0x004bfb15
    c210:	026f0400 	.word	0x026f0400
    c214:	000000dd 	.word	0x000000dd
    c218:	01b42303 	.word	0x01b42303
    c21c:	004b4c15 	.word	0x004b4c15
    c220:	02700400 	.word	0x02700400
    c224:	000000dd 	.word	0x000000dd
    c228:	01bc2303 	.word	0x01bc2303
    c22c:	004b5b15 	.word	0x004b5b15
    c230:	02710400 	.word	0x02710400
    c234:	000000dd 	.word	0x000000dd
    c238:	01c42303 	.word	0x01c42303
    c23c:	05ba0800 	.word	0x05ba0800
    c240:	08250000 	.word	0x08250000
    c244:	b5090000 	.word	0xb5090000
    c248:	19000000 	.word	0x19000000
    c24c:	05ba0800 	.word	0x05ba0800
    c250:	08350000 	.word	0x08350000
    c254:	b5090000 	.word	0xb5090000
    c258:	07000000 	.word	0x07000000
    c25c:	05ba0800 	.word	0x05ba0800
    c260:	08450000 	.word	0x08450000
    c264:	b5090000 	.word	0xb5090000
    c268:	17000000 	.word	0x17000000
    c26c:	04f01800 	.word	0x04f01800
    c270:	086d0277 	.word	0x086d0277
    c274:	cb150000 	.word	0xcb150000
    c278:	0400004c 	.word	0x0400004c
    c27c:	086d0279 	.word	0x086d0279
    c280:	23020000 	.word	0x23020000
    c284:	4e421500 	.word	0x4e421500
    c288:	7a040000 	.word	0x7a040000
    c28c:	00087d02 	.word	0x00087d02
    c290:	78230200 	.word	0x78230200
    c294:	02ee0800 	.word	0x02ee0800
    c298:	087d0000 	.word	0x087d0000
    c29c:	b5090000 	.word	0xb5090000
    c2a0:	1d000000 	.word	0x1d000000
    c2a4:	00480800 	.word	0x00480800
    c2a8:	088d0000 	.word	0x088d0000
    c2ac:	b5090000 	.word	0xb5090000
    c2b0:	1d000000 	.word	0x1d000000
    c2b4:	04f01900 	.word	0x04f01900
    c2b8:	08af025d 	.word	0x08af025d
    c2bc:	8b1a0000 	.word	0x8b1a0000
    c2c0:	0400004d 	.word	0x0400004d
    c2c4:	06f50272 	.word	0x06f50272
    c2c8:	651a0000 	.word	0x651a0000
    c2cc:	0400004e 	.word	0x0400004e
    c2d0:	0845027b 	.word	0x0845027b
    c2d4:	08000000 	.word	0x08000000
    c2d8:	000005ba 	.word	0x000005ba
    c2dc:	000008bf 	.word	0x000008bf
    c2e0:	0000b509 	.word	0x0000b509
    c2e4:	1b001800 	.word	0x1b001800
    c2e8:	0008cb01 	.word	0x0008cb01
    c2ec:	04511400 	.word	0x04511400
    c2f0:	10000000 	.word	0x10000000
    c2f4:	0008bf04 	.word	0x0008bf04
    c2f8:	66041000 	.word	0x66041000
    c2fc:	1b000001 	.word	0x1b000001
    c300:	0008e301 	.word	0x0008e301
    c304:	00411400 	.word	0x00411400
    c308:	10000000 	.word	0x10000000
    c30c:	0008e904 	.word	0x0008e904
    c310:	d7041000 	.word	0xd7041000
    c314:	08000008 	.word	0x08000008
    c318:	00000657 	.word	0x00000657
    c31c:	000008ff 	.word	0x000008ff
    c320:	0000b509 	.word	0x0000b509
    c324:	1c000200 	.word	0x1c000200
    c328:	00004ea9 	.word	0x00004ea9
    c32c:	04570c05 	.word	0x04570c05
    c330:	03050000 	.word	0x03050000
    c334:	200000e0 	.word	0x200000e0
    c338:	004dfd1d 	.word	0x004dfd1d
    c33c:	51100500 	.word	0x51100500
    c340:	01000004 	.word	0x01000004
    c344:	00d80305 	.word	0x00d80305
    c348:	f61d2000 	.word	0xf61d2000
    c34c:	0500004d 	.word	0x0500004d
    c350:	00093411 	.word	0x00093411
    c354:	03050100 	.word	0x03050100
    c358:	08007c8c 	.word	0x08007c8c
    c35c:	00045116 	.word	0x00045116
    c360:	01420000 	.word	0x01420000
    c364:	00020000 	.word	0x00020000
    c368:	00003348 	.word	0x00003348
    c36c:	01fe0104 	.word	0x01fe0104
    c370:	5e010000 	.word	0x5e010000
    c374:	b200004f 	.word	0xb200004f
    c378:	0000004f 	.word	0x0000004f
    c37c:	00000000 	.word	0x00000000
    c380:	0a000000 	.word	0x0a000000
    c384:	0200002f 	.word	0x0200002f
    c388:	049e0601 	.word	0x049e0601
    c38c:	01020000 	.word	0x01020000
    c390:	00049c08 	.word	0x00049c08
    c394:	05020200 	.word	0x05020200
    c398:	000004ca 	.word	0x000004ca
    c39c:	c5070202 	.word	0xc5070202
    c3a0:	03000001 	.word	0x03000001
    c3a4:	6e690504 	.word	0x6e690504
    c3a8:	04020074 	.word	0x04020074
    c3ac:	00013507 	.word	0x00013507
    c3b0:	05080200 	.word	0x05080200
    c3b4:	0000011d 	.word	0x0000011d
    c3b8:	2b070802 	.word	0x2b070802
    c3bc:	02000001 	.word	0x02000001
    c3c0:	01220504 	.word	0x01220504
    c3c4:	04040000 	.word	0x04040000
    c3c8:	4f320507 	.word	0x4f320507
    c3cc:	d6020000 	.word	0xd6020000
    c3d0:	00000048 	.word	0x00000048
    c3d4:	30070402 	.word	0x30070402
    c3d8:	02000001 	.word	0x02000001
    c3dc:	04a50801 	.word	0x04a50801
    c3e0:	01060000 	.word	0x01060000
    c3e4:	00004fe7 	.word	0x00004fe7
    c3e8:	00013201 	.word	0x00013201
    c3ec:	00000000 	.word	0x00000000
    c3f0:	04000000 	.word	0x04000000
    c3f4:	b2000049 	.word	0xb2000049
    c3f8:	07000000 	.word	0x07000000
    c3fc:	00004d9a 	.word	0x00004d9a
    c400:	00673301 	.word	0x00673301
    c404:	55010000 	.word	0x55010000
    c408:	01006908 	.word	0x01006908
    c40c:	00006734 	.word	0x00006734
    c410:	00540100 	.word	0x00540100
    c414:	4fa00106 	.word	0x4fa00106
    c418:	20010000 	.word	0x20010000
    c41c:	00000001 	.word	0x00000001
    c420:	00000000 	.word	0x00000000
    c424:	00492300 	.word	0x00492300
    c428:	0000e400 	.word	0x0000e400
    c42c:	4d9a0700 	.word	0x4d9a0700
    c430:	21010000 	.word	0x21010000
    c434:	00000067 	.word	0x00000067
    c438:	69085501 	.word	0x69085501
    c43c:	67220100 	.word	0x67220100
    c440:	01000000 	.word	0x01000000
    c444:	f1090054 	.word	0xf1090054
    c448:	ef000000 	.word	0xef000000
    c44c:	0a000000 	.word	0x0a000000
    c450:	0c010b00 	.word	0x0c010b00
    c454:	0000ef04 	.word	0x0000ef04
    c458:	4ff90d00 	.word	0x4ff90d00
    c45c:	13010000 	.word	0x13010000
    c460:	000000e4 	.word	0x000000e4
    c464:	4a0d0101 	.word	0x4a0d0101
    c468:	0100004f 	.word	0x0100004f
    c46c:	0000e414 	.word	0x0000e414
    c470:	0d010100 	.word	0x0d010100
    c474:	0000500f 	.word	0x0000500f
    c478:	00e41501 	.word	0x00e41501
    c47c:	01010000 	.word	0x01010000
    c480:	004f8f0d 	.word	0x004f8f0d
    c484:	e4160100 	.word	0xe4160100
    c488:	01000000 	.word	0x01000000
    c48c:	4f1f0d01 	.word	0x4f1f0d01
    c490:	17010000 	.word	0x17010000
    c494:	000000e4 	.word	0x000000e4
    c498:	390d0101 	.word	0x390d0101
    c49c:	0100004f 	.word	0x0100004f
    c4a0:	0000e418 	.word	0x0000e418
    c4a4:	00010100 	.word	0x00010100
    c4a8:	0000010a 	.word	0x0000010a
    c4ac:	33ec0002 	.word	0x33ec0002
    c4b0:	01040000 	.word	0x01040000
    c4b4:	000001fe 	.word	0x000001fe
    c4b8:	00508701 	.word	0x00508701
    c4bc:	00504400 	.word	0x00504400
	...
    c4c8:	002fb000 	.word	0x002fb000
    c4cc:	05040200 	.word	0x05040200
    c4d0:	00746e69 	.word	0x00746e69
    c4d4:	004f3203 	.word	0x004f3203
    c4d8:	37d60200 	.word	0x37d60200
    c4dc:	04000000 	.word	0x04000000
    c4e0:	01350704 	.word	0x01350704
    c4e4:	01050000 	.word	0x01050000
    c4e8:	0000507b 	.word	0x0000507b
    c4ec:	d4013901 	.word	0xd4013901
	...
    c4f8:	42000000 	.word	0x42000000
    c4fc:	d4000049 	.word	0xd4000049
    c500:	06000000 	.word	0x06000000
    c504:	0000503f 	.word	0x0000503f
    c508:	00d43501 	.word	0x00d43501
    c50c:	49610000 	.word	0x49610000
    c510:	2e060000 	.word	0x2e060000
    c514:	01000050 	.word	0x01000050
    c518:	0000d635 	.word	0x0000d635
    c51c:	00497f00 	.word	0x00497f00
    c520:	50820600 	.word	0x50820600
    c524:	35010000 	.word	0x35010000
    c528:	0000002c 	.word	0x0000002c
    c52c:	0000499d 	.word	0x0000499d
    c530:	74736407 	.word	0x74736407
    c534:	dd470100 	.word	0xdd470100
    c538:	c6000000 	.word	0xc6000000
    c53c:	07000049 	.word	0x07000049
    c540:	00637273 	.word	0x00637273
    c544:	00ea4801 	.word	0x00ea4801
    c548:	49d90000 	.word	0x49d90000
    c54c:	33080000 	.word	0x33080000
    c550:	01000050 	.word	0x01000050
    c554:	0000f549 	.word	0x0000f549
    c558:	0049f700 	.word	0x0049f700
    c55c:	50220800 	.word	0x50220800
    c560:	4a010000 	.word	0x4a010000
    c564:	00000102 	.word	0x00000102
    c568:	00004a20 	.word	0x00004a20
    c56c:	6e656c07 	.word	0x6e656c07
    c570:	254b0100 	.word	0x254b0100
    c574:	49000000 	.word	0x49000000
    c578:	0000004a 	.word	0x0000004a
    c57c:	040a0409 	.word	0x040a0409
    c580:	000000dc 	.word	0x000000dc
    c584:	e3040a0b 	.word	0xe3040a0b
    c588:	04000000 	.word	0x04000000
    c58c:	04a50801 	.word	0x04a50801
    c590:	040a0000 	.word	0x040a0000
    c594:	000000f0 	.word	0x000000f0
    c598:	0000e30c 	.word	0x0000e30c
    c59c:	fb040a00 	.word	0xfb040a00
    c5a0:	04000000 	.word	0x04000000
    c5a4:	01220504 	.word	0x01220504
    c5a8:	040a0000 	.word	0x040a0000
    c5ac:	00000108 	.word	0x00000108
    c5b0:	0000fb0c 	.word	0x0000fb0c
    c5b4:	010f0000 	.word	0x010f0000
    c5b8:	00020000 	.word	0x00020000
    c5bc:	00003485 	.word	0x00003485
    c5c0:	01fe0104 	.word	0x01fe0104
    c5c4:	c9010000 	.word	0xc9010000
    c5c8:	44000050 	.word	0x44000050
    c5cc:	00000050 	.word	0x00000050
    c5d0:	00000000 	.word	0x00000000
    c5d4:	85000000 	.word	0x85000000
    c5d8:	02000030 	.word	0x02000030
    c5dc:	049e0601 	.word	0x049e0601
    c5e0:	01020000 	.word	0x01020000
    c5e4:	00049c08 	.word	0x00049c08
    c5e8:	05020200 	.word	0x05020200
    c5ec:	000004ca 	.word	0x000004ca
    c5f0:	c5070202 	.word	0xc5070202
    c5f4:	03000001 	.word	0x03000001
    c5f8:	6e690504 	.word	0x6e690504
    c5fc:	04020074 	.word	0x04020074
    c600:	00013507 	.word	0x00013507
    c604:	05080200 	.word	0x05080200
    c608:	0000011d 	.word	0x0000011d
    c60c:	2b070802 	.word	0x2b070802
    c610:	02000001 	.word	0x02000001
    c614:	01220504 	.word	0x01220504
    c618:	04040000 	.word	0x04040000
    c61c:	02040507 	.word	0x02040507
    c620:	01300704 	.word	0x01300704
    c624:	04060000 	.word	0x04060000
    c628:	00000076 	.word	0x00000076
    c62c:	a5080102 	.word	0xa5080102
    c630:	07000004 	.word	0x07000004
    c634:	00004f32 	.word	0x00004f32
    c638:	0048d602 	.word	0x0048d602
    c63c:	01080000 	.word	0x01080000
    c640:	000050fe 	.word	0x000050fe
    c644:	67012f01 	.word	0x67012f01
	...
    c650:	72000000 	.word	0x72000000
    c654:	0c00004a 	.word	0x0c00004a
    c658:	09000001 	.word	0x09000001
    c65c:	2b01006d 	.word	0x2b01006d
    c660:	00000067 	.word	0x00000067
    c664:	00004a91 	.word	0x00004a91
    c668:	01006309 	.word	0x01006309
    c66c:	0000412b 	.word	0x0000412b
    c670:	004ac500 	.word	0x004ac500
    c674:	006e0900 	.word	0x006e0900
    c678:	007d2b01 	.word	0x007d2b01
    c67c:	4aee0000 	.word	0x4aee0000
    c680:	730a0000 	.word	0x730a0000
    c684:	703a0100 	.word	0x703a0100
    c688:	22000000 	.word	0x22000000
    c68c:	0b00004b 	.word	0x0b00004b
    c690:	3b010069 	.word	0x3b010069
    c694:	00000041 	.word	0x00000041
    c698:	0051050c 	.word	0x0051050c
    c69c:	693c0100 	.word	0x693c0100
    c6a0:	40000000 	.word	0x40000000
    c6a4:	0c00004b 	.word	0x0c00004b
    c6a8:	000050bc 	.word	0x000050bc
    c6ac:	010c3d01 	.word	0x010c3d01
    c6b0:	4b690000 	.word	0x4b690000
    c6b4:	640d0000 	.word	0x640d0000
    c6b8:	483e0100 	.word	0x483e0100
    c6bc:	01000000 	.word	0x01000000
    c6c0:	04060055 	.word	0x04060055
    c6c4:	00000069 	.word	0x00000069
    c6c8:	0009a100 	.word	0x0009a100
    c6cc:	37000200 	.word	0x37000200
    c6d0:	04000035 	.word	0x04000035
    c6d4:	0001fe01 	.word	0x0001fe01
    c6d8:	510c0100 	.word	0x510c0100
    c6dc:	4a580000 	.word	0x4a580000
	...
    c6e8:	31610000 	.word	0x31610000
    c6ec:	04020000 	.word	0x04020000
    c6f0:	746e6905 	.word	0x746e6905
    c6f4:	07040300 	.word	0x07040300
    c6f8:	00000135 	.word	0x00000135
    c6fc:	9e060103 	.word	0x9e060103
    c700:	03000004 	.word	0x03000004
    c704:	049c0801 	.word	0x049c0801
    c708:	02030000 	.word	0x02030000
    c70c:	0004ca05 	.word	0x0004ca05
    c710:	07020300 	.word	0x07020300
    c714:	000001c5 	.word	0x000001c5
    c718:	1d050803 	.word	0x1d050803
    c71c:	03000001 	.word	0x03000001
    c720:	012b0708 	.word	0x012b0708
    c724:	ff040000 	.word	0xff040000
    c728:	0200004c 	.word	0x0200004c
    c72c:	00002507 	.word	0x00002507
    c730:	05040300 	.word	0x05040300
    c734:	00000122 	.word	0x00000122
    c738:	004dae04 	.word	0x004dae04
    c73c:	682c0300 	.word	0x682c0300
    c740:	05000000 	.word	0x05000000
    c744:	00004ca7 	.word	0x00004ca7
    c748:	2c016304 	.word	0x2c016304
    c74c:	06000000 	.word	0x06000000
    c750:	a5470304 	.word	0xa5470304
    c754:	07000000 	.word	0x07000000
    c758:	00004ca1 	.word	0x00004ca1
    c75c:	007a4803 	.word	0x007a4803
    c760:	5b070000 	.word	0x5b070000
    c764:	0300004c 	.word	0x0300004c
    c768:	0000a549 	.word	0x0000a549
    c76c:	3a080000 	.word	0x3a080000
    c770:	b5000000 	.word	0xb5000000
    c774:	09000000 	.word	0x09000000
    c778:	000000b5 	.word	0x000000b5
    c77c:	040a0003 	.word	0x040a0003
    c780:	03080b07 	.word	0x03080b07
    c784:	0000dd44 	.word	0x0000dd44
    c788:	4d980c00 	.word	0x4d980c00
    c78c:	45030000 	.word	0x45030000
    c790:	00000025 	.word	0x00000025
    c794:	0c002302 	.word	0x0c002302
    c798:	00004da0 	.word	0x00004da0
    c79c:	00864a03 	.word	0x00864a03
    c7a0:	23020000 	.word	0x23020000
    c7a4:	34040004 	.word	0x34040004
    c7a8:	0300004d 	.word	0x0300004d
    c7ac:	0000b84b 	.word	0x0000b84b
    c7b0:	4c2d0400 	.word	0x4c2d0400
    c7b4:	4f030000 	.word	0x4f030000
    c7b8:	0000005d 	.word	0x0000005d
    c7bc:	e104040d 	.word	0xe104040d
    c7c0:	0500004d 	.word	0x0500004d
    c7c4:	00010015 	.word	0x00010015
    c7c8:	07040300 	.word	0x07040300
    c7cc:	00000130 	.word	0x00000130
    c7d0:	004c3e0e 	.word	0x004c3e0e
    c7d4:	2d051800 	.word	0x2d051800
    c7d8:	00000166 	.word	0x00000166
    c7dc:	004d4c0c 	.word	0x004d4c0c
    c7e0:	662e0500 	.word	0x662e0500
    c7e4:	02000001 	.word	0x02000001
    c7e8:	5f0f0023 	.word	0x5f0f0023
    c7ec:	2f05006b 	.word	0x2f05006b
    c7f0:	00000025 	.word	0x00000025
    c7f4:	0c042302 	.word	0x0c042302
    c7f8:	00004d83 	.word	0x00004d83
    c7fc:	00252f05 	.word	0x00252f05
    c800:	23020000 	.word	0x23020000
    c804:	4c270c08 	.word	0x4c270c08
    c808:	2f050000 	.word	0x2f050000
    c80c:	00000025 	.word	0x00000025
    c810:	0c0c2302 	.word	0x0c0c2302
    c814:	00004e2d 	.word	0x00004e2d
    c818:	00252f05 	.word	0x00252f05
    c81c:	23020000 	.word	0x23020000
    c820:	785f0f10 	.word	0x785f0f10
    c824:	6c300500 	.word	0x6c300500
    c828:	02000001 	.word	0x02000001
    c82c:	10001423 	.word	0x10001423
    c830:	00010704 	.word	0x00010704
    c834:	00f50800 	.word	0x00f50800
    c838:	017c0000 	.word	0x017c0000
    c83c:	b5090000 	.word	0xb5090000
    c840:	00000000 	.word	0x00000000
    c844:	4c560e00 	.word	0x4c560e00
    c848:	05240000 	.word	0x05240000
    c84c:	00020735 	.word	0x00020735
    c850:	4b920c00 	.word	0x4b920c00
    c854:	36050000 	.word	0x36050000
    c858:	00000025 	.word	0x00000025
    c85c:	0c002302 	.word	0x0c002302
    c860:	00004dbd 	.word	0x00004dbd
    c864:	00253705 	.word	0x00253705
    c868:	23020000 	.word	0x23020000
    c86c:	4ba70c04 	.word	0x4ba70c04
    c870:	38050000 	.word	0x38050000
    c874:	00000025 	.word	0x00000025
    c878:	0c082302 	.word	0x0c082302
    c87c:	00004e9f 	.word	0x00004e9f
    c880:	00253905 	.word	0x00253905
    c884:	23020000 	.word	0x23020000
    c888:	4cd20c0c 	.word	0x4cd20c0c
    c88c:	3a050000 	.word	0x3a050000
    c890:	00000025 	.word	0x00000025
    c894:	0c102302 	.word	0x0c102302
    c898:	00004cc1 	.word	0x00004cc1
    c89c:	00253b05 	.word	0x00253b05
    c8a0:	23020000 	.word	0x23020000
    c8a4:	4e320c14 	.word	0x4e320c14
    c8a8:	3c050000 	.word	0x3c050000
    c8ac:	00000025 	.word	0x00000025
    c8b0:	0c182302 	.word	0x0c182302
    c8b4:	00004d16 	.word	0x00004d16
    c8b8:	00253d05 	.word	0x00253d05
    c8bc:	23020000 	.word	0x23020000
    c8c0:	4e6d0c1c 	.word	0x4e6d0c1c
    c8c4:	3e050000 	.word	0x3e050000
    c8c8:	00000025 	.word	0x00000025
    c8cc:	00202302 	.word	0x00202302
    c8d0:	004bb611 	.word	0x004bb611
    c8d4:	05010800 	.word	0x05010800
    c8d8:	00025047 	.word	0x00025047
    c8dc:	4c1a0c00 	.word	0x4c1a0c00
    c8e0:	48050000 	.word	0x48050000
    c8e4:	00000250 	.word	0x00000250
    c8e8:	0c002302 	.word	0x0c002302
    c8ec:	00004af4 	.word	0x00004af4
    c8f0:	02504905 	.word	0x02504905
    c8f4:	23030000 	.word	0x23030000
    c8f8:	d30c0180 	.word	0xd30c0180
    c8fc:	0500004d 	.word	0x0500004d
    c900:	0000f54b 	.word	0x0000f54b
    c904:	80230300 	.word	0x80230300
    c908:	4bdb0c02 	.word	0x4bdb0c02
    c90c:	4e050000 	.word	0x4e050000
    c910:	000000f5 	.word	0x000000f5
    c914:	02842303 	.word	0x02842303
    c918:	00f30800 	.word	0x00f30800
    c91c:	02600000 	.word	0x02600000
    c920:	b5090000 	.word	0xb5090000
    c924:	1f000000 	.word	0x1f000000
    c928:	4aec1100 	.word	0x4aec1100
    c92c:	01900000 	.word	0x01900000
    c930:	02a75905 	.word	0x02a75905
    c934:	4c0c0000 	.word	0x4c0c0000
    c938:	0500004d 	.word	0x0500004d
    c93c:	0002a75a 	.word	0x0002a75a
    c940:	00230200 	.word	0x00230200
    c944:	004d640c 	.word	0x004d640c
    c948:	255b0500 	.word	0x255b0500
    c94c:	02000000 	.word	0x02000000
    c950:	220c0423 	.word	0x220c0423
    c954:	0500004c 	.word	0x0500004c
    c958:	0002ad5d 	.word	0x0002ad5d
    c95c:	08230200 	.word	0x08230200
    c960:	004bb60c 	.word	0x004bb60c
    c964:	075e0500 	.word	0x075e0500
    c968:	03000002 	.word	0x03000002
    c96c:	00018823 	.word	0x00018823
    c970:	02600410 	.word	0x02600410
    c974:	bf080000 	.word	0xbf080000
    c978:	bd000002 	.word	0xbd000002
    c97c:	09000002 	.word	0x09000002
    c980:	000000b5 	.word	0x000000b5
    c984:	0112001f 	.word	0x0112001f
    c988:	02bd0410 	.word	0x02bd0410
    c98c:	200e0000 	.word	0x200e0000
    c990:	0800004d 	.word	0x0800004d
    c994:	02ee6905 	.word	0x02ee6905
    c998:	a10c0000 	.word	0xa10c0000
    c99c:	0500004b 	.word	0x0500004b
    c9a0:	0002ee6a 	.word	0x0002ee6a
    c9a4:	00230200 	.word	0x00230200
    c9a8:	004b330c 	.word	0x004b330c
    c9ac:	256b0500 	.word	0x256b0500
    c9b0:	02000000 	.word	0x02000000
    c9b4:	10000423 	.word	0x10000423
    c9b8:	00003a04 	.word	0x00003a04
    c9bc:	4d3f0e00 	.word	0x4d3f0e00
    c9c0:	055c0000 	.word	0x055c0000
    c9c4:	000432a9 	.word	0x000432a9
    c9c8:	705f0f00 	.word	0x705f0f00
    c9cc:	eeaa0500 	.word	0xeeaa0500
    c9d0:	02000002 	.word	0x02000002
    c9d4:	5f0f0023 	.word	0x5f0f0023
    c9d8:	ab050072 	.word	0xab050072
    c9dc:	00000025 	.word	0x00000025
    c9e0:	0f042302 	.word	0x0f042302
    c9e4:	0500775f 	.word	0x0500775f
    c9e8:	000025ac 	.word	0x000025ac
    c9ec:	08230200 	.word	0x08230200
    c9f0:	004bd40c 	.word	0x004bd40c
    c9f4:	41ad0500 	.word	0x41ad0500
    c9f8:	02000000 	.word	0x02000000
    c9fc:	720c0c23 	.word	0x720c0c23
    ca00:	0500004c 	.word	0x0500004c
    ca04:	000041ae 	.word	0x000041ae
    ca08:	0e230200 	.word	0x0e230200
    ca0c:	66625f0f 	.word	0x66625f0f
    ca10:	c5af0500 	.word	0xc5af0500
    ca14:	02000002 	.word	0x02000002
    ca18:	6c0c1023 	.word	0x6c0c1023
    ca1c:	0500004b 	.word	0x0500004b
    ca20:	000025b0 	.word	0x000025b0
    ca24:	18230200 	.word	0x18230200
    ca28:	004bc40c 	.word	0x004bc40c
    ca2c:	f3b70500 	.word	0xf3b70500
    ca30:	02000000 	.word	0x02000000
    ca34:	460c1c23 	.word	0x460c1c23
    ca38:	0500004c 	.word	0x0500004c
    ca3c:	0005c1b9 	.word	0x0005c1b9
    ca40:	20230200 	.word	0x20230200
    ca44:	004cba0c 	.word	0x004cba0c
    ca48:	f1bb0500 	.word	0xf1bb0500
    ca4c:	02000005 	.word	0x02000005
    ca50:	a80c2423 	.word	0xa80c2423
    ca54:	0500004d 	.word	0x0500004d
    ca58:	000616bd 	.word	0x000616bd
    ca5c:	28230200 	.word	0x28230200
    ca60:	00310e0c 	.word	0x00310e0c
    ca64:	31be0500 	.word	0x31be0500
    ca68:	02000006 	.word	0x02000006
    ca6c:	5f0f2c23 	.word	0x5f0f2c23
    ca70:	05006275 	.word	0x05006275
    ca74:	0002c5c1 	.word	0x0002c5c1
    ca78:	30230200 	.word	0x30230200
    ca7c:	70755f0f 	.word	0x70755f0f
    ca80:	eec20500 	.word	0xeec20500
    ca84:	02000002 	.word	0x02000002
    ca88:	5f0f3823 	.word	0x5f0f3823
    ca8c:	05007275 	.word	0x05007275
    ca90:	000025c3 	.word	0x000025c3
    ca94:	3c230200 	.word	0x3c230200
    ca98:	004b9b0c 	.word	0x004b9b0c
    ca9c:	37c60500 	.word	0x37c60500
    caa0:	02000006 	.word	0x02000006
    caa4:	5f0c4023 	.word	0x5f0c4023
    caa8:	0500004e 	.word	0x0500004e
    caac:	000647c7 	.word	0x000647c7
    cab0:	43230200 	.word	0x43230200
    cab4:	626c5f0f 	.word	0x626c5f0f
    cab8:	c5ca0500 	.word	0xc5ca0500
    cabc:	02000002 	.word	0x02000002
    cac0:	ea0c4423 	.word	0xea0c4423
    cac4:	0500004b 	.word	0x0500004b
    cac8:	000025cd 	.word	0x000025cd
    cacc:	4c230200 	.word	0x4c230200
    cad0:	00288d0c 	.word	0x00288d0c
    cad4:	25ce0500 	.word	0x25ce0500
    cad8:	02000000 	.word	0x02000000
    cadc:	af0c5023 	.word	0xaf0c5023
    cae0:	0500004e 	.word	0x0500004e
    cae4:	000451d1 	.word	0x000451d1
    cae8:	54230200 	.word	0x54230200
    caec:	004cae0c 	.word	0x004cae0c
    caf0:	e8d50500 	.word	0xe8d50500
    caf4:	02000000 	.word	0x02000000
    caf8:	13005823 	.word	0x13005823
    cafc:	00002501 	.word	0x00002501
    cb00:	00045100 	.word	0x00045100
    cb04:	04511400 	.word	0x04511400
    cb08:	f3140000 	.word	0xf3140000
    cb0c:	14000000 	.word	0x14000000
    cb10:	000005b4 	.word	0x000005b4
    cb14:	00002514 	.word	0x00002514
    cb18:	04100000 	.word	0x04100000
    cb1c:	00000457 	.word	0x00000457
    cb20:	004d8b11 	.word	0x004d8b11
    cb24:	05040000 	.word	0x05040000
    cb28:	0005b425 	.word	0x0005b425
    cb2c:	4db61500 	.word	0x4db61500
    cb30:	41050000 	.word	0x41050000
    cb34:	00002502 	.word	0x00002502
    cb38:	00230200 	.word	0x00230200
    cb3c:	004be315 	.word	0x004be315
    cb40:	02460500 	.word	0x02460500
    cb44:	000006a4 	.word	0x000006a4
    cb48:	15042302 	.word	0x15042302
    cb4c:	00004c62 	.word	0x00004c62
    cb50:	a4024605 	.word	0xa4024605
    cb54:	02000006 	.word	0x02000006
    cb58:	36150823 	.word	0x36150823
    cb5c:	0500004c 	.word	0x0500004c
    cb60:	06a40246 	.word	0x06a40246
    cb64:	23020000 	.word	0x23020000
    cb68:	4d5f150c 	.word	0x4d5f150c
    cb6c:	48050000 	.word	0x48050000
    cb70:	00002502 	.word	0x00002502
    cb74:	10230200 	.word	0x10230200
    cb78:	004b4115 	.word	0x004b4115
    cb7c:	02490500 	.word	0x02490500
    cb80:	000008af 	.word	0x000008af
    cb84:	15142302 	.word	0x15142302
    cb88:	00004e09 	.word	0x00004e09
    cb8c:	25024b05 	.word	0x25024b05
    cb90:	02000000 	.word	0x02000000
    cb94:	69153023 	.word	0x69153023
    cb98:	0500004d 	.word	0x0500004d
    cb9c:	05e6024c 	.word	0x05e6024c
    cba0:	23020000 	.word	0x23020000
    cba4:	4cdb1534 	.word	0x4cdb1534
    cba8:	4e050000 	.word	0x4e050000
    cbac:	00002502 	.word	0x00002502
    cbb0:	38230200 	.word	0x38230200
    cbb4:	004d7915 	.word	0x004d7915
    cbb8:	02500500 	.word	0x02500500
    cbbc:	000008cb 	.word	0x000008cb
    cbc0:	153c2302 	.word	0x153c2302
    cbc4:	00001db9 	.word	0x00001db9
    cbc8:	66025305 	.word	0x66025305
    cbcc:	02000001 	.word	0x02000001
    cbd0:	4c154023 	.word	0x4c154023
    cbd4:	0500004c 	.word	0x0500004c
    cbd8:	00250254 	.word	0x00250254
    cbdc:	23020000 	.word	0x23020000
    cbe0:	4e9a1544 	.word	0x4e9a1544
    cbe4:	55050000 	.word	0x55050000
    cbe8:	00016602 	.word	0x00016602
    cbec:	48230200 	.word	0x48230200
    cbf0:	004cf515 	.word	0x004cf515
    cbf4:	02560500 	.word	0x02560500
    cbf8:	000008d1 	.word	0x000008d1
    cbfc:	154c2302 	.word	0x154c2302
    cc00:	00004c6a 	.word	0x00004c6a
    cc04:	25025905 	.word	0x25025905
    cc08:	02000000 	.word	0x02000000
    cc0c:	f3155023 	.word	0xf3155023
    cc10:	0500004b 	.word	0x0500004b
    cc14:	05b4025a 	.word	0x05b4025a
    cc18:	23020000 	.word	0x23020000
    cc1c:	4d111554 	.word	0x4d111554
    cc20:	7c050000 	.word	0x7c050000
    cc24:	00088d02 	.word	0x00088d02
    cc28:	58230200 	.word	0x58230200
    cc2c:	004aec15 	.word	0x004aec15
    cc30:	027f0500 	.word	0x027f0500
    cc34:	000002a7 	.word	0x000002a7
    cc38:	02c82303 	.word	0x02c82303
    cc3c:	004c7f15 	.word	0x004c7f15
    cc40:	02800500 	.word	0x02800500
    cc44:	00000260 	.word	0x00000260
    cc48:	02cc2303 	.word	0x02cc2303
    cc4c:	004e5515 	.word	0x004e5515
    cc50:	02830500 	.word	0x02830500
    cc54:	000008e3 	.word	0x000008e3
    cc58:	05dc2303 	.word	0x05dc2303
    cc5c:	004bcc15 	.word	0x004bcc15
    cc60:	02880500 	.word	0x02880500
    cc64:	00000663 	.word	0x00000663
    cc68:	05e02303 	.word	0x05e02303
    cc6c:	004bb115 	.word	0x004bb115
    cc70:	02890500 	.word	0x02890500
    cc74:	000008ef 	.word	0x000008ef
    cc78:	05ec2303 	.word	0x05ec2303
    cc7c:	ba041000 	.word	0xba041000
    cc80:	03000005 	.word	0x03000005
    cc84:	04a50801 	.word	0x04a50801
    cc88:	04100000 	.word	0x04100000
    cc8c:	00000432 	.word	0x00000432
    cc90:	00250113 	.word	0x00250113
    cc94:	05e60000 	.word	0x05e60000
    cc98:	51140000 	.word	0x51140000
    cc9c:	14000004 	.word	0x14000004
    cca0:	000000f3 	.word	0x000000f3
    cca4:	0005e614 	.word	0x0005e614
    cca8:	00251400 	.word	0x00251400
    ccac:	10000000 	.word	0x10000000
    ccb0:	0005ec04 	.word	0x0005ec04
    ccb4:	05ba1600 	.word	0x05ba1600
    ccb8:	04100000 	.word	0x04100000
    ccbc:	000005c7 	.word	0x000005c7
    ccc0:	006f0113 	.word	0x006f0113
    ccc4:	06160000 	.word	0x06160000
    ccc8:	51140000 	.word	0x51140000
    cccc:	14000004 	.word	0x14000004
    ccd0:	000000f3 	.word	0x000000f3
    ccd4:	00006f14 	.word	0x00006f14
    ccd8:	00251400 	.word	0x00251400
    ccdc:	10000000 	.word	0x10000000
    cce0:	0005f704 	.word	0x0005f704
    cce4:	25011300 	.word	0x25011300
    cce8:	31000000 	.word	0x31000000
    ccec:	14000006 	.word	0x14000006
    ccf0:	00000451 	.word	0x00000451
    ccf4:	0000f314 	.word	0x0000f314
    ccf8:	04100000 	.word	0x04100000
    ccfc:	0000061c 	.word	0x0000061c
    cd00:	00003a08 	.word	0x00003a08
    cd04:	00064700 	.word	0x00064700
    cd08:	00b50900 	.word	0x00b50900
    cd0c:	00020000 	.word	0x00020000
    cd10:	00003a08 	.word	0x00003a08
    cd14:	00065700 	.word	0x00065700
    cd18:	00b50900 	.word	0x00b50900
    cd1c:	00000000 	.word	0x00000000
    cd20:	004d2d05 	.word	0x004d2d05
    cd24:	010e0500 	.word	0x010e0500
    cd28:	000002f4 	.word	0x000002f4
    cd2c:	004e3c17 	.word	0x004e3c17
    cd30:	13050c00 	.word	0x13050c00
    cd34:	00069e01 	.word	0x00069e01
    cd38:	4d4c1500 	.word	0x4d4c1500
    cd3c:	14050000 	.word	0x14050000
    cd40:	00069e01 	.word	0x00069e01
    cd44:	00230200 	.word	0x00230200
    cd48:	004c7815 	.word	0x004c7815
    cd4c:	01150500 	.word	0x01150500
    cd50:	00000025 	.word	0x00000025
    cd54:	15042302 	.word	0x15042302
    cd58:	00004d27 	.word	0x00004d27
    cd5c:	a4011605 	.word	0xa4011605
    cd60:	02000006 	.word	0x02000006
    cd64:	10000823 	.word	0x10000823
    cd68:	00066304 	.word	0x00066304
    cd6c:	57041000 	.word	0x57041000
    cd70:	17000006 	.word	0x17000006
    cd74:	00004b39 	.word	0x00004b39
    cd78:	012e050e 	.word	0x012e050e
    cd7c:	000006e5 	.word	0x000006e5
    cd80:	004d9215 	.word	0x004d9215
    cd84:	012f0500 	.word	0x012f0500
    cd88:	000006e5 	.word	0x000006e5
    cd8c:	15002302 	.word	0x15002302
    cd90:	00004cb4 	.word	0x00004cb4
    cd94:	e5013005 	.word	0xe5013005
    cd98:	02000006 	.word	0x02000006
    cd9c:	dc150623 	.word	0xdc150623
    cda0:	0500004d 	.word	0x0500004d
    cda4:	00480131 	.word	0x00480131
    cda8:	23020000 	.word	0x23020000
    cdac:	4808000c 	.word	0x4808000c
    cdb0:	f5000000 	.word	0xf5000000
    cdb4:	09000006 	.word	0x09000006
    cdb8:	000000b5 	.word	0x000000b5
    cdbc:	d0180002 	.word	0xd0180002
    cdc0:	15025f05 	.word	0x15025f05
    cdc4:	15000008 	.word	0x15000008
    cdc8:	00004e20 	.word	0x00004e20
    cdcc:	2c026005 	.word	0x2c026005
    cdd0:	02000000 	.word	0x02000000
    cdd4:	c6150023 	.word	0xc6150023
    cdd8:	0500004d 	.word	0x0500004d
    cddc:	05b40261 	.word	0x05b40261
    cde0:	23020000 	.word	0x23020000
    cde4:	4c941504 	.word	0x4c941504
    cde8:	62050000 	.word	0x62050000
    cdec:	00081502 	.word	0x00081502
    cdf0:	08230200 	.word	0x08230200
    cdf4:	004e7815 	.word	0x004e7815
    cdf8:	02630500 	.word	0x02630500
    cdfc:	0000017c 	.word	0x0000017c
    ce00:	15242302 	.word	0x15242302
    ce04:	00004ce6 	.word	0x00004ce6
    ce08:	25026405 	.word	0x25026405
    ce0c:	02000000 	.word	0x02000000
    ce10:	47154823 	.word	0x47154823
    ce14:	0500004d 	.word	0x0500004d
    ce18:	00560265 	.word	0x00560265
    ce1c:	23020000 	.word	0x23020000
    ce20:	4e871550 	.word	0x4e871550
    ce24:	66050000 	.word	0x66050000
    ce28:	0006aa02 	.word	0x0006aa02
    ce2c:	58230200 	.word	0x58230200
    ce30:	004d5215 	.word	0x004d5215
    ce34:	02670500 	.word	0x02670500
    ce38:	000000dd 	.word	0x000000dd
    ce3c:	15682302 	.word	0x15682302
    ce40:	00004e8c 	.word	0x00004e8c
    ce44:	dd026805 	.word	0xdd026805
    ce48:	02000000 	.word	0x02000000
    ce4c:	84157023 	.word	0x84157023
    ce50:	0500004b 	.word	0x0500004b
    ce54:	00dd0269 	.word	0x00dd0269
    ce58:	23020000 	.word	0x23020000
    ce5c:	4e4b1578 	.word	0x4e4b1578
    ce60:	6a050000 	.word	0x6a050000
    ce64:	00082502 	.word	0x00082502
    ce68:	80230300 	.word	0x80230300
    ce6c:	4c881501 	.word	0x4c881501
    ce70:	6b050000 	.word	0x6b050000
    ce74:	00083502 	.word	0x00083502
    ce78:	88230300 	.word	0x88230300
    ce7c:	4de91501 	.word	0x4de91501
    ce80:	6c050000 	.word	0x6c050000
    ce84:	00002502 	.word	0x00002502
    ce88:	a0230300 	.word	0xa0230300
    ce8c:	4c0c1501 	.word	0x4c0c1501
    ce90:	6d050000 	.word	0x6d050000
    ce94:	0000dd02 	.word	0x0000dd02
    ce98:	a4230300 	.word	0xa4230300
    ce9c:	4b751501 	.word	0x4b751501
    cea0:	6e050000 	.word	0x6e050000
    cea4:	0000dd02 	.word	0x0000dd02
    cea8:	ac230300 	.word	0xac230300
    ceac:	4bfb1501 	.word	0x4bfb1501
    ceb0:	6f050000 	.word	0x6f050000
    ceb4:	0000dd02 	.word	0x0000dd02
    ceb8:	b4230300 	.word	0xb4230300
    cebc:	4b4c1501 	.word	0x4b4c1501
    cec0:	70050000 	.word	0x70050000
    cec4:	0000dd02 	.word	0x0000dd02
    cec8:	bc230300 	.word	0xbc230300
    cecc:	4b5b1501 	.word	0x4b5b1501
    ced0:	71050000 	.word	0x71050000
    ced4:	0000dd02 	.word	0x0000dd02
    ced8:	c4230300 	.word	0xc4230300
    cedc:	ba080001 	.word	0xba080001
    cee0:	25000005 	.word	0x25000005
    cee4:	09000008 	.word	0x09000008
    cee8:	000000b5 	.word	0x000000b5
    ceec:	ba080019 	.word	0xba080019
    cef0:	35000005 	.word	0x35000005
    cef4:	09000008 	.word	0x09000008
    cef8:	000000b5 	.word	0x000000b5
    cefc:	ba080007 	.word	0xba080007
    cf00:	45000005 	.word	0x45000005
    cf04:	09000008 	.word	0x09000008
    cf08:	000000b5 	.word	0x000000b5
    cf0c:	f0180017 	.word	0xf0180017
    cf10:	6d027705 	.word	0x6d027705
    cf14:	15000008 	.word	0x15000008
    cf18:	00004ccb 	.word	0x00004ccb
    cf1c:	6d027905 	.word	0x6d027905
    cf20:	02000008 	.word	0x02000008
    cf24:	42150023 	.word	0x42150023
    cf28:	0500004e 	.word	0x0500004e
    cf2c:	087d027a 	.word	0x087d027a
    cf30:	23020000 	.word	0x23020000
    cf34:	ee080078 	.word	0xee080078
    cf38:	7d000002 	.word	0x7d000002
    cf3c:	09000008 	.word	0x09000008
    cf40:	000000b5 	.word	0x000000b5
    cf44:	2c08001d 	.word	0x2c08001d
    cf48:	8d000000 	.word	0x8d000000
    cf4c:	09000008 	.word	0x09000008
    cf50:	000000b5 	.word	0x000000b5
    cf54:	f019001d 	.word	0xf019001d
    cf58:	af025d05 	.word	0xaf025d05
    cf5c:	1a000008 	.word	0x1a000008
    cf60:	00004d8b 	.word	0x00004d8b
    cf64:	f5027205 	.word	0xf5027205
    cf68:	1a000006 	.word	0x1a000006
    cf6c:	00004e65 	.word	0x00004e65
    cf70:	45027b05 	.word	0x45027b05
    cf74:	00000008 	.word	0x00000008
    cf78:	0005ba08 	.word	0x0005ba08
    cf7c:	0008bf00 	.word	0x0008bf00
    cf80:	00b50900 	.word	0x00b50900
    cf84:	00180000 	.word	0x00180000
    cf88:	08cb011b 	.word	0x08cb011b
    cf8c:	51140000 	.word	0x51140000
    cf90:	00000004 	.word	0x00000004
    cf94:	08bf0410 	.word	0x08bf0410
    cf98:	04100000 	.word	0x04100000
    cf9c:	00000166 	.word	0x00000166
    cfa0:	08e3011b 	.word	0x08e3011b
    cfa4:	25140000 	.word	0x25140000
    cfa8:	00000000 	.word	0x00000000
    cfac:	08e90410 	.word	0x08e90410
    cfb0:	04100000 	.word	0x04100000
    cfb4:	000008d7 	.word	0x000008d7
    cfb8:	00065708 	.word	0x00065708
    cfbc:	0008ff00 	.word	0x0008ff00
    cfc0:	00b50900 	.word	0x00b50900
    cfc4:	00020000 	.word	0x00020000
    cfc8:	004ad91c 	.word	0x004ad91c
    cfcc:	06060100 	.word	0x06060100
    cfd0:	0000091e 	.word	0x0000091e
    cfd4:	004ae81d 	.word	0x004ae81d
    cfd8:	cd1d0000 	.word	0xcd1d0000
    cfdc:	0100004a 	.word	0x0100004a
    cfe0:	004ac41d 	.word	0x004ac41d
    cfe4:	1e000200 	.word	0x1e000200
    cfe8:	00514801 	.word	0x00514801
    cfec:	01170100 	.word	0x01170100
    cff0:	00000025 	.word	0x00000025
	...
    cffc:	00004b9d 	.word	0x00004b9d
    d000:	0000098b 	.word	0x0000098b
    d004:	0051431f 	.word	0x0051431f
    d008:	25110100 	.word	0x25110100
    d00c:	bc000000 	.word	0xbc000000
    d010:	2000004b 	.word	0x2000004b
    d014:	01006e66 	.word	0x01006e66
    d018:	0002bf11 	.word	0x0002bf11
    d01c:	004bda00 	.word	0x004bda00
    d020:	72612000 	.word	0x72612000
    d024:	11010067 	.word	0x11010067
    d028:	000000f3 	.word	0x000000f3
    d02c:	00004bf8 	.word	0x00004bf8
    d030:	01006420 	.word	0x01006420
    d034:	0000f311 	.word	0x0000f311
    d038:	004c1600 	.word	0x004c1600
    d03c:	4bbf2100 	.word	0x4bbf2100
    d040:	18010000 	.word	0x18010000
    d044:	0000098b 	.word	0x0000098b
    d048:	01007022 	.word	0x01007022
    d04c:	0002a719 	.word	0x0002a719
    d050:	005c0100 	.word	0x005c0100
    d054:	02070410 	.word	0x02070410
    d058:	f6230000 	.word	0xf6230000
    d05c:	0500004d 	.word	0x0500004d
    d060:	099f0328 	.word	0x099f0328
    d064:	01010000 	.word	0x01010000
    d068:	00045116 	.word	0x00045116
    d06c:	09ae0000 	.word	0x09ae0000
    d070:	00020000 	.word	0x00020000
    d074:	000036f3 	.word	0x000036f3
    d078:	01fe0104 	.word	0x01fe0104
    d07c:	6d010000 	.word	0x6d010000
    d080:	58000051 	.word	0x58000051
    d084:	b000004a 	.word	0xb000004a
    d088:	bc08007a 	.word	0xbc08007a
    d08c:	8808007b 	.word	0x8808007b
    d090:	02000032 	.word	0x02000032
    d094:	01350704 	.word	0x01350704
    d098:	01020000 	.word	0x01020000
    d09c:	00049e06 	.word	0x00049e06
    d0a0:	08010200 	.word	0x08010200
    d0a4:	0000049c 	.word	0x0000049c
    d0a8:	ca050202 	.word	0xca050202
    d0ac:	02000004 	.word	0x02000004
    d0b0:	01c50702 	.word	0x01c50702
    d0b4:	04030000 	.word	0x04030000
    d0b8:	746e6905 	.word	0x746e6905
    d0bc:	05080200 	.word	0x05080200
    d0c0:	0000011d 	.word	0x0000011d
    d0c4:	2b070802 	.word	0x2b070802
    d0c8:	04000001 	.word	0x04000001
    d0cc:	00004cff 	.word	0x00004cff
    d0d0:	00480702 	.word	0x00480702
    d0d4:	04020000 	.word	0x04020000
    d0d8:	00012205 	.word	0x00012205
    d0dc:	4dae0400 	.word	0x4dae0400
    d0e0:	2c030000 	.word	0x2c030000
    d0e4:	00000068 	.word	0x00000068
    d0e8:	004ca705 	.word	0x004ca705
    d0ec:	01630400 	.word	0x01630400
    d0f0:	00000025 	.word	0x00000025
    d0f4:	47030406 	.word	0x47030406
    d0f8:	000000a5 	.word	0x000000a5
    d0fc:	004ca107 	.word	0x004ca107
    d100:	7a480300 	.word	0x7a480300
    d104:	07000000 	.word	0x07000000
    d108:	00004c5b 	.word	0x00004c5b
    d10c:	00a54903 	.word	0x00a54903
    d110:	08000000 	.word	0x08000000
    d114:	00000033 	.word	0x00000033
    d118:	000000b5 	.word	0x000000b5
    d11c:	0000b509 	.word	0x0000b509
    d120:	0a000300 	.word	0x0a000300
    d124:	080b0704 	.word	0x080b0704
    d128:	00dd4403 	.word	0x00dd4403
    d12c:	980c0000 	.word	0x980c0000
    d130:	0300004d 	.word	0x0300004d
    d134:	00004845 	.word	0x00004845
    d138:	00230200 	.word	0x00230200
    d13c:	004da00c 	.word	0x004da00c
    d140:	864a0300 	.word	0x864a0300
    d144:	02000000 	.word	0x02000000
    d148:	04000423 	.word	0x04000423
    d14c:	00004d34 	.word	0x00004d34
    d150:	00b84b03 	.word	0x00b84b03
    d154:	2d040000 	.word	0x2d040000
    d158:	0300004c 	.word	0x0300004c
    d15c:	00005d4f 	.word	0x00005d4f
    d160:	04040d00 	.word	0x04040d00
    d164:	00004de1 	.word	0x00004de1
    d168:	01001505 	.word	0x01001505
    d16c:	04020000 	.word	0x04020000
    d170:	00013007 	.word	0x00013007
    d174:	4c3e0e00 	.word	0x4c3e0e00
    d178:	05180000 	.word	0x05180000
    d17c:	0001662d 	.word	0x0001662d
    d180:	4d4c0c00 	.word	0x4d4c0c00
    d184:	2e050000 	.word	0x2e050000
    d188:	00000166 	.word	0x00000166
    d18c:	0f002302 	.word	0x0f002302
    d190:	05006b5f 	.word	0x05006b5f
    d194:	0000482f 	.word	0x0000482f
    d198:	04230200 	.word	0x04230200
    d19c:	004d830c 	.word	0x004d830c
    d1a0:	482f0500 	.word	0x482f0500
    d1a4:	02000000 	.word	0x02000000
    d1a8:	270c0823 	.word	0x270c0823
    d1ac:	0500004c 	.word	0x0500004c
    d1b0:	0000482f 	.word	0x0000482f
    d1b4:	0c230200 	.word	0x0c230200
    d1b8:	004e2d0c 	.word	0x004e2d0c
    d1bc:	482f0500 	.word	0x482f0500
    d1c0:	02000000 	.word	0x02000000
    d1c4:	5f0f1023 	.word	0x5f0f1023
    d1c8:	30050078 	.word	0x30050078
    d1cc:	0000016c 	.word	0x0000016c
    d1d0:	00142302 	.word	0x00142302
    d1d4:	01070410 	.word	0x01070410
    d1d8:	f5080000 	.word	0xf5080000
    d1dc:	7c000000 	.word	0x7c000000
    d1e0:	09000001 	.word	0x09000001
    d1e4:	000000b5 	.word	0x000000b5
    d1e8:	560e0000 	.word	0x560e0000
    d1ec:	2400004c 	.word	0x2400004c
    d1f0:	02073505 	.word	0x02073505
    d1f4:	920c0000 	.word	0x920c0000
    d1f8:	0500004b 	.word	0x0500004b
    d1fc:	00004836 	.word	0x00004836
    d200:	00230200 	.word	0x00230200
    d204:	004dbd0c 	.word	0x004dbd0c
    d208:	48370500 	.word	0x48370500
    d20c:	02000000 	.word	0x02000000
    d210:	a70c0423 	.word	0xa70c0423
    d214:	0500004b 	.word	0x0500004b
    d218:	00004838 	.word	0x00004838
    d21c:	08230200 	.word	0x08230200
    d220:	004e9f0c 	.word	0x004e9f0c
    d224:	48390500 	.word	0x48390500
    d228:	02000000 	.word	0x02000000
    d22c:	d20c0c23 	.word	0xd20c0c23
    d230:	0500004c 	.word	0x0500004c
    d234:	0000483a 	.word	0x0000483a
    d238:	10230200 	.word	0x10230200
    d23c:	004cc10c 	.word	0x004cc10c
    d240:	483b0500 	.word	0x483b0500
    d244:	02000000 	.word	0x02000000
    d248:	320c1423 	.word	0x320c1423
    d24c:	0500004e 	.word	0x0500004e
    d250:	0000483c 	.word	0x0000483c
    d254:	18230200 	.word	0x18230200
    d258:	004d160c 	.word	0x004d160c
    d25c:	483d0500 	.word	0x483d0500
    d260:	02000000 	.word	0x02000000
    d264:	6d0c1c23 	.word	0x6d0c1c23
    d268:	0500004e 	.word	0x0500004e
    d26c:	0000483e 	.word	0x0000483e
    d270:	20230200 	.word	0x20230200
    d274:	4bb61100 	.word	0x4bb61100
    d278:	01080000 	.word	0x01080000
    d27c:	02504705 	.word	0x02504705
    d280:	1a0c0000 	.word	0x1a0c0000
    d284:	0500004c 	.word	0x0500004c
    d288:	00025048 	.word	0x00025048
    d28c:	00230200 	.word	0x00230200
    d290:	004af40c 	.word	0x004af40c
    d294:	50490500 	.word	0x50490500
    d298:	03000002 	.word	0x03000002
    d29c:	0c018023 	.word	0x0c018023
    d2a0:	00004dd3 	.word	0x00004dd3
    d2a4:	00f54b05 	.word	0x00f54b05
    d2a8:	23030000 	.word	0x23030000
    d2ac:	db0c0280 	.word	0xdb0c0280
    d2b0:	0500004b 	.word	0x0500004b
    d2b4:	0000f54e 	.word	0x0000f54e
    d2b8:	84230300 	.word	0x84230300
    d2bc:	f3080002 	.word	0xf3080002
    d2c0:	60000000 	.word	0x60000000
    d2c4:	09000002 	.word	0x09000002
    d2c8:	000000b5 	.word	0x000000b5
    d2cc:	ec11001f 	.word	0xec11001f
    d2d0:	9000004a 	.word	0x9000004a
    d2d4:	a7590501 	.word	0xa7590501
    d2d8:	0c000002 	.word	0x0c000002
    d2dc:	00004d4c 	.word	0x00004d4c
    d2e0:	02a75a05 	.word	0x02a75a05
    d2e4:	23020000 	.word	0x23020000
    d2e8:	4d640c00 	.word	0x4d640c00
    d2ec:	5b050000 	.word	0x5b050000
    d2f0:	00000048 	.word	0x00000048
    d2f4:	0c042302 	.word	0x0c042302
    d2f8:	00004c22 	.word	0x00004c22
    d2fc:	02ad5d05 	.word	0x02ad5d05
    d300:	23020000 	.word	0x23020000
    d304:	4bb60c08 	.word	0x4bb60c08
    d308:	5e050000 	.word	0x5e050000
    d30c:	00000207 	.word	0x00000207
    d310:	01882303 	.word	0x01882303
    d314:	60041000 	.word	0x60041000
    d318:	08000002 	.word	0x08000002
    d31c:	000002bf 	.word	0x000002bf
    d320:	000002bd 	.word	0x000002bd
    d324:	0000b509 	.word	0x0000b509
    d328:	12001f00 	.word	0x12001f00
    d32c:	bd041001 	.word	0xbd041001
    d330:	0e000002 	.word	0x0e000002
    d334:	00004d20 	.word	0x00004d20
    d338:	ee690508 	.word	0xee690508
    d33c:	0c000002 	.word	0x0c000002
    d340:	00004ba1 	.word	0x00004ba1
    d344:	02ee6a05 	.word	0x02ee6a05
    d348:	23020000 	.word	0x23020000
    d34c:	4b330c00 	.word	0x4b330c00
    d350:	6b050000 	.word	0x6b050000
    d354:	00000048 	.word	0x00000048
    d358:	00042302 	.word	0x00042302
    d35c:	00330410 	.word	0x00330410
    d360:	3f0e0000 	.word	0x3f0e0000
    d364:	5c00004d 	.word	0x5c00004d
    d368:	0432a905 	.word	0x0432a905
    d36c:	5f0f0000 	.word	0x5f0f0000
    d370:	aa050070 	.word	0xaa050070
    d374:	000002ee 	.word	0x000002ee
    d378:	0f002302 	.word	0x0f002302
    d37c:	0500725f 	.word	0x0500725f
    d380:	000048ab 	.word	0x000048ab
    d384:	04230200 	.word	0x04230200
    d388:	00775f0f 	.word	0x00775f0f
    d38c:	0048ac05 	.word	0x0048ac05
    d390:	23020000 	.word	0x23020000
    d394:	4bd40c08 	.word	0x4bd40c08
    d398:	ad050000 	.word	0xad050000
    d39c:	0000003a 	.word	0x0000003a
    d3a0:	0c0c2302 	.word	0x0c0c2302
    d3a4:	00004c72 	.word	0x00004c72
    d3a8:	003aae05 	.word	0x003aae05
    d3ac:	23020000 	.word	0x23020000
    d3b0:	625f0f0e 	.word	0x625f0f0e
    d3b4:	af050066 	.word	0xaf050066
    d3b8:	000002c5 	.word	0x000002c5
    d3bc:	0c102302 	.word	0x0c102302
    d3c0:	00004b6c 	.word	0x00004b6c
    d3c4:	0048b005 	.word	0x0048b005
    d3c8:	23020000 	.word	0x23020000
    d3cc:	4bc40c18 	.word	0x4bc40c18
    d3d0:	b7050000 	.word	0xb7050000
    d3d4:	000000f3 	.word	0x000000f3
    d3d8:	0c1c2302 	.word	0x0c1c2302
    d3dc:	00004c46 	.word	0x00004c46
    d3e0:	05c1b905 	.word	0x05c1b905
    d3e4:	23020000 	.word	0x23020000
    d3e8:	4cba0c20 	.word	0x4cba0c20
    d3ec:	bb050000 	.word	0xbb050000
    d3f0:	000005f1 	.word	0x000005f1
    d3f4:	0c242302 	.word	0x0c242302
    d3f8:	00004da8 	.word	0x00004da8
    d3fc:	0616bd05 	.word	0x0616bd05
    d400:	23020000 	.word	0x23020000
    d404:	310e0c28 	.word	0x310e0c28
    d408:	be050000 	.word	0xbe050000
    d40c:	00000631 	.word	0x00000631
    d410:	0f2c2302 	.word	0x0f2c2302
    d414:	0062755f 	.word	0x0062755f
    d418:	02c5c105 	.word	0x02c5c105
    d41c:	23020000 	.word	0x23020000
    d420:	755f0f30 	.word	0x755f0f30
    d424:	c2050070 	.word	0xc2050070
    d428:	000002ee 	.word	0x000002ee
    d42c:	0f382302 	.word	0x0f382302
    d430:	0072755f 	.word	0x0072755f
    d434:	0048c305 	.word	0x0048c305
    d438:	23020000 	.word	0x23020000
    d43c:	4b9b0c3c 	.word	0x4b9b0c3c
    d440:	c6050000 	.word	0xc6050000
    d444:	00000637 	.word	0x00000637
    d448:	0c402302 	.word	0x0c402302
    d44c:	00004e5f 	.word	0x00004e5f
    d450:	0647c705 	.word	0x0647c705
    d454:	23020000 	.word	0x23020000
    d458:	6c5f0f43 	.word	0x6c5f0f43
    d45c:	ca050062 	.word	0xca050062
    d460:	000002c5 	.word	0x000002c5
    d464:	0c442302 	.word	0x0c442302
    d468:	00004bea 	.word	0x00004bea
    d46c:	0048cd05 	.word	0x0048cd05
    d470:	23020000 	.word	0x23020000
    d474:	288d0c4c 	.word	0x288d0c4c
    d478:	ce050000 	.word	0xce050000
    d47c:	00000048 	.word	0x00000048
    d480:	0c502302 	.word	0x0c502302
    d484:	00004eaf 	.word	0x00004eaf
    d488:	0451d105 	.word	0x0451d105
    d48c:	23020000 	.word	0x23020000
    d490:	4cae0c54 	.word	0x4cae0c54
    d494:	d5050000 	.word	0xd5050000
    d498:	000000e8 	.word	0x000000e8
    d49c:	00582302 	.word	0x00582302
    d4a0:	00480113 	.word	0x00480113
    d4a4:	04510000 	.word	0x04510000
    d4a8:	51140000 	.word	0x51140000
    d4ac:	14000004 	.word	0x14000004
    d4b0:	000000f3 	.word	0x000000f3
    d4b4:	0005b414 	.word	0x0005b414
    d4b8:	00481400 	.word	0x00481400
    d4bc:	10000000 	.word	0x10000000
    d4c0:	00045704 	.word	0x00045704
    d4c4:	4d8b1100 	.word	0x4d8b1100
    d4c8:	04000000 	.word	0x04000000
    d4cc:	05b42505 	.word	0x05b42505
    d4d0:	b6150000 	.word	0xb6150000
    d4d4:	0500004d 	.word	0x0500004d
    d4d8:	00480241 	.word	0x00480241
    d4dc:	23020000 	.word	0x23020000
    d4e0:	4be31500 	.word	0x4be31500
    d4e4:	46050000 	.word	0x46050000
    d4e8:	0006a402 	.word	0x0006a402
    d4ec:	04230200 	.word	0x04230200
    d4f0:	004c6215 	.word	0x004c6215
    d4f4:	02460500 	.word	0x02460500
    d4f8:	000006a4 	.word	0x000006a4
    d4fc:	15082302 	.word	0x15082302
    d500:	00004c36 	.word	0x00004c36
    d504:	a4024605 	.word	0xa4024605
    d508:	02000006 	.word	0x02000006
    d50c:	5f150c23 	.word	0x5f150c23
    d510:	0500004d 	.word	0x0500004d
    d514:	00480248 	.word	0x00480248
    d518:	23020000 	.word	0x23020000
    d51c:	4b411510 	.word	0x4b411510
    d520:	49050000 	.word	0x49050000
    d524:	0008af02 	.word	0x0008af02
    d528:	14230200 	.word	0x14230200
    d52c:	004e0915 	.word	0x004e0915
    d530:	024b0500 	.word	0x024b0500
    d534:	00000048 	.word	0x00000048
    d538:	15302302 	.word	0x15302302
    d53c:	00004d69 	.word	0x00004d69
    d540:	e6024c05 	.word	0xe6024c05
    d544:	02000005 	.word	0x02000005
    d548:	db153423 	.word	0xdb153423
    d54c:	0500004c 	.word	0x0500004c
    d550:	0048024e 	.word	0x0048024e
    d554:	23020000 	.word	0x23020000
    d558:	4d791538 	.word	0x4d791538
    d55c:	50050000 	.word	0x50050000
    d560:	0008cb02 	.word	0x0008cb02
    d564:	3c230200 	.word	0x3c230200
    d568:	001db915 	.word	0x001db915
    d56c:	02530500 	.word	0x02530500
    d570:	00000166 	.word	0x00000166
    d574:	15402302 	.word	0x15402302
    d578:	00004c4c 	.word	0x00004c4c
    d57c:	48025405 	.word	0x48025405
    d580:	02000000 	.word	0x02000000
    d584:	9a154423 	.word	0x9a154423
    d588:	0500004e 	.word	0x0500004e
    d58c:	01660255 	.word	0x01660255
    d590:	23020000 	.word	0x23020000
    d594:	4cf51548 	.word	0x4cf51548
    d598:	56050000 	.word	0x56050000
    d59c:	0008d102 	.word	0x0008d102
    d5a0:	4c230200 	.word	0x4c230200
    d5a4:	004c6a15 	.word	0x004c6a15
    d5a8:	02590500 	.word	0x02590500
    d5ac:	00000048 	.word	0x00000048
    d5b0:	15502302 	.word	0x15502302
    d5b4:	00004bf3 	.word	0x00004bf3
    d5b8:	b4025a05 	.word	0xb4025a05
    d5bc:	02000005 	.word	0x02000005
    d5c0:	11155423 	.word	0x11155423
    d5c4:	0500004d 	.word	0x0500004d
    d5c8:	088d027c 	.word	0x088d027c
    d5cc:	23020000 	.word	0x23020000
    d5d0:	4aec1558 	.word	0x4aec1558
    d5d4:	7f050000 	.word	0x7f050000
    d5d8:	0002a702 	.word	0x0002a702
    d5dc:	c8230300 	.word	0xc8230300
    d5e0:	4c7f1502 	.word	0x4c7f1502
    d5e4:	80050000 	.word	0x80050000
    d5e8:	00026002 	.word	0x00026002
    d5ec:	cc230300 	.word	0xcc230300
    d5f0:	4e551502 	.word	0x4e551502
    d5f4:	83050000 	.word	0x83050000
    d5f8:	0008e302 	.word	0x0008e302
    d5fc:	dc230300 	.word	0xdc230300
    d600:	4bcc1505 	.word	0x4bcc1505
    d604:	88050000 	.word	0x88050000
    d608:	00066302 	.word	0x00066302
    d60c:	e0230300 	.word	0xe0230300
    d610:	4bb11505 	.word	0x4bb11505
    d614:	89050000 	.word	0x89050000
    d618:	0008ef02 	.word	0x0008ef02
    d61c:	ec230300 	.word	0xec230300
    d620:	04100005 	.word	0x04100005
    d624:	000005ba 	.word	0x000005ba
    d628:	a5080102 	.word	0xa5080102
    d62c:	10000004 	.word	0x10000004
    d630:	00043204 	.word	0x00043204
    d634:	48011300 	.word	0x48011300
    d638:	e6000000 	.word	0xe6000000
    d63c:	14000005 	.word	0x14000005
    d640:	00000451 	.word	0x00000451
    d644:	0000f314 	.word	0x0000f314
    d648:	05e61400 	.word	0x05e61400
    d64c:	48140000 	.word	0x48140000
    d650:	00000000 	.word	0x00000000
    d654:	05ec0410 	.word	0x05ec0410
    d658:	ba160000 	.word	0xba160000
    d65c:	10000005 	.word	0x10000005
    d660:	0005c704 	.word	0x0005c704
    d664:	6f011300 	.word	0x6f011300
    d668:	16000000 	.word	0x16000000
    d66c:	14000006 	.word	0x14000006
    d670:	00000451 	.word	0x00000451
    d674:	0000f314 	.word	0x0000f314
    d678:	006f1400 	.word	0x006f1400
    d67c:	48140000 	.word	0x48140000
    d680:	00000000 	.word	0x00000000
    d684:	05f70410 	.word	0x05f70410
    d688:	01130000 	.word	0x01130000
    d68c:	00000048 	.word	0x00000048
    d690:	00000631 	.word	0x00000631
    d694:	00045114 	.word	0x00045114
    d698:	00f31400 	.word	0x00f31400
    d69c:	10000000 	.word	0x10000000
    d6a0:	00061c04 	.word	0x00061c04
    d6a4:	00330800 	.word	0x00330800
    d6a8:	06470000 	.word	0x06470000
    d6ac:	b5090000 	.word	0xb5090000
    d6b0:	02000000 	.word	0x02000000
    d6b4:	00330800 	.word	0x00330800
    d6b8:	06570000 	.word	0x06570000
    d6bc:	b5090000 	.word	0xb5090000
    d6c0:	00000000 	.word	0x00000000
    d6c4:	4d2d0500 	.word	0x4d2d0500
    d6c8:	0e050000 	.word	0x0e050000
    d6cc:	0002f401 	.word	0x0002f401
    d6d0:	4e3c1700 	.word	0x4e3c1700
    d6d4:	050c0000 	.word	0x050c0000
    d6d8:	069e0113 	.word	0x069e0113
    d6dc:	4c150000 	.word	0x4c150000
    d6e0:	0500004d 	.word	0x0500004d
    d6e4:	069e0114 	.word	0x069e0114
    d6e8:	23020000 	.word	0x23020000
    d6ec:	4c781500 	.word	0x4c781500
    d6f0:	15050000 	.word	0x15050000
    d6f4:	00004801 	.word	0x00004801
    d6f8:	04230200 	.word	0x04230200
    d6fc:	004d2715 	.word	0x004d2715
    d700:	01160500 	.word	0x01160500
    d704:	000006a4 	.word	0x000006a4
    d708:	00082302 	.word	0x00082302
    d70c:	06630410 	.word	0x06630410
    d710:	04100000 	.word	0x04100000
    d714:	00000657 	.word	0x00000657
    d718:	004b3917 	.word	0x004b3917
    d71c:	2e050e00 	.word	0x2e050e00
    d720:	0006e501 	.word	0x0006e501
    d724:	4d921500 	.word	0x4d921500
    d728:	2f050000 	.word	0x2f050000
    d72c:	0006e501 	.word	0x0006e501
    d730:	00230200 	.word	0x00230200
    d734:	004cb415 	.word	0x004cb415
    d738:	01300500 	.word	0x01300500
    d73c:	000006e5 	.word	0x000006e5
    d740:	15062302 	.word	0x15062302
    d744:	00004ddc 	.word	0x00004ddc
    d748:	41013105 	.word	0x41013105
    d74c:	02000000 	.word	0x02000000
    d750:	08000c23 	.word	0x08000c23
    d754:	00000041 	.word	0x00000041
    d758:	000006f5 	.word	0x000006f5
    d75c:	0000b509 	.word	0x0000b509
    d760:	18000200 	.word	0x18000200
    d764:	025f05d0 	.word	0x025f05d0
    d768:	00000815 	.word	0x00000815
    d76c:	004e2015 	.word	0x004e2015
    d770:	02600500 	.word	0x02600500
    d774:	00000025 	.word	0x00000025
    d778:	15002302 	.word	0x15002302
    d77c:	00004dc6 	.word	0x00004dc6
    d780:	b4026105 	.word	0xb4026105
    d784:	02000005 	.word	0x02000005
    d788:	94150423 	.word	0x94150423
    d78c:	0500004c 	.word	0x0500004c
    d790:	08150262 	.word	0x08150262
    d794:	23020000 	.word	0x23020000
    d798:	4e781508 	.word	0x4e781508
    d79c:	63050000 	.word	0x63050000
    d7a0:	00017c02 	.word	0x00017c02
    d7a4:	24230200 	.word	0x24230200
    d7a8:	004ce615 	.word	0x004ce615
    d7ac:	02640500 	.word	0x02640500
    d7b0:	00000048 	.word	0x00000048
    d7b4:	15482302 	.word	0x15482302
    d7b8:	00004d47 	.word	0x00004d47
    d7bc:	56026505 	.word	0x56026505
    d7c0:	02000000 	.word	0x02000000
    d7c4:	87155023 	.word	0x87155023
    d7c8:	0500004e 	.word	0x0500004e
    d7cc:	06aa0266 	.word	0x06aa0266
    d7d0:	23020000 	.word	0x23020000
    d7d4:	4d521558 	.word	0x4d521558
    d7d8:	67050000 	.word	0x67050000
    d7dc:	0000dd02 	.word	0x0000dd02
    d7e0:	68230200 	.word	0x68230200
    d7e4:	004e8c15 	.word	0x004e8c15
    d7e8:	02680500 	.word	0x02680500
    d7ec:	000000dd 	.word	0x000000dd
    d7f0:	15702302 	.word	0x15702302
    d7f4:	00004b84 	.word	0x00004b84
    d7f8:	dd026905 	.word	0xdd026905
    d7fc:	02000000 	.word	0x02000000
    d800:	4b157823 	.word	0x4b157823
    d804:	0500004e 	.word	0x0500004e
    d808:	0825026a 	.word	0x0825026a
    d80c:	23030000 	.word	0x23030000
    d810:	88150180 	.word	0x88150180
    d814:	0500004c 	.word	0x0500004c
    d818:	0835026b 	.word	0x0835026b
    d81c:	23030000 	.word	0x23030000
    d820:	e9150188 	.word	0xe9150188
    d824:	0500004d 	.word	0x0500004d
    d828:	0048026c 	.word	0x0048026c
    d82c:	23030000 	.word	0x23030000
    d830:	0c1501a0 	.word	0x0c1501a0
    d834:	0500004c 	.word	0x0500004c
    d838:	00dd026d 	.word	0x00dd026d
    d83c:	23030000 	.word	0x23030000
    d840:	751501a4 	.word	0x751501a4
    d844:	0500004b 	.word	0x0500004b
    d848:	00dd026e 	.word	0x00dd026e
    d84c:	23030000 	.word	0x23030000
    d850:	fb1501ac 	.word	0xfb1501ac
    d854:	0500004b 	.word	0x0500004b
    d858:	00dd026f 	.word	0x00dd026f
    d85c:	23030000 	.word	0x23030000
    d860:	4c1501b4 	.word	0x4c1501b4
    d864:	0500004b 	.word	0x0500004b
    d868:	00dd0270 	.word	0x00dd0270
    d86c:	23030000 	.word	0x23030000
    d870:	5b1501bc 	.word	0x5b1501bc
    d874:	0500004b 	.word	0x0500004b
    d878:	00dd0271 	.word	0x00dd0271
    d87c:	23030000 	.word	0x23030000
    d880:	080001c4 	.word	0x080001c4
    d884:	000005ba 	.word	0x000005ba
    d888:	00000825 	.word	0x00000825
    d88c:	0000b509 	.word	0x0000b509
    d890:	08001900 	.word	0x08001900
    d894:	000005ba 	.word	0x000005ba
    d898:	00000835 	.word	0x00000835
    d89c:	0000b509 	.word	0x0000b509
    d8a0:	08000700 	.word	0x08000700
    d8a4:	000005ba 	.word	0x000005ba
    d8a8:	00000845 	.word	0x00000845
    d8ac:	0000b509 	.word	0x0000b509
    d8b0:	18001700 	.word	0x18001700
    d8b4:	027705f0 	.word	0x027705f0
    d8b8:	0000086d 	.word	0x0000086d
    d8bc:	004ccb15 	.word	0x004ccb15
    d8c0:	02790500 	.word	0x02790500
    d8c4:	0000086d 	.word	0x0000086d
    d8c8:	15002302 	.word	0x15002302
    d8cc:	00004e42 	.word	0x00004e42
    d8d0:	7d027a05 	.word	0x7d027a05
    d8d4:	02000008 	.word	0x02000008
    d8d8:	08007823 	.word	0x08007823
    d8dc:	000002ee 	.word	0x000002ee
    d8e0:	0000087d 	.word	0x0000087d
    d8e4:	0000b509 	.word	0x0000b509
    d8e8:	08001d00 	.word	0x08001d00
    d8ec:	00000025 	.word	0x00000025
    d8f0:	0000088d 	.word	0x0000088d
    d8f4:	0000b509 	.word	0x0000b509
    d8f8:	19001d00 	.word	0x19001d00
    d8fc:	025d05f0 	.word	0x025d05f0
    d900:	000008af 	.word	0x000008af
    d904:	004d8b1a 	.word	0x004d8b1a
    d908:	02720500 	.word	0x02720500
    d90c:	000006f5 	.word	0x000006f5
    d910:	004e651a 	.word	0x004e651a
    d914:	027b0500 	.word	0x027b0500
    d918:	00000845 	.word	0x00000845
    d91c:	05ba0800 	.word	0x05ba0800
    d920:	08bf0000 	.word	0x08bf0000
    d924:	b5090000 	.word	0xb5090000
    d928:	18000000 	.word	0x18000000
    d92c:	cb011b00 	.word	0xcb011b00
    d930:	14000008 	.word	0x14000008
    d934:	00000451 	.word	0x00000451
    d938:	bf041000 	.word	0xbf041000
    d93c:	10000008 	.word	0x10000008
    d940:	00016604 	.word	0x00016604
    d944:	e3011b00 	.word	0xe3011b00
    d948:	14000008 	.word	0x14000008
    d94c:	00000048 	.word	0x00000048
    d950:	e9041000 	.word	0xe9041000
    d954:	10000008 	.word	0x10000008
    d958:	0008d704 	.word	0x0008d704
    d95c:	06570800 	.word	0x06570800
    d960:	08ff0000 	.word	0x08ff0000
    d964:	b5090000 	.word	0xb5090000
    d968:	02000000 	.word	0x02000000
    d96c:	5c011c00 	.word	0x5c011c00
    d970:	01000051 	.word	0x01000051
    d974:	7ab00112 	.word	0x7ab00112
    d978:	7bbc0800 	.word	0x7bbc0800
    d97c:	4c340800 	.word	0x4c340800
    d980:	09920000 	.word	0x09920000
    d984:	1b1d0000 	.word	0x1b1d0000
    d988:	0100004e 	.word	0x0100004e
    d98c:	00004810 	.word	0x00004810
    d990:	004c5f00 	.word	0x004c5f00
    d994:	00641e00 	.word	0x00641e00
    d998:	00f31001 	.word	0x00f31001
    d99c:	4cae0000 	.word	0x4cae0000
    d9a0:	701f0000 	.word	0x701f0000
    d9a4:	a7130100 	.word	0xa7130100
    d9a8:	01000002 	.word	0x01000002
    d9ac:	51a92056 	.word	0x51a92056
    d9b0:	14010000 	.word	0x14010000
    d9b4:	00000992 	.word	0x00000992
    d9b8:	004bbf20 	.word	0x004bbf20
    d9bc:	98150100 	.word	0x98150100
    d9c0:	1f000009 	.word	0x1f000009
    d9c4:	1601006e 	.word	0x1601006e
    d9c8:	00000048 	.word	0x00000048
    d9cc:	69215501 	.word	0x69215501
    d9d0:	48170100 	.word	0x48170100
    d9d4:	22000000 	.word	0x22000000
    d9d8:	01006e66 	.word	0x01006e66
    d9dc:	0002bf18 	.word	0x0002bf18
    d9e0:	004ccc00 	.word	0x004ccc00
    d9e4:	51af2300 	.word	0x51af2300
    d9e8:	49010000 	.word	0x49010000
    d9ec:	00034824 	.word	0x00034824
    d9f0:	6e691f00 	.word	0x6e691f00
    d9f4:	27010064 	.word	0x27010064
    d9f8:	00000048 	.word	0x00000048
    d9fc:	00005801 	.word	0x00005801
    da00:	02a70410 	.word	0x02a70410
    da04:	04100000 	.word	0x04100000
    da08:	00000207 	.word	0x00000207
    da0c:	004df625 	.word	0x004df625
    da10:	03280500 	.word	0x03280500
    da14:	000009ac 	.word	0x000009ac
    da18:	51160101 	.word	0x51160101
    da1c:	00000004 	.word	0x00000004
    da20:	00000049 	.word	0x00000049
    da24:	38c30002 	.word	0x38c30002
    da28:	01040000 	.word	0x01040000
    da2c:	000033a7 	.word	0x000033a7
    da30:	00000368 	.word	0x00000368
    da34:	6e747263 	.word	0x6e747263
    da38:	6d73612e 	.word	0x6d73612e
    da3c:	5c3a6300 	.word	0x5c3a6300
    da40:	616e6977 	.word	0x616e6977
    da44:	5c736d72 	.word	0x5c736d72
    da48:	6c697562 	.word	0x6c697562
    da4c:	63675c64 	.word	0x63675c64
    da50:	75622d63 	.word	0x75622d63
    da54:	5c646c69 	.word	0x5c646c69
    da58:	00636367 	.word	0x00636367
    da5c:	20554e47 	.word	0x20554e47
    da60:	32205341 	.word	0x32205341
    da64:	2e38312e 	.word	0x2e38312e
    da68:	01003035 	.word	0x01003035
    da6c:	Address 0x0000da6c is out of bounds.


Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
       0:	10001101 	andne	r1, r0, r1, lsl #2
       4:	03065506 	movweq	r5, #25862	; 0x6506
       8:	25081b08 	strcs	r1, [r8, #-2824]
       c:	00051308 	andeq	r1, r5, r8, lsl #6
      10:	11010000 	tstne	r1, r0
      14:	11061000 	tstne	r6, r0
      18:	03011201 	movweq	r1, #4609	; 0x1201
      1c:	25081b08 	strcs	r1, [r8, #-2824]
      20:	00051308 	andeq	r1, r5, r8, lsl #6
      24:	11010000 	tstne	r1, r0
      28:	130e2501 	movwne	r2, #58625	; 0xe501
      2c:	1b0e030b 	blne	380c60 <__Stack_Size+0x380860>
      30:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
      34:	00061001 	andeq	r1, r6, r1
      38:	00240200 	eoreq	r0, r4, r0, lsl #4
      3c:	0b3e0b0b 	bleq	f82c70 <__Stack_Size+0xf82870>
      40:	00000e03 	andeq	r0, r0, r3, lsl #28
      44:	03001603 	movweq	r1, #1539	; 0x603
      48:	3b0b3a08 	blcc	2ce870 <__Stack_Size+0x2ce470>
      4c:	0013490b 	andseq	r4, r3, fp, lsl #18
      50:	00160400 	andseq	r0, r6, r0, lsl #8
      54:	0b3a0e03 	bleq	e83868 <__Stack_Size+0xe83468>
      58:	13490b3b 	movtne	r0, #39739	; 0x9b3b
      5c:	24050000 	strcs	r0, [r5]
      60:	3e0b0b00 	fmacdcc	d0, d11, d0
      64:	0600000b 	streq	r0, [r0], -fp
      68:	0e030104 	adfeqs	f0, f3, f4
      6c:	0b3a0b0b 	bleq	e82ca0 <__Stack_Size+0xe828a0>
      70:	13010b3b 	movwne	r0, #6971	; 0x1b3b
      74:	28070000 	stmdacs	r7, {}
      78:	1c0e0300 	stcne	3, cr0, [lr], {0}
      7c:	0800000d 	stmdaeq	r0, {r0, r2, r3}
      80:	08030028 	stmdaeq	r3, {r3, r5}
      84:	00000d1c 	andeq	r0, r0, ip, lsl sp
      88:	0b010409 	bleq	410b4 <__Stack_Size+0x40cb4>
      8c:	3b0b3a0b 	blcc	2ce8c0 <__Stack_Size+0x2ce4c0>
      90:	0013010b 	andseq	r0, r3, fp, lsl #2
      94:	01040a00 	tsteq	r4, r0, lsl #20
      98:	0b3a0b0b 	bleq	e82ccc <__Stack_Size+0xe828cc>
      9c:	1301053b 	movwne	r0, #5435	; 0x153b
      a0:	240b0000 	strcs	r0, [fp]
      a4:	3e0b0b00 	fmacdcc	d0, d11, d0
      a8:	0008030b 	andeq	r0, r8, fp, lsl #6
      ac:	002e0c00 	eoreq	r0, lr, r0, lsl #24
      b0:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
      b4:	0b3b0b3a 	bleq	ec2da4 <__Stack_Size+0xec29a4>
      b8:	01110c27 	tsteq	r1, r7, lsr #24
      bc:	0a400112 	beq	100050c <__Stack_Size+0x100010c>
      c0:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
      c4:	030c3f01 	movweq	r3, #52993	; 0xcf01
      c8:	3b0b3a0e 	blcc	2ce908 <__Stack_Size+0x2ce508>
      cc:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
      d0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
      d4:	01064001 	tsteq	r6, r1
      d8:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
      dc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
      e0:	0b3b0b3a 	bleq	ec2dd0 <__Stack_Size+0xec29d0>
      e4:	06021349 	streq	r1, [r2], -r9, asr #6
      e8:	340f0000 	strcc	r0, [pc], #0	; f0 <_Minimum_Stack_Size-0x10>
      ec:	3a0e0300 	bcc	380cf4 <__Stack_Size+0x3808f4>
      f0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
      f4:	10000013 	andne	r0, r0, r3, lsl r0
      f8:	0e03012e 	adfeqsp	f0, f3, #0.5
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
      fc:	0b3b0b3a 	bleq	ec2dec <__Stack_Size+0xec29ec>
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
     100:	13490c27 	movtne	r0, #39975	; 0x9c27

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
     104:	13010c3c 	movwne	r0, #7228	; 0x1c3c
     108:	05110000 	ldreq	r0, [r1]
	nextframe_ = getMillis() + frameLength;
     10c:	00134900 	andseq	r4, r3, r0, lsl #18
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     110:	010b1200 	tsteq	fp, r0, lsl #4
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
     114:	01120111 	tsteq	r2, r1, lsl r1
     118:	34130000 	ldrcc	r0, [r3]
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     11c:	3a080300 	bcc	200d24 <__Stack_Size+0x200924>
     120:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     124:	000a0213 	andeq	r0, sl, r3, lsl r2
		if (nextpose_[i] > pose_[i]) {
     128:	01011400 	tsteq	r1, r0, lsl #8
     12c:	13011349 	movwne	r1, #4937	; 0x1349
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
     130:	21150000 	tstcs	r5, r0
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
     134:	2f134900 	svccs	0x00134900
     138:	1600000b 	strne	r0, [r0], -fp
     13c:	0b0b000f 	bleq	2c0180 <__Stack_Size+0x2bfd80>
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     140:	00001349 	andeq	r1, r0, r9, asr #6
     144:	49003517 	stmdbmi	r0, {r0, r1, r2, r4, r8, sl, ip, sp}
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
     148:	18000013 	stmdane	r0, {r0, r1, r4}
     14c:	13490021 	movtne	r0, #36897	; 0x9021
}
     150:	0000052f 	andeq	r0, r0, pc, lsr #10
     154:	03003419 	movweq	r3, #1049	; 0x419
     158:	3b0b3a0e 	blcc	2ce998 <__Stack_Size+0x2ce598>
     15c:	1c13490b 	ldcne	9, cr4, [r3], {11}
     160:	1a00000b 	bne	194 <_Minimum_Stack_Size+0x94>
     164:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     168:	0b3b0b3a 	bleq	ec2e58 <__Stack_Size+0xec2a58>
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
     16c:	0c3f1349 	ldceq	3, cr1, [pc], #-292
     170:	00000c3c 	andeq	r0, r0, ip, lsr ip
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
     174:	01110100 	tsteq	r1, r0, lsl #2
     178:	0b130e25 	bleq	4c3a14 <__Stack_Size+0x4c3614>
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     17c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     180:	01120111 	tsteq	r2, r1, lsl r1
		nextpose_[i] = 512;
     184:	00000610 	andeq	r0, r0, r0, lsl r6
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
     188:	0b002402 	bleq	9198 <__Stack_Size+0x8d98>
		pose_[i] = 512;
     18c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
		nextpose_[i] = 512;
     190:	0300000e 	movweq	r0, #14	; 0xe
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
     194:	08030016 	stmdaeq	r3, {r1, r2, r4}
     198:	0b3b0b3a 	bleq	ec2e88 <__Stack_Size+0xec2a88>
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
     19c:	00001349 	andeq	r1, r0, r9, asr #6
     1a0:	0b002404 	bleq	91b8 <__Stack_Size+0x8db8>
	nextframe_ = getMillis();
     1a4:	000b3e0b 	andeq	r3, fp, fp, lsl #28
     1a8:	002e0500 	eoreq	r0, lr, r0, lsl #10
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     1ac:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     1b0:	0b3b0b3a 	bleq	ec2ea0 <__Stack_Size+0xec2aa0>
     1b4:	01110c27 	tsteq	r1, r7, lsr #24
     1b8:	0a400112 	beq	1000608 <__Stack_Size+0x1000208>
     1bc:	2e060000 	cdpcs	0, 0, cr0, cr6, cr0, {0}
     1c0:	030c3f00 	movweq	r3, #52992	; 0xcf00
     1c4:	3b0b3a0e 	blcc	2cea04 <__Stack_Size+0x2ce604>
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1c8:	110c2705 	tstne	ip, r5, lsl #14
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
     1cc:	40011201 	andmi	r1, r1, r1, lsl #4
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d0:	0700000a 	streq	r0, [r0, -sl]
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1d4:	0c3f002e 	ldceq	0, cr0, [pc], #-184
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d8:	0b3a0e03 	bleq	e839ec <__Stack_Size+0xe835ec>
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
     1dc:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
     1e0:	01120111 	tsteq	r2, r1, lsl r1
		pose_[i] = 512;
		nextpose_[i] = 512;
     1e4:	00000640 	andeq	r0, r0, r0, asr #12
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1e8:	3f002e08 	svccc	0x00002e08
		nextpose_[i] = 512;
     1ec:	3a0e030c 	bcc	380e24 <__Stack_Size+0x380a24>
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
     1f0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
     1f4:	1201110c 	andne	r1, r1, #3	; 0x3
     1f8:	00064001 	andeq	r4, r6, r1
	interpolating = 0;
     1fc:	00340900 	eorseq	r0, r4, r0, lsl #18
	nextframe_ = getMillis();
     200:	0b3a0e03 	bleq	e83a14 <__Stack_Size+0xe83614>
     204:	13490b3b 	movtne	r0, #39739	; 0x9b3b
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     208:	350a0000 	strcc	r0, [sl]
     20c:	00134900 	andseq	r4, r3, r0, lsl #18
     210:	01010b00 	tsteq	r1, r0, lsl #22
     214:	13011349 	movwne	r1, #4937	; 0x1349
     218:	210c0000 	tstcs	ip, r0
     21c:	2f134900 	svccs	0x00134900
     220:	0d000005 	stceq	0, cr0, [r0, #-20]
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
     224:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     228:	0b3b0b3a 	bleq	ec2f18 <__Stack_Size+0xec2b18>
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
     22c:	0b1c1349 	bleq	704f58 <__Stack_Size+0x704b58>
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
     230:	210e0000 	tstcs	lr, r0
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
     234:	2f134900 	svccs	0x00134900
     238:	0000000b 	andeq	r0, r0, fp
	dxl_set_txpacket_parameter(1, 2);
     23c:	25011101 	strcs	r1, [r1, #-257]
     240:	030b130e 	movweq	r1, #45838	; 0xb30e
     244:	110e1b0e 	tstne	lr, lr, lsl #22
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     248:	10011201 	andne	r1, r1, r1, lsl #4
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
     24c:	02000006 	andeq	r0, r0, #6	; 0x6
     250:	0b0b0024 	bleq	2c02e8 <__Stack_Size+0x2bfee8>
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     254:	0e030b3e 	vmoveq.16	d3[0], r0
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     258:	26030000 	strcs	r0, [r3], -r0
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     25c:	00134900 	andseq	r4, r3, r0, lsl #18
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     260:	00160400 	andseq	r0, r6, r0, lsl #8
     264:	0b3a0803 	bleq	e82278 <__Stack_Size+0xe81e78>
     268:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     26c:	16050000 	strne	r0, [r5], -r0
     270:	3a0e0300 	bcc	380e78 <__Stack_Size+0x380a78>
     274:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     278:	06000013 	undefined
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     27c:	0b0b0104 	bleq	2c0694 <__Stack_Size+0x2c0294>
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
     280:	0b3b0b3a 	bleq	ec2f70 <__Stack_Size+0xec2b70>
     284:	00001301 	andeq	r1, r0, r1, lsl #6
     288:	03002807 	movweq	r2, #2055	; 0x807
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
     28c:	000d1c0e 	andeq	r1, sp, lr, lsl #24
     290:	00240800 	eoreq	r0, r4, r0, lsl #16
     294:	0b3e0b0b 	bleq	f82ec8 <__Stack_Size+0xf82ac8>
	dxl_txrx_packet();
     298:	28090000 	stmdacs	r9, {}
	u16 CommStatus = dxl_get_result();
     29c:	1c080300 	stcne	3, cr0, [r8], {0}
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
     2a0:	0a00000d 	beq	2dc <_Minimum_Stack_Size+0x1dc>
		PrintErrorCode();
     2a4:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
	else
		PrintCommStatus(CommStatus);
     2a8:	0b3a0b0b 	bleq	e82edc <__Stack_Size+0xe82adc>
#endif
}
     2ac:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     2b0:	0d0b0000 	stceq	0, cr0, [fp]
     2b4:	3a080300 	bcc	200ebc <__Stack_Size+0x200abc>
     2b8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
     2bc:	000a3813 	andeq	r3, sl, r3, lsl r8
     2c0:	000d0c00 	andeq	r0, sp, r0, lsl #24

	if (interpolating == 0)
     2c4:	0b3a0e03 	bleq	e83ad8 <__Stack_Size+0xe836d8>
		return 0;
	int i;
	int complete = poseSize;
     2c8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	if (!fWait) {
     2cc:	00000a38 	andeq	r0, r0, r8, lsr sl
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
     2d0:	4901010d 	stmdbmi	r1, {r0, r2, r3, r8}
     2d4:	00130113 	andseq	r0, r3, r3, lsl r1
     2d8:	00210e00 	eoreq	r0, r1, r0, lsl #28
			return (getMillis() - nextframe_); // We still have some time to do something...
     2dc:	0b2f1349 	bleq	bc5008 <__Stack_Size+0xbc4c08>
     2e0:	040f0000 	streq	r0, [pc], #0	; 2e8 <_Minimum_Stack_Size+0x1e8>
     2e4:	0b0e0301 	bleq	380ef0 <__Stack_Size+0x380af0>
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
     2e8:	3b0b3a0b 	blcc	2ceb1c <__Stack_Size+0x2ce71c>
     2ec:	0013010b 	andseq	r0, r3, fp, lsl #2
     2f0:	01041000 	tsteq	r4, r0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     2f4:	0b3a0b0b 	bleq	e82f28 <__Stack_Size+0xe82b28>
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     2f8:	1301053b 	movwne	r0, #5435	; 0x153b
     2fc:	24110000 	ldrcs	r0, [r1]
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     300:	3e0b0b00 	fmacdcc	d0, d11, d0
     304:	0008030b 	andeq	r0, r8, fp, lsl #6
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     308:	012e1200 	teqeq	lr, r0, lsl #4
		int diff = nextpose_[i] - pose_[i];
     30c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     310:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     314:	13490c27 	movtne	r0, #39975	; 0x9c27
     318:	13010b20 	movwne	r0, #6944	; 0x1b20
     31c:	05130000 	ldreq	r0, [r3]
		if (diff == 0) {
     320:	3a080300 	bcc	200f28 <__Stack_Size+0x200b28>
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     324:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
     328:	14000013 	strne	r0, [r0], #-19
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     32c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
					pose_[i] = nextpose_[i];
     330:	053b0b3a 	ldreq	r0, [fp, #-2874]!
					complete--;
     334:	00001349 	andeq	r1, r0, r9, asr #6
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     338:	03003415 	movweq	r3, #1045	; 0x415
     33c:	3b0b3a08 	blcc	2ceb64 <__Stack_Size+0x2ce764>
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     340:	00134905 	andseq	r4, r3, r5, lsl #18
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     344:	000f1600 	andeq	r1, pc, r0, lsl #12
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     348:	13490b0b 	movtne	r0, #39691	; 0x9b0b
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     34c:	2e170000 	wxorcs	wr0, wr7, wr0
     350:	030c3f01 	movweq	r3, #52993	; 0xcf01
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
     354:	3b0b3a0e 	blcc	2ceb94 <__Stack_Size+0x2ce794>
		interpolating = 0;
     358:	200c270b 	andcs	r2, ip, fp, lsl #14
	BioloidControllerEx_writePose();
     35c:	0013010b 	andseq	r0, r3, fp, lsl #2
     360:	00051800 	andeq	r1, r5, r0, lsl #16
	return 0;
}
     364:	0b3a0e03 	bleq	e83b78 <__Stack_Size+0xe83778>
     368:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     36c:	2e190000 	wxorcs	wr0, wr9, wr0
     370:	030c3f00 	movweq	r3, #52992	; 0xcf00
     374:	3b0b3a0e 	blcc	2cebb4 <__Stack_Size+0x2ce7b4>
     378:	200c2705 	andcs	r2, ip, r5, lsl #14
     37c:	1a00000b 	bne	3b0 <_Minimum_Stack_Size+0x2b0>
     380:	0c3f002e 	ldceq	0, cr0, [pc], #-184
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
     384:	0b3a0e03 	bleq	e83b98 <__Stack_Size+0xe83798>
     388:	0c270b3b 	stceq	11, cr0, [r7], #-236
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
     38c:	00000b20 	andeq	r0, r0, r0, lsr #22
     390:	3f012e1b 	svccc	0x00012e1b
     394:	3a0e030c 	bcc	380fcc <__Stack_Size+0x380bcc>
     398:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     39c:	010b200c 	tsteq	fp, ip
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
     3a0:	1c000013 	stcne	0, cr0, [r0], {19}

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
     3a4:	1331002e 	teqne	r1, #46	; 0x2e
     3a8:	01120111 	tsteq	r2, r1, lsl r1
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
     3ac:	00000a40 	andeq	r0, r0, r0, asr #20
     3b0:	31012e1d 	tstcc	r1, sp, lsl lr
     3b4:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     3b8:	010a4001 	tsteq	sl, r1
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
     3bc:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
     3c0:	13310005 	teqne	r1, #5	; 0x5
     3c4:	00000a02 	andeq	r0, r0, r2, lsl #20
     3c8:	3f002e1f 	svccc	0x00002e1f
     3cc:	3a0e030c 	bcc	381004 <__Stack_Size+0x380c04>
     3d0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     3d4:	1201110c 	andne	r1, r1, #3	; 0x3
     3d8:	000a4001 	andeq	r4, sl, r1
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
     3dc:	002e2000 	eoreq	r2, lr, r0
     3e0:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     3e4:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     3e8:	01120111 	tsteq	r2, r1, lsl r1
     3ec:	00000a40 	andeq	r0, r0, r0, asr #20
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     3f0:	3f012e21 	svccc	0x00012e21
     3f4:	3a0e030c 	bcc	38102c <__Stack_Size+0x380c2c>
     3f8:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     3fc:	1201110c 	andne	r1, r1, #3	; 0x3
     400:	010a4001 	tsteq	sl, r1
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
     404:	22000013 	andcs	r0, r0, #19	; 0x13
     408:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     40c:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     410:	0a021349 	beq	8513c <__Stack_Size+0x84d3c>
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
     414:	2e230000 	cdpcs	0, 2, cr0, cr3, cr0, {0}
     418:	030c3f01 	movweq	r3, #52993	; 0xcf01
     41c:	3b0b3a0e 	blcc	2cec5c <__Stack_Size+0x2ce85c>
     420:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
     424:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     428:	010a4001 	tsteq	sl, r1
     42c:	24000013 	strcs	r0, [r0], #-19
     430:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     434:	0b3b0b3a 	bleq	ec3124 <__Stack_Size+0xec2d24>
     438:	06021349 	streq	r1, [r2], -r9, asr #6
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     43c:	05250000 	streq	r0, [r5]!
     440:	3a0e0300 	bcc	381048 <__Stack_Size+0x380c48>
     444:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     448:	000a0213 	andeq	r0, sl, r3, lsl r2
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     44c:	00342600 	eorseq	r2, r4, r0, lsl #12
     450:	0b3a0e03 	bleq	e83c64 <__Stack_Size+0xe83864>
     454:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     458:	00000602 	andeq	r0, r0, r2, lsl #12
     45c:	03003427 	movweq	r3, #1063	; 0x427
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     460:	3b0b3a0e 	blcc	2ceca0 <__Stack_Size+0x2ce8a0>
     464:	0013490b 	andseq	r4, r3, fp, lsl #18
     468:	002e2800 	eoreq	r2, lr, r0, lsl #16
     46c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     470:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     474:	01110c27 	tsteq	r1, r7, lsr #24
     478:	06400112 	undefined
     47c:	2e290000 	cdpcs	0, 2, cr0, cr9, cr0, {0}
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
     480:	11133100 	tstne	r3, r0, lsl #2
     484:	40011201 	andmi	r1, r1, r1, lsl #4
     488:	2a000006 	bcs	4a8 <__Stack_Size+0xa8>
     48c:	0c3f012e 	ldfeqs	f0, [pc], #-184
     490:	0b3a0e03 	bleq	e83ca4 <__Stack_Size+0xe838a4>
     494:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
     498:	01120111 	tsteq	r2, r1, lsl r1
     49c:	13010640 	movwne	r0, #5696	; 0x1640
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     4a0:	052b0000 	streq	r0, [fp]!
     4a4:	3a0e0300 	bcc	3810ac <__Stack_Size+0x380cac>
     4a8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     4ac:	00060213 	andeq	r0, r6, r3, lsl r2
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     4b0:	00342c00 	eorseq	r2, r4, r0, lsl #24
     4b4:	0b3a0e03 	bleq	e83cc8 <__Stack_Size+0xe838c8>
     4b8:	1349053b 	movtne	r0, #38203	; 0x953b
     4bc:	00000602 	andeq	r0, r0, r2, lsl #12
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     4c0:	3f012e2d 	svccc	0x00012e2d
     4c4:	3a0e030c 	bcc	3810fc <__Stack_Size+0x380cfc>
     4c8:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
		GaitPosY[GaitCurrentLegNr] = 0;
     4cc:	1113490c 	tstne	r3, ip, lsl #18
     4d0:	40011201 	andmi	r1, r1, r1, lsl #4
	}

	//Move body forward
	else {
		GaitPosX[GaitCurrentLegNr] = GaitPosX[GaitCurrentLegNr]
     4d4:	00130106 	andseq	r0, r3, r6, lsl #2
     4d8:	012e2e00 	teqeq	lr, r0, lsl #28
     4dc:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     4e0:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     4e4:	13490c27 	movtne	r0, #39975	; 0x9c27
     4e8:	01120111 	tsteq	r2, r1, lsl r1
				- (g_InControlState.TravelLength.x
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitPosY[GaitCurrentLegNr] = 0;
     4ec:	13010a40 	movwne	r0, #6720	; 0x1a40
     4f0:	052f0000 	streq	r0, [pc, #0]!	; 4f8 <__Stack_Size+0xf8>
     4f4:	3a080300 	bcc	2010fc <__Stack_Size+0x200cfc>
		GaitPosZ[GaitCurrentLegNr] = GaitPosZ[GaitCurrentLegNr]
     4f8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     4fc:	00060213 	andeq	r0, r6, r3, lsl r2
     500:	00343000 	eorseq	r3, r4, r0
     504:	0b3a0e03 	bleq	e83d18 <__Stack_Size+0xe83918>
				- (g_InControlState.TravelLength.z
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitRotY[GaitCurrentLegNr] = GaitRotY[GaitCurrentLegNr]
     508:	1349053b 	movtne	r0, #38203	; 0x953b
     50c:	00000a02 	andeq	r0, r0, r2, lsl #20
     510:	03003431 	movweq	r3, #1073	; 0x431
     514:	3b0b3a0e 	blcc	2ced54 <__Stack_Size+0x2ce954>
				- (g_InControlState.TravelLength.y
						/ (short) g_InControlState.gaitCur.TLDivFactor);
	}

}
     518:	00134905 	andseq	r4, r3, r5, lsl #18
     51c:	00053200 	andeq	r3, r5, r0, lsl #4
     520:	06021331 	undefined
     524:	34330000 	ldrtcc	r0, [r3]
     528:	02133100 	andseq	r3, r3, #0	; 0x0
     52c:	34000006 	strcc	r0, [r0], #-6
     530:	1331011d 	teqne	r1, #1073741831	; 0x40000007

}

//--------------------------------------------------------------------
//[GAIT Sequence]
void GaitSeq(void) {
     534:	0b580655 	bleq	1601e90 <__Stack_Size+0x1601a90>
	//Check if the Gait is in motion - If not if we are going to start a motion try to align our Gaitstep to start with a good foot
	// for the direction we are about to go...

	if (fWalking || (g_InControlState.ForceGaitStepCnt != 0))
     538:	13010559 	movwne	r0, #5465	; 0x1559
     53c:	05350000 	ldreq	r0, [r5]!
     540:	00133100 	andseq	r3, r3, r0, lsl #2
		TravelRequest = true;   // Is walking or was walking...
     544:	010b3600 	tsteq	fp, r0, lsl #12
     548:	00000655 	andeq	r0, r0, r5, asr r6
	else {
		TravelRequest = (abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
     54c:	31011d37 	tstcc	r1, r7, lsr sp
     550:	58065513 	stmdapl	r6, {r0, r1, r4, r8, sl, ip, lr}
     554:	0005590b 	andeq	r5, r5, fp, lsl #18
     558:	002e3800 	eoreq	r3, lr, r0, lsl #16
     55c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     560:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     564:	13490c27 	movtne	r0, #39975	; 0x9c27
     568:	01120111 	tsteq	r2, r1, lsl r1
     56c:	00000640 	andeq	r0, r0, r0, asr #12
     570:	3f012e39 	svccc	0x00012e39
     574:	3a0e030c 	bcc	3811ac <__Stack_Size+0x380dac>
     578:	11053b0b 	tstne	r5, fp, lsl #22
     57c:	40011201 	andmi	r1, r1, r1, lsl #4
				|| (abs(g_InControlState.TravelLength.y) > cTravelDeadZone);

		if (TravelRequest) {

		} else {    //Clear values under the cTravelDeadZone
			g_InControlState.TravelLength.x = 0;
     580:	00130106 	andseq	r0, r3, r6, lsl #2
			g_InControlState.TravelLength.z = 0;
     584:	00343a00 	eorseq	r3, r4, r0, lsl #20
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     588:	0b3a0803 	bleq	e8259c <__Stack_Size+0xe8219c>
     58c:	1349053b 	movtne	r0, #38203	; 0x953b
     590:	00000602 	andeq	r0, r0, r2, lsl #12
		Gait(LegIndex);
     594:	0300343b 	movweq	r3, #1083	; 0x43b
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     598:	3b0b3a08 	blcc	2cedc0 <__Stack_Size+0x2ce9c0>
     59c:	02134905 	andseq	r4, r3, #81920	; 0x14000
     5a0:	3c00000a 	stccc	0, cr0, [r0], {10}
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5a4:	0111010b 	tsteq	r1, fp, lsl #2
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5a8:	00000112 	andeq	r0, r0, r2, lsl r1
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5ac:	3f012e3d 	svccc	0x00012e3d
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5b0:	3a0e030c 	bcc	3811e8 <__Stack_Size+0x380de8>
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5b4:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
		g_InControlState.GaitStep = 1;
     5b8:	1201110c 	andne	r1, r1, #3	; 0x3
     5bc:	01064001 	tsteq	r6, r1

	// If we have a force count decrement it now...
	if (g_InControlState.ForceGaitStepCnt)
     5c0:	3e000013 	mcrcc	0, 0, r0, cr0, cr3, {0}
     5c4:	08030034 	stmdaeq	r3, {r2, r4, r5}
		g_InControlState.ForceGaitStepCnt--;
     5c8:	0b3b0b3a 	bleq	ec32b8 <__Stack_Size+0xec2eb8>
}
     5cc:	00001349 	andeq	r1, r0, r9, asr #6
     5d0:	3f002e3f 	svccc	0x00002e3f
     5d4:	3a0e030c 	bcc	38120c <__Stack_Size+0x380e0c>
     5d8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     5dc:	1201110c 	andne	r1, r1, #3	; 0x3
}
//--------------------------------------------------------------------
//[BalanceBody]
void BalanceBody(void) {

	TotalTransZ = TotalTransZ / BalanceDivFactor;
     5e0:	00064001 	andeq	r4, r6, r1
     5e4:	001d4000 	andseq	r4, sp, r0
     5e8:	06551331 	undefined
     5ec:	05590b58 	ldrbeq	r0, [r9, #-2904]
     5f0:	2e410000 	cdpcs	0, 4, cr0, cr1, cr0, {0}
	TotalTransX = TotalTransX / BalanceDivFactor;
     5f4:	030c3f01 	movweq	r3, #52993	; 0xcf01
     5f8:	3b0b3a0e 	blcc	2cee38 <__Stack_Size+0x2cea38>
     5fc:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
	TotalTransY = TotalTransY / BalanceDivFactor;
     600:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     604:	01064001 	tsteq	r6, r1
     608:	42000013 	andmi	r0, r0, #19	; 0x13
     60c:	0c3f002e 	ldceq	0, cr0, [pc], #-184

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     610:	0b3a0e03 	bleq	e83e24 <__Stack_Size+0xe83a24>
     614:	1349053b 	movtne	r0, #38203	; 0x953b
	TotalTransX = TotalTransX / BalanceDivFactor;
	TotalTransY = TotalTransY / BalanceDivFactor;

#ifndef QUADMODE // ??? on PhantomX Hex at no movment YBal1 = 1800, on Quad = 0...  Need to experiment
	if (TotalYBal1 > 0)        //Rotate balance circle by +/- 180 deg
		TotalYBal1 -= 1800;
     618:	01120111 	tsteq	r2, r1, lsl r1
     61c:	00000640 	andeq	r0, r0, r0, asr #12
	else
		TotalYBal1 += 1800;
     620:	11010b43 	tstne	r1, r3, asr #22
#endif

	if (TotalZBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     624:	01011201 	tsteq	r1, r1, lsl #4
     628:	44000013 	strmi	r0, [r0], #-19
     62c:	1331001d 	teqne	r1, #29	; 0x1d
		TotalZBal1 += 3600;
     630:	01120111 	tsteq	r2, r1, lsl r1
     634:	05590b58 	ldrbeq	r0, [r9, #-2904]

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     638:	35450000 	strbcc	r0, [r5]
     63c:	00134900 	andseq	r4, r3, r0, lsl #18
		TotalXBal1 += 3600;
     640:	00214600 	eoreq	r4, r1, r0, lsl #12
     644:	052f1349 	streq	r1, [pc, #-841]!	; 303 <_Minimum_Stack_Size+0x203>

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     648:	34470000 	strbcc	r0, [r7]
     64c:	3a0e0300 	bcc	381254 <__Stack_Size+0x380e54>
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     650:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     654:	000b1c13 	andeq	r1, fp, r3, lsl ip
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     658:	00344800 	eorseq	r4, r4, r0, lsl #16
	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     65c:	0b3a0e03 	bleq	e83e70 <__Stack_Size+0xe83a70>
     660:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     664:	00000a02 	andeq	r0, r0, r2, lsl #20
     668:	03003449 	movweq	r3, #1097	; 0x449

}
     66c:	3b0b3a0e 	blcc	2ceeac <__Stack_Size+0x2ceaac>
     670:	3f134905 	svccc	0x00134905
     674:	000a020c 	andeq	r0, sl, ip, lsl #4
     678:	00344a00 	eorseq	r4, r4, r0, lsl #20
     67c:	0b3a0e03 	bleq	e83e90 <__Stack_Size+0xe83a90>
     680:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     684:	0a020c3f 	beq	83788 <__Stack_Size+0x83388>
     688:	344b0000 	strbcc	r0, [fp]
//sin4        - Output Sinus of AngleDeg
//cos4          - Output Cosinus of AngleDeg
void GetSinCos(short AngleDeg1) {
	short ABSAngleDeg1;   //Absolute value of the Angle in Degrees, decimals = 1
	//Get the absolute value of AngleDeg
	if (AngleDeg1 < 0)
     68c:	3a080300 	bcc	201294 <__Stack_Size+0x200e94>
     690:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		ABSAngleDeg1 = AngleDeg1 * -1;
     694:	020c3f13 	andeq	r3, ip, #76	; 0x4c
     698:	4c00000a 	stcmi	0, cr0, [r0], {10}
	else
		ABSAngleDeg1 = AngleDeg1;

	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
     69c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     6a0:	0b3b0b3a 	bleq	ec3390 <__Stack_Size+0xec2f90>
     6a4:	0c3f1349 	ldceq	3, cr1, [pc], #-292
     6a8:	00000c3c 	andeq	r0, r0, ip, lsr ip
     6ac:	0300344d 	movweq	r3, #1101	; 0x44d
     6b0:	3b0b3a08 	blcc	2ceed8 <__Stack_Size+0x2cead8>
     6b4:	3f134905 	svccc	0x00134905
     6b8:	000a020c 	andeq	r0, sl, ip, lsl #4
     6bc:	11010000 	tstne	r1, r0
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
     6c0:	130e2501 	movwne	r2, #58625	; 0xe501
     6c4:	1b0e030b 	blne	3812f8 <__Stack_Size+0x380ef8>
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6c8:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
     6cc:	00061001 	andeq	r1, r6, r1
     6d0:	00240200 	eoreq	r0, r4, r0, lsl #4
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6d4:	0b3e0b0b 	bleq	f83308 <__Stack_Size+0xf82f08>
     6d8:	00000e03 	andeq	r0, r0, r3, lsl #28
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6dc:	03001603 	movweq	r1, #1539	; 0x603
     6e0:	3b0b3a08 	blcc	2cef08 <__Stack_Size+0x2ceb08>
     6e4:	0013490b 	andseq	r4, r3, fp, lsl #18
     6e8:	01040400 	tsteq	r4, r0, lsl #8
     6ec:	0b3a0b0b 	bleq	e83320 <__Stack_Size+0xe82f20>
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6f0:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     6f4:	28050000 	stmdacs	r5, {}
     6f8:	1c0e0300 	stcne	3, cr0, [lr], {0}
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
     6fc:	0600000d 	streq	r0, [r0], -sp
     700:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     704:	0b3b0b3a 	bleq	ec33f4 <__Stack_Size+0xec2ff4>
     708:	00001349 	andeq	r1, r0, r9, asr #6
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     70c:	0b011307 	bleq	45330 <__Stack_Size+0x44f30>
     710:	3b0b3a0b 	blcc	2cef44 <__Stack_Size+0x2ceb44>
     714:	0013010b 	andseq	r0, r3, fp, lsl #2
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     718:	000d0800 	andeq	r0, sp, r0, lsl #16
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     71c:	0b3a0e03 	bleq	e83f30 <__Stack_Size+0xe83b30>
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     720:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     724:	00000a38 	andeq	r0, r0, r8, lsr sl
     728:	0b000f09 	bleq	4354 <__Stack_Size+0x3f54>
     72c:	0013490b 	andseq	r4, r3, fp, lsl #18
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     730:	00240a00 	eoreq	r0, r4, r0, lsl #20
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     734:	0b3e0b0b 	bleq	f83368 <__Stack_Size+0xf82f68>
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     738:	00000803 	andeq	r0, r0, r3, lsl #16
     73c:	0b01040b 	bleq	41770 <__Stack_Size+0x41370>
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
     740:	3b0b3a0b 	blcc	2cef74 <__Stack_Size+0x2ceb74>
     744:	00130105 	andseq	r0, r3, r5, lsl #2
     748:	00240c00 	eoreq	r0, r4, r0, lsl #24
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     74c:	0b3e0b0b 	bleq	f83380 <__Stack_Size+0xf82f80>
     750:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
     754:	030c3f01 	movweq	r3, #52993	; 0xcf01
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     758:	3b0b3a0e 	blcc	2cef98 <__Stack_Size+0x2ceb98>
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     75c:	110c270b 	tstne	ip, fp, lsl #14
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     760:	40011201 	andmi	r1, r1, r1, lsl #4
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     764:	0013010a 	andseq	r0, r3, sl, lsl #2
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     768:	00050e00 	andeq	r0, r5, r0, lsl #28
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     76c:	0b3a0e03 	bleq	e83f80 <__Stack_Size+0xe83b80>
     770:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     774:	00000a02 	andeq	r0, r0, r2, lsl #20
     778:	0300050f 	movweq	r0, #1295	; 0x50f
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     77c:	3b0b3a08 	blcc	2cefa4 <__Stack_Size+0x2ceba4>
     780:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     784:	1000000a 	andne	r0, r0, sl
     788:	0c3f012e 	ldfeqs	f0, [pc], #-184
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
     78c:	0b3a0e03 	bleq	e83fa0 <__Stack_Size+0xe83ba0>
     790:	0c270b3b 	stceq	11, cr0, [r7], #-236
     794:	01111349 	tsteq	r1, r9, asr #6
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     798:	0a400112 	beq	1000be8 <__Stack_Size+0x10007e8>
     79c:	00001301 	andeq	r1, r0, r1, lsl #6
     7a0:	03000511 	movweq	r0, #1297	; 0x511
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7a4:	3b0b3a0e 	blcc	2cefe4 <__Stack_Size+0x2cebe4>
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7a8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7ac:	12000006 	andne	r0, r0, #6	; 0x6
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b0:	08030034 	stmdaeq	r3, {r2, r4, r5}
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7b4:	0b3b0b3a 	bleq	ec34a4 <__Stack_Size+0xec30a4>
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b8:	00001349 	andeq	r1, r0, r9, asr #6
     7bc:	49002613 	stmdbmi	r0, {r0, r1, r4, r9, sl, sp}
     7c0:	14000013 	strne	r0, [r0], #-19
     7c4:	08030005 	stmdaeq	r3, {r0, r2}
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7c8:	0b3b0b3a 	bleq	ec34b8 <__Stack_Size+0xec30b8>
     7cc:	06021349 	streq	r1, [r2], -r9, asr #6
     7d0:	34150000 	ldrcc	r0, [r5]
	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));
     7d4:	3a080300 	bcc	2013dc <__Stack_Size+0x200fdc>
     7d8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     7dc:	00060213 	andeq	r0, r6, r3, lsl r2
     7e0:	012e1600 	teqeq	lr, r0, lsl #12
     7e4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     7e8:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     7ec:	01110c27 	tsteq	r1, r7, lsr #24
     7f0:	06400112 	undefined
     7f4:	00001301 	andeq	r1, r0, r1, lsl #6
     7f8:	03000517 	movweq	r0, #1303	; 0x517
	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
	}
}
     7fc:	3b0b3a08 	blcc	2cf024 <__Stack_Size+0x2cec24>
     800:	02134905 	andseq	r4, r3, #81920	; 0x14000
     804:	1800000a 	stmdane	r0, {r1, r3}
     808:	08030034 	stmdaeq	r3, {r2, r4, r5}
     80c:	053b0b3a 	ldreq	r0, [fp, #-2874]!
//cos4        - Input Cosinus
//AngleRad4     - Output Angle in AngleRad4
long GetArcCos(short cos4) {
	boolean NegativeValue/*:1*/;    //If the the value is Negative
	//Check for negative value
	if (cos4 < 0) {
     810:	0a021349 	beq	8553c <__Stack_Size+0x8513c>
     814:	2e190000 	wxorcs	wr0, wr9, wr0
     818:	030c3f01 	movweq	r3, #52993	; 0xcf01
		cos4 = -cos4;
     81c:	3b0b3a0e 	blcc	2cf05c <__Stack_Size+0x2cec5c>
     820:	110c2705 	tstne	ip, r5, lsl #14
		NegativeValue = 1;
	} else
		NegativeValue = 0;

	//Limit cos4 to his maximal value
	cos4 = min(cos4, c4DEC);
     824:	40011201 	andmi	r1, r1, r1, lsl #4
     828:	0013010a 	andseq	r0, r3, sl, lsl #2
     82c:	00051a00 	andeq	r1, r5, r0, lsl #20

	if ((cos4 >= 0) && (cos4 < 9000)) {
     830:	0b3a0e03 	bleq	e84044 <__Stack_Size+0xe83c44>
     834:	1349053b 	movtne	r0, #38203	; 0x953b
     838:	00000a02 	andeq	r0, r0, r2, lsl #20
		AngleRad4 = (byte) pgm_read_byte(&GetACos[cos4 / 79]);
     83c:	3f012e1b 	svccc	0x00012e1b
     840:	3a0e030c 	bcc	381478 <__Stack_Size+0x381078>
     844:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
		AngleRad4 = ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255) ;
     848:	1201110c 	andne	r1, r1, #3	; 0x3
     84c:	01064001 	tsteq	r6, r1
	} else if ((cos4 >= 9000) && (cos4 < 9900)) {
     850:	1c000013 	stcne	0, cr0, [r0], {19}
     854:	08030034 	stmdaeq	r3, {r2, r4, r5}
     858:	0b3b0b3a 	bleq	ec3548 <__Stack_Size+0xec3148>
     85c:	0a021349 	beq	85588 <__Stack_Size+0x85188>
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9000) / 8 + 114]);
     860:	341d0000 	ldrcc	r0, [sp]
     864:	3a0e0300 	bcc	38146c <__Stack_Size+0x38106c>
     868:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     86c:	000a0213 	andeq	r0, sl, r3, lsl r2
     870:	012e1e00 	teqeq	lr, r0, lsl #28
     874:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     878:	0b3b0b3a 	bleq	ec3568 <__Stack_Size+0xec3168>
	} else if ((cos4 >= 9900) && (cos4 <= 10000)) {
     87c:	01120111 	tsteq	r2, r1, lsl r1
     880:	13010640 	movwne	r0, #5696	; 0x1640
     884:	341f0000 	ldrcc	r0, [pc], #0	; 88c <__Stack_Size+0x48c>
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9900) / 2 + 227]);
     888:	3a0e0300 	bcc	381490 <__Stack_Size+0x381090>
     88c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     890:	00060213 	andeq	r0, r6, r3, lsl r2
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     894:	00342000 	eorseq	r2, r4, r0
     898:	0b3a0e03 	bleq	e840ac <__Stack_Size+0xe83cac>
     89c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     8a0:	2e210000 	cdpcs	0, 2, cr0, cr1, cr0, {0}
     8a4:	030c3f01 	movweq	r3, #52993	; 0xcf01
     8a8:	3b0b3a0e 	blcc	2cf0e8 <__Stack_Size+0x2cece8>
     8ac:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
	}

	//Add negative sign
	if (NegativeValue)
		AngleRad4 = 31416 - AngleRad4;
     8b0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     8b4:	01064001 	tsteq	r6, r1
     8b8:	22000013 	andcs	r0, r0, #19	; 0x13
     8bc:	0111010b 	tsteq	r1, fp, lsl #2
     8c0:	00000112 	andeq	r0, r0, r2, lsl r1

	return AngleRad4;
}
     8c4:	49003523 	stmdbmi	r0, {r0, r1, r5, r8, sl, ip, sp}
     8c8:	24000013 	strcs	r0, [r0], #-19
     8cc:	13490101 	movtne	r0, #37121	; 0x9101
     8d0:	00001301 	andeq	r1, r0, r1, lsl #6
     8d4:	49002125 	stmdbmi	r0, {r0, r2, r5, r8, sp}
     8d8:	00052f13 	andeq	r2, r5, r3, lsl pc

unsigned long isqrt32(unsigned long n) //
{
     8dc:	00342600 	eorseq	r2, r4, r0, lsl #12
     8e0:	0b3a0e03 	bleq	e840f4 <__Stack_Size+0xe83cf4>

	root = 0;
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
     8e4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     8e8:	00000b1c 	andeq	r0, r0, ip, lsl fp
     8ec:	49002127 	stmdbmi	r0, {r0, r1, r2, r5, r8, sp}
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
     8f0:	000b2f13 	andeq	r2, fp, r3, lsl pc
			remainder = remainder - root - place;
     8f4:	00342800 	eorseq	r2, r4, r0, lsl #16
     8f8:	0b3a0e03 	bleq	e8410c <__Stack_Size+0xe83d0c>
			root = root + (place << 1);
     8fc:	13490b3b 	movtne	r0, #39739	; 0x9b3b

	while (place > remainder)
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
			remainder = remainder - root - place;
     900:	0a020c3f 	beq	83a04 <__Stack_Size+0x83604>
			root = root + (place << 1);
		}
		root = root >> 1;
		place = place >> 2;
     904:	34290000 	strtcc	r0, [r9]
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
		place = place >> 2;
	while (place) {
     908:	3a080300 	bcc	201510 <__Stack_Size+0x201110>
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
	XYhyp2 = isqrt32(
     90c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     910:	020c3f13 	andeq	r3, ip, #76	; 0x4c
	XYhyp2 = isqrt32(
     914:	0000000a 	andeq	r0, r0, sl
     918:	25011101 	strcs	r1, [r1, #-257]
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     91c:	030b130e 	movweq	r1, #45838	; 0xb30e
	XYhyp2 = isqrt32(
     920:	110e1b0e 	tstne	lr, lr, lsl #22
     924:	10011201 	andne	r1, r1, r1, lsl #4
     928:	02000006 	andeq	r0, r0, #6	; 0x6
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);
     92c:	08030016 	stmdaeq	r3, {r1, r2, r4}
     930:	0b3b0b3a 	bleq	ec3620 <__Stack_Size+0xec3220>
     934:	00001349 	andeq	r1, r0, r9, asr #6
     938:	0b002403 	bleq	994c <__Stack_Size+0x954c>
     93c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     940:	0400000e 	streq	r0, [r0], #-14
     944:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
     948:	0b3b0b3a 	bleq	ec3638 <__Stack_Size+0xec3238>
		Atan4 = -AngleRad4;
     94c:	00001349 	andeq	r1, r0, r9, asr #6
	else
		Atan4 = AngleRad4;
     950:	0b002405 	bleq	996c <__Stack_Size+0x956c>
	XYhyp2 = isqrt32(
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
		Atan4 = -AngleRad4;
     954:	000b3e0b 	andeq	r3, fp, fp, lsl #28
	else
		Atan4 = AngleRad4;
     958:	01040600 	tsteq	r4, r0, lsl #12
     95c:	0b3a0b0b 	bleq	e83590 <__Stack_Size+0xe83190>
	return Atan4;
}
     960:	13010b3b 	movwne	r0, #6971	; 0x1b3b
     964:	28070000 	stmdacs	r7, {}
     968:	1c0e0300 	stcne	3, cr0, [lr], {0}
     96c:	0800000d 	stmdaeq	r0, {r0, r2, r3}

}

//--------------------------------------------------------------------
//[BalCalcOneLeg]
void BalCalcOneLeg(long PosX, long PosZ, long PosY, byte BalLegNr) {
     970:	0b0b0024 	bleq	2c0a08 <__Stack_Size+0x2c0608>
	long CPR_Y;            //Final Y value for centerpoint of rotation
	long CPR_Z;            //Final Z value for centerpoint of rotation

	long lAtan;
	//Calculating totals from center of the body to the feet
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BalLegNr]) + PosZ;
     974:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     978:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
	CPR_X = (short) pgm_read_word(&cOffsetX[BalLegNr]) + PosX;
     97c:	030c3f00 	movweq	r3, #52992	; 0xcf00
     980:	3b0b3a0e 	blcc	2cf1c0 <__Stack_Size+0x2cedc0>
	CPR_Y = 150 + PosY; // using the value 150 to lower the centerpoint of rotation 'g_InControlState.BodyPos.y +

	TotalTransY += (long) PosY;
     984:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     988:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     98c:	000a4001 	andeq	r4, sl, r1
	TotalTransZ += (long) CPR_Z;
     990:	012e0a00 	teqeq	lr, r0, lsl #20
     994:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     998:	0b3b0b3a 	bleq	ec3688 <__Stack_Size+0xec3288>
	TotalTransX += (long) CPR_X;
     99c:	13490c27 	movtne	r0, #39975	; 0x9c27
     9a0:	01120111 	tsteq	r2, r1, lsl r1
     9a4:	13010a40 	movwne	r0, #6720	; 0x1a40
     9a8:	340b0000 	strcc	r0, [fp]

	lAtan = GetATan2(CPR_X, CPR_Z);
     9ac:	3a0e0300 	bcc	3815b4 <__Stack_Size+0x3811b4>
	TotalYBal1 += (lAtan * 1800) / 31415;
     9b0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     9b4:	000a0213 	andeq	r0, sl, r3, lsl r2
     9b8:	012e0c00 	teqeq	lr, r0, lsl #24
     9bc:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     9c0:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     9c4:	01110c27 	tsteq	r1, r7, lsr #24
     9c8:	06400112 	undefined
     9cc:	00001301 	andeq	r1, r0, r1, lsl #6

	lAtan = GetATan2(CPR_X, CPR_Y);
     9d0:	0300050d 	movweq	r0, #1293	; 0x50d
     9d4:	3b0b3a0e 	blcc	2cf214 <__Stack_Size+0x2cee14>
	TotalZBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     9d8:	02134905 	andseq	r4, r3, #81920	; 0x14000
     9dc:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}
     9e0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     9e4:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     9e8:	0a021349 	beq	85714 <__Stack_Size+0x85314>
     9ec:	340f0000 	strcc	r0, [pc], #0	; 9f4 <__Stack_Size+0x5f4>
     9f0:	3a0e0300 	bcc	3815f8 <__Stack_Size+0x3811f8>
     9f4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     9f8:	00060213 	andeq	r0, r6, r3, lsl r2
     9fc:	012e1000 	teqeq	lr, r0

	lAtan = GetATan2(CPR_Z, CPR_Y);
     a00:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     a04:	0b3b0b3a 	bleq	ec36f4 <__Stack_Size+0xec32f4>
	TotalXBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     a08:	13490c27 	movtne	r0, #39975	; 0x9c27
     a0c:	01120111 	tsteq	r2, r1, lsl r1
     a10:	13010640 	movwne	r0, #5696	; 0x1640
     a14:	05110000 	ldreq	r0, [r1]
     a18:	3a080300 	bcc	201620 <__Stack_Size+0x201220>
     a1c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     a20:	00060213 	andeq	r0, r6, r3, lsl r2
     a24:	00341200 	eorseq	r1, r4, r0, lsl #4

}
     a28:	0b3a0803 	bleq	e82a3c <__Stack_Size+0xe8263c>
     a2c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     a30:	00000a02 	andeq	r0, r0, r2, lsl #20
     a34:	0b000f13 	bleq	4688 <__Stack_Size+0x4288>
     a38:	0013490b 	andseq	r4, r3, fp, lsl #18
     a3c:	00261400 	eoreq	r1, r6, r0, lsl #8
     a40:	00001349 	andeq	r1, r0, r9, asr #6
     a44:	03003415 	movweq	r3, #1045	; 0x415
     a48:	3b0b3a08 	blcc	2cf270 <__Stack_Size+0x2cee70>
     a4c:	02134905 	andseq	r4, r3, #81920	; 0x14000
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a50:	1600000a 	strne	r0, [r0], -sl
     a54:	13490101 	movtne	r0, #37121	; 0x9101
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a58:	00001301 	andeq	r1, r0, r1, lsl #6
     a5c:	49002117 	stmdbmi	r0, {r0, r1, r2, r4, r8, sp}
     a60:	000b2f13 	andeq	r2, fp, r3, lsl pc
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a64:	00341800 	eorseq	r1, r4, r0, lsl #16
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a68:	0b3a0803 	bleq	e82a7c <__Stack_Size+0xe8267c>
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
     a6c:	1349053b 	movtne	r0, #38203	; 0x953b
     a70:	00000602 	andeq	r0, r0, r2, lsl #12
     a74:	03003419 	movweq	r3, #1049	; 0x419

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     a78:	3b0b3a08 	blcc	2cf2a0 <__Stack_Size+0x2ceea0>

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a7c:	00134905 	andseq	r4, r3, r5, lsl #18
     a80:	012e1a00 	teqeq	lr, r0, lsl #20
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a84:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     a88:	0b3b0b3a 	bleq	ec3778 <__Stack_Size+0xec3378>

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a8c:	01110c27 	tsteq	r1, r7, lsr #24
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a90:	06400112 	undefined
     a94:	00001301 	andeq	r1, r0, r1, lsl #6
	SinG4 = sin4;
     a98:	0300051b 	movweq	r0, #1307	; 0x51b
	CosG4 = cos4;
     a9c:	3b0b3a0e 	blcc	2cf2dc <__Stack_Size+0x2ceedc>
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
	CosG4 = cos4;
     aa4:	1c000006 	stcne	0, cr0, [r0], {6}
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
	CosG4 = cos4;

	GetSinCos(g_InControlState.BodyRot1.z + TotalZBal1);
     aac:	0b3b0b3a 	bleq	ec379c <__Stack_Size+0xec339c>
	SinB4 = sin4;
     ab0:	00001349 	andeq	r1, r0, r9, asr #6
     ab4:	0300341d 	movweq	r3, #1053	; 0x41d
	CosB4 = cos4;
     ab8:	3b0b3a08 	blcc	2cf2e0 <__Stack_Size+0x2ceee0>

	GetSinCos(g_InControlState.BodyRot1.y + (RotationY * c1DEC) + TotalYBal1);
     abc:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     ac0:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
     ac4:	08030034 	stmdaeq	r3, {r2, r4, r5}
     ac8:	0b3b0b3a 	bleq	ec37b8 <__Stack_Size+0xec33b8>
     acc:	00001349 	andeq	r1, r0, r9, asr #6

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     ad0:	3f002e1f 	svccc	0x00002e1f
     ad4:	3a0e030c 	bcc	38170c <__Stack_Size+0x38130c>
     ad8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     adc:	1201110c 	andne	r1, r1, #3	; 0x3
     ae0:	00064001 	andeq	r4, r6, r1
     ae4:	002e2000 	eoreq	r2, lr, r0
     ae8:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     aec:	0b3b0b3a 	bleq	ec37dc <__Stack_Size+0xec33dc>
     af0:	13490c27 	movtne	r0, #39975	; 0x9c27
     af4:	01120111 	tsteq	r2, r1, lsl r1
     af8:	00000640 	andeq	r0, r0, r0, asr #12
     afc:	49003521 	stmdbmi	r0, {r0, r5, r8, sl, ip, sp}
     b00:	22000013 	andcs	r0, r0, #19	; 0x13
     b04:	13490021 	movtne	r0, #36897	; 0x9021
     b08:	0000052f 	andeq	r0, r0, pc, lsr #10
     b0c:	03003423 	movweq	r3, #1059	; 0x423
     b10:	3b0b3a0e 	blcc	2cf350 <__Stack_Size+0x2cef50>
     b14:	1c13490b 	ldcne	9, cr4, [r3], {11}
     b18:	0000000b 	andeq	r0, r0, fp
     b1c:	25011101 	strcs	r1, [r1, #-257]
     b20:	030b130e 	movweq	r1, #45838	; 0xb30e
     b24:	110e1b0e 	tstne	lr, lr, lsl #22
     b28:	10011201 	andne	r1, r1, r1, lsl #4
     b2c:	02000006 	andeq	r0, r0, #6	; 0x6
     b30:	0b0b0024 	bleq	2c0bc8 <__Stack_Size+0x2c07c8>
     b34:	0e030b3e 	vmoveq.16	d3[0], r0
     b38:	16030000 	strne	r0, [r3], -r0
     b3c:	3a080300 	bcc	201744 <__Stack_Size+0x201344>
     b40:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     b44:	04000013 	streq	r0, [r0], #-19
     b48:	0b0b0024 	bleq	2c0be0 <__Stack_Size+0x2c07e0>
     b4c:	00000b3e 	andeq	r0, r0, lr, lsr fp
     b50:	0b010405 	bleq	41b6c <__Stack_Size+0x4176c>
     b54:	3b0b3a0b 	blcc	2cf388 <__Stack_Size+0x2cef88>
     b58:	0013010b 	andseq	r0, r3, fp, lsl #2
     b5c:	00280600 	eoreq	r0, r8, r0, lsl #12
     b60:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b64:	16070000 	strne	r0, [r7], -r0
     b68:	3a0e0300 	bcc	381770 <__Stack_Size+0x381370>

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     b6c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b70:	08000013 	stmdaeq	r0, {r0, r1, r4}
     b74:	0b0b0024 	bleq	2c0c0c <__Stack_Size+0x2c080c>
     b78:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
     b7c:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
     b80:	030c3f01 	movweq	r3, #52993	; 0xcf01
     b84:	3b0b3a0e 	blcc	2cf3c4 <__Stack_Size+0x2cefc4>
     b88:	200c2705 	andcs	r2, ip, r5, lsl #14
     b8c:	0013010b 	andseq	r0, r3, fp, lsl #2
     b90:	00340a00 	eorseq	r0, r4, r0, lsl #20
     b94:	0b3a0803 	bleq	e82ba8 <__Stack_Size+0xe827a8>
     b98:	1349053b 	movtne	r0, #38203	; 0x953b
     b9c:	2e0b0000 	cdpcs	0, 0, cr0, cr11, cr0, {0}
     ba0:	030c3f01 	movweq	r3, #52993	; 0xcf01
     ba4:	3b0b3a0e 	blcc	2cf3e4 <__Stack_Size+0x2cefe4>
     ba8:	200c270b 	andcs	r2, ip, fp, lsl #14
     bac:	0013010b 	andseq	r0, r3, fp, lsl #2
     bb0:	00050c00 	andeq	r0, r5, r0, lsl #24
     bb4:	0b3a0803 	bleq	e82bc8 <__Stack_Size+0xe827c8>
     bb8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     bbc:	050d0000 	streq	r0, [sp]
     bc0:	3a0e0300 	bcc	3817c8 <__Stack_Size+0x3813c8>
     bc4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     bc8:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     bcc:	0c3f012e 	ldfeqs	f0, [pc], #-184
     bd0:	0b3a0e03 	bleq	e843e4 <__Stack_Size+0xe83fe4>
     bd4:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
     bd8:	0b201349 	bleq	805904 <__Stack_Size+0x805504>
     bdc:	00001301 	andeq	r1, r0, r1, lsl #6
     be0:	0300050f 	movweq	r0, #1295	; 0x50f
     be4:	3b0b3a0e 	blcc	2cf424 <__Stack_Size+0x2cf024>
     be8:	00134905 	andseq	r4, r3, r5, lsl #18
     bec:	00341000 	eorseq	r1, r4, r0
     bf0:	0b3a0e03 	bleq	e84404 <__Stack_Size+0xe84004>
     bf4:	1349053b 	movtne	r0, #38203	; 0x953b
     bf8:	2e110000 	wxorcs	wr0, wr1, wr0
     bfc:	030c3f00 	movweq	r3, #52992	; 0xcf00
     c00:	3b0b3a0e 	blcc	2cf440 <__Stack_Size+0x2cf040>
     c04:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
     c08:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     c0c:	000a4001 	andeq	r4, sl, r1
     c10:	012e1200 	teqeq	lr, r0, lsl #4
     c14:	01111331 	tsteq	r1, r1, lsr r3
     c18:	0a400112 	beq	1001068 <__Stack_Size+0x1000c68>
     c1c:	00001301 	andeq	r1, r0, r1, lsl #6
     c20:	31000513 	tstcc	r0, r3, lsl r5
     c24:	000a0213 	andeq	r0, sl, r3, lsl r2
     c28:	012e1400 	teqeq	lr, r0, lsl #8
     c2c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c30:	0b3b0b3a 	bleq	ec3920 <__Stack_Size+0xec3520>
	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     c34:	13490c27 	movtne	r0, #39975	; 0x9c27
     c38:	01120111 	tsteq	r2, r1, lsl r1
     c3c:	13010a40 	movwne	r0, #6720	; 0x1a40
     c40:	05150000 	ldreq	r0, [r5]
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c44:	3a0e0300 	bcc	38184c <__Stack_Size+0x38144c>
     c48:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     c4c:	00060213 	andeq	r0, r6, r3, lsl r2
     c50:	002e1600 	eoreq	r1, lr, r0, lsl #12
     c54:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     c58:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     c5c:	13490c27 	movtne	r0, #39975	; 0x9c27
     c60:	01120111 	tsteq	r2, r1, lsl r1
     c64:	00000a40 	andeq	r0, r0, r0, asr #20
     c68:	3f012e17 	svccc	0x00012e17
     c6c:	3a0e030c 	bcc	3818a4 <__Stack_Size+0x3814a4>
     c70:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     c74:	1113490c 	tstne	r3, ip, lsl #18
     c78:	40011201 	andmi	r1, r1, r1, lsl #4
     c7c:	0013010a 	andseq	r0, r3, sl, lsl #2
     c80:	00051800 	andeq	r1, r5, r0, lsl #16
     c84:	0b3a0e03 	bleq	e84498 <__Stack_Size+0xe84098>
     c88:	1349053b 	movtne	r0, #38203	; 0x953b
     c8c:	00000602 	andeq	r0, r0, r2, lsl #12
     c90:	31000519 	tstcc	r0, r9, lsl r5
     c94:	00060213 	andeq	r0, r6, r3, lsl r2
     c98:	00341a00 	eorseq	r1, r4, r0, lsl #20
     c9c:	00001331 	andeq	r1, r0, r1, lsr r3
     ca0:	3100341b 	tstcc	r0, fp, lsl r4
     ca4:	00060213 	andeq	r0, r6, r3, lsl r2
     ca8:	012e1c00 	teqeq	lr, r0, lsl #24
     cac:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     cb0:	0b3b0b3a 	bleq	ec39a0 <__Stack_Size+0xec35a0>
     cb4:	01110c27 	tsteq	r1, r7, lsr #24
     cb8:	06400112 	undefined
     cbc:	00001301 	andeq	r1, r0, r1, lsl #6
     cc0:	0300341d 	movweq	r3, #1053	; 0x41d
     cc4:	3b0b3a08 	blcc	2cf4ec <__Stack_Size+0x2cf0ec>
     cc8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     ccc:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
     cd0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     cd4:	0b3b0b3a 	bleq	ec39c4 <__Stack_Size+0xec35c4>
     cd8:	00001349 	andeq	r1, r0, r9, asr #6
     cdc:	0300341f 	movweq	r3, #1055	; 0x41f
     ce0:	3b0b3a0e 	blcc	2cf520 <__Stack_Size+0x2cf120>
     ce4:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * SinG4 / c4DEC
					+ (long) CPR_Z * c2DEC * CosG4 / c4DEC * SinA4 / c4DEC
							* SinB4 / c4DEC
					+ (long) CPR_Y * c2DEC * CosB4 / c4DEC * CosG4 / c4DEC))
			/ c2DEC;
}
     ce8:	20000006 	andcs	r0, r0, r6
     cec:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     cf0:	0b3b0b3a 	bleq	ec39e0 <__Stack_Size+0xec35e0>
     cf4:	0a021349 	beq	85a20 <__Stack_Size+0x85620>
     cf8:	1d210000 	stcne	0, cr0, [r1]
     cfc:	11133101 	tstne	r3, r1, lsl #2
     d00:	58011201 	stmdapl	r1, {r0, r9, ip}
     d04:	000b590b 	andeq	r5, fp, fp, lsl #18
     d08:	010b2200 	tsteq	fp, r0, lsl #4
     d0c:	01120111 	tsteq	r2, r1, lsl r1
     d10:	2e230000 	cdpcs	0, 2, cr0, cr3, cr0, {0}
     d14:	030c3f01 	movweq	r3, #52993	; 0xcf01
     d18:	3b0b3a0e 	blcc	2cf558 <__Stack_Size+0x2cf158>
     d1c:	110c2705 	tstne	ip, r5, lsl #14
//FemurAngle1           - Output Angle of Femur in degrees
//TibiaAngle1           - Output Angle of Tibia in degrees
//CoxaAngle1            - Output Angle of Coxa in degrees
//--------------------------------------------------------------------
void LegIK(short IKFeetPosX, short IKFeetPosY, short IKFeetPosZ,
		byte LegIKLegNr) {
     d20:	40011201 	andmi	r1, r1, r1, lsl #4
     d24:	00130106 	andseq	r0, r3, r6, lsl #2
     d28:	00052400 	andeq	r2, r5, r0, lsl #8
	long Temp1;
	long Temp2;
	long T3;

	//Calculate IKCoxaAngle and IKFeetPosXZ
	GetATan2(IKFeetPosX, IKFeetPosZ);
     d2c:	0b3a0803 	bleq	e82d40 <__Stack_Size+0xe82940>
	CoxaAngle1[LegIKLegNr] = (((long) Atan4 * 180) / 3141)
     d30:	1349053b 	movtne	r0, #38203	; 0x953b
     d34:	00000602 	andeq	r0, r0, r2, lsl #12
     d38:	03003425 	movweq	r3, #1061	; 0x425
     d3c:	3b0b3a08 	blcc	2cf564 <__Stack_Size+0x2cf164>
     d40:	02134905 	andseq	r4, r3, #81920	; 0x14000
     d44:	26000006 	strcs	r0, [r0], -r6
     d48:	1331011d 	teqne	r1, #1073741831	; 0x40000007
     d4c:	01120111 	tsteq	r2, r1, lsl r1
     d50:	05590b58 	ldrbeq	r0, [r9, #-2904]
     d54:	00001301 	andeq	r1, r0, r1, lsl #6
	//Length between the Coxa and tars [foot]
	IKFeetPosXZ = XYhyp2 / c2DEC;

	//Using GetAtan2 for solving IKA1 and IKSW
	//IKA14 - Angle between SW line and the ground in radians
	IKA14 = GetATan2(IKFeetPosY - TarsOffsetY,
     d58:	31000527 	tstcc	r0, r7, lsr #10
     d5c:	28000013 	stmdacs	r0, {r0, r1, r4}
     d60:	1331011d 	teqne	r1, #1073741831	; 0x40000007
     d64:	0b580655 	bleq	16026c0 <__Stack_Size+0x16022c0>
     d68:	13010559 	movwne	r0, #5465	; 0x1559
     d6c:	1d290000 	stcne	0, cr0, [r9]
     d70:	11133101 	tstne	r3, r1, lsl #2

	//IKSW2 - Length between femur axis and tars
	IKSW2 = XYhyp2;

	//IKA2 - Angle of the line S>W with respect to the femur in radians
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     d74:	58011201 	stmdapl	r1, {r0, r9, ip}
     d78:	0005590b 	andeq	r5, r5, fp, lsl #18
     d7c:	000f2a00 	andeq	r2, pc, r0, lsl #20
     d80:	13490b0b 	movtne	r0, #39691	; 0x9b0b
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			+ ((long) IKSW2 * IKSW2));
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);
     d84:	262b0000 	strtcs	r0, [fp], -r0
     d88:	00134900 	andseq	r4, r3, r0, lsl #18
     d8c:	012e2c00 	teqeq	lr, r0, lsl #24
     d90:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     d94:	053b0b3a 	ldreq	r0, [fp, #-2874]!
     d98:	13490c27 	movtne	r0, #39975	; 0x9c27
     d9c:	01120111 	tsteq	r2, r1, lsl r1
     da0:	13010640 	movwne	r0, #5696	; 0x1640
     da4:	2e2d0000 	cdpcs	0, 2, cr0, cr13, cr0, {0}
     da8:	030c3f00 	movweq	r3, #52992	; 0xcf00
     dac:	3b0b3a0e 	blcc	2cf5ec <__Stack_Size+0x2cf1ec>
     db0:	110c270b 	tstne	ip, fp, lsl #14
     db4:	40011201 	andmi	r1, r1, r1, lsl #4

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     db8:	2e000006 	cdpcs	0, 0, cr0, cr0, cr6, {0}
     dbc:	0c3f012e 	ldfeqs	f0, [pc], #-184
     dc0:	0b3a0e03 	bleq	e845d4 <__Stack_Size+0xe841d4>
     dc4:	0c270b3b 	stceq	11, cr0, [r7], #-236
     dc8:	01111349 	tsteq	r1, r9, asr #6
     dcc:	06400112 	undefined
     dd0:	00001301 	andeq	r1, r0, r1, lsl #6
     dd4:	4900352f 	stmdbmi	r0, {r0, r1, r2, r3, r5, r8, sl, ip, sp}
     dd8:	30000013 	andcc	r0, r0, r3, lsl r0
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     ddc:	13490101 	movtne	r0, #37121	; 0x9101
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     de0:	00001301 	andeq	r1, r0, r1, lsl #6
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     de4:	49002131 	stmdbmi	r0, {r0, r4, r5, r8, sp}
     de8:	00052f13 	andeq	r2, r5, r3, lsl pc
			+ ((long) (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr])
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);
     dec:	00343200 	eorseq	r3, r4, r0, lsl #4
     df0:	0b3a0e03 	bleq	e84604 <__Stack_Size+0xe84204>
     df4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     df8:	00000b1c 	andeq	r0, r0, ip, lsl fp
     dfc:	49002133 	stmdbmi	r0, {r0, r1, r4, r5, r8, sp}
     e00:	000b2f13 	andeq	r2, fp, r3, lsl pc
     e04:	00343400 	eorseq	r3, r4, r0, lsl #8
     e08:	0b3a0e03 	bleq	e8461c <__Stack_Size+0xe8421c>

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e0c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     e10:	0a020c3f 	beq	83f14 <__Stack_Size+0x83b14>
     e14:	01000000 	tsteq	r0, r0
     e18:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     e1c:	0e030b13 	vmoveq.32	d3[0], r0
     e20:	01110e1b 	tsteq	r1, fp, lsl lr
     e24:	06100112 	undefined
     e28:	24020000 	strcs	r0, [r2]
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e2c:	3e0b0b00 	fmacdcc	d0, d11, d0
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e30:	000e030b 	andeq	r0, lr, fp, lsl #6
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e34:	00160300 	andseq	r0, r6, r0, lsl #6
     e38:	0b3a0803 	bleq	e82e4c <__Stack_Size+0xe82a4c>
     e3c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     e40:	16040000 	strne	r0, [r4], -r0
     e44:	3a0e0300 	bcc	381a4c <__Stack_Size+0x38164c>
			< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
					+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]) - 30)
					* c2DEC))
		IKSolution = 1;
     e48:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	else {
		if (IKSW2
     e4c:	05000013 	streq	r0, [r0, #-19]
     e50:	0b0b0024 	bleq	2c0ee8 <__Stack_Size+0x2c0ae8>
				< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
						+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))
						* c2DEC))
			IKSolutionWarning = 1;
     e54:	00000b3e 	andeq	r0, r0, lr, lsr fp
     e58:	3f002e06 	svccc	0x00002e06
		else
			IKSolutionError = 1;
     e5c:	3a0e030c 	bcc	381a94 <__Stack_Size+0x381694>
	}

}
     e60:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     e64:	1113490c 	tstne	r3, ip, lsl #18
     e68:	40011201 	andmi	r1, r1, r1, lsl #4
     e6c:	0700000a 	streq	r0, [r0, -sl]
     e70:	0c3f002e 	ldceq	0, cr0, [pc], #-184
     e74:	0b3a0e03 	bleq	e84688 <__Stack_Size+0xe84288>
     e78:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
     e7c:	01111349 	tsteq	r1, r9, asr #6
     e80:	0a400112 	beq	10012d0 <__Stack_Size+0x1000ed0>
     e84:	24080000 	strcs	r0, [r8]
     e88:	3e0b0b00 	fmacdcc	d0, d11, d0
     e8c:	0008030b 	andeq	r0, r8, fp, lsl #6
     e90:	012e0900 	teqeq	lr, r0, lsl #18
     e94:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     e98:	0b3b0b3a 	bleq	ec3b88 <__Stack_Size+0xec3788>
     e9c:	13490c27 	movtne	r0, #39975	; 0x9c27
     ea0:	01120111 	tsteq	r2, r1, lsl r1
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ea4:	13010640 	movwne	r0, #5696	; 0x1640
	if (sVal < s) {
     ea8:	340a0000 	strcc	r0, [sl]
     eac:	3a0e0300 	bcc	381ab4 <__Stack_Size+0x3816b4>
		return s;
	}

	s = (short) pgm_read_word(sMax);
     eb0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     eb4:	0b000013 	bleq	f08 <__Stack_Size+0xb08>
     eb8:	08030034 	stmdaeq	r3, {r2, r4, r5}

		return s;
	}
	return sVal;

}
     ebc:	0b3b0b3a 	bleq	ec3bac <__Stack_Size+0xec37ac>
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec0:	06021349 	streq	r1, [r2], -r9, asr #6
}

//--------------------------------------------------------------------
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
     ec4:	050c0000 	streq	r0, [ip]
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec8:	3a0e0300 	bcc	381ad0 <__Stack_Size+0x3816d0>
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ecc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     ed0:	00060213 	andeq	r0, r6, r3, lsl r2
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ed4:	00340d00 	eorseq	r0, r4, r0, lsl #26
	if (sVal < s) {
     ed8:	0b3a0e03 	bleq	e846ec <__Stack_Size+0xe842ec>
     edc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     ee0:	00000a02 	andeq	r0, r0, r2, lsl #20
		return s;
	}

	s = (short) pgm_read_word(sMax);
     ee4:	0300340e 	movweq	r3, #1038	; 0x40e
     ee8:	3b0b3a0e 	blcc	2cf728 <__Stack_Size+0x2cf328>
     eec:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
     ef0:	0f000006 	svceq	0x00000006
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ef4:	13490101 	movtne	r0, #37121	; 0x9101
	if (sVal < s) {
     ef8:	00001301 	andeq	r1, r0, r1, lsl #6
     efc:	49002110 	stmdbmi	r0, {r4, r8, sp}
     f00:	000b2f13 	andeq	r2, fp, r3, lsl pc
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f04:	002e1100 	eoreq	r1, lr, r0, lsl #2
     f08:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
     f0c:	0b3b0b3a 	bleq	ec3bfc <__Stack_Size+0xec37fc>
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f10:	01110c27 	tsteq	r1, r7, lsr #24
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f14:	06400112 	undefined
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f18:	35120000 	ldrcc	r0, [r2]
	if (sVal < s) {
     f1c:	00134900 	andseq	r4, r3, r0, lsl #18
     f20:	00211300 	eoreq	r1, r1, r0, lsl #6
     f24:	052f1349 	streq	r1, [pc, #-841]!	; be3 <__Stack_Size+0x7e3>
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f28:	34140000 	ldrcc	r0, [r4]
     f2c:	3a0e0300 	bcc	381b34 <__Stack_Size+0x381734>
     f30:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
				FemurAngle1[LegIndex], &cFemurMin1[LegIndex],
				&cFemurMax1[LegIndex]);
		TibiaAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f34:	000b1c13 	andeq	r1, fp, r3, lsl ip
     f38:	00341500 	eorseq	r1, r4, r0, lsl #10
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     f3c:	0b3a0e03 	bleq	e84750 <__Stack_Size+0xe84350>
     f40:	13490b3b 	movtne	r0, #39739	; 0x9b3b
				TibiaAngle1[LegIndex], &cTibiaMin1[LegIndex],
				&cTibiaMax1[LegIndex]);

	}
#endif
}
     f44:	0a020c3f 	beq	84048 <__Stack_Size+0x83c48>
     f48:	01000000 	tsteq	r0, r0
     f4c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     f50:	0e030b13 	vmoveq.32	d3[0], r0
     f54:	01110e1b 	tsteq	r1, fp, lsl lr
     f58:	06100112 	undefined
     f5c:	24020000 	strcs	r0, [r2]
     f60:	3e0b0b00 	fmacdcc	d0, d11, d0
     f64:	000e030b 	andeq	r0, lr, fp, lsl #6
     f68:	00160300 	andseq	r0, r6, r0, lsl #6
     f6c:	0b3a0e03 	bleq	e84780 <__Stack_Size+0xe84380>
// SmoothControl (From Zenta) -  This function makes the body
//            rotation and translation much smoother
//--------------------------------------------------------------------
short SmoothControl(short CtrlMoveInp, short CtrlMoveOut, byte CtrlDivider) {

	if (CtrlMoveOut < (CtrlMoveInp - 4))
     f70:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     f74:	24040000 	strcs	r0, [r4]
		return CtrlMoveOut + abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f78:	3e0b0b00 	fmacdcc	d0, d11, d0
     f7c:	0008030b 	andeq	r0, r8, fp, lsl #6
     f80:	00160500 	andseq	r0, r6, r0, lsl #10
     f84:	0b3a0803 	bleq	e82f98 <__Stack_Size+0xe82b98>
     f88:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     f8c:	04060000 	streq	r0, [r6]
     f90:	3a0b0b01 	bcc	2c3b9c <__Stack_Size+0x2c379c>
	else if (CtrlMoveOut > (CtrlMoveInp + 4))
     f94:	010b3b0b 	tsteq	fp, fp, lsl #22
		return CtrlMoveOut - abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f98:	07000013 	smladeq	r0, r3, r0, r0
     f9c:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
     fa0:	00000d1c 	andeq	r0, r0, ip, lsl sp
     fa4:	0b011308 	bleq	45bcc <__Stack_Size+0x457cc>
     fa8:	3b0b3a0b 	blcc	2cf7dc <__Stack_Size+0x2cf3dc>
     fac:	0013010b 	andseq	r0, r3, fp, lsl #2
     fb0:	000d0900 	andeq	r0, sp, r0, lsl #18

	return CtrlMoveInp;
}
     fb4:	0b3a0e03 	bleq	e847c8 <__Stack_Size+0xe843c8>
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
     fb8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     fbc:	00000a38 	andeq	r0, r0, r8, lsr sl
     fc0:	4901010a 	stmdbmi	r1, {r1, r3, r8}

//--------------------------------------------------------------------
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
     fc4:	00130113 	andseq	r0, r3, r3, lsl r1
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
		return g_wLegsXZLength;

	return isqrt32((LegPosX[0] * LegPosX[0]) + (LegPosZ[0] * LegPosZ[0]));
     fc8:	00210b00 	eoreq	r0, r1, r0, lsl #22
     fcc:	0b2f1349 	bleq	bc5cf8 <__Stack_Size+0xbc58f8>
     fd0:	240c0000 	strcs	r0, [ip]
     fd4:	3e0b0b00 	fmacdcc	d0, d11, d0
     fd8:	0d00000b 	stceq	0, cr0, [r0, #-44]
     fdc:	050b0113 	streq	r0, [fp, #-275]
}
     fe0:	0b3b0b3a 	bleq	ec3cd0 <__Stack_Size+0xec38d0>
     fe4:	00001301 	andeq	r1, r0, r1, lsl #6
     fe8:	03000d0e 	movweq	r0, #3342	; 0xd0e
     fec:	3b0b3a08 	blcc	2cf814 <__Stack_Size+0x2cf414>

#ifndef MAX_XZ_LEG_ADJUST
#define MAX_XZ_LEG_ADJUST   (word)(cCoxaLength[0]+cTibiaLength[0] + cFemurLength[0]/4)
#endif

void AdjustLegPositions(word XZLength1) {
     ff0:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     ff4:	0f00000a 	svceq	0x0000000a
     ff8:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
     ffc:	0b3a050b 	bleq	e82430 <__Stack_Size+0xe82030>
    1000:	13010b3b 	movwne	r0, #6971	; 0x1b3b
		XZLength1 = MAX_XZ_LEG_ADJUST;
	if (XZLength1 < MIN_XZ_LEG_ADJUST)
		XZLength1 = MIN_XZ_LEG_ADJUST;

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
    1004:	2e100000 	wxorcs	wr0, wr0, wr0
    1008:	030c3f00 	movweq	r3, #52992	; 0xcf00
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    100c:	3b0b3a0e 	blcc	2cf84c <__Stack_Size+0x2cf44c>

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
		return;

	g_wLegsXZLength = XZLength1;
    1010:	11134905 	tstne	r3, r5, lsl #18

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));
    1014:	40011201 	andmi	r1, r1, r1, lsl #4
    1018:	1100000a 	tstne	r0, sl

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
    101c:	0c3f012e 	ldfeqs	f0, [pc], #-184
    1020:	0b3a0e03 	bleq	e84834 <__Stack_Size+0xe84434>
    1024:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
    1028:	01120111 	tsteq	r2, r1, lsl r1
    102c:	13010a40 	movwne	r0, #6720	; 0x1a40
    1030:	05120000 	ldreq	r0, [r2]
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    1034:	3a0e0300 	bcc	381c3c <__Stack_Size+0x38183c>
    1038:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    103c:	00060213 	andeq	r0, r6, r3, lsl r2
    1040:	012e1300 	teqeq	lr, r0, lsl #6
    1044:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1048:	053b0b3a 	ldreq	r0, [fp, #-2874]!
		return;

	g_wLegsXZLength = XZLength1;

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    104c:	01120111 	tsteq	r2, r1, lsl r1
		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
	}

	// Make sure we cycle through one gait to have the legs all move into their new locations...
	g_InControlState.ForceGaitStepCnt = g_InControlState.gaitCur.StepsInGait;
    1050:	13010640 	movwne	r0, #5696	; 0x1640
    1054:	0b140000 	bleq	50105c <__Stack_Size+0x500c5c>
}
    1058:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
    105c:	00130101 	andseq	r0, r3, r1, lsl #2
    1060:	00341500 	eorseq	r1, r4, r0, lsl #10
    1064:	0b3a0803 	bleq	e83078 <__Stack_Size+0xe82c78>
    1068:	1349053b 	movtne	r0, #38203	; 0x953b
    106c:	00000602 	andeq	r0, r0, r2, lsl #12
    1070:	11010b16 	tstne	r1, r6, lsl fp
    1074:	00011201 	andeq	r1, r1, r1, lsl #4
    1078:	010b1700 	tsteq	fp, r0, lsl #14
		g_InControlState.aCoxaInitAngle1[LegIndex] = (short)pgm_read_word(&cCoxaAngle1[LegIndex]);
#endif
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    107c:	00000655 	andeq	r0, r0, r5, asr r6
		else if (g_InControlState.aCoxaInitAngle1[LegIndex] < -700)
		g_InControlState.aCoxaInitAngle1[LegIndex] = -700;
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    1080:	03003418 	movweq	r3, #1048	; 0x418
//     to be appropriate for the current y location of the body...
//--------------------------------------------------------------------

u8 g_iLegInitIndex = 0x00; // remember which index we are currently using...

void AdjustLegPositionsToBodyHeight() {
    1084:	3b0b3a08 	blcc	2cf8ac <__Stack_Size+0x2cf4ac>
    1088:	02134905 	andseq	r4, r3, #81920	; 0x14000
#ifdef CNT_HEX_INITS
	// Lets see which of our units we should use...
	// Note: We will also limit our body height here...
	if (g_InControlState.BodyPos.y
    108c:	1900000a 	stmdbne	r0, {r1, r3}
			> (short) pgm_read_byte(&g_abHexMaxBodyY[CNT_HEX_INITS-1]))
		g_InControlState.BodyPos.y = (short) pgm_read_byte(
    1090:	0c3f002e 	ldceq	0, cr0, [pc], #-184
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    1094:	0b3a0e03 	bleq	e848a8 <__Stack_Size+0xe844a8>
    1098:	1349053b 	movtne	r0, #38203	; 0x953b
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    109c:	01120111 	tsteq	r2, r1, lsl r1
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    10a0:	00000640 	andeq	r0, r0, r0, asr #12
    10a4:	3f012e1a 	svccc	0x00012e1a
    10a8:	3a0e030c 	bcc	381ce0 <__Stack_Size+0x3818e0>
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    10ac:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
		g_iLegInitIndex = i;  // remember the current index...
		AdjustLegPositions(XZLength1);
    10b0:	1113490c 	tstne	r3, ip, lsl #18
	}
#endif // CNT_HEX_INITS
}
    10b4:	40011201 	andmi	r1, r1, r1, lsl #4
    10b8:	00130106 	andseq	r0, r3, r6, lsl #2
    10bc:	00341b00 	eorseq	r1, r4, r0, lsl #22
}
//--------------------------------------------------------------------
//[CHECK VOLTAGE]
//Reads the input voltage and shuts down the bot when the power drops
byte s_bLVBeepCnt;
boolean CheckVoltage() {
    10c0:	0b3a0e03 	bleq	e848d4 <__Stack_Size+0xe844d4>
    10c4:	1349053b 	movtne	r0, #38203	; 0x953b
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10c8:	00000602 	andeq	r0, r0, r2, lsl #12

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10cc:	3f012e1c 	svccc	0x00012e1c
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d0:	3a0e030c 	bcc	381d08 <__Stack_Size+0x381908>

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10d4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004

	if (!g_fLowVoltageShutdown) {
		/**PrintString("Voltage : ");
		Printu32d(Voltage);
		PrintString("\n");*/
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {
    10dc:	01064001 	tsteq	r6, r1
    10e0:	1d000013 	stcne	0, cr0, [r0, #-76]
    10e4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}


			//Turn off
			g_InControlState.BodyPos.x = 0;
    10e8:	053b0b3a 	ldreq	r0, [fp, #-2874]!
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;

#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
    10ec:	0a021349 	beq	85e18 <__Stack_Size+0x85a18>
    10f0:	341e0000 	ldrcc	r0, [lr]
#endif
			g_fLowVoltageShutdown = 1;
    10f4:	3a080300 	bcc	201cfc <__Stack_Size+0x2018fc>
			s_bLVBeepCnt = 0;    // how many times we beeped...
    10f8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {


			//Turn off
			g_InControlState.BodyPos.x = 0;
			g_InControlState.BodyPos.y = 0;
    10fc:	1f000013 	svcne	0x00000013
			g_InControlState.BodyPos.z = 0;
			g_InControlState.BodyRot1.x = 0;
    1100:	0c3f012e 	ldfeqs	f0, [pc], #-184
			g_InControlState.BodyRot1.y = 0;
			g_InControlState.BodyRot1.z = 0;
    1104:	0b3a0e03 	bleq	e84918 <__Stack_Size+0xe84518>
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;
    1108:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
#endif
			g_fLowVoltageShutdown = 1;
			s_bLVBeepCnt = 0;    // how many times we beeped...
    110c:	01120111 	tsteq	r2, r1, lsl r1
			g_InControlState.fRobotOn = false;
    1110:	13010640 	movwne	r0, #5696	; 0x1640
		}
#ifdef cTurnOnVol
	} else if ((Voltage > cTurnOnVol) && (Voltage < 1999)) {
    1114:	0f200000 	svceq	0x00200000
    1118:	490b0b00 	stmdbmi	fp, {r8, r9, fp}

		g_fLowVoltageShutdown = 0;
    111c:	21000013 	tstcs	r0, r3, lsl r0
    1120:	13490026 	movtne	r0, #36902	; 0x9026

#endif
	} else {
		if (s_bLVBeepCnt < 5) {
    1124:	34220000 	strtcc	r0, [r2]
    1128:	3a0e0300 	bcc	381d30 <__Stack_Size+0x381930>
			s_bLVBeepCnt++;
    112c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}

			//MSound( 1, 45, 2000);
			Buzzed(45, 2000);
    1130:	23000013 	movwcs	r0, #19	; 0x13
    1134:	0655010b 	ldrbeq	r0, [r5], -fp, lsl #2
    1138:	00001301 	andeq	r1, r0, r1, lsl #6
		}
		mDelay(2000);
    113c:	3f012e24 	svccc	0x00012e24
    1140:	3a0e030c 	bcc	381d78 <__Stack_Size+0x381978>
    1144:	110b3b0b 	tstne	fp, fp, lsl #22
	}
#endif

	return g_fLowVoltageShutdown;
}
    1148:	40011201 	andmi	r1, r1, r1, lsl #4
    114c:	00130106 	andseq	r0, r3, r6, lsl #2
    1150:	00342500 	eorseq	r2, r4, r0, lsl #10
    1154:	0b3a0803 	bleq	e83168 <__Stack_Size+0xe82d68>
    1158:	13490b3b 	movtne	r0, #39739	; 0x9b3b

//==============================================================================
// BackgroundProcess - Allows us to have some background processing for those
//    servo drivers that need us to do things like polling...
//==============================================================================
void BackgroundProcess(void) {
    115c:	00000602 	andeq	r0, r0, r2, lsl #12
    1160:	03003426 	movweq	r3, #1062	; 0x426
	if (g_fAXSpeedControl)
    1164:	3b0b3a0e 	blcc	2cf9a4 <__Stack_Size+0x2cf5a4>
		return;  // nothing to do in this mode...

	if (ServosEnabled) {
		//DebugToggle(A3);
		BioloidControllerEx_interpolateStep(false); // Do our background stuff...
    1168:	0013490b 	andseq	r4, r3, fp, lsl #18
		Battery_Monitor_Alarm();
    116c:	00352700 	eorseq	r2, r5, r0, lsl #14
	}
}
    1170:	00001349 	andeq	r1, r0, r9, asr #6
    1174:	49002128 	stmdbmi	r0, {r3, r5, r8, sp}
//Function that gets called from the main loop if the robot is not logically
//     on.  Gives us a chance to play some...
//--------------------------------------------------------------------
static u8 g_iIdleServoNum = (u8) - 1;
static u8 g_iIdleLedState = 1;  // what state to we wish to set...
void IdleTime(void) {
    1178:	00052f13 	andeq	r2, r5, r3, lsl pc
    117c:	00342900 	eorseq	r2, r4, r0, lsl #18
	// Each time we call this set servos LED on or off...
	g_iIdleServoNum++;
    1180:	0b3a0e03 	bleq	e84994 <__Stack_Size+0xe84594>
	if (g_iIdleServoNum >= NUMSERVOS) {
    1184:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1188:	00000b1c 	andeq	r0, r0, ip, lsl fp
		g_iIdleServoNum = 0;
    118c:	0300342a 	movweq	r3, #1066	; 0x42a
		g_iIdleLedState = 1 - g_iIdleLedState;
    1190:	3b0b3a0e 	blcc	2cf9d0 <__Stack_Size+0x2cf5d0>
    1194:	3f13490b 	svccc	0x0013490b
	}
	dxl_write_byte(pgm_read_byte(&cPinTable[g_iIdleServoNum]), AXM_LED,
    1198:	000c3c0c 	andeq	r3, ip, ip, lsl #24
    119c:	00342b00 	eorseq	r2, r4, r0, lsl #22
    11a0:	0b3a0e03 	bleq	e849b4 <__Stack_Size+0xe845b4>
    11a4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    11a8:	0a020c3f 	beq	842ac <__Stack_Size+0x83eac>
			g_iIdleLedState);
	//ax12ReadPacket(6);  // get the response...


}
    11ac:	0f2c0000 	svceq	0x002c0000
    11b0:	000b0b00 	andeq	r0, fp, r0, lsl #22
    11b4:	11010000 	tstne	r1, r0
    11b8:	130e2501 	movwne	r2, #58625	; 0xe501

//--------------------------------------------------------------------
//[SetRegOnAllServos] Function that is called to set the state of one
//  register in all of the servos, like Torque on...
//--------------------------------------------------------------------
void SetRegOnAllServos(u8 bReg, u8 bVal) {
    11bc:	1b0e030b 	blne	381df0 <__Stack_Size+0x3819f0>
    11c0:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
    11c4:	00061001 	andeq	r1, r6, r1
	 ax12write(bVal);

  }
  ax12write(0xff - (checksum % 256));
  setRX(0);*/
	 dxl_set_txpacket_id (BROADCAST_ID);
    11c8:	00240200 	eoreq	r0, r4, r0, lsl #4
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    11cc:	0b3e0b0b 	bleq	f83e00 <__Stack_Size+0xf83a00>
	dxl_set_txpacket_parameter(0,bReg);
    11d0:	00000e03 	andeq	r0, r0, r3, lsl #28
    11d4:	03001603 	movweq	r1, #1539	; 0x603
	dxl_set_txpacket_parameter(1,2);
    11d8:	3b0b3a0e 	blcc	2cfa18 <__Stack_Size+0x2cf618>
    11dc:	0013490b 	andseq	r4, r3, fp, lsl #18
    11e0:	00240400 	eoreq	r0, r4, r0, lsl #8
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
    11e4:	0b3e0b0b 	bleq	f83e18 <__Stack_Size+0xf83a18>
    11e8:	00000803 	andeq	r0, r0, r3, lsl #16
    11ec:	49003505 	stmdbmi	r0, {r0, r2, r8, sl, ip, sp}
    11f0:	06000013 	undefined
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    11f4:	0b0b0104 	bleq	2c160c <__Stack_Size+0x2c120c>
    11f8:	0b3b0b3a 	bleq	ec3ee8 <__Stack_Size+0xec3ae8>
    11fc:	00001301 	andeq	r1, r0, r1, lsl #6
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1200:	03002807 	movweq	r2, #2055	; 0x807
    1204:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    1208:	01010800 	tsteq	r1, r0, lsl #16
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    120c:	13011349 	movwne	r1, #4937	; 0x1349
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1210:	21090000 	tstcs	r9, r0
	 dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0,bReg);
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
    1214:	2f134900 	svccs	0x00134900
    1218:	0a00000b 	beq	124c <__Stack_Size+0xe4c>
    121c:	0b0b0024 	bleq	2c12b4 <__Stack_Size+0x2c0eb4>
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
	}

	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
    1220:	00000b3e 	andeq	r0, r0, lr, lsr fp
    1224:	0300340b 	movweq	r3, #1035	; 0x40b
    1228:	3b0b3a0e 	blcc	2cfa68 <__Stack_Size+0x2cf668>
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- SetRegOnAllServos ---\n");
#endif
	dxl_txrx_packet();
    122c:	3f13490b 	svccc	0x0013490b

	u16 CommStatus = dxl_get_result();
    1230:	000a020c 	andeq	r0, sl, ip, lsl #4
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
    1234:	00260c00 	eoreq	r0, r6, r0, lsl #24
		PrintErrorCode();
    1238:	00001349 	andeq	r1, r0, r9, asr #6
	else
		PrintCommStatus(CommStatus);
    123c:	0b000f0d 	bleq	4e78 <__Stack_Size+0x4a78>
#endif
}
    1240:	0013490b 	andseq	r4, r3, fp, lsl #18
    1244:	11010000 	tstne	r1, r0
    1248:	130e2501 	movwne	r2, #58625	; 0xe501
//--------------------------------------------------------------------
//[MakeSureServosAreOn] Function that is called to handle when you are
//  transistioning from servos all off to being on.  May need to read
//  in the current pose...
//--------------------------------------------------------------------
void MakeSureServosAreOn(void) {
    124c:	1b0e030b 	blne	381e80 <__Stack_Size+0x381a80>

	if (ServosEnabled) {

		if (!g_fServosFree)
    1250:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
			return;    // we are not free

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {
    1254:	00061001 	andeq	r1, r6, r1
    1258:	00240200 	eoreq	r0, r4, r0, lsl #4

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
    125c:	0b3e0b0b 	bleq	f83e90 <__Stack_Size+0xf83a90>
    1260:	00000e03 	andeq	r0, r0, r3, lsl #28
    1264:	03001603 	movweq	r1, #1539	; 0x603
    1268:	3b0b3a0e 	blcc	2cfaa8 <__Stack_Size+0x2cf6a8>
						AXM_PRESENT_POSITION_L);
				mDelay(25);
    126c:	0013490b 	andseq	r4, r3, fp, lsl #18
    1270:	00240400 	eoreq	r0, r4, r0, lsl #8

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
    1274:	0b3e0b0b 	bleq	f83ea8 <__Stack_Size+0xf83aa8>
    1278:	00000803 	andeq	r0, r0, r3, lsl #16
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
						AXM_PRESENT_POSITION_L);
				mDelay(25);
			}
		} else {
			BioloidControllerEx_readPose();
    127c:	03001605 	movweq	r1, #1541	; 0x605
		}

		SetRegOnAllServos(AXM_TORQUE_ENABLE, 1);  // Use sync write to do it.
    1280:	3b0b3a08 	blcc	2cfaa8 <__Stack_Size+0x2cf6a8>
    1284:	0013490b 	andseq	r4, r3, fp, lsl #18

		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = false;
    1288:	01040600 	tsteq	r4, r0, lsl #12
	}

}
    128c:	0b3a0b0b 	bleq	e83ec0 <__Stack_Size+0xe83ac0>
    1290:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    1294:	28070000 	stmdacs	r7, {}
    1298:	1c0e0300 	stcne	3, cr0, [lr], {0}
    129c:	0800000d 	stmdaeq	r0, {r0, r2, r3}

//------------------------------------------------------------------------------------------
//[BeginServoUpdate] Does whatever preperation that is needed to starrt a move of our servos
//------------------------------------------------------------------------------------------
void BeginServoUpdate(void)    // Start the update
		{
    12a0:	0b0b0024 	bleq	2c1338 <__Stack_Size+0x2c0f38>

	MakeSureServosAreOn();
    12a4:	00000b3e 	andeq	r0, r0, lr, lsr fp
	if (ServosEnabled) {

		if (g_fAXSpeedControl) {
    12a8:	3f012e09 	svccc	0x00012e09
    12ac:	3a0e030c 	bcc	381ee4 <__Stack_Size+0x381ae4>

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awCurAXPos[i] = g_awGoalAXPos[i];
    12b0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    12b4:	1113490c 	tstne	r3, ip, lsl #18
    12b8:	40011201 	andmi	r1, r1, r1, lsl #4
		if (g_fAXSpeedControl) {

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
    12bc:	0013010a 	andseq	r0, r3, sl, lsl #2
				g_awCurAXPos[i] = g_awGoalAXPos[i];
			}
#endif
		} else
			BioloidControllerEx_interpolateStep(true); // Make sure we call at least once
    12c0:	00050a00 	andeq	r0, r5, r0, lsl #20
    12c4:	0b3a0e03 	bleq	e84ad8 <__Stack_Size+0xe846d8>

	}
}
    12c8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    12cc:	00000602 	andeq	r0, r0, r2, lsl #12
    12d0:	0300050b 	movweq	r0, #1291	; 0x50b
    12d4:	3b0b3a0e 	blcc	2cfb14 <__Stack_Size+0x2cf714>
}

//--------------------------------------------------------------------
//[FREE SERVOS] Frees all the servos
//--------------------------------------------------------------------
void FreeServos(void) {
    12d8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    12dc:	0c00000a 	stceq	0, cr0, [r0], {10}

	if (!g_fServosFree) {
    12e0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
    12e4:	0b3b0b3a 	bleq	ec3fd4 <__Stack_Size+0xec3bd4>
    12e8:	00001349 	andeq	r1, r0, r9, asr #6
    12ec:	0300340d 	movweq	r3, #1037	; 0x40d
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
			Relax(pgm_read_byte(&cPinTable[i]));
    12f0:	3b0b3a0e 	blcc	2cfb30 <__Stack_Size+0x2cf730>
    12f4:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    12f8:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}

	if (!g_fServosFree) {
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
    12fc:	0c3f012e 	ldfeqs	f0, [pc], #-184
			Relax(pgm_read_byte(&cPinTable[i]));
		}
		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = true;
    1300:	0b3a0e03 	bleq	e84b14 <__Stack_Size+0xe84714>
	}
}
    1304:	0c270b3b 	stceq	11, cr0, [r7], #-236
    1308:	01120111 	tsteq	r2, r1, lsl r1
    130c:	13010640 	movwne	r0, #5696	; 0x1640
extern void SetRegOnAllServos(u8 bReg, u8 bVal);

//--------------------------------------------------------------------
//Init
//--------------------------------------------------------------------
void Servo_Init(void) {
    1310:	340f0000 	strcc	r0, [pc], #0	; 1318 <__Stack_Size+0xf18>
	// First lets get the actual servo positions for all of our servos...
	//pinMode(0, OUTPUT);
	g_fServosFree = true;
    1314:	3a080300 	bcc	201f1c <__Stack_Size+0x201b1c>

  poseSize = NUMSERVOS;
    1318:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    131c:	10000013 	andne	r0, r0, r3, lsl r0
  BioloidControllerEx_readPose();
    1320:	0b0b000f 	bleq	2c1364 <__Stack_Size+0x2c0f64>
#ifdef cVoltagePin
	for (byte i=0; i < 8; i++)
	GetBatteryVoltage();  // init the voltage pin
#endif

	g_fAXSpeedControl = false;
    1324:	00001349 	andeq	r1, r0, r9, asr #6
    1328:	3f012e11 	svccc	0x00012e11



	// Added - try to speed things up later if we do a query...
	SetRegOnAllServos(AXM_RETURN_DELAY_TIME, 0); // tell servos to give us back their info as quick as they can...
    132c:	3a0e030c 	bcc	381f64 <__Stack_Size+0x381b64>
    1330:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]

}
    1334:	1201110c 	andne	r1, r1, #3	; 0x3
    1338:	010a4001 	tsteq	sl, r1
    133c:	12000013 	andne	r0, r0, #19	; 0x13
    1340:	0655010b 	ldrbeq	r0, [r5], -fp, lsl #2

}

void setupPhoenix() {

	g_fShowDebugPrompt = true;
    1344:	34130000 	ldrcc	r0, [r3]
void readSensors(){


}

void setupPhoenix() {
    1348:	3a080300 	bcc	201f50 <__Stack_Size+0x201b50>

	g_fShowDebugPrompt = true;
	g_fDebugOutput = false;
    134c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1350:	14000013 	strne	r0, [r0], #-19
	//init BioloidEx
	BioloidControllerEx();
    1354:	0c3f012e 	ldfeqs	f0, [pc], #-184

	// Init our ServoDriver
	Servo_Init();
    1358:	0b3a0e03 	bleq	e84b6c <__Stack_Size+0xe8476c>

	mDelay(10);
    135c:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1360:	01111349 	tsteq	r1, r9, asr #6
    1364:	0a400112 	beq	10017b4 <__Stack_Size+0x10013b4>
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    1368:	00001301 	andeq	r1, r0, r1, lsl #6
    136c:	03000515 	movweq	r0, #1301	; 0x515
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1370:	3b0b3a08 	blcc	2cfb98 <__Stack_Size+0x2cf798>

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1374:	02134905 	andseq	r4, r3, #81920	; 0x14000
    1378:	16000006 	strne	r0, [r0], -r6
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    137c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1380:	053b0b3a 	ldreq	r0, [fp, #-2874]!
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1384:	0a021349 	beq	860b0 <__Stack_Size+0x85cb0>
    1388:	2e170000 	wxorcs	wr0, wr7, wr0
    138c:	030c3f00 	movweq	r3, #52992	; 0xcf00
	Servo_Init();

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1390:	3b0b3a0e 	blcc	2cfbd0 <__Stack_Size+0x2cf7d0>
    1394:	11134905 	tstne	r3, r5, lsl #18
    1398:	40011201 	andmi	r1, r1, r1, lsl #4

	ResetLegInitAngles();

	//Single leg control. Make sure no leg is selected
#ifdef OPT_SINGLELEG
	g_InControlState.SelectedLeg = 255; // No Leg selected
    139c:	1800000a 	stmdane	r0, {r1, r3}
    13a0:	0c3f012e 	ldfeqs	f0, [pc], #-184
	g_InControlState.PrevSelectedLeg = 255;
    13a4:	0b3a0e03 	bleq	e84bb8 <__Stack_Size+0xe847b8>
#endif
	//Body Positions
	g_InControlState.BodyPos.x = 0;
    13a8:	0111053b 	tsteq	r1, fp, lsr r5
	g_InControlState.BodyPos.y = 0;
	g_InControlState.BodyPos.z = 0;
    13ac:	06400112 	undefined

//Body Rotations
	g_InControlState.BodyRot1.x = 0;
	g_InControlState.BodyRot1.y = 0;
    13b0:	00001301 	andeq	r1, r0, r1, lsl #6
	g_InControlState.BodyRot1.z = 0;
	g_InControlState.BodyRotOffset.x = 0;
    13b4:	03003419 	movweq	r3, #1049	; 0x419
	g_InControlState.BodyRotOffset.y = 0; //Input Y offset value to adjust centerpoint of rotation
	g_InControlState.BodyRotOffset.z = 0;
    13b8:	3b0b3a0e 	blcc	2cfbf8 <__Stack_Size+0x2cf7f8>

	//Gait
	g_InControlState.GaitType = 0;
    13bc:	02134905 	andseq	r4, r3, #81920	; 0x14000
	g_InControlState.BalanceMode = 0;
    13c0:	1a00000a 	bne	13f0 <__Stack_Size+0xff0>
	g_InControlState.LegLiftHeight = 50;
	g_InControlState.ForceGaitStepCnt = 0; // added to try to adjust starting positions depending on height...
    13c4:	08030034 	stmdaeq	r3, {r2, r4, r5}
	g_InControlState.GaitStep = 1;
    13c8:	053b0b3a 	ldreq	r0, [fp, #-2874]!
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    13cc:	06021349 	streq	r1, [r2], -r9, asr #6
	g_InControlState.BodyRotOffset.z = 0;

	//Gait
	g_InControlState.GaitType = 0;
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
    13d0:	341b0000 	ldrcc	r0, [fp]
    13d4:	3a0e0300 	bcc	381fdc <__Stack_Size+0x381bdc>
void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    13d8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    13dc:	00060213 	andeq	r0, r6, r3, lsl r2
    13e0:	010b1c00 	tsteq	fp, r0, lsl #24
//==============================================================================

// If both PS2 and XBee are defined then we will become secondary to the xbee
void CommanderInputController_Init(void) {

	g_BodyYOffset = 0;
    13e4:	01120111 	tsteq	r2, r1, lsl r1
    13e8:	00001301 	andeq	r1, r0, r1, lsl #6
    13ec:	0300341d 	movweq	r3, #1053	; 0x41d
	g_BodyYShift = 0;
	//begin(XBEE_BAUD);
	GPSeq = 0;  // init to something...
    13f0:	3b0b3a0e 	blcc	2cfc30 <__Stack_Size+0x2cf830>
    13f4:	00134905 	andseq	r4, r3, r5, lsl #18

	ControlMode = WALKMODE;
    13f8:	01011e00 	tsteq	r1, r0, lsl #28
	HeightSpeedMode = NORM_NORM;
    13fc:	13011349 	movwne	r1, #4937	; 0x1349
	//    DoubleHeightOn = false;
	DoubleTravelOn = false;
    1400:	211f0000 	tstcs	pc, r0
	bJoystickWalkMode = 0;
    1404:	2f134900 	svccs	0x00134900
	GaitSelect();

	CommanderInputController_Init();

	// Servo Driver
	ServoMoveTime = 150;
    1408:	2000000b 	andcs	r0, r0, fp
	g_InControlState.fRobotOn = 0;
    140c:	13490026 	movtne	r0, #36902	; 0x9026
	g_fLowVoltageShutdown = false;
    1410:	2e210000 	cdpcs	0, 2, cr0, cr1, cr0, {0}

}
    1414:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1418:	3b0b3a0e 	blcc	2cfc58 <__Stack_Size+0x2cf858>
    141c:	110c2705 	tstne	ip, r5, lsl #14
    1420:	40011201 	andmi	r1, r1, r1, lsl #4
    1424:	00130106 	andseq	r0, r3, r6, lsl #2
    1428:	00052200 	andeq	r2, r5, r0, lsl #4
    142c:	0b3a0e03 	bleq	e84c40 <__Stack_Size+0xe84840>
    1430:	1349053b 	movtne	r0, #38203	; 0x953b
    1434:	00000602 	andeq	r0, r0, r2, lsl #12
    1438:	3f012e23 	svccc	0x00012e23
    143c:	3a0e030c 	bcc	382074 <__Stack_Size+0x381c74>
    1440:	110b3b0b 	tstne	fp, fp, lsl #22
    1444:	40011201 	andmi	r1, r1, r1, lsl #4
    1448:	00130106 	andseq	r0, r3, r6, lsl #2
    144c:	00342400 	eorseq	r2, r4, r0, lsl #8
    1450:	0b3a0e03 	bleq	e84c64 <__Stack_Size+0xe84864>
    1454:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1458:	00000a02 	andeq	r0, r0, r2, lsl #20
    145c:	03003425 	movweq	r3, #1061	; 0x425
    1460:	3b0b3a08 	blcc	2cfc88 <__Stack_Size+0x2cf888>
    1464:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
//[CommitServoDriver Updates the positions of the servos - This outputs
//         as much of the command as we can without committing it.  This
//         allows us to once the previous update was completed to quickly
//        get the next command to start
//--------------------------------------------------------------------
void CommitServoDriver(word wMoveTime) {
    1468:	2600000a 	strcs	r0, [r0], -sl
    146c:	0c3f012e 	ldfeqs	f0, [pc], #-184
    1470:	0b3a0e03 	bleq	e84c84 <__Stack_Size+0xe84884>


	CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1474:	0c270b3b 	stceq	11, cr0, [r7], #-236

      }
      ax12write(0xff - (checksum % 256));
      setRX(0);
*/
  	    dxl_set_txpacket_id (BROADCAST_ID);
    1478:	01111349 	tsteq	r1, r9, asr #6
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    147c:	06400112 	undefined
    1480:	00001301 	andeq	r1, r0, r1, lsl #6
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
    1484:	55010b27 	strpl	r0, [r1, #-2855]
    1488:	00130106 	andseq	r0, r3, r6, lsl #2
		dxl_set_txpacket_parameter(1, 2);
    148c:	00342800 	eorseq	r2, r4, r0, lsl #16
    1490:	0b3a0803 	bleq	e834a4 <__Stack_Size+0xe830a4>
    1494:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1498:	00000602 	andeq	r0, r0, r2, lsl #12
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
			wSpeed = CalculateAX12MoveSpeed(g_awCurAXPos[i], g_awGoalAXPos[i], wMoveTime);    // What order should we store these values?
    149c:	3f002e29 	svccc	0x00002e29
    14a0:	3a0e030c 	bcc	3820d8 <__Stack_Size+0x381cd8>
    14a4:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    14a8:	1201110c 	andne	r1, r1, #3	; 0x3
			//dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
			byte id = pgm_read_byte(&cPinTable[i]);
			dxl_set_txpacket_parameter(2 + 3 * i, id);
    14ac:	00064001 	andeq	r4, r6, r1
    14b0:	00352a00 	eorseq	r2, r5, r0, lsl #20
    14b4:	00001349 	andeq	r1, r0, r9, asr #6
    14b8:	4900212b 	stmdbmi	r0, {r0, r1, r3, r5, r8, sp}
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(g_awGoalAXPos[i]));
    14bc:	00052f13 	andeq	r2, r5, r3, lsl pc
    14c0:	00342c00 	eorseq	r2, r4, r0, lsl #24
    14c4:	0b3a0e03 	bleq	e84cd8 <__Stack_Size+0xe848d8>
    14c8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    14cc:	00000b1c 	andeq	r0, r0, ip, lsl fp
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
    14d0:	0300342d 	movweq	r3, #1069	; 0x42d
    14d4:	3b0b3a0e 	blcc	2cfd14 <__Stack_Size+0x2cf914>
    14d8:	3f13490b 	svccc	0x0013490b
    14dc:	000c3c0c 	andeq	r3, ip, ip, lsl #24
    14e0:	00342e00 	eorseq	r2, r4, r0, lsl #28
    14e4:	0b3a0e03 	bleq	e84cf8 <__Stack_Size+0xe848f8>
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
    14e8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    14ec:	0a020c3f 	beq	845f0 <__Stack_Size+0x841f0>
    14f0:	01000000 	tsteq	r0, r0
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
    14f4:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    14f8:	0e030b13 	vmoveq.32	d3[0], r0
    14fc:	01110e1b 	tsteq	r1, fp, lsl lr
    1500:	06100112 	undefined
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
		dxl_set_txpacket_parameter(1, 2);
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
    1504:	24020000 	strcs	r0, [r2]
    1508:	3e0b0b00 	fmacdcc	d0, d11, d0
    150c:	000e030b 	andeq	r0, lr, fp, lsl #6
    1510:	00160300 	andseq	r0, r6, r0, lsl #6
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
		}

		dxl_set_txpacket_length((4 + 1) * poseSize + 4);
    1514:	0b3a0e03 	bleq	e84d28 <__Stack_Size+0xe84928>
    1518:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    151c:	24040000 	strcs	r0, [r4]
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- CommitServoDriver ---\n");
#endif
		dxl_txrx_packet();
    1520:	3e0b0b00 	fmacdcc	d0, d11, d0

			u16 CommStatus = dxl_get_result();
    1524:	0008030b 	andeq	r0, r8, fp, lsl #6
#ifdef USING_PC_UART
			if (CommStatus == DXL_RXSUCCESS)
    1528:	00160500 	andseq	r0, r6, r0, lsl #10
				PrintErrorCode();
    152c:	0b3a0803 	bleq	e83540 <__Stack_Size+0xe83140>
			else
				PrintCommStatus(CommStatus);
    1530:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1534:	24060000 	strcs	r0, [r6]
#endif
#endif
		} else {
			BioloidControllerEx_interpolateSetup(wMoveTime);
    1538:	3e0b0b00 	fmacdcc	d0, d11, d0

	}

	CommanderInputController_AllowControllerInterrupts(true);

}
    153c:	0700000b 	streq	r0, [r0, -fp]
    1540:	0c3f012e 	ldfeqs	f0, [pc], #-184
    1544:	0b3a0e03 	bleq	e84d58 <__Stack_Size+0xe84958>
    1548:	0c270b3b 	stceq	11, cr0, [r7], #-236
    154c:	01120111 	tsteq	r2, r1, lsl r1
    1550:	13010a40 	movwne	r0, #6720	; 0x1a40
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    1554:	05080000 	streq	r0, [r8]
    1558:	3a0e0300 	bcc	382160 <__Stack_Size+0x381d60>
    155c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1560:	000a0213 	andeq	r0, sl, r3, lsl r2
    1564:	002e0900 	eoreq	r0, lr, r0, lsl #18


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1568:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    156c:	0b3b0b3a 	bleq	ec425c <__Stack_Size+0xec3e5c>
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1570:	01111349 	tsteq	r1, r9, asr #6
    1574:	0a400112 	beq	10019c4 <__Stack_Size+0x10015c4>
    1578:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    157c:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1580:	3b0b3a0e 	blcc	2cfdc0 <__Stack_Size+0x2cf9c0>
    1584:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1588:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    158c:	010a4001 	tsteq	sl, r1
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1590:	0b000013 	bleq	15e4 <__Stack_Size+0x11e4>
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1594:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    1598:	0b3b0b3a 	bleq	ec4288 <__Stack_Size+0xec3e88>

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
    159c:	06021349 	streq	r1, [r2], -r9, asr #6
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    15a0:	2e0c0000 	cdpcs	0, 0, cr0, cr12, cr0, {0}
			g_awGoalAXPos[FIRSTTIBIAPIN + LegIndex] = wTibiaSDV;
    15a4:	030c3f01 	movweq	r3, #52993	; 0xcf01
    15a8:	3b0b3a0e 	blcc	2cfde8 <__Stack_Size+0x2cf9e8>
    15ac:	1201110b 	andne	r1, r1, #-1073741822	; 0xc0000002

#endif
		} else {
			BioloidControllerEx_setNextPose(
    15b0:	01064001 	tsteq	r6, r1
    15b4:	0d000013 	stceq	0, cr0, [r0, #-76]
					pgm_read_byte(&cPinTable[FIRSTCOXAPIN + LegIndex]),
					wCoxaSDV);
			BioloidControllerEx_setNextPose(
    15b8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    15bc:	0b3b0b3a 	bleq	ec42ac <__Stack_Size+0xec3eac>
    15c0:	00001349 	andeq	r1, r0, r9, asr #6
					pgm_read_byte(&cPinTable[FIRSTFEMURPIN + LegIndex]),
					wFemurSDV);
			BioloidControllerEx_setNextPose(
    15c4:	4900350e 	stmdbmi	r0, {r1, r2, r3, r8, sl, ip, sp}
    15c8:	0f000013 	svceq	0x00000013
					wTibiaSDV);

		}
	}
	CommanderInputController_AllowControllerInterrupts(true); // Ok for hserial again...
}
    15cc:	13490101 	movtne	r0, #37121	; 0x9101
    15d0:	00001301 	andeq	r1, r0, r1, lsl #6
    15d4:	49002110 	stmdbmi	r0, {r4, r8, sp}
    15d8:	00052f13 	andeq	r2, r5, r3, lsl pc
    15dc:	00341100 	eorseq	r1, r4, r0, lsl #2

void StartUpdateServos() {
    15e0:	0b3a0e03 	bleq	e84df4 <__Stack_Size+0xe849f4>
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update
    15e4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    15e8:	00000b1c 	andeq	r0, r0, ip, lsl fp
    15ec:	49002112 	stmdbmi	r0, {r1, r4, r8, sp}

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		OutputServoInfoForLeg(LegIndex,
    15f0:	000b2f13 	andeq	r2, fp, r3, lsl pc
    15f4:	00341300 	eorseq	r1, r4, r0, lsl #6
    15f8:	0b3a0e03 	bleq	e84e0c <__Stack_Size+0xe84a0c>
    15fc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1600:	00000a02 	andeq	r0, r0, r2, lsl #20
    1604:	03003414 	movweq	r3, #1044	; 0x414
    1608:	3b0b3a0e 	blcc	2cfe48 <__Stack_Size+0x2cfa48>
    160c:	3f13490b 	svccc	0x0013490b
    1610:	000c3c0c 	andeq	r3, ip, ip, lsl #24
    1614:	11010000 	tstne	r1, r0
    1618:	130e2501 	movwne	r2, #58625	; 0xe501
    161c:	1b0e030b 	blne	382250 <__Stack_Size+0x381e50>
    1620:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
    1624:	00061001 	andeq	r1, r6, r1
    1628:	00240200 	eoreq	r0, r4, r0, lsl #4
    162c:	0b3e0b0b 	bleq	f84260 <__Stack_Size+0xf83e60>
    1630:	00000e03 	andeq	r0, r0, r3, lsl #28
    1634:	03001603 	movweq	r1, #1539	; 0x603
    1638:	3b0b3a08 	blcc	2cfe60 <__Stack_Size+0x2cfa60>
    163c:	0013490b 	andseq	r4, r3, fp, lsl #18
    1640:	00350400 	eorseq	r0, r5, r0, lsl #8
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1644:	00001349 	andeq	r1, r0, r9, asr #6
				cTibiaInv[LegIndex] ?
						-TibiaAngle1[LegIndex] : TibiaAngle1[LegIndex]);

	}

}
    1648:	0b010405 	bleq	42664 <__Stack_Size+0x42264>
    164c:	3b0b3a0b 	blcc	2cfe80 <__Stack_Size+0x2cfa80>
    1650:	0013010b 	andseq	r0, r3, fp, lsl #2
    1654:	00280600 	eoreq	r0, r8, r0, lsl #12
    1658:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
    165c:	13070000 	movwne	r0, #28672	; 0x7000
    1660:	3a0b0b01 	bcc	2c426c <__Stack_Size+0x2c3e6c>
#else
word g_wLastVoltage = 0xffff;    // save the last voltage we retrieved...
byte g_bLegVoltage = 0;		// what leg did we last check?
unsigned long g_ulTimeLastBatteryVoltage;
#define VOLTAGE_REPEAT_MAX  3
word GetBatteryVoltage(void) {
    1664:	010b3b0b 	tsteq	fp, fp, lsl #22
	if (interpolating && (g_wLastVoltage != 0xffff)
    1668:	08000013 	stmdaeq	r0, {r0, r1, r4}
    166c:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    1670:	0b3b0b3a 	bleq	ec4360 <__Stack_Size+0xec3f60>
    1674:	0a381349 	beq	e063a0 <__Stack_Size+0xe05fa0>
    1678:	0d090000 	stceq	0, cr0, [r9]
    167c:	3a0e0300 	bcc	382284 <__Stack_Size+0x381e84>
    1680:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1684:	000a3813 	andeq	r3, sl, r3, lsl r8
			&& ((getMillis() - g_ulTimeLastBatteryVoltage)
					< VOLTAGE_MAX_TIME_BETWEEN_CALLS))
		return g_wLastVoltage;
    1688:	00240a00 	eoreq	r0, r4, r0, lsl #20

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
    168c:	0b3e0b0b 	bleq	f842c0 <__Stack_Size+0xf83ec0>
    1690:	130b0000 	movwne	r0, #45056	; 0xb000
    1694:	3a0b0b01 	bcc	2c42a0 <__Stack_Size+0x2c3ea0>
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    1698:	01053b0b 	tsteq	r5, fp, lsl #22
			g_wLastVoltage = wVoltage * 10;
    169c:	0c000013 	stceq	0, cr0, [r0], {19}

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    16a0:	0803000d 	stmdaeq	r3, {r0, r2, r3}
			g_wLastVoltage = wVoltage * 10;
    16a4:	053b0b3a 	ldreq	r0, [fp, #-2874]!
		}
	} while (--bLoopCnt);

	return 0;

}
    16a8:	0a381349 	beq	e063d4 <__Stack_Size+0xe05fd4>
    16ac:	0d0d0000 	stceq	0, cr0, [sp]
    16b0:	3a0e0300 	bcc	3822b8 <__Stack_Size+0x381eb8>
    16b4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
// ReadMsgs
//==============================================================================

/* process messages coming from Commander
 *  format = 0xFF RIGHT_H RIGHT_V LEFT_H LEFT_V BUTTONS EXT CHECKSUM */
int Commander_ReadMsgs() {
    16b8:	000a3813 	andeq	r3, sl, r3, lsl r8
	 }
	 #endif
	 */
	//while (CheckZBNewArrive() > 0) {
	while (1) {
		if (zgb_rx_check_arduino() == 1) {
    16bc:	00160e00 	andseq	r0, r6, r0, lsl #28
    16c0:	0b3a0e03 	bleq	e84ed4 <__Stack_Size+0xe84ad4>

			leftV = (signed char) (zgb_rx_data_right_V_());
    16c4:	1349053b 	movtne	r0, #38203	; 0x953b
    16c8:	040f0000 	streq	r0, [pc], #0	; 16d0 <__Stack_Size+0x12d0>
			leftH = (signed char) (zgb_rx_data_right_H_());
    16cc:	0b0e0301 	bleq	3822d8 <__Stack_Size+0x381ed8>
    16d0:	3b0b3a0b 	blcc	2cff04 <__Stack_Size+0x2cfb04>
			rightV = (signed char) (zgb_rx_data_left_V_());
    16d4:	0013010b 	andseq	r0, r3, fp, lsl #2
    16d8:	00161000 	andseq	r1, r6, r0
			rightH = (signed char) (zgb_rx_data_left_H_());
    16dc:	0b3a0e03 	bleq	e84ef0 <__Stack_Size+0xe84af0>
    16e0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
			buttons = zgb_rx_data_buttons();
    16e4:	13110000 	tstne	r1, #0	; 0x0
    16e8:	0b0e0301 	bleq	3822f4 <__Stack_Size+0x381ef4>
			ext = zgb_rx_data_extra();
    16ec:	3b0b3a0b 	blcc	2cff20 <__Stack_Size+0x2cfb20>
    16f0:	0013010b 	andseq	r0, r3, fp, lsl #2

	}

	return 0;

}
    16f4:	000f1200 	andeq	r1, pc, r0, lsl #4
    16f8:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    16fc:	2e130000 	wxorcs	wr0, wr3, wr0
    1700:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1704:	3b0b3a0e 	blcc	2cff44 <__Stack_Size+0x2cfb44>
    1708:	110c270b 	tstne	ip, fp, lsl #14
    170c:	40011201 	andmi	r1, r1, r1, lsl #4
    1710:	00130106 	andseq	r0, r3, r6, lsl #2

//==============================================================================
// This is The main code to input function to read inputs from the Commander and then
//process any commands.
//==============================================================================
void CommanderInputController_ControlInput(void) {
    1714:	00051400 	andeq	r1, r5, r0, lsl #8

	// See if we have a new command available...
	if (Commander_ReadMsgs() > 0) {
    1718:	0b3a0803 	bleq	e8372c <__Stack_Size+0xe8332c>
    171c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1720:	00000602 	andeq	r0, r0, r2, lsl #12
    1724:	03000515 	movweq	r0, #1301	; 0x515
		// If we receive a valid message than turn robot on...
		boolean fAdjustLegPositions = false;
		short sLegInitXZAdjust = 0;
		short sLegInitAngleAdjust = 0;

		if (!g_InControlState.fRobotOn) {
    1728:	3b0b3a0e 	blcc	2cff68 <__Stack_Size+0x2cfb68>
    172c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
			g_InControlState.fRobotOn = true;
    1730:	16000006 	strne	r0, [r0], -r6
    1734:	0c3f012e 	ldfeqs	f0, [pc], #-184
		}

		// [SWITCH MODES]

		// Cycle through modes...
		if ((buttons & BUT_LT) && !(buttonsPrev & BUT_LT)) {
    1738:	0b3a0e03 	bleq	e84f4c <__Stack_Size+0xe84b4c>
    173c:	0c270b3b 	stceq	11, cr0, [r7], #-236
    1740:	01111349 	tsteq	r1, r9, asr #6
    1744:	06400112 	undefined
    1748:	00001301 	andeq	r1, r0, r1, lsl #6
    174c:	11010b17 	tstne	r1, r7, lsl fp

			if (++ControlMode >= MODECNT) {
    1750:	00011201 	andeq	r1, r1, r1, lsl #4
    1754:	00341800 	eorseq	r1, r4, r0, lsl #16
    1758:	0b3a0e03 	bleq	e84f6c <__Stack_Size+0xe84b6c>
    175c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
				ControlMode = WALKMODE;    // cycled back around...
				Buzzed(50, 2000);
    1760:	00000602 	andeq	r0, r0, r2, lsl #12
    1764:	03003419 	movweq	r3, #1049	; 0x419
    1768:	3b0b3a0e 	blcc	2cffa8 <__Stack_Size+0x2cfba8>
				Buzzed(50, 3000);
    176c:	0013490b 	andseq	r4, r3, fp, lsl #18
    1770:	01011a00 	tsteq	r1, r0, lsl #20

			} else {
				Buzzed(50, 2000);
    1774:	13011349 	movwne	r1, #4937	; 0x1349
    1778:	211b0000 	tstcs	fp, r0
    177c:	2f134900 	svccs	0x00134900
			}
			if (ControlMode != SINGLELEGMODE)
    1780:	1c00000b 	stcne	0, cr0, [r0], {11}
    1784:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
				g_InControlState.SelectedLeg = 255;
    1788:	0b3b0b3a 	bleq	ec4478 <__Stack_Size+0xec4078>
    178c:	0c3f1349 	ldceq	3, cr1, [pc], #-292
    1790:	00000a02 	andeq	r0, r0, r2, lsl #20

		}

		//[Common functions]
		//Switch Balance mode on/off
		if ((buttons & BUT_L4) && !(buttonsPrev & BUT_L4)) {
    1794:	01110100 	tsteq	r1, r0, lsl #2
    1798:	0b130e25 	bleq	4c5034 <__Stack_Size+0x4c4c34>
    179c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    17a0:	01120111 	tsteq	r2, r1, lsl r1
    17a4:	00000610 	andeq	r0, r0, r0, lsl r6
    17a8:	0b002402 	bleq	a7b8 <__Stack_Size+0xa3b8>

			g_InControlState.BalanceMode = !g_InControlState.BalanceMode;
    17ac:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    17b0:	0300000e 	movweq	r0, #14	; 0xe
    17b4:	08030016 	stmdaeq	r3, {r1, r2, r4}
    17b8:	0b3b0b3a 	bleq	ec44a8 <__Stack_Size+0xec40a8>
    17bc:	00001349 	andeq	r1, r0, r9, asr #6
			if (g_InControlState.BalanceMode) {
    17c0:	49003504 	stmdbmi	r0, {r2, r8, sl, ip, sp}
				Buzzed(250, 1500);
    17c4:	05000013 	streq	r0, [r0, #-19]
    17c8:	0b0b0104 	bleq	2c1be0 <__Stack_Size+0x2c17e0>
			} else {
				Buzzed(100, 2000);
    17cc:	0b3b0b3a 	bleq	ec44bc <__Stack_Size+0xec40bc>
    17d0:	00001301 	andeq	r1, r0, r1, lsl #6
				Buzzed(50, 4000);
    17d4:	03002806 	movweq	r2, #2054	; 0x806
    17d8:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    17dc:	00280700 	eoreq	r0, r8, r0, lsl #14
			}
		}

		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
    17e0:	0d1c0803 	ldceq	8, cr0, [ip, #-12]
    17e4:	04080000 	streq	r0, [r8]
    17e8:	0b0e0301 	bleq	3823f4 <__Stack_Size+0x381ff4>
    17ec:	3b0b3a0b 	blcc	2d0020 <__Stack_Size+0x2cfc20>
    17f0:	0013010b 	andseq	r0, r3, fp, lsl #2
    17f4:	00160900 	andseq	r0, r6, r0, lsl #18
			if (g_BodyYOffset > 0)
    17f8:	0b3a0e03 	bleq	e8500c <__Stack_Size+0xe84c0c>
    17fc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
				g_BodyYOffset = 0;
    1800:	240a0000 	strcs	r0, [sl]
    1804:	3e0b0b00 	fmacdcc	d0, d11, d0
			else
				g_BodyYOffset = 35;
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1808:	0b00000b 	bleq	183c <__Stack_Size+0x143c>
		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
			if (g_BodyYOffset > 0)
				g_BodyYOffset = 0;
			else
				g_BodyYOffset = 35;
    180c:	0b0b0113 	bleq	2c1c60 <__Stack_Size+0x2c1860>
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1810:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    1814:	00001301 	andeq	r1, r0, r1, lsl #6

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1818:	03000d0c 	movweq	r0, #3340	; 0xd0c
		int ly = leftV;
		if (buttons & BUT_L6) {
    181c:	3b0b3a08 	blcc	2d0044 <__Stack_Size+0x2cfc44>

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1820:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
    1824:	0d00000a 	stceq	0, cr0, [r0, #-40]
		int ly = leftV;
    1828:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    182c:	053b0b3a 	ldreq	r0, [fp, #-2874]!
		if (buttons & BUT_L6) {
    1830:	0a381349 	beq	e0655c <__Stack_Size+0xe0615c>
    1834:	160e0000 	strne	r0, [lr], -r0
			// raise or lower the robot on the joystick up /down
			// Maybe should have Min/Max
			int delta = rightV / 25;
    1838:	3a0e0300 	bcc	382440 <__Stack_Size+0x382040>
    183c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1840:	0f000013 	svceq	0x00000013
    1844:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    1848:	0b3a0b0b 	bleq	e8447c <__Stack_Size+0xe8407c>
    184c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
			if (delta) {
    1850:	0d100000 	ldceq	0, cr0, [r0]
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
    1854:	3a0e0300 	bcc	38245c <__Stack_Size+0x38205c>
    1858:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    185c:	000a3813 	andeq	r3, sl, r3, lsl r8
    1860:	000d1100 	andeq	r1, sp, r0, lsl #2
    1864:	0b3a0803 	bleq	e83878 <__Stack_Size+0xe83478>
    1868:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    186c:	00000a38 	andeq	r0, r0, r8, lsr sl
    1870:	0b000f12 	bleq	54c0 <__Stack_Size+0x50c0>
    1874:	0013490b 	andseq	r4, r3, fp, lsl #18
			sLegInitAngleAdjust = ly / 8;
			lx = 0;
			ly = 0;

			// Likewise for Speed control
			delta = rightH / 16;   //
    1878:	012e1300 	teqeq	lr, r0, lsl #6
    187c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1880:	0b3b0b3a 	bleq	ec4570 <__Stack_Size+0xec4170>
    1884:	13490c27 	movtne	r0, #39975	; 0x9c27
    1888:	01120111 	tsteq	r2, r1, lsl r1
			if ((delta < 0) && g_InControlState.SpeedControl) {
    188c:	13010640 	movwne	r0, #5696	; 0x1640
    1890:	05140000 	ldreq	r0, [r4]
    1894:	3a0e0300 	bcc	38249c <__Stack_Size+0x38209c>
				if ((word)(-delta) < g_InControlState.SpeedControl)
    1898:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
					g_InControlState.SpeedControl += delta;
    189c:	00060213 	andeq	r0, r6, r3, lsl r2
				else
					g_InControlState.SpeedControl = 0;
    18a0:	01011500 	tsteq	r1, r0, lsl #10
    18a4:	13011349 	movwne	r1, #4937	; 0x1349

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
    18a8:	21160000 	tstcs	r6, r0
    18ac:	2f134900 	svccs	0x00134900
    18b0:	1700000b 	strne	r0, [r0, -fp]
				g_InControlState.SpeedControl += delta;
				if (g_InControlState.SpeedControl > 2000)
    18b4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
					g_InControlState.SpeedControl = 0;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
				g_InControlState.SpeedControl += delta;
    18b8:	0b3b0b3a 	bleq	ec45a8 <__Stack_Size+0xec41a8>
				if (g_InControlState.SpeedControl > 2000)
					g_InControlState.SpeedControl = 2000;
    18bc:	0c3f1349 	ldceq	3, cr1, [pc], #-292
    18c0:	00000a02 	andeq	r0, r0, r2, lsl #20

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
    18c4:	01110100 	tsteq	r1, r0, lsl #2
    18c8:	0b130e25 	bleq	4c5164 <__Stack_Size+0x4c4d64>
    18cc:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18d0:	01120111 	tsteq	r2, r1, lsl r1
    18d4:	00000610 	andeq	r0, r0, r0, lsl r6
    18d8:	0b002402 	bleq	a8e8 <__Stack_Size+0xa4e8>
    18dc:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
			sLegInitAngleAdjust = ly / 8;
    18e0:	0300000e 	movweq	r0, #14	; 0xe
    18e4:	08030016 	stmdaeq	r3, {r1, r2, r4}
    18e8:	0b3b0b3a 	bleq	ec45d8 <__Stack_Size+0xec41d8>
    18ec:	00001349 	andeq	r1, r0, r9, asr #6
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f0:	49003504 	stmdbmi	r0, {r2, r8, sl, ip, sp}
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18f4:	05000013 	streq	r0, [r0, #-19]
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f8:	0e030104 	adfeqs	f0, f3, f4
		}

		//[Walk functions]
		if (ControlMode == WALKMODE) {
    18fc:	0b3a0b0b 	bleq	e84530 <__Stack_Size+0xe84130>
    1900:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    1904:	28060000 	stmdacs	r6, {}

			//Switch gates
			if (((buttons & BUT_R1) && !(buttonsPrev & BUT_R1))
    1908:	1c0e0300 	stcne	3, cr0, [lr], {0}
    190c:	0700000d 	streq	r0, [r0, -sp]
    1910:	08030028 	stmdaeq	r3, {r3, r5}
    1914:	00000d1c 	andeq	r0, r0, ip, lsl sp
    1918:	03001608 	movweq	r1, #1544	; 0x608
    191c:	3b0b3a0e 	blcc	2d015c <__Stack_Size+0x2cfd5c>
    1920:	0013490b 	andseq	r4, r3, fp, lsl #18
    1924:	00240900 	eoreq	r0, r4, r0, lsl #18
    1928:	0b3e0b0b 	bleq	f8455c <__Stack_Size+0xf8415c>
    192c:	130a0000 	movwne	r0, #40960	; 0xa000
    1930:	3a0b0b01 	bcc	2c453c <__Stack_Size+0x2c413c>
    1934:	01053b0b 	tsteq	r5, fp, lsl #22
    1938:	0b000013 	bleq	198c <__Stack_Size+0x158c>
    193c:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    1940:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    1944:	0a381349 	beq	e06670 <__Stack_Size+0xe06270>
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1948:	0d0c0000 	stceq	0, cr0, [ip]
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    194c:	3a0e0300 	bcc	382554 <__Stack_Size+0x382154>
    1950:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1954:	000a3813 	andeq	r3, sl, r3, lsl r8
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    1958:	00160d00 	andseq	r0, r6, r0, lsl #26
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
					Buzzed(50, 2000);
    195c:	0b3a0e03 	bleq	e85170 <__Stack_Size+0xe84d70>
    1960:	1349053b 	movtne	r0, #38203	; 0x953b
    1964:	130e0000 	movwne	r0, #57344	; 0xe000
				} else {
					Buzzed(50, 2000);
    1968:	0b0e0301 	bleq	382574 <__Stack_Size+0x382174>
    196c:	3b0b3a0b 	blcc	2d01a0 <__Stack_Size+0x2cfda0>
    1970:	0013010b 	andseq	r0, r3, fp, lsl #2
					Buzzed(50, 2250);
    1974:	000d0f00 	andeq	r0, sp, r0, lsl #30
    1978:	0b3a0e03 	bleq	e8518c <__Stack_Size+0xe84d8c>
					g_InControlState.GaitType = 0;
    197c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1980:	00000a38 	andeq	r0, r0, r8, lsr sl
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    1984:	03000d10 	movweq	r0, #3344	; 0xd10
    1988:	3b0b3a08 	blcc	2d01b0 <__Stack_Size+0x2cfdb0>
    198c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    1990:	1100000a 	tstne	r0, sl
    1994:	0b0b000f 	bleq	2c19d8 <__Stack_Size+0x2c15d8>
    1998:	00001349 	andeq	r1, r0, r9, asr #6
    199c:	3f012e12 	svccc	0x00012e12
    19a0:	3a0e030c 	bcc	3825d8 <__Stack_Size+0x3821d8>
				}
				GaitSelect();
			}

			//Double leg lift height
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    19a4:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    19a8:	1201110c 	andne	r1, r1, #3	; 0x3
    19ac:	01064001 	tsteq	r6, r1
    19b0:	13000013 	movwne	r0, #19	; 0x13
    19b4:	08030005 	stmdaeq	r3, {r0, r2}
				Buzzed(50, 2000);
    19b8:	0b3b0b3a 	bleq	ec46a8 <__Stack_Size+0xec42a8>
    19bc:	06021349 	streq	r1, [r2], -r9, asr #6
				HeightSpeedMode = (HeightSpeedMode + 1) & 0x3; // wrap around mode
    19c0:	05140000 	ldreq	r0, [r4]
    19c4:	3a0e0300 	bcc	3825cc <__Stack_Size+0x3821cc>
    19c8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    19cc:	00060213 	andeq	r0, r6, r3, lsl r2
				DoubleTravelOn = HeightSpeedMode & 0x1;
    19d0:	01011500 	tsteq	r1, r0, lsl #10
    19d4:	13011349 	movwne	r1, #4937	; 0x1349
				if (HeightSpeedMode & 0x2)
    19d8:	21160000 	tstcs	r6, r0
    19dc:	2f134900 	svccs	0x00134900
					g_InControlState.LegLiftHeight = 80;
    19e0:	1700000b 	strne	r0, [r0, -fp]
    19e4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
				else
					g_InControlState.LegLiftHeight = 50;
			}

			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {
    19e8:	0b3b0b3a 	bleq	ec46d8 <__Stack_Size+0xec42d8>
    19ec:	0c3f1349 	ldceq	3, cr1, [pc], #-292
    19f0:	00000a02 	andeq	r0, r0, r2, lsl #20
    19f4:	01110100 	tsteq	r1, r0, lsl #2
    19f8:	0b130e25 	bleq	4c5294 <__Stack_Size+0x4c4e94>

				if ((++bJoystickWalkMode) > 1)
    19fc:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1a00:	01120111 	tsteq	r2, r1, lsl r1
    1a04:	00000610 	andeq	r0, r0, r0, lsl r6

					bJoystickWalkMode = 0;
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a08:	0b002402 	bleq	aa18 <__Stack_Size+0xa618>
			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {

				if ((++bJoystickWalkMode) > 1)

					bJoystickWalkMode = 0;
    1a0c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a10:	0300000e 	movweq	r0, #14	; 0xe
    1a14:	08030016 	stmdaeq	r3, {r1, r2, r4}
    1a18:	0b3b0b3a 	bleq	ec4708 <__Stack_Size+0xec4308>
    1a1c:	00001349 	andeq	r1, r0, r9, asr #6
			}

			//Walking
			switch (bJoystickWalkMode) {
    1a20:	49003504 	stmdbmi	r0, {r2, r8, sl, ip, sp}
    1a24:	05000013 	streq	r0, [r0, #-19]
    1a28:	0e030104 	adfeqs	f0, f3, f4
			case 0:
				g_InControlState.TravelLength.x = -lx;
    1a2c:	0b3a0b0b 	bleq	e84660 <__Stack_Size+0xe84260>
    1a30:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    1a34:	28060000 	stmdacs	r6, {}
				g_InControlState.TravelLength.z = -ly;
    1a38:	1c0e0300 	stcne	3, cr0, [lr], {0}
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
				break;
			case 1:
				g_InControlState.TravelLength.z = (rightV); //Right Stick Up/Down
    1a3c:	0700000d 	streq	r0, [r0, -sp]
    1a40:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    1a44:	0b3b0b3a 	bleq	ec4734 <__Stack_Size+0xec4334>
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
    1a48:	00001349 	andeq	r1, r0, r9, asr #6
    1a4c:	0b002408 	bleq	aa74 <__Stack_Size+0xa674>
    1a50:	000b3e0b 	andeq	r3, fp, fp, lsl #28
    1a54:	01130900 	tsteq	r3, r0, lsl #18
    1a58:	0b3a0b0b 	bleq	e8468c <__Stack_Size+0xe8428c>
    1a5c:	1301053b 	movwne	r0, #5435	; 0x153b
				break;

			}

			if (!DoubleTravelOn) {  //(Double travel length)
    1a60:	0d0a0000 	stceq	0, cr0, [sl]
				g_InControlState.TravelLength.x =
    1a64:	3a080300 	bcc	20266c <__Stack_Size+0x20226c>
    1a68:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1a6c:	000a3813 	andeq	r3, sl, r3, lsl r8
						g_InControlState.TravelLength.x / 2;
				g_InControlState.TravelLength.z =
    1a70:	000d0b00 	andeq	r0, sp, r0, lsl #22
    1a74:	0b3a0e03 	bleq	e85288 <__Stack_Size+0xe84e88>
    1a78:	1349053b 	movtne	r0, #38203	; 0x953b
			}

		}

		//[Translate functions]
		g_BodyYShift = 0;
    1a7c:	00000a38 	andeq	r0, r0, r8, lsr sl
    1a80:	3f012e0c 	svccc	0x00012e0c
		if (ControlMode == TRANSLATEMODE) {
    1a84:	3a0e030c 	bcc	3826bc <__Stack_Size+0x3822bc>
    1a88:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
    1a8c:	1201110c 	andne	r1, r1, #3	; 0x3
    1a90:	01064001 	tsteq	r6, r1
    1a94:	0d000013 	stceq	0, cr0, [r0, #-76]
    1a98:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1a9c:	0b3b0b3a 	bleq	ec478c <__Stack_Size+0xec438c>
    1aa0:	06021349 	streq	r1, [r2], -r9, asr #6
    1aa4:	340e0000 	strcc	r0, [lr]
    1aa8:	3a0e0300 	bcc	3826b0 <__Stack_Size+0x3822b0>
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1aac:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1ab0:	3c0c3f13 	stccc	15, cr3, [ip], {19}
    1ab4:	0000000c 	andeq	r0, r0, ip
    1ab8:	25011101 	strcs	r1, [r1, #-257]
    1abc:	030b130e 	movweq	r1, #45838	; 0xb30e
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac0:	110e1b0e 	tstne	lr, lr, lsl #22
		//[Translate functions]
		g_BodyYShift = 0;
		if (ControlMode == TRANSLATEMODE) {

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1ac4:	10011201 	andne	r1, r1, r1, lsl #4
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac8:	02000006 	andeq	r0, r0, #6	; 0x6
    1acc:	0b0b0024 	bleq	2c1b64 <__Stack_Size+0x2c1764>
    1ad0:	0e030b3e 	vmoveq.16	d3[0], r0
    1ad4:	16030000 	strne	r0, [r3], -r0


			//      g_InControlState.BodyPos.x = (lx)/2;
			//      g_InControlState.BodyPos.z = -(ly)/3;
			//      g_InControlState.BodyRot1.y = (rightH)*2;
			g_BodyYShift = (-(rightV) / 2);
    1ad8:	3a080300 	bcc	2026e0 <__Stack_Size+0x2022e0>
    1adc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1ae0:	04000013 	streq	r0, [r0], #-19
    1ae4:	0b0b0024 	bleq	2c1b7c <__Stack_Size+0x2c177c>
    1ae8:	00000b3e 	andeq	r0, r0, lr, lsr fp
    1aec:	03010405 	movweq	r0, #5125	; 0x1405
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
    1af0:	3a0b0b0e 	bcc	2c4730 <__Stack_Size+0x2c4330>
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1af4:	010b3b0b 	tsteq	fp, fp, lsl #22
    1af8:	06000013 	undefined
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1afc:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1b00:	00000d1c 	andeq	r0, r0, ip, lsl sp
			g_BodyYShift = (-(rightV) / 2);
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
    1b04:	03002807 	movweq	r2, #2055	; 0x807
			g_InControlState.BodyRot1.y = (rightH) * 2;
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1b08:	000d1c08 	andeq	r1, sp, r8, lsl #24
    1b0c:	012e0800 	teqeq	lr, r0, lsl #16
    1b10:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1b14:	0b3b0b3a 	bleq	ec4804 <__Stack_Size+0xec4404>
    1b18:	01110c27 	tsteq	r1, r7, lsr #24
		}

		//[Single leg functions]
#ifdef OPT_SINGLELEG
		if (ControlMode == SINGLELEGMODE) {
    1b1c:	0a400112 	beq	1001f6c <__Stack_Size+0x1001b6c>

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
    1b20:	00001301 	andeq	r1, r0, r1, lsl #6
    1b24:	03000509 	movweq	r0, #1289	; 0x509
    1b28:	3b0b3a0e 	blcc	2d0368 <__Stack_Size+0x2cff68>
    1b2c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1b30:	0a00000a 	beq	1b60 <__Stack_Size+0x1760>
				Buzzed(50,2000);
    1b34:	0c3f012e 	ldfeqs	f0, [pc], #-184
    1b38:	0b3a0e03 	bleq	e8534c <__Stack_Size+0xe84f4c>
    1b3c:	0c270b3b 	stceq	11, cr0, [r7], #-236
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b40:	01120111 	tsteq	r2, r1, lsl r1
    1b44:	13010640 	movwne	r0, #5696	; 0x1640
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
				} else {
					g_InControlState.SelectedLeg = 0;
    1b48:	050b0000 	streq	r0, [fp]
		if (ControlMode == SINGLELEGMODE) {

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
				Buzzed(50,2000);
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b4c:	3a0e0300 	bcc	382754 <__Stack_Size+0x382354>
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
    1b50:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
			   g_InControlState.SLLeg.x= (signed char)((int)((int)lx+128)/2); //Left Stick Right/Left
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
    1b54:	00060213 	andeq	r0, r6, r3, lsl r2
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b58:	002e0c00 	eoreq	r0, lr, r0, lsl #24
    1b5c:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1b60:	0b3b0b3a 	bleq	ec4850 <__Stack_Size+0xec4450>
    1b64:	13490c27 	movtne	r0, #39975	; 0x9c27
    1b68:	01120111 	tsteq	r2, r1, lsl r1
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b6c:	00000a40 	andeq	r0, r0, r0, asr #20
    1b70:	3f002e0d 	svccc	0x00002e0d
    1b74:	3a0e030c 	bcc	3827ac <__Stack_Size+0x3823ac>
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b78:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b7c:	1201110c 	andne	r1, r1, #3	; 0x3
    1b80:	000a4001 	andeq	r4, sl, r1
    1b84:	002e0e00 	eoreq	r0, lr, r0, lsl #28
				Buzzed(50,2000);
    1b88:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1b8c:	0b3b0b3a 	bleq	ec487c <__Stack_Size+0xec447c>
				g_InControlState.fSLHold = !g_InControlState.fSLHold;
    1b90:	01110c27 	tsteq	r1, r7, lsr #24
    1b94:	06400112 	undefined
    1b98:	2e0f0000 	cdpcs	0, 0, cr0, cr15, cr0, {0}
    1b9c:	030c3f01 	movweq	r3, #52993	; 0xcf01
			}
		}
#endif

		//Calculate walking time delay
		g_InControlState.InputTimeDelay = 128- max(max(abs(lx), abs(ly)), abs(rightH));
    1ba0:	3b0b3a0e 	blcc	2d03e0 <__Stack_Size+0x2cffe0>
    1ba4:	1113490b 	tstne	r3, fp, lsl #18
    1ba8:	40011201 	andmi	r1, r1, r1, lsl #4
    1bac:	00130106 	andseq	r0, r3, r6, lsl #2
    1bb0:	00341000 	eorseq	r1, r4, r0
    1bb4:	0b3a0803 	bleq	e83bc8 <__Stack_Size+0xe837c8>
    1bb8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1bbc:	00000a02 	andeq	r0, r0, r2, lsl #20
    1bc0:	03003411 	movweq	r3, #1041	; 0x411
    1bc4:	3b0b3a08 	blcc	2d03ec <__Stack_Size+0x2cffec>
    1bc8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1bcc:	12000006 	andne	r0, r0, #6	; 0x6
    1bd0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

		//Calculate g_InControlState.BodyPos.y
		g_InControlState.BodyPos.y = max(g_BodyYOffset + g_BodyYShift, 0);
    1bd4:	0b3b0b3a 	bleq	ec48c4 <__Stack_Size+0xec44c4>
    1bd8:	0c3f1349 	ldceq	3, cr1, [pc], #-292
    1bdc:	00000a02 	andeq	r0, r0, r2, lsl #20
    1be0:	49003513 	stmdbmi	r0, {r0, r1, r4, r8, sl, ip, sp}
    1be4:	00000013 	andeq	r0, r0, r3, lsl r0
    1be8:	25011101 	strcs	r1, [r1, #-257]

		if (sLegInitXZAdjust || sLegInitAngleAdjust) {
    1bec:	030b130e 	movweq	r1, #45838	; 0xb30e
    1bf0:	110e1b0e 	tstne	lr, lr, lsl #22
			// User asked for manual leg adjustment - only do when we have finished any previous adjustment

			if (!g_InControlState.ForceGaitStepCnt) {
    1bf4:	10011201 	andne	r1, r1, r1, lsl #4
				if (sLegInitXZAdjust)
    1bf8:	02000006 	andeq	r0, r0, #6	; 0x6
					g_fDynamicLegXZLength = true;
    1bfc:	0b0b0024 	bleq	2c1c94 <__Stack_Size+0x2c1894>
    1c00:	0e030b3e 	vmoveq.16	d3[0], r0

				sLegInitXZAdjust += GetLegsXZLength(); // Add on current length to our adjustment...
    1c04:	16030000 	strne	r0, [r3], -r0
    1c08:	3a080300 	bcc	202810 <__Stack_Size+0x202410>
				// Handle maybe change angles...
				if (sLegInitAngleAdjust)
					RotateLegInitAngles(sLegInitAngleAdjust);

				// Give system time to process previous calls
				AdjustLegPositions(sLegInitXZAdjust);
    1c0c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
			}
		}

		if (fAdjustLegPositions && !g_fDynamicLegXZLength)
    1c10:	04000013 	streq	r0, [r0], #-19
    1c14:	13490035 	movtne	r0, #36917	; 0x9035
    1c18:	04050000 	streq	r0, [r5]
			AdjustLegPositionsToBodyHeight(); // Put main workings into main program file
    1c1c:	3a0b0b01 	bcc	2c4828 <__Stack_Size+0x2c4428>
		// Save away the buttons state as to not process the same press twice.
		buttonsPrev = buttons;
    1c20:	010b3b0b 	tsteq	fp, fp, lsl #22
    1c24:	06000013 	undefined
		extPrev = ext;
    1c28:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
    1c2c:	00000d1c 	andeq	r0, r0, ip, lsl sp
		g_ulLastMsgTime = getMillis();
    1c30:	03002807 	movweq	r2, #2055	; 0x807
    1c34:	000d1c08 	andeq	r1, sp, r8, lsl #24
	} else {
		// We did not receive a valid packet.  check for a timeout to see if we should turn robot off...
		if (g_InControlState.fRobotOn) {
    1c38:	00160800 	andseq	r0, r6, r0, lsl #16
			if ((getMillis() - g_ulLastMsgTime) > ARBOTIX_TO)
    1c3c:	0b3a0e03 	bleq	e85450 <__Stack_Size+0xe85050>
    1c40:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1c44:	13090000 	movwne	r0, #36864	; 0x9000
    1c48:	3a0b0b01 	bcc	2c4854 <__Stack_Size+0x2c4454>
    1c4c:	010b3b0b 	tsteq	fp, fp, lsl #22
				CommanderTurnRobotOff();
    1c50:	0a000013 	beq	1ca4 <__Stack_Size+0x18a4>
		}
	}

}
    1c54:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    1c58:	0b3b0b3a 	bleq	ec4948 <__Stack_Size+0xec4548>
    1c5c:	0a381349 	beq	e06988 <__Stack_Size+0xe06588>
    1c60:	0d0b0000 	stceq	0, cr0, [fp]
    1c64:	3a0e0300 	bcc	38286c <__Stack_Size+0x38246c>
    1c68:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1c6c:	000a3813 	andeq	r3, sl, r3, lsl r8
    1c70:	00240c00 	eoreq	r0, r4, r0, lsl #24
    1c74:	0b3e0b0b 	bleq	f848a8 <__Stack_Size+0xf844a8>
    1c78:	130d0000 	movwne	r0, #53248	; 0xd000
    1c7c:	3a0b0b01 	bcc	2c4888 <__Stack_Size+0x2c4488>
    1c80:	01053b0b 	tsteq	r5, fp, lsl #22
    1c84:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    1c88:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    1c8c:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    1c90:	0a381349 	beq	e069bc <__Stack_Size+0xe065bc>
    1c94:	0d0f0000 	stceq	0, cr0, [pc]
    1c98:	3a0e0300 	bcc	3828a0 <__Stack_Size+0x3824a0>
    1c9c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    1ca0:	000a3813 	andeq	r3, sl, r3, lsl r8
    1ca4:	00241000 	eoreq	r1, r4, r0
    1ca8:	0b3e0b0b 	bleq	f848dc <__Stack_Size+0xf844dc>
    1cac:	00000803 	andeq	r0, r0, r3, lsl #16

extern void setupPhoenix(void);
extern void readSensors(void);


int Big_main(void) {
    1cb0:	3f012e11 	svccc	0x00012e11

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
    1cb4:	3a0e030c 	bcc	3828ec <__Stack_Size+0x3824ec>
	setupPhoenix();
    1cb8:	11053b0b 	tstne	r5, fp, lsl #22
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1cbc:	40011201 	andmi	r1, r1, r1, lsl #4

	while (1){
		while (1) {
			//Start time
			unsigned long lTimeWaitEnd;
			lTimerStart = getMillis();
    1cc0:	00130106 	andseq	r0, r3, r6, lsl #2
    1cc4:	00341200 	eorseq	r1, r4, r0, lsl #4
    1cc8:	0b3a0e03 	bleq	e854dc <__Stack_Size+0xe850dc>
#ifdef MILLIS
			PrintString("Barebones lTimerStart ");
			Printu32d(lTimerStart);
			PrintString("\n");
#endif
			DoBackgroundProcess();
    1ccc:	1349053b 	movtne	r0, #38203	; 0x953b
			//Read input
			CheckVoltage();        // check our voltages...
    1cd0:	2e130000 	wxorcs	wr0, wr3, wr0
			if (!g_fLowVoltageShutdown) {
    1cd4:	030c3f00 	movweq	r3, #52992	; 0xcf00
    1cd8:	3b0b3a0e 	blcc	2d0518 <__Stack_Size+0x2d0118>
				CommanderInputController_ControlInput();
    1cdc:	110c2705 	tstne	ip, r5, lsl #14
			}
			WriteOutputs();        // Write Outputs
			//Single leg control
			SingleLegControl();
    1ce0:	40011201 	andmi	r1, r1, r1, lsl #4
			DoBackgroundProcess();
    1ce4:	14000006 	strne	r0, [r0], #-6

			//Gait
			GaitSeq();
    1ce8:	0c3f012e 	ldfeqs	f0, [pc], #-184

			DoBackgroundProcess();
    1cec:	0b3a0e03 	bleq	e85500 <__Stack_Size+0xe85100>

			//Balance calculations
			TotalTransX = 0;     //reset values used for calculation of balance
    1cf0:	0c270b3b 	stceq	11, cr0, [r7], #-236
    1cf4:	01120111 	tsteq	r2, r1, lsl r1
			TotalTransZ = 0;
    1cf8:	13010640 	movwne	r0, #5696	; 0x1640
			TotalTransY = 0;
    1cfc:	34150000 	ldrcc	r0, [r5]
    1d00:	3a0e0300 	bcc	382908 <__Stack_Size+0x382508>
			TotalXBal1 = 0;
    1d04:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
			TotalYBal1 = 0;
    1d08:	000a0213 	andeq	r0, sl, r3, lsl r2
    1d0c:	00341600 	eorseq	r1, r4, r0, lsl #12
			TotalZBal1 = 0;
    1d10:	0b3a0e03 	bleq	e85524 <__Stack_Size+0xe85124>

			if (g_InControlState.BalanceMode) {
    1d14:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1d18:	2e170000 	wxorcs	wr0, wr7, wr0
    1d1c:	030c3f00 	movweq	r3, #52992	; 0xcf00

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d20:	3b0b3a0e 	blcc	2d0560 <__Stack_Size+0x2d0160>

					DoBackgroundProcess();
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d24:	1201110b 	andne	r1, r1, #-1073741822	; 0xc0000002
    1d28:	00064001 	andeq	r4, r6, r1
    1d2c:	01011800 	tsteq	r1, r0, lsl #16

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs

					DoBackgroundProcess();
    1d30:	13011349 	movwne	r1, #4937	; 0x1349
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d34:	21190000 	tstcs	r9, r0
    1d38:	2f134900 	svccs	0x00134900
    1d3c:	1a000005 	bne	1d58 <__Stack_Size+0x1958>
    1d40:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1d44:	0b3b0b3a 	bleq	ec4a34 <__Stack_Size+0xec4634>
    1d48:	0b1c1349 	bleq	706a74 <__Stack_Size+0x706674>
    1d4c:	211b0000 	tstcs	fp, r0
    1d50:	2f134900 	svccs	0x00134900
    1d54:	1c00000b 	stcne	0, cr0, [r0], {11}
    1d58:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1d5c:	0b3b0b3a 	bleq	ec4a4c <__Stack_Size+0xec464c>
    1d60:	0c3f1349 	ldceq	3, cr1, [pc], #-292
    1d64:	00000c3c 	andeq	r0, r0, ip, lsr ip
    1d68:	01110100 	tsteq	r1, r0, lsl #2
    1d6c:	0b130e25 	bleq	4c5608 <__Stack_Size+0x4c5208>
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d70:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1d74:	01120111 	tsteq	r2, r1, lsl r1
    1d78:	00000610 	andeq	r0, r0, r0, lsl r6
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1d7c:	0b002402 	bleq	ad8c <__Stack_Size+0xa98c>
    1d80:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
					DoBackgroundProcess();
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d84:	0300000e 	movweq	r0, #14	; 0xe
    1d88:	08030016 	stmdaeq	r3, {r1, r2, r4}
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
					DoBackgroundProcess();
    1d8c:	0b3b0b3a 	bleq	ec4a7c <__Stack_Size+0xec467c>
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d90:	00001349 	andeq	r1, r0, r9, asr #6
    1d94:	49003504 	stmdbmi	r0, {r2, r8, sl, ip, sp}
    1d98:	05000013 	streq	r0, [r0, #-19]
    1d9c:	0b0b0104 	bleq	2c21b4 <__Stack_Size+0x2c1db4>
    1da0:	0b3b0b3a 	bleq	ec4a90 <__Stack_Size+0xec4690>
    1da4:	00001301 	andeq	r1, r0, r1, lsl #6
    1da8:	03002806 	movweq	r2, #2054	; 0x806
    1dac:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    1db0:	00280700 	eoreq	r0, r8, r0, lsl #14
    1db4:	0d1c0803 	ldceq	8, cr0, [ip, #-12]
    1db8:	24080000 	strcs	r0, [r8]
    1dbc:	3e0b0b00 	fmacdcc	d0, d11, d0
    1dc0:	0900000b 	stmdbeq	r0, {r0, r1, r3}
    1dc4:	0b0b0113 	bleq	2c2218 <__Stack_Size+0x2c1e18>
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1dc8:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    1dcc:	00001301 	andeq	r1, r0, r1, lsl #6
    1dd0:	03000d0a 	movweq	r0, #3338	; 0xd0a
							LegPosZ[LegIndex] + GaitPosZ[LegIndex],
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}
				BalanceBody();
    1dd4:	3b0b3a08 	blcc	2d05fc <__Stack_Size+0x2d01fc>
			}

			//Reset IKsolution indicators
			IKSolution = 0;
    1dd8:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
    1ddc:	0b00000a 	bleq	1e0c <__Stack_Size+0x1a0c>
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1de0:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
			}

			//Reset IKsolution indicators
			IKSolution = 0;
			IKSolutionWarning = 0;
			IKSolutionError = 0;
    1de4:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    1de8:	0a381349 	beq	e06b14 <__Stack_Size+0xe06714>

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
				DoBackgroundProcess();
    1dec:	130c0000 	movwne	r0, #49152	; 0xc000
				BodyFK(
    1df0:	3a0b0b01 	bcc	2c49fc <__Stack_Size+0x2c45fc>
    1df4:	010b3b0b 	tsteq	fp, fp, lsl #22
    1df8:	0d000013 	stceq	0, cr0, [r0, #-76]
    1dfc:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1e00:	0b3b0b3a 	bleq	ec4af0 <__Stack_Size+0xec46f0>
    1e04:	0a381349 	beq	e06b30 <__Stack_Size+0xe06730>
    1e08:	160e0000 	strne	r0, [lr], -r0
    1e0c:	3a0e0300 	bcc	382a14 <__Stack_Size+0x382614>
    1e10:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1e14:	0f000013 	svceq	0x00000013
    1e18:	0e030104 	adfeqs	f0, f3, f4
    1e1c:	0b3a0b0b 	bleq	e84a50 <__Stack_Size+0xe84650>
    1e20:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    1e24:	2e100000 	wxorcs	wr0, wr0, wr0
    1e28:	030c3f00 	movweq	r3, #52992	; 0xcf00
    1e2c:	3b0b3a0e 	blcc	2d066c <__Stack_Size+0x2d026c>
    1e30:	200c270b 	andcs	r2, ip, fp, lsl #14
    1e34:	1100000b 	tstne	r0, fp
    1e38:	0c3f002e 	ldceq	0, cr0, [pc], #-184
    1e3c:	0b3a0e03 	bleq	e85650 <__Stack_Size+0xe85250>
    1e40:	0c270b3b 	stceq	11, cr0, [r7], #-236
    1e44:	01111349 	tsteq	r1, r9, asr #6
    1e48:	0a400112 	beq	1002298 <__Stack_Size+0x1001e98>
    1e4c:	2e120000 	wxorcs	wr0, wr2, wr0
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);

				LegIK(
    1e50:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1e54:	3b0b3a0e 	blcc	2d0694 <__Stack_Size+0x2d0294>
    1e58:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    1e5c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1e60:	010a4001 	tsteq	sl, r1
    1e64:	13000013 	movwne	r0, #19	; 0x13
    1e68:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1e6c:	0b3b0b3a 	bleq	ec4b5c <__Stack_Size+0xec475c>
    1e70:	06021349 	streq	r1, [r2], -r9, asr #6
    1e74:	2e140000 	wxorcs	wr0, wr4, wr0
    1e78:	11133100 	tstne	r3, r0, lsl #2
    1e7c:	40011201 	andmi	r1, r1, r1, lsl #4
    1e80:	1500000a 	strne	r0, [r0, #-10]
    1e84:	1331001d 	teqne	r1, #29	; 0x1d
    1e88:	01120111 	tsteq	r2, r1, lsl r1
    1e8c:	0b590b58 	bleq	1644bf4 <__Stack_Size+0x16447f4>
    1e90:	2e160000 	wxorcs	wr0, wr6, wr0
    1e94:	030c3f01 	movweq	r3, #52993	; 0xcf01
    1e98:	3b0b3a0e 	blcc	2d06d8 <__Stack_Size+0x2d02d8>
    1e9c:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    1ea0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1ea4:	01064001 	tsteq	r6, r1
    1ea8:	17000013 	smladne	r0, r3, r0, r0
    1eac:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1eb0:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    1eb4:	06021349 	streq	r1, [r2], -r9, asr #6
    1eb8:	34180000 	ldrcc	r0, [r8]
    1ebc:	3a080300 	bcc	202ac4 <__Stack_Size+0x2026c4>
    1ec0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1ec4:	00060213 	andeq	r0, r6, r3, lsl r2
    1ec8:	000f1900 	andeq	r1, pc, r0, lsl #18
    1ecc:	13490b0b 	movtne	r0, #39691	; 0x9b0b
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1ed0:	2e1a0000 	wxorcs	wr0, wr10, wr0
    1ed4:	030c3f01 	movweq	r3, #52993	; 0xcf01
				DoBackgroundProcess();
    1ed8:	3b0b3a0e 	blcc	2d0718 <__Stack_Size+0x2d0318>
				BodyFK(
    1edc:	110c2705 	tstne	ip, r5, lsl #14
    1ee0:	40011201 	andmi	r1, r1, r1, lsl #4
    1ee4:	0013010a 	andseq	r0, r3, sl, lsl #2
    1ee8:	00341b00 	eorseq	r1, r4, r0, lsl #22
    1eec:	0b3a0803 	bleq	e83f00 <__Stack_Size+0xe83b00>
    1ef0:	1349053b 	movtne	r0, #38203	; 0x953b
    1ef4:	2e1c0000 	wxorcs	wr0, wr12, wr0
    1ef8:	030c3f00 	movweq	r3, #52992	; 0xcf00
    1efc:	3b0b3a0e 	blcc	2d073c <__Stack_Size+0x2d033c>
    1f00:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    1f04:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1f08:	000a4001 	andeq	r4, sl, r1
    1f0c:	012e1d00 	teqeq	lr, r0, lsl #26
    1f10:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1f14:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    1f18:	01110c27 	tsteq	r1, r7, lsr #24
    1f1c:	06400112 	undefined
    1f20:	00001301 	andeq	r1, r0, r1, lsl #6
    1f24:	0300341e 	movweq	r3, #1054	; 0x41e
    1f28:	3b0b3a0e 	blcc	2d0768 <__Stack_Size+0x2d0368>
    1f2c:	02134905 	andseq	r4, r3, #81920	; 0x14000
    1f30:	1f00000a 	svcne	0x0000000a
    1f34:	0c3f002e 	ldceq	0, cr0, [pc], #-184
    1f38:	0b3a0e03 	bleq	e8574c <__Stack_Size+0xe8534c>
    1f3c:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
    1f40:	01120111 	tsteq	r2, r1, lsl r1
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);
				LegIK(
    1f44:	00000640 	andeq	r0, r0, r0, asr #12
    1f48:	3f002e20 	svccc	0x00002e20
    1f4c:	3a0e030c 	bcc	382b84 <__Stack_Size+0x382784>
    1f50:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1f54:	1201110c 	andne	r1, r1, #3	; 0x3
    1f58:	00064001 	andeq	r4, r6, r1
    1f5c:	012e2100 	teqeq	lr, r0, lsl #2
    1f60:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    1f64:	0b3b0b3a 	bleq	ec4c54 <__Stack_Size+0xec4854>
    1f68:	13490c27 	movtne	r0, #39975	; 0x9c27
    1f6c:	01120111 	tsteq	r2, r1, lsl r1
    1f70:	13010640 	movwne	r0, #5696	; 0x1640
    1f74:	05220000 	streq	r0, [r2]!
    1f78:	3a0e0300 	bcc	382b80 <__Stack_Size+0x382780>
    1f7c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1f80:	00060213 	andeq	r0, r6, r3, lsl r2
    1f84:	00342300 	eorseq	r2, r4, r0, lsl #6
    1f88:	0b3a0e03 	bleq	e8579c <__Stack_Size+0xe8539c>
    1f8c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1f90:	00000a02 	andeq	r0, r0, r2, lsl #20
    1f94:	3f012e24 	svccc	0x00012e24
    1f98:	3a0e030c 	bcc	382bd0 <__Stack_Size+0x3827d0>
    1f9c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1fa0:	1201110c 	andne	r1, r1, #3	; 0x3
    1fa4:	01064001 	tsteq	r6, r1
    1fa8:	25000013 	strcs	r0, [r0, #-19]
    1fac:	13490101 	movtne	r0, #37121	; 0x9101
    1fb0:	00001301 	andeq	r1, r0, r1, lsl #6
    1fb4:	49002126 	stmdbmi	r0, {r1, r2, r5, r8, sp}
    1fb8:	00052f13 	andeq	r2, r5, r3, lsl pc
    1fbc:	00212700 	eoreq	r2, r1, r0, lsl #14
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1fc0:	0b2f1349 	bleq	bc6cec <__Stack_Size+0xbc68ec>
    1fc4:	34280000 	strtcc	r0, [r8]
    1fc8:	3a0e0300 	bcc	382bd0 <__Stack_Size+0x3827d0>
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Check mechanical limits
			CheckAngles();
    1fcc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

			//Drive Servos
			if (g_InControlState.fRobotOn) {
    1fd0:	020c3f13 	andeq	r3, ip, #76	; 0x4c
    1fd4:	2900000a 	stmdbcs	r0, {r1, r3}
    1fd8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
				if (g_InControlState.fRobotOn && !g_InControlState.fPrev_RobotOn) {
					// MSound(3, 60, 2000, 80, 2250, 100, 2500);
					Buzzed(30, 2000);
    1fdc:	0b3b0b3a 	bleq	ec4ccc <__Stack_Size+0xec48cc>
    1fe0:	0c3f1349 	ldceq	3, cr1, [pc], #-292
    1fe4:	00000c3c 	andeq	r0, r0, ip, lsr ip
					Buzzed(80, 2250);
    1fe8:	01110100 	tsteq	r1, r0, lsl #2
    1fec:	0b130e25 	bleq	4c5888 <__Stack_Size+0x4c5488>
					Buzzed(100, 2500);
    1ff0:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1ff4:	01120111 	tsteq	r2, r1, lsl r1
    1ff8:	00000610 	andeq	r0, r0, r0, lsl r6

				}

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
    1ffc:	0b002402 	bleq	b00c <__Stack_Size+0xac0c>
    2000:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    2004:	0300000e 	movweq	r0, #14	; 0xe
    2008:	08030016 	stmdaeq	r3, {r1, r2, r4}
    200c:	0b3b0b3a 	bleq	ec4cfc <__Stack_Size+0xec48fc>
    2010:	00001349 	andeq	r1, r0, r9, asr #6
    2014:	49003504 	stmdbmi	r0, {r2, r8, sl, ip, sp}
    2018:	05000013 	streq	r0, [r0, #-19]
    201c:	0b0b0104 	bleq	2c2434 <__Stack_Size+0x2c2034>
    2020:	0b3b0b3a 	bleq	ec4d10 <__Stack_Size+0xec4910>
    2024:	00001301 	andeq	r1, r0, r1, lsl #6
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2028:	03002806 	movweq	r2, #2054	; 0x806
    202c:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    2030:	00280700 	eoreq	r0, r8, r0, lsl #14
    2034:	0d1c0803 	ldceq	8, cr0, [ip, #-12]
    2038:	16080000 	strne	r0, [r8], -r0
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
    203c:	3a0e0300 	bcc	382c44 <__Stack_Size+0x382844>

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2040:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
						ServoMoveTime = ServoMoveTime + BALANCE_DELAY;
    2044:	09000013 	stmdbeq	r0, {r0, r1, r4}
    2048:	0b0b0113 	bleq	2c249c <__Stack_Size+0x2c209c>
				} else
					//Movement speed excl. Walking
					ServoMoveTime = 200 + g_InControlState.SpeedControl;
    204c:	0b3b0b3a 	bleq	ec4d3c <__Stack_Size+0xec493c>
    2050:	00001301 	andeq	r1, r0, r1, lsl #6
    2054:	03000d0a 	movweq	r0, #3338	; 0xd0a

				// note we broke up the servo driver into start/commit that way we can output all of the servo information
				// before we wait and only have the termination information to output after the wait.  That way we hopefully
				// be more accurate with our timings...
				DoBackgroundProcess();
    2058:	3b0b3a08 	blcc	2d0880 <__Stack_Size+0x2d0480>
				StartUpdateServos();
    205c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    2060:	0b00000a 	bleq	2090 <__Stack_Size+0x1c90>
					if ((GaitPosX[LegIndex] > cGPlimit)
    2064:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    2068:	0b3b0b3a 	bleq	ec4d58 <__Stack_Size+0xec4958>
    206c:	0a381349 	beq	e06d98 <__Stack_Size+0xe06998>
    2070:	240c0000 	strcs	r0, [ip]
    2074:	3e0b0b00 	fmacdcc	d0, d11, d0
    2078:	0d00000b 	stceq	0, cr0, [r0, #-44]
    207c:	0c3f012e 	ldfeqs	f0, [pc], #-184
    2080:	0b3a0e03 	bleq	e85894 <__Stack_Size+0xe85494>
    2084:	0c270b3b 	stceq	11, cr0, [r7], #-236
    2088:	01120111 	tsteq	r2, r1, lsl r1
    208c:	13010a40 	movwne	r0, #6720	; 0x1a40
    2090:	050e0000 	streq	r0, [lr]
    2094:	3a0e0300 	bcc	382c9c <__Stack_Size+0x38289c>
    2098:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    209c:	000a0213 	andeq	r0, sl, r3, lsl r2
							|| (GaitPosZ[LegIndex] > cGPlimit)
							|| (GaitPosZ[LegIndex] < -cGPlimit)
							|| (GaitRotY[LegIndex] > cGPlimit)
							|| (GaitRotY[LegIndex] < -cGPlimit)) {

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
    20a0:	00340f00 	eorseq	r0, r4, r0, lsl #30
    20a4:	0b3a0e03 	bleq	e858b8 <__Stack_Size+0xe854b8>
    20a8:	13490b3b 	movtne	r0, #39739	; 0x9b3b

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    20ac:	00000602 	andeq	r0, r0, r2, lsl #12
    20b0:	03003410 	movweq	r3, #1040	; 0x410

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
						break;
					}
				}
				if (bExtraCycle > 0) {
    20b4:	3b0b3a0e 	blcc	2d08f4 <__Stack_Size+0x2d04f4>
					bExtraCycle--;
    20b8:	0013490b 	andseq	r4, r3, fp, lsl #18
    20bc:	000f1100 	andeq	r1, pc, r0, lsl #2
					fWalking = !(bExtraCycle == 0);
    20c0:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    20c4:	2e120000 	wxorcs	wr0, wr2, wr0

					//Get endtime and calculate wait time
					lTimeWaitEnd = lTimerStart + PrevServoMoveTime;
    20c8:	030c3f01 	movweq	r3, #52993	; 0xcf01
    20cc:	3b0b3a0e 	blcc	2d090c <__Stack_Size+0x2d050c>
    20d0:	110c2705 	tstne	ip, r5, lsl #14
					PrintString("\n");
#endif
					//DebugWrite(A1, HIGH);
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    20d4:	40011201 	andmi	r1, r1, r1, lsl #4
					} while (getMillis() < lTimeWaitEnd);
    20d8:	0013010a 	andseq	r0, r3, sl, lsl #2
    20dc:	00051300 	andeq	r1, r5, r0, lsl #6
					PrintString("\n");
#endif

				}
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
    20e0:	0b3a0e03 	bleq	e858f4 <__Stack_Size+0xe854f4>
    20e4:	1349053b 	movtne	r0, #38203	; 0x953b
    20e8:	00000a02 	andeq	r0, r0, r2, lsl #20
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
    20ec:	03000514 	movweq	r0, #1300	; 0x514
					PrintString("Barebones lTimeWaitEnd-Millis  ");
					Printu32d(getMillis);
					PrintString("\n");
#endif
				} else {
					FreeServos();
    20f0:	3b0b3a0e 	blcc	2d0930 <__Stack_Size+0x2d0530>
    20f4:	02134905 	andseq	r4, r3, #81920	; 0x14000
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
					ServoMoveTime = 600;
    20f8:	15000006 	strne	r0, [r0, #-6]
    20fc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
					StartUpdateServos();
    2100:	053b0b3a 	ldreq	r0, [fp, #-2874]!
					CommitServoDriver(ServoMoveTime);
    2104:	0a021349 	beq	86e30 <__Stack_Size+0x86a30>
					//MSound(3, 100, 2500, 80, 2250, 60, 2000);
					Buzzed(100, 2500);
    2108:	2e160000 	wxorcs	wr0, wr6, wr0
    210c:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2110:	3b0b3a0e 	blcc	2d0950 <__Stack_Size+0x2d0550>
					Buzzed(80, 2250);
    2114:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    2118:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
					Buzzed(60, 2000);
    211c:	010a4001 	tsteq	sl, r1
    2120:	17000013 	smladne	r0, r3, r0, r0
    2124:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

					//lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
					lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
    2128:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    212c:	00001349 	andeq	r1, r0, r9, asr #6
					Printu32d(lTimeWaitEnd);
					PrintString("\n");
#endif
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    2130:	3f012e18 	svccc	0x00012e18
					} while (getMillis() < lTimeWaitEnd);
    2134:	3a0e030c 	bcc	382d6c <__Stack_Size+0x38296c>
    2138:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
				} else {
					FreeServos();
				}

				// Allow the Servo driver to do stuff durint our idle time
				IdleTime();
    213c:	1201110c 	andne	r1, r1, #3	; 0x3
				mDelay(20); // give a pause between times we call if nothing is happening
    2140:	01064001 	tsteq	r6, r1
			}
			PrevServoMoveTime = ServoMoveTime;
    2144:	19000013 	stmdbne	r0, {r0, r1, r4}
    2148:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

			//Store previous g_InControlState.fRobotOn State
			if (g_InControlState.fRobotOn)
    214c:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2150:	06021349 	streq	r1, [r2], -r9, asr #6
				g_InControlState.fPrev_RobotOn = 1;
			else
				g_InControlState.fPrev_RobotOn = 0;
    2154:	2e1a0000 	wxorcs	wr0, wr10, wr0
    2158:	030c3f00 	movweq	r3, #52992	; 0xcf00
    215c:	3b0b3a0e 	blcc	2d099c <__Stack_Size+0x2d059c>
    2160:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    2164:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2168:	000a4001 	andeq	r4, sl, r1
    216c:	012e1b00 	teqeq	lr, r0, lsl #22
    2170:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2174:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2178:	13490c27 	movtne	r0, #39975	; 0x9c27
    217c:	01120111 	tsteq	r2, r1, lsl r1
    2180:	13010640 	movwne	r0, #5696	; 0x1640
    2184:	2e1c0000 	wxorcs	wr0, wr12, wr0
    2188:	030c3f01 	movweq	r3, #52993	; 0xcf01
    218c:	3b0b3a0e 	blcc	2d09cc <__Stack_Size+0x2d05cc>
    2190:	110c270b 	tstne	ip, fp, lsl #14
    2194:	40011201 	andmi	r1, r1, r1, lsl #4
    2198:	1d000006 	stcne	0, cr0, [r0, #-24]
    219c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    21a0:	0b3b0b3a 	bleq	ec4e90 <__Stack_Size+0xec4a90>
    21a4:	06021349 	streq	r1, [r2], -r9, asr #6
    21a8:	01000000 	tsteq	r0, r0
    21ac:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    21b0:	0e030b13 	vmoveq.32	d3[0], r0
    21b4:	01110e1b 	tsteq	r1, fp, lsl lr
    21b8:	06100112 	undefined
    21bc:	24020000 	strcs	r0, [r2]
    21c0:	3e0b0b00 	fmacdcc	d0, d11, d0
    21c4:	000e030b 	andeq	r0, lr, fp, lsl #6
    21c8:	00160300 	andseq	r0, r6, r0, lsl #6
    21cc:	0b3a0803 	bleq	e841e0 <__Stack_Size+0xe83de0>
    21d0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    21d4:	35040000 	strcc	r0, [r4]
    21d8:	00134900 	andseq	r4, r3, r0, lsl #18
    21dc:	01040500 	tsteq	r4, r0, lsl #10
    21e0:	0b3a0b0b 	bleq	e84e14 <__Stack_Size+0xe84a14>
    21e4:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    21e8:	28060000 	stmdacs	r6, {}
    21ec:	1c0e0300 	stcne	3, cr0, [lr], {0}
    21f0:	0700000d 	streq	r0, [r0, -sp]
    21f4:	08030028 	stmdaeq	r3, {r3, r5}
    21f8:	00000d1c 	andeq	r0, r0, ip, lsl sp
    21fc:	03001608 	movweq	r1, #1544	; 0x608
    2200:	3b0b3a0e 	blcc	2d0a40 <__Stack_Size+0x2d0640>
    2204:	0013490b 	andseq	r4, r3, fp, lsl #18
    2208:	00240900 	eoreq	r0, r4, r0, lsl #18
    220c:	0b3e0b0b 	bleq	f84e40 <__Stack_Size+0xf84a40>
    2210:	130a0000 	movwne	r0, #40960	; 0xa000
    2214:	3a0b0b01 	bcc	2c4e20 <__Stack_Size+0x2c4a20>
    2218:	01053b0b 	tsteq	r5, fp, lsl #22
    221c:	0b000013 	bleq	2270 <__Stack_Size+0x1e70>
    2220:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    2224:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2228:	0a381349 	beq	e06f54 <__Stack_Size+0xe06b54>
    222c:	0d0c0000 	stceq	0, cr0, [ip]
    2230:	3a0e0300 	bcc	382e38 <__Stack_Size+0x382a38>
    2234:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2238:	000a3813 	andeq	r3, sl, r3, lsl r8
    223c:	012e0d00 	teqeq	lr, r0, lsl #26
    2240:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2244:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2248:	13490c27 	movtne	r0, #39975	; 0x9c27
    224c:	13010b20 	movwne	r0, #6944	; 0x1b20
    2250:	340e0000 	strcc	r0, [lr]
    2254:	3a0e0300 	bcc	382e5c <__Stack_Size+0x382a5c>
    2258:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    225c:	0f000013 	svceq	0x00000013
    2260:	0e03012e 	adfeqsp	f0, f3, #0.5
    2264:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2268:	0b200c27 	bleq	80530c <__Stack_Size+0x804f0c>
    226c:	00001301 	andeq	r1, r0, r1, lsl #6
    2270:	03003410 	movweq	r3, #1040	; 0x410
    2274:	3b0b3a08 	blcc	2d0a9c <__Stack_Size+0x2d069c>
    2278:	00134905 	andseq	r4, r3, r5, lsl #18
    227c:	012e1100 	teqeq	lr, r0, lsl #2
    2280:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2284:	0b3b0b3a 	bleq	ec4f74 <__Stack_Size+0xec4b74>
    2288:	01110c27 	tsteq	r1, r7, lsr #24
    228c:	0a400112 	beq	10026dc <__Stack_Size+0x10022dc>
    2290:	00001301 	andeq	r1, r0, r1, lsl #6
    2294:	03000512 	movweq	r0, #1298	; 0x512
    2298:	3b0b3a0e 	blcc	2d0ad8 <__Stack_Size+0x2d06d8>
    229c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    22a0:	13000006 	movwne	r0, #6	; 0x6
    22a4:	0c3f002e 	ldceq	0, cr0, [pc], #-184
    22a8:	0b3a0e03 	bleq	e85abc <__Stack_Size+0xe856bc>
    22ac:	0c270b3b 	stceq	11, cr0, [r7], #-236
    22b0:	01120111 	tsteq	r2, r1, lsl r1
    22b4:	00000a40 	andeq	r0, r0, r0, asr #20
    22b8:	3f002e14 	svccc	0x00002e14
    22bc:	3a0e030c 	bcc	382ef4 <__Stack_Size+0x382af4>
    22c0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    22c4:	1113490c 	tstne	r3, ip, lsl #18
    22c8:	40011201 	andmi	r1, r1, r1, lsl #4
    22cc:	1500000a 	strne	r0, [r0, #-10]
    22d0:	0c3f012e 	ldfeqs	f0, [pc], #-184
    22d4:	0b3a0e03 	bleq	e85ae8 <__Stack_Size+0xe856e8>
    22d8:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
    22dc:	01111349 	tsteq	r1, r9, asr #6
    22e0:	0a400112 	beq	1002730 <__Stack_Size+0x1002330>
    22e4:	00001301 	andeq	r1, r0, r1, lsl #6
    22e8:	3f012e16 	svccc	0x00012e16
    22ec:	3a0e030c 	bcc	382f24 <__Stack_Size+0x382b24>
    22f0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    22f4:	1201110c 	andne	r1, r1, #3	; 0x3
    22f8:	010a4001 	tsteq	sl, r1
    22fc:	17000013 	smladne	r0, r3, r0, r0
    2300:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    2304:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2308:	0a021349 	beq	87034 <__Stack_Size+0x86c34>
    230c:	05180000 	ldreq	r0, [r8]
    2310:	3a0e0300 	bcc	382f18 <__Stack_Size+0x382b18>
    2314:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2318:	00060213 	andeq	r0, r6, r3, lsl r2
    231c:	00341900 	eorseq	r1, r4, r0, lsl #18
    2320:	0b3a0e03 	bleq	e85b34 <__Stack_Size+0xe85734>
    2324:	1349053b 	movtne	r0, #38203	; 0x953b
    2328:	00000602 	andeq	r0, r0, r2, lsl #12
    232c:	31012e1a 	tstcc	r1, sl, lsl lr
    2330:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2334:	010a4001 	tsteq	sl, r1
    2338:	1b000013 	blne	238c <__Stack_Size+0x1f8c>
    233c:	13310034 	teqne	r1, #52	; 0x34
    2340:	00000602 	andeq	r0, r0, r2, lsl #12
    2344:	3f012e1c 	svccc	0x00012e1c
    2348:	3a0e030c 	bcc	382f80 <__Stack_Size+0x382b80>
    234c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2350:	1113490c 	tstne	r3, ip, lsl #18
    2354:	40011201 	andmi	r1, r1, r1, lsl #4
    2358:	00130106 	andseq	r0, r3, r6, lsl #2
    235c:	011d1d00 	tsteq	sp, r0, lsl #26
    2360:	06551331 	undefined
    2364:	05590b58 	ldrbeq	r0, [r9, #-2904]
    2368:	00001301 	andeq	r1, r0, r1, lsl #6
    236c:	55010b1e 	strpl	r0, [r1, #-2846]
    2370:	1f000006 	svcne	0x00000006
    2374:	13310034 	teqne	r1, #52	; 0x34
    2378:	1d200000 	stcne	0, cr0, [r0]
    237c:	55133101 	ldrpl	r3, [r3, #-257]
    2380:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
    2384:	21000005 	tstcs	r0, r5
    2388:	0c3f012e 	ldfeqs	f0, [pc], #-184
    238c:	0b3a0e03 	bleq	e85ba0 <__Stack_Size+0xe857a0>
    2390:	0c270b3b 	stceq	11, cr0, [r7], #-236
    2394:	01111349 	tsteq	r1, r9, asr #6
    2398:	06400112 	undefined
    239c:	00001301 	andeq	r1, r0, r1, lsl #6
    23a0:	03003422 	movweq	r3, #1058	; 0x422
    23a4:	3b0b3a0e 	blcc	2d0be4 <__Stack_Size+0x2d07e4>
    23a8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    23ac:	23000006 	movwcs	r0, #6	; 0x6
    23b0:	0c3f012e 	ldfeqs	f0, [pc], #-184
    23b4:	0b3a0e03 	bleq	e85bc8 <__Stack_Size+0xe857c8>
    23b8:	0c270b3b 	stceq	11, cr0, [r7], #-236
    23bc:	01111349 	tsteq	r1, r9, asr #6
    23c0:	06400112 	undefined
    23c4:	01000000 	tsteq	r0, r0
    23c8:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    23cc:	0e030b13 	vmoveq.32	d3[0], r0
    23d0:	01110e1b 	tsteq	r1, fp, lsl lr
    23d4:	06100112 	undefined
    23d8:	24020000 	strcs	r0, [r2]
    23dc:	3e0b0b00 	fmacdcc	d0, d11, d0
    23e0:	000e030b 	andeq	r0, lr, fp, lsl #6
    23e4:	00160300 	andseq	r0, r6, r0, lsl #6
    23e8:	0b3a0803 	bleq	e843fc <__Stack_Size+0xe83ffc>
    23ec:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    23f0:	35040000 	strcc	r0, [r4]
    23f4:	00134900 	andseq	r4, r3, r0, lsl #18
    23f8:	01040500 	tsteq	r4, r0, lsl #10
    23fc:	0b3a0b0b 	bleq	e85030 <__Stack_Size+0xe84c30>
    2400:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    2404:	28060000 	stmdacs	r6, {}
    2408:	1c0e0300 	stcne	3, cr0, [lr], {0}
    240c:	0700000d 	streq	r0, [r0, -sp]
    2410:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    2414:	0b3b0b3a 	bleq	ec5104 <__Stack_Size+0xec4d04>
    2418:	00001349 	andeq	r1, r0, r9, asr #6
    241c:	0b002408 	bleq	b444 <__Stack_Size+0xb044>
    2420:	000b3e0b 	andeq	r3, fp, fp, lsl #28
    2424:	01130900 	tsteq	r3, r0, lsl #18
    2428:	0b3a0b0b 	bleq	e8505c <__Stack_Size+0xe84c5c>
    242c:	1301053b 	movwne	r0, #5435	; 0x153b
    2430:	0d0a0000 	stceq	0, cr0, [sl]
    2434:	3a080300 	bcc	20303c <__Stack_Size+0x202c3c>
    2438:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    243c:	000a3813 	andeq	r3, sl, r3, lsl r8
    2440:	000d0b00 	andeq	r0, sp, r0, lsl #22
    2444:	0b3a0e03 	bleq	e85c58 <__Stack_Size+0xe85858>
    2448:	1349053b 	movtne	r0, #38203	; 0x953b
    244c:	00000a38 	andeq	r0, r0, r8, lsr sl
    2450:	0300160c 	movweq	r1, #1548	; 0x60c
    2454:	3b0b3a0e 	blcc	2d0c94 <__Stack_Size+0x2d0894>
    2458:	00134905 	andseq	r4, r3, r5, lsl #18
    245c:	01010d00 	tsteq	r1, r0, lsl #26
    2460:	13011349 	movwne	r1, #4937	; 0x1349
    2464:	210e0000 	tstcs	lr, r0
    2468:	2f134900 	svccs	0x00134900
    246c:	0f00000b 	svceq	0x0000000b
    2470:	0b0b0113 	bleq	2c28c4 <__Stack_Size+0x2c24c4>
    2474:	0b3b0b3a 	bleq	ec5164 <__Stack_Size+0xec4d64>
    2478:	00001301 	andeq	r1, r0, r1, lsl #6
    247c:	03000d10 	movweq	r0, #3344	; 0xd10
    2480:	3b0b3a0e 	blcc	2d0cc0 <__Stack_Size+0x2d08c0>
    2484:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    2488:	1100000a 	tstne	r0, sl
    248c:	0c3f012e 	ldfeqs	f0, [pc], #-184
    2490:	0b3a0e03 	bleq	e85ca4 <__Stack_Size+0xe858a4>
    2494:	0c270b3b 	stceq	11, cr0, [r7], #-236
    2498:	01120111 	tsteq	r2, r1, lsl r1
    249c:	13010640 	movwne	r0, #5696	; 0x1640
    24a0:	05120000 	ldreq	r0, [r2]
    24a4:	3a0e0300 	bcc	3830ac <__Stack_Size+0x382cac>
    24a8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    24ac:	000a0213 	andeq	r0, sl, r3, lsl r2
    24b0:	00051300 	andeq	r1, r5, r0, lsl #6
    24b4:	0b3a0e03 	bleq	e85cc8 <__Stack_Size+0xe858c8>
    24b8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    24bc:	00000602 	andeq	r0, r0, r2, lsl #12
    24c0:	03003414 	movweq	r3, #1044	; 0x414
    24c4:	3b0b3a0e 	blcc	2d0d04 <__Stack_Size+0x2d0904>
    24c8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    24cc:	1500000a 	strne	r0, [r0, #-10]
    24d0:	08030034 	stmdaeq	r3, {r2, r4, r5}
    24d4:	0b3b0b3a 	bleq	ec51c4 <__Stack_Size+0xec4dc4>
    24d8:	06021349 	streq	r1, [r2], -r9, asr #6
    24dc:	34160000 	ldrcc	r0, [r6]
    24e0:	3a0e0300 	bcc	3830e8 <__Stack_Size+0x382ce8>
    24e4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    24e8:	17000013 	smladne	r0, r3, r0, r0
    24ec:	0b0b000f 	bleq	2c2530 <__Stack_Size+0x2c2130>
    24f0:	00001349 	andeq	r1, r0, r9, asr #6
    24f4:	3f012e18 	svccc	0x00012e18
    24f8:	3a0e030c 	bcc	383130 <__Stack_Size+0x382d30>
    24fc:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    2500:	1201110c 	andne	r1, r1, #3	; 0x3
    2504:	010a4001 	tsteq	sl, r1
    2508:	19000013 	stmdbne	r0, {r0, r1, r4}
    250c:	0c3f012e 	ldfeqs	f0, [pc], #-184
    2510:	0b3a0e03 	bleq	e85d24 <__Stack_Size+0xe85924>
    2514:	0c270b3b 	stceq	11, cr0, [r7], #-236
    2518:	01111349 	tsteq	r1, r9, asr #6
    251c:	0a400112 	beq	100296c <__Stack_Size+0x100256c>
    2520:	00001301 	andeq	r1, r0, r1, lsl #6
    2524:	3f012e1a 	svccc	0x00012e1a
    2528:	3a0e030c 	bcc	383160 <__Stack_Size+0x382d60>
    252c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2530:	1113490c 	tstne	r3, ip, lsl #18
    2534:	40011201 	andmi	r1, r1, r1, lsl #4
    2538:	0013010a 	andseq	r0, r3, sl, lsl #2
    253c:	00051b00 	andeq	r1, r5, r0, lsl #22
    2540:	0b3a0e03 	bleq	e85d54 <__Stack_Size+0xe85954>
    2544:	1349053b 	movtne	r0, #38203	; 0x953b
    2548:	00000602 	andeq	r0, r0, r2, lsl #12
    254c:	0300051c 	movweq	r0, #1308	; 0x51c
    2550:	3b0b3a0e 	blcc	2d0d90 <__Stack_Size+0x2d0990>
    2554:	02134905 	andseq	r4, r3, #81920	; 0x14000
    2558:	1d00000a 	stcne	0, cr0, [r0, #-40]
    255c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2560:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2564:	00001349 	andeq	r1, r0, r9, asr #6
    2568:	3f012e1e 	svccc	0x00012e1e
    256c:	3a0e030c 	bcc	3831a4 <__Stack_Size+0x382da4>
    2570:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2574:	1201110c 	andne	r1, r1, #3	; 0x3
    2578:	010a4001 	tsteq	sl, r1
    257c:	1f000013 	svcne	0x00000013
    2580:	08030034 	stmdaeq	r3, {r2, r4, r5}
    2584:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2588:	0a021349 	beq	872b4 <__Stack_Size+0x86eb4>
    258c:	34200000 	strtcc	r0, [r0]
    2590:	3a0e0300 	bcc	383198 <__Stack_Size+0x382d98>
    2594:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2598:	00060213 	andeq	r0, r6, r3, lsl r2
    259c:	012e2100 	teqeq	lr, r0, lsl #2
    25a0:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    25a4:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    25a8:	01110c27 	tsteq	r1, r7, lsr #24
    25ac:	06400112 	undefined
    25b0:	00001301 	andeq	r1, r0, r1, lsl #6
    25b4:	03003422 	movweq	r3, #1058	; 0x422
    25b8:	3b0b3a08 	blcc	2d0de0 <__Stack_Size+0x2d09e0>
    25bc:	00134905 	andseq	r4, r3, r5, lsl #18
    25c0:	002e2300 	eoreq	r2, lr, r0, lsl #6
    25c4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    25c8:	0b3b0b3a 	bleq	ec52b8 <__Stack_Size+0xec4eb8>
    25cc:	01110c27 	tsteq	r1, r7, lsr #24
    25d0:	06400112 	undefined
    25d4:	2e240000 	cdpcs	0, 2, cr0, cr4, cr0, {0}
    25d8:	030c3f01 	movweq	r3, #52993	; 0xcf01
    25dc:	3b0b3a0e 	blcc	2d0e1c <__Stack_Size+0x2d0a1c>
    25e0:	110c270b 	tstne	ip, fp, lsl #14
    25e4:	40011201 	andmi	r1, r1, r1, lsl #4
    25e8:	00000006 	andeq	r0, r0, r6
    25ec:	25011101 	strcs	r1, [r1, #-257]
    25f0:	030b130e 	movweq	r1, #45838	; 0xb30e
    25f4:	110e1b0e 	tstne	lr, lr, lsl #22
    25f8:	10011201 	andne	r1, r1, r1, lsl #4
    25fc:	02000006 	andeq	r0, r0, #6	; 0x6
    2600:	0b0b0024 	bleq	2c2698 <__Stack_Size+0x2c2298>
    2604:	0e030b3e 	vmoveq.16	d3[0], r0
    2608:	16030000 	strne	r0, [r3], -r0
    260c:	3a080300 	bcc	203214 <__Stack_Size+0x202e14>
    2610:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2614:	04000013 	streq	r0, [r0], #-19
    2618:	13490035 	movtne	r0, #36917	; 0x9035
    261c:	26050000 	strcs	r0, [r5], -r0
    2620:	00134900 	andseq	r4, r3, r0, lsl #18
    2624:	01040600 	tsteq	r4, r0, lsl #12
    2628:	0b3a0b0b 	bleq	e8525c <__Stack_Size+0xe84e5c>
    262c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    2630:	28070000 	stmdacs	r7, {}
    2634:	1c0e0300 	stcne	3, cr0, [lr], {0}
    2638:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    263c:	08030028 	stmdaeq	r3, {r3, r5}
    2640:	00000d1c 	andeq	r0, r0, ip, lsl sp
    2644:	03001609 	movweq	r1, #1545	; 0x609
    2648:	3b0b3a0e 	blcc	2d0e88 <__Stack_Size+0x2d0a88>
    264c:	0013490b 	andseq	r4, r3, fp, lsl #18
    2650:	00240a00 	eoreq	r0, r4, r0, lsl #20
    2654:	0b3e0b0b 	bleq	f85288 <__Stack_Size+0xf84e88>
    2658:	130b0000 	movwne	r0, #45056	; 0xb000
    265c:	3a050b01 	bcc	145268 <__Stack_Size+0x144e68>
    2660:	01053b0b 	tsteq	r5, fp, lsl #22
    2664:	0c000013 	stceq	0, cr0, [r0], {19}
    2668:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    266c:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2670:	0a381349 	beq	e0739c <__Stack_Size+0xe06f9c>
    2674:	0d0d0000 	stceq	0, cr0, [sp]
    2678:	3a080300 	bcc	203280 <__Stack_Size+0x202e80>
    267c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2680:	000a3813 	andeq	r3, sl, r3, lsl r8
    2684:	01010e00 	tsteq	r1, r0, lsl #28
    2688:	13011349 	movwne	r1, #4937	; 0x1349
    268c:	210f0000 	mrscs	r0, CPSR
    2690:	2f134900 	svccs	0x00134900
    2694:	1000000b 	andne	r0, r0, fp
    2698:	0b0b0113 	bleq	2c2aec <__Stack_Size+0x2c26ec>
    269c:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    26a0:	00001301 	andeq	r1, r0, r1, lsl #6
    26a4:	0b011311 	bleq	472f0 <__Stack_Size+0x46ef0>
    26a8:	3b0b3a0b 	blcc	2d0edc <__Stack_Size+0x2d0adc>
    26ac:	0013010b 	andseq	r0, r3, fp, lsl #2
    26b0:	000d1200 	andeq	r1, sp, r0, lsl #4
    26b4:	0b3a0e03 	bleq	e85ec8 <__Stack_Size+0xe85ac8>
    26b8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    26bc:	00000a38 	andeq	r0, r0, r8, lsr sl
    26c0:	3f012e13 	svccc	0x00012e13
    26c4:	3a0e030c 	bcc	3832fc <__Stack_Size+0x382efc>
    26c8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    26cc:	1201110c 	andne	r1, r1, #3	; 0x3
    26d0:	010a4001 	tsteq	sl, r1
    26d4:	14000013 	strne	r0, [r0], #-19
    26d8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    26dc:	0b3b0b3a 	bleq	ec53cc <__Stack_Size+0xec4fcc>
    26e0:	0a021349 	beq	8740c <__Stack_Size+0x8700c>
    26e4:	34150000 	ldrcc	r0, [r5]
    26e8:	3a0e0300 	bcc	3832f0 <__Stack_Size+0x382ef0>
    26ec:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    26f0:	16000013 	undefined
    26f4:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    26f8:	0b3b0b3a 	bleq	ec53e8 <__Stack_Size+0xec4fe8>
    26fc:	06021349 	streq	r1, [r2], -r9, asr #6
    2700:	2e170000 	wxorcs	wr0, wr7, wr0
    2704:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2708:	3b0b3a0e 	blcc	2d0f48 <__Stack_Size+0x2d0b48>
    270c:	110c270b 	tstne	ip, fp, lsl #14
    2710:	40011201 	andmi	r1, r1, r1, lsl #4
    2714:	00130106 	andseq	r0, r3, r6, lsl #2
    2718:	00341800 	eorseq	r1, r4, r0, lsl #16
    271c:	0b3a0e03 	bleq	e85f30 <__Stack_Size+0xe85b30>
    2720:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2724:	00000602 	andeq	r0, r0, r2, lsl #12
    2728:	0b000f19 	bleq	6394 <__Stack_Size+0x5f94>
    272c:	0013490b 	andseq	r4, r3, fp, lsl #18
    2730:	00051a00 	andeq	r1, r5, r0, lsl #20
    2734:	0b3a0e03 	bleq	e85f48 <__Stack_Size+0xe85b48>
    2738:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    273c:	00000a02 	andeq	r0, r0, r2, lsl #20
    2740:	3f002e1b 	svccc	0x00002e1b
    2744:	3a0e030c 	bcc	38337c <__Stack_Size+0x382f7c>
    2748:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    274c:	1113490c 	tstne	r3, ip, lsl #18
    2750:	40011201 	andmi	r1, r1, r1, lsl #4
    2754:	1c00000a 	stcne	0, cr0, [r0], {10}
    2758:	0c3f012e 	ldfeqs	f0, [pc], #-184
    275c:	0b3a0e03 	bleq	e85f70 <__Stack_Size+0xe85b70>
    2760:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
    2764:	01111349 	tsteq	r1, r9, asr #6
    2768:	0a400112 	beq	1002bb8 <__Stack_Size+0x10027b8>
    276c:	00001301 	andeq	r1, r0, r1, lsl #6
    2770:	0300051d 	movweq	r0, #1309	; 0x51d
    2774:	3b0b3a0e 	blcc	2d0fb4 <__Stack_Size+0x2d0bb4>
    2778:	02134905 	andseq	r4, r3, #81920	; 0x14000
    277c:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
    2780:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2784:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2788:	00001349 	andeq	r1, r0, r9, asr #6
    278c:	0300341f 	movweq	r3, #1055	; 0x41f
    2790:	3b0b3a08 	blcc	2d0fb8 <__Stack_Size+0x2d0bb8>
    2794:	02134905 	andseq	r4, r3, #81920	; 0x14000
    2798:	2000000a 	andcs	r0, r0, sl
    279c:	0c3f012e 	ldfeqs	f0, [pc], #-184
    27a0:	0b3a0e03 	bleq	e85fb4 <__Stack_Size+0xe85bb4>
    27a4:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
    27a8:	01120111 	tsteq	r2, r1, lsl r1
    27ac:	13010a40 	movwne	r0, #6720	; 0x1a40
    27b0:	05210000 	streq	r0, [r1]!
    27b4:	3a0e0300 	bcc	3833bc <__Stack_Size+0x382fbc>
    27b8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    27bc:	000a0213 	andeq	r0, sl, r3, lsl r2
    27c0:	002e2200 	eoreq	r2, lr, r0, lsl #4
    27c4:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    27c8:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    27cc:	01110c27 	tsteq	r1, r7, lsr #24
    27d0:	0a400112 	beq	1002c20 <__Stack_Size+0x1002820>
    27d4:	34230000 	strtcc	r0, [r3]
    27d8:	3a0e0300 	bcc	3833e0 <__Stack_Size+0x382fe0>
    27dc:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    27e0:	000a0213 	andeq	r0, sl, r3, lsl r2
    27e4:	012e2400 	teqeq	lr, r0, lsl #8
    27e8:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    27ec:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    27f0:	01110c27 	tsteq	r1, r7, lsr #24
    27f4:	06400112 	undefined
    27f8:	00001301 	andeq	r1, r0, r1, lsl #6
    27fc:	03003425 	movweq	r3, #1061	; 0x425
    2800:	3b0b3a0e 	blcc	2d1040 <__Stack_Size+0x2d0c40>
    2804:	02134905 	andseq	r4, r3, #81920	; 0x14000
    2808:	26000006 	strcs	r0, [r0], -r6
    280c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    2810:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2814:	00001349 	andeq	r1, r0, r9, asr #6
    2818:	3f002e27 	svccc	0x00002e27
    281c:	3a0e030c 	bcc	383454 <__Stack_Size+0x383054>
    2820:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    2824:	1113490c 	tstne	r3, ip, lsl #18
    2828:	40011201 	andmi	r1, r1, r1, lsl #4
    282c:	28000006 	stmdacs	r0, {r1, r2}
    2830:	0c3f002e 	ldceq	0, cr0, [pc], #-184
    2834:	0b3a0e03 	bleq	e86048 <__Stack_Size+0xe85c48>
    2838:	0c270b3b 	stceq	11, cr0, [r7], #-236
    283c:	01120111 	tsteq	r2, r1, lsl r1
    2840:	00000640 	andeq	r0, r0, r0, asr #12
    2844:	01110100 	tsteq	r1, r0, lsl #2
    2848:	0b130e25 	bleq	4c60e4 <__Stack_Size+0x4c5ce4>
    284c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    2850:	01120111 	tsteq	r2, r1, lsl r1
    2854:	00000610 	andeq	r0, r0, r0, lsl r6
    2858:	0b002402 	bleq	b868 <__Stack_Size+0xb468>
    285c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    2860:	0300000e 	movweq	r0, #14	; 0xe
    2864:	08030016 	stmdaeq	r3, {r1, r2, r4}
    2868:	0b3b0b3a 	bleq	ec5558 <__Stack_Size+0xec5158>
    286c:	00001349 	andeq	r1, r0, r9, asr #6
    2870:	49003504 	stmdbmi	r0, {r2, r8, sl, ip, sp}
    2874:	05000013 	streq	r0, [r0, #-19]
    2878:	0b0b0104 	bleq	2c2c90 <__Stack_Size+0x2c2890>
    287c:	0b3b0b3a 	bleq	ec556c <__Stack_Size+0xec516c>
    2880:	00001301 	andeq	r1, r0, r1, lsl #6
    2884:	03002806 	movweq	r2, #2054	; 0x806
    2888:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    288c:	00280700 	eoreq	r0, r8, r0, lsl #14
    2890:	0d1c0803 	ldceq	8, cr0, [ip, #-12]
    2894:	16080000 	strne	r0, [r8], -r0
    2898:	3a0e0300 	bcc	3834a0 <__Stack_Size+0x3830a0>
    289c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    28a0:	09000013 	stmdbeq	r0, {r0, r1, r4}
    28a4:	0b0b0024 	bleq	2c293c <__Stack_Size+0x2c253c>
    28a8:	00000b3e 	andeq	r0, r0, lr, lsr fp
    28ac:	0b01130a 	bleq	474dc <__Stack_Size+0x470dc>
    28b0:	3b0b3a0b 	blcc	2d10e4 <__Stack_Size+0x2d0ce4>
    28b4:	00130105 	andseq	r0, r3, r5, lsl #2
    28b8:	000d0b00 	andeq	r0, sp, r0, lsl #22
    28bc:	0b3a0803 	bleq	e848d0 <__Stack_Size+0xe844d0>
    28c0:	1349053b 	movtne	r0, #38203	; 0x953b
    28c4:	00000a38 	andeq	r0, r0, r8, lsr sl
    28c8:	3f012e0c 	svccc	0x00012e0c
    28cc:	3a0e030c 	bcc	383504 <__Stack_Size+0x383104>
    28d0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    28d4:	1201110c 	andne	r1, r1, #3	; 0x3
    28d8:	010a4001 	tsteq	sl, r1
    28dc:	0d000013 	stceq	0, cr0, [r0, #-76]
    28e0:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    28e4:	0b3b0b3a 	bleq	ec55d4 <__Stack_Size+0xec51d4>
    28e8:	0a021349 	beq	87614 <__Stack_Size+0x87214>
    28ec:	050e0000 	streq	r0, [lr]
    28f0:	3a0e0300 	bcc	3834f8 <__Stack_Size+0x3830f8>
    28f4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    28f8:	00060213 	andeq	r0, r6, r3, lsl r2
    28fc:	00340f00 	eorseq	r0, r4, r0, lsl #30
    2900:	0b3a0e03 	bleq	e86114 <__Stack_Size+0xe85d14>
    2904:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2908:	00000602 	andeq	r0, r0, r2, lsl #12
    290c:	3f012e10 	svccc	0x00012e10
    2910:	3a0e030c 	bcc	383548 <__Stack_Size+0x383148>
    2914:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    2918:	1113490c 	tstne	r3, ip, lsl #18
    291c:	40011201 	andmi	r1, r1, r1, lsl #4
    2920:	0013010a 	andseq	r0, r3, sl, lsl #2
    2924:	00341100 	eorseq	r1, r4, r0, lsl #2
    2928:	0b3a0e03 	bleq	e8613c <__Stack_Size+0xe85d3c>
    292c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2930:	2e120000 	wxorcs	wr0, wr2, wr0
    2934:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2938:	3b0b3a0e 	blcc	2d1178 <__Stack_Size+0x2d0d78>
    293c:	110c2705 	tstne	ip, r5, lsl #14
    2940:	40011201 	andmi	r1, r1, r1, lsl #4
    2944:	0013010a 	andseq	r0, r3, sl, lsl #2
    2948:	00051300 	andeq	r1, r5, r0, lsl #6
    294c:	0b3a0e03 	bleq	e86160 <__Stack_Size+0xe85d60>
    2950:	1349053b 	movtne	r0, #38203	; 0x953b
    2954:	00000a02 	andeq	r0, r0, r2, lsl #20
    2958:	3f002e14 	svccc	0x00002e14
    295c:	3a0e030c 	bcc	383594 <__Stack_Size+0x383194>
    2960:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    2964:	1201110c 	andne	r1, r1, #3	; 0x3
    2968:	00064001 	andeq	r4, r6, r1
    296c:	012e1500 	teqeq	lr, r0, lsl #10
    2970:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2974:	0b3b0b3a 	bleq	ec5664 <__Stack_Size+0xec5264>
    2978:	01110c27 	tsteq	r1, r7, lsr #24
    297c:	06400112 	undefined
    2980:	00001301 	andeq	r1, r0, r1, lsl #6
    2984:	01110100 	tsteq	r1, r0, lsl #2
    2988:	0b130e25 	bleq	4c6224 <__Stack_Size+0x4c5e24>
    298c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    2990:	01120111 	tsteq	r2, r1, lsl r1
    2994:	00000610 	andeq	r0, r0, r0, lsl r6
    2998:	0b002402 	bleq	b9a8 <__Stack_Size+0xb5a8>
    299c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    29a0:	0300000e 	movweq	r0, #14	; 0xe
    29a4:	08030016 	stmdaeq	r3, {r1, r2, r4}
    29a8:	0b3b0b3a 	bleq	ec5698 <__Stack_Size+0xec5298>
    29ac:	00001349 	andeq	r1, r0, r9, asr #6
    29b0:	49003504 	stmdbmi	r0, {r2, r8, sl, ip, sp}
    29b4:	05000013 	streq	r0, [r0, #-19]
    29b8:	0b0b0104 	bleq	2c2dd0 <__Stack_Size+0x2c29d0>
    29bc:	0b3b0b3a 	bleq	ec56ac <__Stack_Size+0xec52ac>
    29c0:	00001301 	andeq	r1, r0, r1, lsl #6
    29c4:	03002806 	movweq	r2, #2054	; 0x806
    29c8:	000d1c0e 	andeq	r1, sp, lr, lsl #24
    29cc:	00280700 	eoreq	r0, r8, r0, lsl #14
    29d0:	0d1c0803 	ldceq	8, cr0, [ip, #-12]
    29d4:	16080000 	strne	r0, [r8], -r0
    29d8:	3a0e0300 	bcc	3835e0 <__Stack_Size+0x3831e0>
    29dc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    29e0:	09000013 	stmdbeq	r0, {r0, r1, r4}
    29e4:	0b0b0024 	bleq	2c2a7c <__Stack_Size+0x2c267c>
    29e8:	00000b3e 	andeq	r0, r0, lr, lsr fp
    29ec:	0b01130a 	bleq	4761c <__Stack_Size+0x4721c>
    29f0:	3b0b3a0b 	blcc	2d1224 <__Stack_Size+0x2d0e24>
    29f4:	00130105 	andseq	r0, r3, r5, lsl #2
    29f8:	000d0b00 	andeq	r0, sp, r0, lsl #22
    29fc:	0b3a0803 	bleq	e84a10 <__Stack_Size+0xe84610>
    2a00:	1349053b 	movtne	r0, #38203	; 0x953b
    2a04:	00000a38 	andeq	r0, r0, r8, lsr sl
    2a08:	03000d0c 	movweq	r0, #3340	; 0xd0c
    2a0c:	3b0b3a0e 	blcc	2d124c <__Stack_Size+0x2d0e4c>
    2a10:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
    2a14:	0d00000a 	stceq	0, cr0, [r0, #-40]
    2a18:	0b0b0113 	bleq	2c2e6c <__Stack_Size+0x2c2a6c>
    2a1c:	0b3b0b3a 	bleq	ec570c <__Stack_Size+0xec530c>
    2a20:	00001301 	andeq	r1, r0, r1, lsl #6
    2a24:	03000d0e 	movweq	r0, #3342	; 0xd0e
    2a28:	3b0b3a0e 	blcc	2d1268 <__Stack_Size+0x2d0e68>
    2a2c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    2a30:	0f00000a 	svceq	0x0000000a
    2a34:	0c3f012e 	ldfeqs	f0, [pc], #-184
    2a38:	0b3a0e03 	bleq	e8624c <__Stack_Size+0xe85e4c>
    2a3c:	0c27053b 	cfstr32eq	mvfx0, [r7], #-236
    2a40:	0b201349 	bleq	80776c <__Stack_Size+0x80736c>
    2a44:	00001301 	andeq	r1, r0, r1, lsl #6
    2a48:	03000510 	movweq	r0, #1296	; 0x510
    2a4c:	3b0b3a0e 	blcc	2d128c <__Stack_Size+0x2d0e8c>
    2a50:	00134905 	andseq	r4, r3, r5, lsl #18
    2a54:	00341100 	eorseq	r1, r4, r0, lsl #2
    2a58:	0b3a0803 	bleq	e84a6c <__Stack_Size+0xe8466c>
    2a5c:	1349053b 	movtne	r0, #38203	; 0x953b
    2a60:	34120000 	ldrcc	r0, [r2]
    2a64:	3a0e0300 	bcc	38366c <__Stack_Size+0x38326c>
    2a68:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2a6c:	13000013 	movwne	r0, #19	; 0x13
    2a70:	0c3f002e 	ldceq	0, cr0, [pc], #-184
    2a74:	0b3a0e03 	bleq	e86288 <__Stack_Size+0xe85e88>
    2a78:	0c270b3b 	stceq	11, cr0, [r7], #-236
    2a7c:	01120111 	tsteq	r2, r1, lsl r1
    2a80:	00000a40 	andeq	r0, r0, r0, asr #20
    2a84:	3f012e14 	svccc	0x00012e14
    2a88:	3a0e030c 	bcc	3836c0 <__Stack_Size+0x3832c0>
    2a8c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    2a90:	1201110c 	andne	r1, r1, #3	; 0x3
    2a94:	010a4001 	tsteq	sl, r1
    2a98:	15000013 	strne	r0, [r0, #-19]
    2a9c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    2aa0:	0b3b0b3a 	bleq	ec5790 <__Stack_Size+0xec5390>
    2aa4:	0a021349 	beq	877d0 <__Stack_Size+0x873d0>
    2aa8:	2e160000 	wxorcs	wr0, wr6, wr0
    2aac:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2ab0:	3b0b3a0e 	blcc	2d12f0 <__Stack_Size+0x2d0ef0>
    2ab4:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    2ab8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2abc:	01064001 	tsteq	r6, r1
    2ac0:	17000013 	smladne	r0, r3, r0, r0
    2ac4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2ac8:	0b3b0b3a 	bleq	ec57b8 <__Stack_Size+0xec53b8>
    2acc:	06021349 	streq	r1, [r2], -r9, asr #6
    2ad0:	34180000 	ldrcc	r0, [r8]
    2ad4:	3a0e0300 	bcc	3836dc <__Stack_Size+0x3832dc>
    2ad8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2adc:	19000013 	stmdbne	r0, {r0, r1, r4}
    2ae0:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    2ae4:	06550152 	undefined
    2ae8:	0b590b58 	bleq	1645850 <__Stack_Size+0x1645450>
    2aec:	00001301 	andeq	r1, r0, r1, lsl #6
    2af0:	3100051a 	tstcc	r0, sl, lsl r5
    2af4:	1b000013 	blne	2b48 <__Stack_Size+0x2748>
    2af8:	0655010b 	ldrbeq	r0, [r5], -fp, lsl #2
    2afc:	341c0000 	ldrcc	r0, [ip]
    2b00:	00133100 	andseq	r3, r3, r0, lsl #2
    2b04:	00341d00 	eorseq	r1, r4, r0, lsl #26
    2b08:	0a021331 	beq	877d4 <__Stack_Size+0x873d4>
    2b0c:	1d1e0000 	ldcne	0, cr0, [lr]
    2b10:	11133101 	tstne	r3, r1, lsl #2
    2b14:	58011201 	stmdapl	r1, {r0, r9, ip}
    2b18:	000b590b 	andeq	r5, fp, fp, lsl #18
    2b1c:	010b1f00 	tsteq	fp, r0, lsl #30
    2b20:	01120111 	tsteq	r2, r1, lsl r1
    2b24:	34200000 	strtcc	r0, [r0]
    2b28:	02133100 	andseq	r3, r3, #0	; 0x0
    2b2c:	21000006 	tstcs	r0, r6
    2b30:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2b34:	0b3b0b3a 	bleq	ec5824 <__Stack_Size+0xec5424>
    2b38:	0a021349 	beq	87864 <__Stack_Size+0x87464>
    2b3c:	2e220000 	cdpcs	0, 2, cr0, cr2, cr0, {0}
    2b40:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2b44:	3b0b3a0e 	blcc	2d1384 <__Stack_Size+0x2d0f84>
    2b48:	110c2705 	tstne	ip, r5, lsl #14
    2b4c:	40011201 	andmi	r1, r1, r1, lsl #4
    2b50:	0013010a 	andseq	r0, r3, sl, lsl #2
    2b54:	00052300 	andeq	r2, r5, r0, lsl #6
    2b58:	0b3a0e03 	bleq	e8636c <__Stack_Size+0xe85f6c>
    2b5c:	1349053b 	movtne	r0, #38203	; 0x953b
    2b60:	00000a02 	andeq	r0, r0, r2, lsl #20
    2b64:	03000524 	movweq	r0, #1316	; 0x524
    2b68:	3b0b3a0e 	blcc	2d13a8 <__Stack_Size+0x2d0fa8>
    2b6c:	02134905 	andseq	r4, r3, #81920	; 0x14000
    2b70:	25000006 	strcs	r0, [r0, #-6]
    2b74:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2b78:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2b7c:	06021349 	streq	r1, [r2], -r9, asr #6
    2b80:	2e260000 	cdpcs	0, 2, cr0, cr6, cr0, {0}
    2b84:	030c3f00 	movweq	r3, #52992	; 0xcf00
    2b88:	3b0b3a0e 	blcc	2d13c8 <__Stack_Size+0x2d0fc8>
    2b8c:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    2b90:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2b94:	000a4001 	andeq	r4, sl, r1
    2b98:	00342700 	eorseq	r2, r4, r0, lsl #14
    2b9c:	0b3a0e03 	bleq	e863b0 <__Stack_Size+0xe85fb0>
    2ba0:	1349053b 	movtne	r0, #38203	; 0x953b
    2ba4:	00000a02 	andeq	r0, r0, r2, lsl #20
    2ba8:	03003428 	movweq	r3, #1064	; 0x428
    2bac:	3b0b3a08 	blcc	2d13d4 <__Stack_Size+0x2d0fd4>
    2bb0:	02134905 	andseq	r4, r3, #81920	; 0x14000
    2bb4:	29000006 	stmdbcs	r0, {r1, r2}
    2bb8:	0b0b000f 	bleq	2c2bfc <__Stack_Size+0x2c27fc>
    2bbc:	00001349 	andeq	r1, r0, r9, asr #6
    2bc0:	31012e2a 	tstcc	r1, sl, lsr #28
    2bc4:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2bc8:	010a4001 	tsteq	sl, r1
    2bcc:	2b000013 	blcs	2c20 <__Stack_Size+0x2820>
    2bd0:	13310005 	teqne	r1, #5	; 0x5
    2bd4:	00000602 	andeq	r0, r0, r2, lsl #12
    2bd8:	3f002e2c 	svccc	0x00002e2c
    2bdc:	3a0e030c 	bcc	383814 <__Stack_Size+0x383414>
    2be0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2be4:	1201110c 	andne	r1, r1, #3	; 0x3
    2be8:	000a4001 	andeq	r4, sl, r1
    2bec:	012e2d00 	teqeq	lr, r0, lsl #26
    2bf0:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2bf4:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2bf8:	13490c27 	movtne	r0, #39975	; 0x9c27
    2bfc:	01120111 	tsteq	r2, r1, lsl r1
    2c00:	13010a40 	movwne	r0, #6720	; 0x1a40
    2c04:	012e0000 	teqeq	lr, r0
    2c08:	01134901 	tsteq	r3, r1, lsl #18
    2c0c:	2f000013 	svccs	0x00000013
    2c10:	13490021 	movtne	r0, #36897	; 0x9021
    2c14:	00000b2f 	andeq	r0, r0, pc, lsr #22
    2c18:	49002630 	stmdbmi	r0, {r4, r5, r9, sl, sp}
    2c1c:	00000013 	andeq	r0, r0, r3, lsl r0
    2c20:	25011101 	strcs	r1, [r1, #-257]
    2c24:	030b130e 	movweq	r1, #45838	; 0xb30e
    2c28:	110e1b0e 	tstne	lr, lr, lsl #22
    2c2c:	10011201 	andne	r1, r1, r1, lsl #4
    2c30:	02000006 	andeq	r0, r0, #6	; 0x6
    2c34:	0b0b0024 	bleq	2c2ccc <__Stack_Size+0x2c28cc>
    2c38:	0e030b3e 	vmoveq.16	d3[0], r0
    2c3c:	16030000 	strne	r0, [r3], -r0
    2c40:	3a080300 	bcc	203848 <__Stack_Size+0x203448>
    2c44:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2c48:	04000013 	streq	r0, [r0], #-19
    2c4c:	13490035 	movtne	r0, #36917	; 0x9035
    2c50:	26050000 	strcs	r0, [r5], -r0
    2c54:	00134900 	andseq	r4, r3, r0, lsl #18
    2c58:	01040600 	tsteq	r4, r0, lsl #12
    2c5c:	0b3a0b0b 	bleq	e85890 <__Stack_Size+0xe85490>
    2c60:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    2c64:	28070000 	stmdacs	r7, {}
    2c68:	1c0e0300 	stcne	3, cr0, [lr], {0}
    2c6c:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    2c70:	08030028 	stmdaeq	r3, {r3, r5}
    2c74:	00000d1c 	andeq	r0, r0, ip, lsl sp
    2c78:	03001609 	movweq	r1, #1545	; 0x609
    2c7c:	3b0b3a0e 	blcc	2d14bc <__Stack_Size+0x2d10bc>
    2c80:	0013490b 	andseq	r4, r3, fp, lsl #18
    2c84:	00240a00 	eoreq	r0, r4, r0, lsl #20
    2c88:	0b3e0b0b 	bleq	f858bc <__Stack_Size+0xf854bc>
    2c8c:	130b0000 	movwne	r0, #45056	; 0xb000
    2c90:	3a0b0b01 	bcc	2c589c <__Stack_Size+0x2c549c>
    2c94:	01053b0b 	tsteq	r5, fp, lsl #22
    2c98:	0c000013 	stceq	0, cr0, [r0], {19}
    2c9c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    2ca0:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2ca4:	0a381349 	beq	e079d0 <__Stack_Size+0xe075d0>
    2ca8:	0d0d0000 	stceq	0, cr0, [sp]
    2cac:	3a080300 	bcc	2038b4 <__Stack_Size+0x2034b4>
    2cb0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2cb4:	000a3813 	andeq	r3, sl, r3, lsl r8
    2cb8:	012e0e00 	teqeq	lr, r0, lsl #28
    2cbc:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2cc0:	0b3b0b3a 	bleq	ec59b0 <__Stack_Size+0xec55b0>
    2cc4:	01110c27 	tsteq	r1, r7, lsr #24
    2cc8:	0a400112 	beq	1003118 <__Stack_Size+0x1002d18>
    2ccc:	00001301 	andeq	r1, r0, r1, lsl #6
    2cd0:	0300050f 	movweq	r0, #1295	; 0x50f
    2cd4:	3b0b3a0e 	blcc	2d1514 <__Stack_Size+0x2d1114>
    2cd8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    2cdc:	1000000a 	andne	r0, r0, sl
    2ce0:	0c3f002e 	ldceq	0, cr0, [pc], #-184
    2ce4:	0b3a0e03 	bleq	e864f8 <__Stack_Size+0xe860f8>
    2ce8:	0c270b3b 	stceq	11, cr0, [r7], #-236
    2cec:	01111349 	tsteq	r1, r9, asr #6
    2cf0:	0a400112 	beq	1003140 <__Stack_Size+0x1002d40>
    2cf4:	2e110000 	wxorcs	wr0, wr1, wr0
    2cf8:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2cfc:	3b0b3a0e 	blcc	2d153c <__Stack_Size+0x2d113c>
    2d00:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    2d04:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2d08:	000a4001 	andeq	r4, sl, r1
    2d0c:	00051200 	andeq	r1, r5, r0, lsl #4
    2d10:	0b3a0e03 	bleq	e86524 <__Stack_Size+0xe86124>
    2d14:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2d18:	00000602 	andeq	r0, r0, r2, lsl #12
    2d1c:	03003413 	movweq	r3, #1043	; 0x413
    2d20:	3b0b3a0e 	blcc	2d1560 <__Stack_Size+0x2d1160>
    2d24:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    2d28:	14000006 	strne	r0, [r0], #-6
    2d2c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    2d30:	0b3b0b3a 	bleq	ec5a20 <__Stack_Size+0xec5620>
    2d34:	00001349 	andeq	r1, r0, r9, asr #6
    2d38:	03003415 	movweq	r3, #1045	; 0x415
    2d3c:	3b0b3a0e 	blcc	2d157c <__Stack_Size+0x2d117c>
    2d40:	0013490b 	andseq	r4, r3, fp, lsl #18
    2d44:	11010000 	tstne	r1, r0
    2d48:	130e2501 	movwne	r2, #58625	; 0xe501
    2d4c:	1b0e030b 	blne	383980 <__Stack_Size+0x383580>
    2d50:	1201110e 	andne	r1, r1, #-2147483645	; 0x80000003
    2d54:	00061001 	andeq	r1, r6, r1
    2d58:	00240200 	eoreq	r0, r4, r0, lsl #4
    2d5c:	0b3e0b0b 	bleq	f85990 <__Stack_Size+0xf85590>
    2d60:	00000e03 	andeq	r0, r0, r3, lsl #28
    2d64:	03001603 	movweq	r1, #1539	; 0x603
    2d68:	3b0b3a08 	blcc	2d1590 <__Stack_Size+0x2d1190>
    2d6c:	0013490b 	andseq	r4, r3, fp, lsl #18
    2d70:	00350400 	eorseq	r0, r5, r0, lsl #8
    2d74:	00001349 	andeq	r1, r0, r9, asr #6
    2d78:	0b010405 	bleq	43d94 <__Stack_Size+0x43994>
    2d7c:	3b0b3a0b 	blcc	2d15b0 <__Stack_Size+0x2d11b0>
    2d80:	0013010b 	andseq	r0, r3, fp, lsl #2
    2d84:	00280600 	eoreq	r0, r8, r0, lsl #12
    2d88:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
    2d8c:	28070000 	stmdacs	r7, {}
    2d90:	1c080300 	stcne	3, cr0, [r8], {0}
    2d94:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    2d98:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    2d9c:	0b3b0b3a 	bleq	ec5a8c <__Stack_Size+0xec568c>
    2da0:	00001349 	andeq	r1, r0, r9, asr #6
    2da4:	0b002409 	bleq	bdd0 <__Stack_Size+0xb9d0>
    2da8:	000b3e0b 	andeq	r3, fp, fp, lsl #28
    2dac:	01130a00 	tsteq	r3, r0, lsl #20
    2db0:	0b3a0b0b 	bleq	e859e4 <__Stack_Size+0xe855e4>
    2db4:	1301053b 	movwne	r0, #5435	; 0x153b
    2db8:	0d0b0000 	stceq	0, cr0, [fp]
    2dbc:	3a080300 	bcc	2039c4 <__Stack_Size+0x2035c4>
    2dc0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2dc4:	000a3813 	andeq	r3, sl, r3, lsl r8
    2dc8:	000d0c00 	andeq	r0, sp, r0, lsl #24
    2dcc:	0b3a0e03 	bleq	e865e0 <__Stack_Size+0xe861e0>
    2dd0:	1349053b 	movtne	r0, #38203	; 0x953b
    2dd4:	00000a38 	andeq	r0, r0, r8, lsr sl
    2dd8:	0300160d 	movweq	r1, #1549	; 0x60d
    2ddc:	3b0b3a0e 	blcc	2d161c <__Stack_Size+0x2d121c>
    2de0:	00134905 	andseq	r4, r3, r5, lsl #18
    2de4:	01130e00 	tsteq	r3, r0, lsl #28
    2de8:	0b3a0b0b 	bleq	e85a1c <__Stack_Size+0xe8561c>
    2dec:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    2df0:	0d0f0000 	stceq	0, cr0, [pc]
    2df4:	3a0e0300 	bcc	3839fc <__Stack_Size+0x3835fc>
    2df8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2dfc:	000a3813 	andeq	r3, sl, r3, lsl r8
    2e00:	012e1000 	teqeq	lr, r0
    2e04:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2e08:	0b3b0b3a 	bleq	ec5af8 <__Stack_Size+0xec56f8>
    2e0c:	01110c27 	tsteq	r1, r7, lsr #24
    2e10:	0a400112 	beq	1003260 <__Stack_Size+0x1002e60>
    2e14:	00001301 	andeq	r1, r0, r1, lsl #6
    2e18:	03000511 	movweq	r0, #1297	; 0x511
    2e1c:	3b0b3a0e 	blcc	2d165c <__Stack_Size+0x2d125c>
    2e20:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    2e24:	1200000a 	andne	r0, r0, #10	; 0xa
    2e28:	0b0b000f 	bleq	2c2e6c <__Stack_Size+0x2c2a6c>
    2e2c:	00001349 	andeq	r1, r0, r9, asr #6
    2e30:	3f012e13 	svccc	0x00012e13
    2e34:	3a0e030c 	bcc	383a6c <__Stack_Size+0x38366c>
    2e38:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2e3c:	1201110c 	andne	r1, r1, #3	; 0x3
    2e40:	010a4001 	tsteq	sl, r1
    2e44:	14000013 	strne	r0, [r0], #-19
    2e48:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    2e4c:	0b3b0b3a 	bleq	ec5b3c <__Stack_Size+0xec573c>
    2e50:	06021349 	streq	r1, [r2], -r9, asr #6
    2e54:	34150000 	ldrcc	r0, [r5]
    2e58:	3a0e0300 	bcc	383a60 <__Stack_Size+0x383660>
    2e5c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2e60:	000a0213 	andeq	r0, sl, r3, lsl r2
    2e64:	00051600 	andeq	r1, r5, r0, lsl #12
    2e68:	0b3a0e03 	bleq	e8667c <__Stack_Size+0xe8627c>
    2e6c:	1349053b 	movtne	r0, #38203	; 0x953b
    2e70:	00000a02 	andeq	r0, r0, r2, lsl #20
    2e74:	3f012e17 	svccc	0x00012e17
    2e78:	3a0e030c 	bcc	383ab0 <__Stack_Size+0x3836b0>
    2e7c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2e80:	1201110c 	andne	r1, r1, #3	; 0x3
    2e84:	01064001 	tsteq	r6, r1
    2e88:	18000013 	stmdane	r0, {r0, r1, r4}
    2e8c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    2e90:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2e94:	06021349 	streq	r1, [r2], -r9, asr #6
    2e98:	34190000 	ldrcc	r0, [r9]
    2e9c:	3a0e0300 	bcc	383aa4 <__Stack_Size+0x3836a4>
    2ea0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2ea4:	1a000013 	bne	2ef8 <__Stack_Size+0x2af8>
    2ea8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2eac:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    2eb0:	06021349 	streq	r1, [r2], -r9, asr #6
    2eb4:	2e1b0000 	wxorcs	wr0, wr11, wr0
    2eb8:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2ebc:	3b0b3a0e 	blcc	2d16fc <__Stack_Size+0x2d12fc>
    2ec0:	490c2705 	stmdbmi	ip, {r0, r2, r8, r9, sl, sp}
    2ec4:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2ec8:	010a4001 	tsteq	sl, r1
    2ecc:	1c000013 	stcne	0, cr0, [r0], {19}
    2ed0:	0c3f012e 	ldfeqs	f0, [pc], #-184
    2ed4:	0b3a0e03 	bleq	e866e8 <__Stack_Size+0xe862e8>
    2ed8:	0c270b3b 	stceq	11, cr0, [r7], #-236
    2edc:	01120111 	tsteq	r2, r1, lsl r1
    2ee0:	13010640 	movwne	r0, #5696	; 0x1640
    2ee4:	341d0000 	ldrcc	r0, [sp]
    2ee8:	3a0e0300 	bcc	383af0 <__Stack_Size+0x3836f0>
    2eec:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2ef0:	00060213 	andeq	r0, r6, r3, lsl r2
    2ef4:	00341e00 	eorseq	r1, r4, r0, lsl #28
    2ef8:	0b3a0e03 	bleq	e8670c <__Stack_Size+0xe8630c>
    2efc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2f00:	00000a02 	andeq	r0, r0, r2, lsl #20
    2f04:	0300341f 	movweq	r3, #1055	; 0x41f
    2f08:	3b0b3a0e 	blcc	2d1748 <__Stack_Size+0x2d1348>
    2f0c:	0013490b 	andseq	r4, r3, fp, lsl #18
    2f10:	012e2000 	teqeq	lr, r0
    2f14:	0e030c3f 	mcreq	12, 0, r0, cr3, cr15, {1}
    2f18:	0b3b0b3a 	bleq	ec5c08 <__Stack_Size+0xec5808>
    2f1c:	01110c27 	tsteq	r1, r7, lsr #24
    2f20:	06400112 	undefined
    2f24:	01000000 	tsteq	r0, r0
    2f28:	06100011 	undefined
    2f2c:	01120111 	tsteq	r2, r1, lsl r1
    2f30:	081b0803 	ldmdaeq	fp, {r0, r1, fp}
    2f34:	05130825 	ldreq	r0, [r3, #-2085]
    2f38:	01000000 	tsteq	r0, r0
    2f3c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    2f40:	0e030b13 	vmoveq.32	d3[0], r0
    2f44:	01110e1b 	tsteq	r1, fp, lsl lr
    2f48:	06100112 	undefined
    2f4c:	24020000 	strcs	r0, [r2]
    2f50:	3e0b0b00 	fmacdcc	d0, d11, d0
    2f54:	000e030b 	andeq	r0, lr, fp, lsl #6
    2f58:	00240300 	eoreq	r0, r4, r0, lsl #6
    2f5c:	0b3e0b0b 	bleq	f85b90 <__Stack_Size+0xf85790>
    2f60:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
    2f64:	030c3f01 	movweq	r3, #52993	; 0xcf01
    2f68:	3b0b3a0e 	blcc	2d17a8 <__Stack_Size+0x2d13a8>
    2f6c:	110c270b 	tstne	ip, fp, lsl #14
    2f70:	40011201 	andmi	r1, r1, r1, lsl #4
    2f74:	00130106 	andseq	r0, r3, r6, lsl #2
    2f78:	00340500 	eorseq	r0, r4, r0, lsl #10
    2f7c:	0b3a0e03 	bleq	e86790 <__Stack_Size+0xe86390>
    2f80:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2f84:	34060000 	strcc	r0, [r6]
    2f88:	3a0e0300 	bcc	383b90 <__Stack_Size+0x383790>
    2f8c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2f90:	00060213 	andeq	r0, r6, r3, lsl r2
    2f94:	000f0700 	andeq	r0, pc, r0, lsl #14
    2f98:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    2f9c:	34080000 	strcc	r0, [r8]
    2fa0:	3a0e0300 	bcc	383ba8 <__Stack_Size+0x3837a8>
    2fa4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2fa8:	3c0c3f13 	stccc	15, cr3, [ip], {19}
    2fac:	0900000c 	stmdbeq	r0, {r2, r3}
    2fb0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2fb4:	0b3b0b3a 	bleq	ec5ca4 <__Stack_Size+0xec58a4>
    2fb8:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252
    2fbc:	010a0000 	tsteq	sl, r0
    2fc0:	01134901 	tsteq	r3, r1, lsl #18
    2fc4:	0b000013 	bleq	3018 <__Stack_Size+0x2c18>
    2fc8:	13490021 	movtne	r0, #36897	; 0x9021
    2fcc:	00000b2f 	andeq	r0, r0, pc, lsr #22
    2fd0:	2700150c 	strcs	r1, [r0, -ip, lsl #10]
    2fd4:	0d00000c 	stceq	0, cr0, [r0, #-48]
    2fd8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2fdc:	0b3b0b3a 	bleq	ec5ccc <__Stack_Size+0xec58cc>
    2fe0:	0c3f1349 	ldceq	3, cr1, [pc], #-292
    2fe4:	00000a02 	andeq	r0, r0, r2, lsl #20
    2fe8:	4900260e 	stmdbmi	r0, {r1, r2, r3, r9, sl, sp}
    2fec:	00000013 	andeq	r0, r0, r3, lsl r0
    2ff0:	25011101 	strcs	r1, [r1, #-257]
    2ff4:	030b130e 	movweq	r1, #45838	; 0xb30e
    2ff8:	110e1b0e 	tstne	lr, lr, lsl #22
    2ffc:	10011201 	andne	r1, r1, r1, lsl #4
    3000:	02000006 	andeq	r0, r0, #6	; 0x6
    3004:	0b0b0024 	bleq	2c309c <__Stack_Size+0x2c2c9c>
    3008:	0e030b3e 	vmoveq.16	d3[0], r0
    300c:	24030000 	strcs	r0, [r3]
    3010:	3e0b0b00 	fmacdcc	d0, d11, d0
    3014:	0008030b 	andeq	r0, r8, fp, lsl #6
    3018:	00240400 	eoreq	r0, r4, r0, lsl #8
    301c:	0b3e0b0b 	bleq	f85c50 <__Stack_Size+0xf85850>
    3020:	15050000 	strne	r0, [r5]
    3024:	000c2700 	andeq	r2, ip, r0, lsl #14
    3028:	000f0600 	andeq	r0, pc, r0, lsl #12
    302c:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    3030:	04070000 	streq	r0, [r7]
    3034:	0b0e0301 	bleq	383c40 <__Stack_Size+0x383840>
    3038:	3b0b3a0b 	blcc	2d186c <__Stack_Size+0x2d146c>
    303c:	0013010b 	andseq	r0, r3, fp, lsl #2
    3040:	00280800 	eoreq	r0, r8, r0, lsl #16
    3044:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
    3048:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
    304c:	030c3f01 	movweq	r3, #52993	; 0xcf01
    3050:	3b0b3a0e 	blcc	2d1890 <__Stack_Size+0x2d1490>
    3054:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    3058:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    305c:	00064001 	andeq	r4, r6, r1
    3060:	00050a00 	andeq	r0, r5, r0, lsl #20
    3064:	0b3a0803 	bleq	e85078 <__Stack_Size+0xe84c78>
    3068:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    306c:	00000602 	andeq	r0, r0, r2, lsl #12
    3070:	01110100 	tsteq	r1, r0, lsl #2
    3074:	0b130e25 	bleq	4c6910 <__Stack_Size+0x4c6510>
    3078:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    307c:	01120111 	tsteq	r2, r1, lsl r1
    3080:	00000610 	andeq	r0, r0, r0, lsl r6
    3084:	0b002402 	bleq	c094 <__Stack_Size+0xbc94>
    3088:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    308c:	0300000e 	movweq	r0, #14	; 0xe
    3090:	0b0b0024 	bleq	2c3128 <__Stack_Size+0x2c2d28>
    3094:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    3098:	16040000 	strne	r0, [r4], -r0
    309c:	3a0e0300 	bcc	383ca4 <__Stack_Size+0x3838a4>
    30a0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    30a4:	05000013 	streq	r0, [r0, #-19]
    30a8:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    30ac:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    30b0:	00001349 	andeq	r1, r0, r9, asr #6
    30b4:	0b011706 	bleq	48cd4 <__Stack_Size+0x488d4>
    30b8:	3b0b3a0b 	blcc	2d18ec <__Stack_Size+0x2d14ec>
    30bc:	0013010b 	andseq	r0, r3, fp, lsl #2
    30c0:	000d0700 	andeq	r0, sp, r0, lsl #14
    30c4:	0b3a0e03 	bleq	e868d8 <__Stack_Size+0xe864d8>
    30c8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    30cc:	01080000 	tsteq	r8, r0
    30d0:	01134901 	tsteq	r3, r1, lsl #18
    30d4:	09000013 	stmdbeq	r0, {r0, r1, r4}
    30d8:	13490021 	movtne	r0, #36897	; 0x9021
    30dc:	00000b2f 	andeq	r0, r0, pc, lsr #22
    30e0:	0b00240a 	bleq	c110 <__Stack_Size+0xbd10>
    30e4:	000b3e0b 	andeq	r3, fp, fp, lsl #28
    30e8:	01130b00 	tsteq	r3, r0, lsl #22
    30ec:	0b3a0b0b 	bleq	e85d20 <__Stack_Size+0xe85920>
    30f0:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    30f4:	0d0c0000 	stceq	0, cr0, [ip]
    30f8:	3a0e0300 	bcc	383d00 <__Stack_Size+0x383900>
    30fc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    3100:	000a3813 	andeq	r3, sl, r3, lsl r8
    3104:	000f0d00 	andeq	r0, pc, r0, lsl #26
    3108:	00000b0b 	andeq	r0, r0, fp, lsl #22
    310c:	0301130e 	movweq	r1, #4878	; 0x130e
    3110:	3a0b0b0e 	bcc	2c5d50 <__Stack_Size+0x2c5950>
    3114:	010b3b0b 	tsteq	fp, fp, lsl #22
    3118:	0f000013 	svceq	0x00000013
    311c:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    3120:	0b3b0b3a 	bleq	ec5e10 <__Stack_Size+0xec5a10>
    3124:	0a381349 	beq	e07e50 <__Stack_Size+0xe07a50>
    3128:	0f100000 	svceq	0x00100000
    312c:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    3130:	11000013 	tstne	r0, r3, lsl r0
    3134:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    3138:	0b3a050b 	bleq	e8456c <__Stack_Size+0xe8416c>
    313c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    3140:	15120000 	ldrne	r0, [r2]
    3144:	000c2700 	andeq	r2, ip, r0, lsl #14
    3148:	01151300 	tsteq	r5, r0, lsl #6
    314c:	13490c27 	movtne	r0, #39975	; 0x9c27
    3150:	00001301 	andeq	r1, r0, r1, lsl #6
    3154:	49000514 	stmdbmi	r0, {r2, r4, r8, sl}
    3158:	15000013 	strne	r0, [r0, #-19]
    315c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    3160:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    3164:	0a381349 	beq	e07e90 <__Stack_Size+0xe07a90>
    3168:	26160000 	ldrcs	r0, [r6], -r0
    316c:	00134900 	andseq	r4, r3, r0, lsl #18
    3170:	01131700 	tsteq	r3, r0, lsl #14
    3174:	0b0b0e03 	bleq	2c6988 <__Stack_Size+0x2c6588>
    3178:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    317c:	00001301 	andeq	r1, r0, r1, lsl #6
    3180:	0b011318 	bleq	47de8 <__Stack_Size+0x479e8>
    3184:	3b0b3a0b 	blcc	2d19b8 <__Stack_Size+0x2d15b8>
    3188:	00130105 	andseq	r0, r3, r5, lsl #2
    318c:	01171900 	tsteq	r7, r0, lsl #18
    3190:	0b3a0b0b 	bleq	e85dc4 <__Stack_Size+0xe859c4>
    3194:	1301053b 	movwne	r0, #5435	; 0x153b
    3198:	0d1a0000 	ldceq	0, cr0, [sl]
    319c:	3a0e0300 	bcc	383da4 <__Stack_Size+0x3839a4>
    31a0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    31a4:	1b000013 	blne	31f8 <__Stack_Size+0x2df8>
    31a8:	0c270115 	stfeqs	f0, [r7], #-84
    31ac:	00001301 	andeq	r1, r0, r1, lsl #6
    31b0:	3f012e1c 	svccc	0x00012e1c
    31b4:	3a0e030c 	bcc	383dec <__Stack_Size+0x3839ec>
    31b8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    31bc:	1201110c 	andne	r1, r1, #3	; 0x3
    31c0:	010a4001 	tsteq	sl, r1
    31c4:	1d000013 	stcne	0, cr0, [r0, #-76]
    31c8:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    31cc:	0b3b0b3a 	bleq	ec5ebc <__Stack_Size+0xec5abc>
    31d0:	06021349 	streq	r1, [r2], -r9, asr #6
    31d4:	341e0000 	ldrcc	r0, [lr]
    31d8:	3a0e0300 	bcc	383de0 <__Stack_Size+0x3839e0>
    31dc:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    31e0:	3c0c3f13 	stccc	15, cr3, [ip], {19}
    31e4:	0000000c 	andeq	r0, r0, ip
    31e8:	25011101 	strcs	r1, [r1, #-257]
    31ec:	030b130e 	movweq	r1, #45838	; 0xb30e
    31f0:	110e1b0e 	tstne	lr, lr, lsl #22
    31f4:	10011201 	andne	r1, r1, r1, lsl #4
    31f8:	02000006 	andeq	r0, r0, #6	; 0x6
    31fc:	0b0b0024 	bleq	2c3294 <__Stack_Size+0x2c2e94>
    3200:	0e030b3e 	vmoveq.16	d3[0], r0
    3204:	24030000 	strcs	r0, [r3]
    3208:	3e0b0b00 	fmacdcc	d0, d11, d0
    320c:	0008030b 	andeq	r0, r8, fp, lsl #6
    3210:	00160400 	andseq	r0, r6, r0, lsl #8
    3214:	0b3a0e03 	bleq	e86a28 <__Stack_Size+0xe86628>
    3218:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    321c:	16050000 	strne	r0, [r5], -r0
    3220:	3a0e0300 	bcc	383e28 <__Stack_Size+0x383a28>
    3224:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    3228:	06000013 	undefined
    322c:	0b0b0117 	bleq	2c3690 <__Stack_Size+0x2c3290>
    3230:	0b3b0b3a 	bleq	ec5f20 <__Stack_Size+0xec5b20>
    3234:	00001301 	andeq	r1, r0, r1, lsl #6
    3238:	03000d07 	movweq	r0, #3335	; 0xd07
    323c:	3b0b3a0e 	blcc	2d1a7c <__Stack_Size+0x2d167c>
    3240:	0013490b 	andseq	r4, r3, fp, lsl #18
    3244:	01010800 	tsteq	r1, r0, lsl #16
    3248:	13011349 	movwne	r1, #4937	; 0x1349
    324c:	21090000 	tstcs	r9, r0
    3250:	2f134900 	svccs	0x00134900
    3254:	0a00000b 	beq	3288 <__Stack_Size+0x2e88>
    3258:	0b0b0024 	bleq	2c32f0 <__Stack_Size+0x2c2ef0>
    325c:	00000b3e 	andeq	r0, r0, lr, lsr fp
    3260:	0b01130b 	bleq	47e94 <__Stack_Size+0x47a94>
    3264:	3b0b3a0b 	blcc	2d1a98 <__Stack_Size+0x2d1698>
    3268:	0013010b 	andseq	r0, r3, fp, lsl #2
    326c:	000d0c00 	andeq	r0, sp, r0, lsl #24
    3270:	0b3a0e03 	bleq	e86a84 <__Stack_Size+0xe86684>
    3274:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    3278:	00000a38 	andeq	r0, r0, r8, lsr sl
    327c:	0b000f0d 	bleq	6eb8 <__Stack_Size+0x6ab8>
    3280:	0e00000b 	cdpeq	0, 0, cr0, cr0, cr11, {0}
    3284:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    3288:	0b3a0b0b 	bleq	e85ebc <__Stack_Size+0xe85abc>
    328c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    3290:	0d0f0000 	stceq	0, cr0, [pc]
    3294:	3a080300 	bcc	203e9c <__Stack_Size+0x203a9c>
    3298:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    329c:	000a3813 	andeq	r3, sl, r3, lsl r8
    32a0:	000f1000 	andeq	r1, pc, r0
    32a4:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    32a8:	13110000 	tstne	r1, #0	; 0x0
    32ac:	0b0e0301 	bleq	383eb8 <__Stack_Size+0x383ab8>
    32b0:	3b0b3a05 	blcc	2d1acc <__Stack_Size+0x2d16cc>
    32b4:	0013010b 	andseq	r0, r3, fp, lsl #2
    32b8:	00151200 	andseq	r1, r5, r0, lsl #4
    32bc:	00000c27 	andeq	r0, r0, r7, lsr #24
    32c0:	27011513 	smladcs	r1, r3, r5, r1
    32c4:	0113490c 	tsteq	r3, ip, lsl #18
    32c8:	14000013 	strne	r0, [r0], #-19
    32cc:	13490005 	movtne	r0, #36869	; 0x9005
    32d0:	0d150000 	ldceq	0, cr0, [r5]
    32d4:	3a0e0300 	bcc	383edc <__Stack_Size+0x383adc>
    32d8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    32dc:	000a3813 	andeq	r3, sl, r3, lsl r8
    32e0:	00261600 	eoreq	r1, r6, r0, lsl #12
    32e4:	00001349 	andeq	r1, r0, r9, asr #6
    32e8:	03011317 	movweq	r1, #4887	; 0x1317
    32ec:	3a0b0b0e 	bcc	2c5f2c <__Stack_Size+0x2c5b2c>
    32f0:	01053b0b 	tsteq	r5, fp, lsl #22
    32f4:	18000013 	stmdane	r0, {r0, r1, r4}
    32f8:	0b0b0113 	bleq	2c374c <__Stack_Size+0x2c334c>
    32fc:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    3300:	00001301 	andeq	r1, r0, r1, lsl #6
    3304:	0b011719 	bleq	48f70 <__Stack_Size+0x48b70>
    3308:	3b0b3a0b 	blcc	2d1b3c <__Stack_Size+0x2d173c>
    330c:	00130105 	andseq	r0, r3, r5, lsl #2
    3310:	000d1a00 	andeq	r1, sp, r0, lsl #20
    3314:	0b3a0e03 	bleq	e86b28 <__Stack_Size+0xe86728>
    3318:	1349053b 	movtne	r0, #38203	; 0x953b
    331c:	151b0000 	ldrne	r0, [fp]
    3320:	010c2701 	tsteq	ip, r1, lsl #14
    3324:	1c000013 	stcne	0, cr0, [r0], {19}
    3328:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    332c:	0b3b0b3a 	bleq	ec601c <__Stack_Size+0xec5c1c>
    3330:	0a021349 	beq	8805c <__Stack_Size+0x87c5c>
    3334:	341d0000 	ldrcc	r0, [sp]
    3338:	3a0e0300 	bcc	383f40 <__Stack_Size+0x383b40>
    333c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    3340:	020c3f13 	andeq	r3, ip, #76	; 0x4c
    3344:	0000000a 	andeq	r0, r0, sl
    3348:	25011101 	strcs	r1, [r1, #-257]
    334c:	030b130e 	movweq	r1, #45838	; 0xb30e
    3350:	110e1b0e 	tstne	lr, lr, lsl #22
    3354:	10011201 	andne	r1, r1, r1, lsl #4
    3358:	02000006 	andeq	r0, r0, #6	; 0x6
    335c:	0b0b0024 	bleq	2c33f4 <__Stack_Size+0x2c2ff4>
    3360:	0e030b3e 	vmoveq.16	d3[0], r0
    3364:	24030000 	strcs	r0, [r3]
    3368:	3e0b0b00 	fmacdcc	d0, d11, d0
    336c:	0008030b 	andeq	r0, r8, fp, lsl #6
    3370:	00240400 	eoreq	r0, r4, r0, lsl #8
    3374:	0b3e0b0b 	bleq	f85fa8 <__Stack_Size+0xf85ba8>
    3378:	16050000 	strne	r0, [r5], -r0
    337c:	3a0e0300 	bcc	383f84 <__Stack_Size+0x383b84>
    3380:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    3384:	06000013 	undefined
    3388:	0c3f012e 	ldfeqs	f0, [pc], #-184
    338c:	0b3a0e03 	bleq	e86ba0 <__Stack_Size+0xe867a0>
    3390:	0c270b3b 	stceq	11, cr0, [r7], #-236
    3394:	01120111 	tsteq	r2, r1, lsl r1
    3398:	13010640 	movwne	r0, #5696	; 0x1640
    339c:	34070000 	strcc	r0, [r7]
    33a0:	3a0e0300 	bcc	383fa8 <__Stack_Size+0x383ba8>
    33a4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    33a8:	000a0213 	andeq	r0, sl, r3, lsl r2
    33ac:	00340800 	eorseq	r0, r4, r0, lsl #16
    33b0:	0b3a0803 	bleq	e853c4 <__Stack_Size+0xe84fc4>
    33b4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    33b8:	00000a02 	andeq	r0, r0, r2, lsl #20
    33bc:	49010109 	stmdbmi	r1, {r0, r3, r8}
    33c0:	00130113 	andseq	r0, r3, r3, lsl r1
    33c4:	00210a00 	eoreq	r0, r1, r0, lsl #20
    33c8:	150b0000 	strne	r0, [fp]
    33cc:	000c2700 	andeq	r2, ip, r0, lsl #14
    33d0:	000f0c00 	andeq	r0, pc, r0, lsl #24
    33d4:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    33d8:	340d0000 	strcc	r0, [sp]
    33dc:	3a0e0300 	bcc	383fe4 <__Stack_Size+0x383be4>
    33e0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    33e4:	3c0c3f13 	stccc	15, cr3, [ip], {19}
    33e8:	0000000c 	andeq	r0, r0, ip
    33ec:	25011101 	strcs	r1, [r1, #-257]
    33f0:	030b130e 	movweq	r1, #45838	; 0xb30e
    33f4:	110e1b0e 	tstne	lr, lr, lsl #22
    33f8:	10011201 	andne	r1, r1, r1, lsl #4
    33fc:	02000006 	andeq	r0, r0, #6	; 0x6
    3400:	0b0b0024 	bleq	2c3498 <__Stack_Size+0x2c3098>
    3404:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    3408:	16030000 	strne	r0, [r3], -r0
    340c:	3a0e0300 	bcc	384014 <__Stack_Size+0x383c14>
    3410:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    3414:	04000013 	streq	r0, [r0], #-19
    3418:	0b0b0024 	bleq	2c34b0 <__Stack_Size+0x2c30b0>
    341c:	0e030b3e 	vmoveq.16	d3[0], r0
    3420:	2e050000 	cdpcs	0, 0, cr0, cr5, cr0, {0}
    3424:	030c3f01 	movweq	r3, #52993	; 0xcf01
    3428:	3b0b3a0e 	blcc	2d1c68 <__Stack_Size+0x2d1868>
    342c:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    3430:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    3434:	01064001 	tsteq	r6, r1
    3438:	06000013 	undefined
    343c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    3440:	0b3b0b3a 	bleq	ec6130 <__Stack_Size+0xec5d30>
    3444:	06021349 	streq	r1, [r2], -r9, asr #6
    3448:	34070000 	strcc	r0, [r7]
    344c:	3a080300 	bcc	204054 <__Stack_Size+0x203c54>
    3450:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    3454:	00060213 	andeq	r0, r6, r3, lsl r2
    3458:	00340800 	eorseq	r0, r4, r0, lsl #16
    345c:	0b3a0e03 	bleq	e86c70 <__Stack_Size+0xe86870>
    3460:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    3464:	00000602 	andeq	r0, r0, r2, lsl #12
    3468:	0b000f09 	bleq	7094 <__Stack_Size+0x6c94>
    346c:	0a00000b 	beq	34a0 <__Stack_Size+0x30a0>
    3470:	0b0b000f 	bleq	2c34b4 <__Stack_Size+0x2c30b4>
    3474:	00001349 	andeq	r1, r0, r9, asr #6
    3478:	0000260b 	andeq	r2, r0, fp, lsl #12
    347c:	00260c00 	eoreq	r0, r6, r0, lsl #24
    3480:	00001349 	andeq	r1, r0, r9, asr #6
    3484:	01110100 	tsteq	r1, r0, lsl #2
    3488:	0b130e25 	bleq	4c6d24 <__Stack_Size+0x4c6924>
    348c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    3490:	01120111 	tsteq	r2, r1, lsl r1
    3494:	00000610 	andeq	r0, r0, r0, lsl r6
    3498:	0b002402 	bleq	c4a8 <__Stack_Size+0xc0a8>
    349c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    34a0:	0300000e 	movweq	r0, #14	; 0xe
    34a4:	0b0b0024 	bleq	2c353c <__Stack_Size+0x2c313c>
    34a8:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    34ac:	24040000 	strcs	r0, [r4]
    34b0:	3e0b0b00 	fmacdcc	d0, d11, d0
    34b4:	0500000b 	streq	r0, [r0, #-11]
    34b8:	0b0b000f 	bleq	2c34fc <__Stack_Size+0x2c30fc>
    34bc:	0f060000 	svceq	0x00060000
    34c0:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    34c4:	07000013 	smladeq	r0, r3, r0, r0
    34c8:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    34cc:	0b3b0b3a 	bleq	ec61bc <__Stack_Size+0xec5dbc>
    34d0:	00001349 	andeq	r1, r0, r9, asr #6
    34d4:	3f012e08 	svccc	0x00012e08
    34d8:	3a0e030c 	bcc	384110 <__Stack_Size+0x383d10>
    34dc:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    34e0:	1113490c 	tstne	r3, ip, lsl #18
    34e4:	40011201 	andmi	r1, r1, r1, lsl #4
    34e8:	00130106 	andseq	r0, r3, r6, lsl #2
    34ec:	00050900 	andeq	r0, r5, r0, lsl #18
    34f0:	0b3a0803 	bleq	e85504 <__Stack_Size+0xe85104>
    34f4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    34f8:	00000602 	andeq	r0, r0, r2, lsl #12
    34fc:	0300340a 	movweq	r3, #1034	; 0x40a
    3500:	3b0b3a08 	blcc	2d1d28 <__Stack_Size+0x2d1928>
    3504:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    3508:	0b000006 	bleq	3528 <__Stack_Size+0x3128>
    350c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    3510:	0b3b0b3a 	bleq	ec6200 <__Stack_Size+0xec5e00>
    3514:	00001349 	andeq	r1, r0, r9, asr #6
    3518:	0300340c 	movweq	r3, #1036	; 0x40c
    351c:	3b0b3a0e 	blcc	2d1d5c <__Stack_Size+0x2d195c>
    3520:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    3524:	0d000006 	stceq	0, cr0, [r0, #-24]
    3528:	08030034 	stmdaeq	r3, {r2, r4, r5}
    352c:	0b3b0b3a 	bleq	ec621c <__Stack_Size+0xec5e1c>
    3530:	0a021349 	beq	8825c <__Stack_Size+0x87e5c>
    3534:	01000000 	tsteq	r0, r0
    3538:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    353c:	0e030b13 	vmoveq.32	d3[0], r0
    3540:	01110e1b 	tsteq	r1, fp, lsl lr
    3544:	06100112 	undefined
    3548:	24020000 	strcs	r0, [r2]
    354c:	3e0b0b00 	fmacdcc	d0, d11, d0
    3550:	0008030b 	andeq	r0, r8, fp, lsl #6
    3554:	00240300 	eoreq	r0, r4, r0, lsl #6
    3558:	0b3e0b0b 	bleq	f8618c <__Stack_Size+0xf85d8c>
    355c:	00000e03 	andeq	r0, r0, r3, lsl #28
    3560:	03001604 	movweq	r1, #1540	; 0x604
    3564:	3b0b3a0e 	blcc	2d1da4 <__Stack_Size+0x2d19a4>
    3568:	0013490b 	andseq	r4, r3, fp, lsl #18
    356c:	00160500 	andseq	r0, r6, r0, lsl #10
    3570:	0b3a0e03 	bleq	e86d84 <__Stack_Size+0xe86984>
    3574:	1349053b 	movtne	r0, #38203	; 0x953b
    3578:	17060000 	strne	r0, [r6, -r0]
    357c:	3a0b0b01 	bcc	2c6188 <__Stack_Size+0x2c5d88>
    3580:	010b3b0b 	tsteq	fp, fp, lsl #22
    3584:	07000013 	smladeq	r0, r3, r0, r0
    3588:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    358c:	0b3b0b3a 	bleq	ec627c <__Stack_Size+0xec5e7c>
    3590:	00001349 	andeq	r1, r0, r9, asr #6
    3594:	49010108 	stmdbmi	r1, {r3, r8}
    3598:	00130113 	andseq	r0, r3, r3, lsl r1
    359c:	00210900 	eoreq	r0, r1, r0, lsl #18
    35a0:	0b2f1349 	bleq	bc82cc <__Stack_Size+0xbc7ecc>
    35a4:	240a0000 	strcs	r0, [sl]
    35a8:	3e0b0b00 	fmacdcc	d0, d11, d0
    35ac:	0b00000b 	bleq	35e0 <__Stack_Size+0x31e0>
    35b0:	0b0b0113 	bleq	2c3a04 <__Stack_Size+0x2c3604>
    35b4:	0b3b0b3a 	bleq	ec62a4 <__Stack_Size+0xec5ea4>
    35b8:	00001301 	andeq	r1, r0, r1, lsl #6
    35bc:	03000d0c 	movweq	r0, #3340	; 0xd0c
    35c0:	3b0b3a0e 	blcc	2d1e00 <__Stack_Size+0x2d1a00>
    35c4:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    35c8:	0d00000a 	stceq	0, cr0, [r0, #-40]
    35cc:	0b0b000f 	bleq	2c3610 <__Stack_Size+0x2c3210>
    35d0:	130e0000 	movwne	r0, #57344	; 0xe000
    35d4:	0b0e0301 	bleq	3841e0 <__Stack_Size+0x383de0>
    35d8:	3b0b3a0b 	blcc	2d1e0c <__Stack_Size+0x2d1a0c>
    35dc:	0013010b 	andseq	r0, r3, fp, lsl #2
    35e0:	000d0f00 	andeq	r0, sp, r0, lsl #30
    35e4:	0b3a0803 	bleq	e855f8 <__Stack_Size+0xe851f8>
    35e8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    35ec:	00000a38 	andeq	r0, r0, r8, lsr sl
    35f0:	0b000f10 	bleq	7238 <__Stack_Size+0x6e38>
    35f4:	0013490b 	andseq	r4, r3, fp, lsl #18
    35f8:	01131100 	tsteq	r3, r0, lsl #2
    35fc:	050b0e03 	streq	r0, [fp, #-3587]
    3600:	0b3b0b3a 	bleq	ec62f0 <__Stack_Size+0xec5ef0>
    3604:	00001301 	andeq	r1, r0, r1, lsl #6
    3608:	27001512 	smladcs	r0, r2, r5, r1
    360c:	1300000c 	movwne	r0, #12	; 0xc
    3610:	0c270115 	stfeqs	f0, [r7], #-84
    3614:	13011349 	movwne	r1, #4937	; 0x1349
    3618:	05140000 	ldreq	r0, [r4]
    361c:	00134900 	andseq	r4, r3, r0, lsl #18
    3620:	000d1500 	andeq	r1, sp, r0, lsl #10
    3624:	0b3a0e03 	bleq	e86e38 <__Stack_Size+0xe86a38>
    3628:	1349053b 	movtne	r0, #38203	; 0x953b
    362c:	00000a38 	andeq	r0, r0, r8, lsr sl
    3630:	49002616 	stmdbmi	r0, {r1, r2, r4, r9, sl, sp}
    3634:	17000013 	smladne	r0, r3, r0, r0
    3638:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    363c:	0b3a0b0b 	bleq	e86270 <__Stack_Size+0xe85e70>
    3640:	1301053b 	movwne	r0, #5435	; 0x153b
    3644:	13180000 	tstne	r8, #0	; 0x0
    3648:	3a0b0b01 	bcc	2c6254 <__Stack_Size+0x2c5e54>
    364c:	01053b0b 	tsteq	r5, fp, lsl #22
    3650:	19000013 	stmdbne	r0, {r0, r1, r4}
    3654:	0b0b0117 	bleq	2c3ab8 <__Stack_Size+0x2c36b8>
    3658:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    365c:	00001301 	andeq	r1, r0, r1, lsl #6
    3660:	03000d1a 	movweq	r0, #3354	; 0xd1a
    3664:	3b0b3a0e 	blcc	2d1ea4 <__Stack_Size+0x2d1aa4>
    3668:	00134905 	andseq	r4, r3, r5, lsl #18
    366c:	01151b00 	tsteq	r5, r0, lsl #22
    3670:	13010c27 	movwne	r0, #7207	; 0x1c27
    3674:	041c0000 	ldreq	r0, [ip]
    3678:	0b0e0301 	bleq	384284 <__Stack_Size+0x383e84>
    367c:	3b0b3a0b 	blcc	2d1eb0 <__Stack_Size+0x2d1ab0>
    3680:	0013010b 	andseq	r0, r3, fp, lsl #2
    3684:	00281d00 	eoreq	r1, r8, r0, lsl #26
    3688:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
    368c:	2e1e0000 	wxorcs	wr0, wr14, wr0
    3690:	030c3f01 	movweq	r3, #52993	; 0xcf01
    3694:	3b0b3a0e 	blcc	2d1ed4 <__Stack_Size+0x2d1ad4>
    3698:	490c270b 	stmdbmi	ip, {r0, r1, r3, r8, r9, sl, sp}
    369c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    36a0:	01064001 	tsteq	r6, r1
    36a4:	1f000013 	svcne	0x00000013
    36a8:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    36ac:	0b3b0b3a 	bleq	ec639c <__Stack_Size+0xec5f9c>
    36b0:	06021349 	streq	r1, [r2], -r9, asr #6
    36b4:	05200000 	streq	r0, [r0]!
    36b8:	3a080300 	bcc	2042c0 <__Stack_Size+0x203ec0>
    36bc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    36c0:	00060213 	andeq	r0, r6, r3, lsl r2
    36c4:	00342100 	eorseq	r2, r4, r0, lsl #2
    36c8:	0b3a0e03 	bleq	e86edc <__Stack_Size+0xe86adc>
    36cc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    36d0:	34220000 	strtcc	r0, [r2]
    36d4:	3a080300 	bcc	2042dc <__Stack_Size+0x203edc>
    36d8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    36dc:	000a0213 	andeq	r0, sl, r3, lsl r2
    36e0:	00342300 	eorseq	r2, r4, r0, lsl #6
    36e4:	0b3a0e03 	bleq	e86ef8 <__Stack_Size+0xe86af8>
    36e8:	1349053b 	movtne	r0, #38203	; 0x953b
    36ec:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252
    36f0:	01000000 	tsteq	r0, r0
    36f4:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    36f8:	0e030b13 	vmoveq.32	d3[0], r0
    36fc:	01110e1b 	tsteq	r1, fp, lsl lr
    3700:	06100112 	undefined
    3704:	24020000 	strcs	r0, [r2]
    3708:	3e0b0b00 	fmacdcc	d0, d11, d0
    370c:	000e030b 	andeq	r0, lr, fp, lsl #6
    3710:	00240300 	eoreq	r0, r4, r0, lsl #6
    3714:	0b3e0b0b 	bleq	f86348 <__Stack_Size+0xf85f48>
    3718:	00000803 	andeq	r0, r0, r3, lsl #16
    371c:	03001604 	movweq	r1, #1540	; 0x604
    3720:	3b0b3a0e 	blcc	2d1f60 <__Stack_Size+0x2d1b60>
    3724:	0013490b 	andseq	r4, r3, fp, lsl #18
    3728:	00160500 	andseq	r0, r6, r0, lsl #10
    372c:	0b3a0e03 	bleq	e86f40 <__Stack_Size+0xe86b40>
    3730:	1349053b 	movtne	r0, #38203	; 0x953b
    3734:	17060000 	strne	r0, [r6, -r0]
    3738:	3a0b0b01 	bcc	2c6344 <__Stack_Size+0x2c5f44>
    373c:	010b3b0b 	tsteq	fp, fp, lsl #22
    3740:	07000013 	smladeq	r0, r3, r0, r0
    3744:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    3748:	0b3b0b3a 	bleq	ec6438 <__Stack_Size+0xec6038>
    374c:	00001349 	andeq	r1, r0, r9, asr #6
    3750:	49010108 	stmdbmi	r1, {r3, r8}
    3754:	00130113 	andseq	r0, r3, r3, lsl r1
    3758:	00210900 	eoreq	r0, r1, r0, lsl #18
    375c:	0b2f1349 	bleq	bc8488 <__Stack_Size+0xbc8088>
    3760:	240a0000 	strcs	r0, [sl]
    3764:	3e0b0b00 	fmacdcc	d0, d11, d0
    3768:	0b00000b 	bleq	379c <__Stack_Size+0x339c>
    376c:	0b0b0113 	bleq	2c3bc0 <__Stack_Size+0x2c37c0>
    3770:	0b3b0b3a 	bleq	ec6460 <__Stack_Size+0xec6060>
    3774:	00001301 	andeq	r1, r0, r1, lsl #6
    3778:	03000d0c 	movweq	r0, #3340	; 0xd0c
    377c:	3b0b3a0e 	blcc	2d1fbc <__Stack_Size+0x2d1bbc>
    3780:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    3784:	0d00000a 	stceq	0, cr0, [r0, #-40]
    3788:	0b0b000f 	bleq	2c37cc <__Stack_Size+0x2c33cc>
    378c:	130e0000 	movwne	r0, #57344	; 0xe000
    3790:	0b0e0301 	bleq	38439c <__Stack_Size+0x383f9c>
    3794:	3b0b3a0b 	blcc	2d1fc8 <__Stack_Size+0x2d1bc8>
    3798:	0013010b 	andseq	r0, r3, fp, lsl #2
    379c:	000d0f00 	andeq	r0, sp, r0, lsl #30
    37a0:	0b3a0803 	bleq	e857b4 <__Stack_Size+0xe853b4>
    37a4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    37a8:	00000a38 	andeq	r0, r0, r8, lsr sl
    37ac:	0b000f10 	bleq	73f4 <__Stack_Size+0x6ff4>
    37b0:	0013490b 	andseq	r4, r3, fp, lsl #18
    37b4:	01131100 	tsteq	r3, r0, lsl #2
    37b8:	050b0e03 	streq	r0, [fp, #-3587]
    37bc:	0b3b0b3a 	bleq	ec64ac <__Stack_Size+0xec60ac>
    37c0:	00001301 	andeq	r1, r0, r1, lsl #6
    37c4:	27001512 	smladcs	r0, r2, r5, r1
    37c8:	1300000c 	movwne	r0, #12	; 0xc
    37cc:	0c270115 	stfeqs	f0, [r7], #-84
    37d0:	13011349 	movwne	r1, #4937	; 0x1349
    37d4:	05140000 	ldreq	r0, [r4]
    37d8:	00134900 	andseq	r4, r3, r0, lsl #18
    37dc:	000d1500 	andeq	r1, sp, r0, lsl #10
    37e0:	0b3a0e03 	bleq	e86ff4 <__Stack_Size+0xe86bf4>
    37e4:	1349053b 	movtne	r0, #38203	; 0x953b
    37e8:	00000a38 	andeq	r0, r0, r8, lsr sl
    37ec:	49002616 	stmdbmi	r0, {r1, r2, r4, r9, sl, sp}
    37f0:	17000013 	smladne	r0, r3, r0, r0
    37f4:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
    37f8:	0b3a0b0b 	bleq	e8642c <__Stack_Size+0xe8602c>
    37fc:	1301053b 	movwne	r0, #5435	; 0x153b
    3800:	13180000 	tstne	r8, #0	; 0x0
    3804:	3a0b0b01 	bcc	2c6410 <__Stack_Size+0x2c6010>
    3808:	01053b0b 	tsteq	r5, fp, lsl #22
    380c:	19000013 	stmdbne	r0, {r0, r1, r4}
    3810:	0b0b0117 	bleq	2c3c74 <__Stack_Size+0x2c3874>
    3814:	053b0b3a 	ldreq	r0, [fp, #-2874]!
    3818:	00001301 	andeq	r1, r0, r1, lsl #6
    381c:	03000d1a 	movweq	r0, #3354	; 0xd1a
    3820:	3b0b3a0e 	blcc	2d2060 <__Stack_Size+0x2d1c60>
    3824:	00134905 	andseq	r4, r3, r5, lsl #18
    3828:	01151b00 	tsteq	r5, r0, lsl #22
    382c:	13010c27 	movwne	r0, #7207	; 0x1c27
    3830:	2e1c0000 	wxorcs	wr0, wr12, wr0
    3834:	030c3f01 	movweq	r3, #52993	; 0xcf01
    3838:	3b0b3a0e 	blcc	2d2078 <__Stack_Size+0x2d1c78>
    383c:	110c270b 	tstne	ip, fp, lsl #14
    3840:	40011201 	andmi	r1, r1, r1, lsl #4
    3844:	00130106 	andseq	r0, r3, r6, lsl #2
    3848:	00051d00 	andeq	r1, r5, r0, lsl #26
    384c:	0b3a0e03 	bleq	e87060 <__Stack_Size+0xe86c60>
    3850:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    3854:	00000602 	andeq	r0, r0, r2, lsl #12
    3858:	0300051e 	movweq	r0, #1310	; 0x51e
    385c:	3b0b3a08 	blcc	2d2084 <__Stack_Size+0x2d1c84>
    3860:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    3864:	1f000006 	svcne	0x00000006
    3868:	08030034 	stmdaeq	r3, {r2, r4, r5}
    386c:	0b3b0b3a 	bleq	ec655c <__Stack_Size+0xec615c>
    3870:	0a021349 	beq	8859c <__Stack_Size+0x8819c>
    3874:	34200000 	strtcc	r0, [r0]
    3878:	3a0e0300 	bcc	384480 <__Stack_Size+0x384080>
    387c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    3880:	21000013 	tstcs	r0, r3, lsl r0
    3884:	08030034 	stmdaeq	r3, {r2, r4, r5}
    3888:	0b3b0b3a 	bleq	ec6578 <__Stack_Size+0xec6178>
    388c:	00001349 	andeq	r1, r0, r9, asr #6
    3890:	03003422 	movweq	r3, #1058	; 0x422
    3894:	3b0b3a08 	blcc	2d20bc <__Stack_Size+0x2d1cbc>
    3898:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    389c:	23000006 	movwcs	r0, #6	; 0x6
    38a0:	0e03000a 	cdpeq	0, 0, cr0, cr3, cr10, {0}
    38a4:	0b3b0b3a 	bleq	ec6594 <__Stack_Size+0xec6194>
    38a8:	0b240000 	bleq	9038b0 <__Stack_Size+0x9034b0>
    38ac:	00065501 	andeq	r5, r6, r1, lsl #10
    38b0:	00342500 	eorseq	r2, r4, r0, lsl #10
    38b4:	0b3a0e03 	bleq	e870c8 <__Stack_Size+0xe86cc8>
    38b8:	1349053b 	movtne	r0, #38203	; 0x953b
    38bc:	0c3c0c3f 	ldceq	12, cr0, [ip], #-252
    38c0:	01000000 	tsteq	r0, r0
    38c4:	06100011 	undefined
    38c8:	08030655 	stmdaeq	r3, {r0, r2, r4, r6, r9, sl}
    38cc:	0825081b 	stmdaeq	r5!, {r0, r1, r3, r4, fp}
    38d0:	00000513 	andeq	r0, r0, r3, lsl r5
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000045 	andeq	r0, r0, r5, asr #32
       4:	001f0002 	andseq	r0, pc, r2
       8:	01020000 	tsteq	r2, r0
       c:	000d0efb 	strdeq	r0, [sp], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	tsteq	r0, r0
      18:	00010000 	andeq	r0, r1, r0
      1c:	69747263 	ldmdbvs	r4!, {r0, r1, r5, r6, r9, ip, sp, lr}^
      20:	6d73612e 	ldfvse	f6, [r3, #-184]!
      24:	00000000 	andeq	r0, r0, r0
      28:	02050000 	andeq	r0, r5, #0	; 0x0
      2c:	00000000 	andeq	r0, r0, r0
      30:	0100cc03 	tsteq	r0, r3, lsl #24
      34:	01000602 	tsteq	r0, r2, lsl #12
      38:	02050001 	andeq	r0, r5, #1	; 0x1
      3c:	00000000 	andeq	r0, r0, r0
      40:	0100d703 	tsteq	r0, r3, lsl #14
      44:	01000602 	tsteq	r0, r2, lsl #12
      48:	00009601 	andeq	r9, r0, r1, lsl #12
      4c:	40000200 	andmi	r0, r0, r0, lsl #4
      50:	02000000 	andeq	r0, r0, #0	; 0x0
      54:	0d0efb01 	vstreq	d15, [lr, #-4]
      58:	01010100 	tsteq	r1, r0, lsl #2
      5c:	00000001 	andeq	r0, r0, r1
      60:	01000001 	tsteq	r0, r1
      64:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
      68:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
      6c:	2f2e2e2f 	svccs	0x002e2e2f
      70:	2d636367 	stclcs	3, cr6, [r3, #-412]!
      74:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
      78:	696c2f30 	stmdbvs	ip!, {r4, r5, r8, r9, sl, fp, sp}^
      7c:	6f6c6762 	svcvs	0x006c6762
      80:	612f7373 	teqvs	pc, r3, ror r3
      84:	00006d72 	andeq	r6, r0, r2, ror sp
      88:	30747263 	rsbscc	r7, r4, r3, ror #4
      8c:	0100532e 	tsteq	r0, lr, lsr #6
      90:	00000000 	andeq	r0, r0, r0
      94:	00000205 	andeq	r0, r0, r5, lsl #4
      98:	d2030000 	andle	r0, r3, #0	; 0x0
      9c:	2f2f0100 	svccs	0x002f0100
      a0:	2f2f2f33 	svccs	0x002f2f33
      a4:	302f2f2f 	eorcc	r2, pc, pc, lsr #30
      a8:	302f2f2f 	eorcc	r2, pc, pc, lsr #30
      ac:	2f302f2f 	svccs	0x00302f2f
      b0:	2f2f302f 	svccs	0x002f302f
      b4:	2f302f2f 	svccs	0x00302f2f
      b8:	09032f30 	stmdbeq	r3, {r4, r5, r8, r9, sl, fp, sp}
      bc:	2f2f322e 	svccs	0x002f322e
      c0:	032f2f30 	teqeq	pc, #192	; 0xc0
      c4:	2f342e0e 	svccs	0x00342e0e
      c8:	302f2f2f 	eorcc	r2, pc, pc, lsr #30
      cc:	2f2f2f2f 	svccs	0x002f2f2f
      d0:	f9032f30 	undefined instruction 0xf9032f30
      d4:	2f2f2e00 	svccs	0x002f2e00
      d8:	2f2f2f2f 	svccs	0x002f2f2f
      dc:	10023030 	andne	r3, r2, r0, lsr r0
      e0:	44010100 	strmi	r0, [r1], #-256
      e4:	02000001 	andeq	r0, r0, #1	; 0x1
      e8:	0000a800 	andeq	sl, r0, r0, lsl #16
      ec:	fb010200 	blx	408f6 <__Stack_Size+0x404f6>
      f0:	01000d0e 	tsteq	r0, lr, lsl #26
      f4:	00010101 	andeq	r0, r1, r1, lsl #2
      f8:	00010000 	andeq	r0, r1, r0
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
      fc:	50410100 	subpl	r0, r1, r0, lsl #2
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
     100:	72732f50 	rsbsvc	r2, r3, #320	; 0x140

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
     104:	74730063 	ldrbtvc	r0, [r3], #-99
     108:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
	nextframe_ = getMillis() + frameLength;
     10c:	5f783031 	svcpl	0x00783031
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     110:	2f62696c 	svccs	0x0062696c
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
     114:	00636e69 	rsbeq	r6, r3, r9, ror #28
     118:	33354d43 	teqcc	r5, #4288	; 0x10c0
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     11c:	57485f30 	smlaldxpl	r5, r8, r0, pc
     120:	636e692f 	cmnvs	lr, #770048	; 0xbc000
     124:	616d0000 	cmnvs	sp, r0
		if (nextpose_[i] > pose_[i]) {
     128:	632e6e69 	teqvs	lr, #1680	; 0x690
     12c:	00000100 	andeq	r0, r0, r0, lsl #2
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
     130:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
     134:	30316632 	eorscc	r6, r1, r2, lsr r6
     138:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     13c:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     140:	00000200 	andeq	r0, r0, r0, lsl #4
     144:	616e7964 	cmnvs	lr, r4, ror #18
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
     148:	6578696d 	ldrbvs	r6, [r8, #-2413]!
     14c:	64615f6c 	strbtvs	r5, [r1], #-3948
}
     150:	73657264 	cmnvc	r5, #1073741830	; 0x40000006
     154:	61745f73 	cmnvs	r4, r3, ror pc
     158:	73656c62 	cmnvc	r5, #25088	; 0x6200
     15c:	0300682e 	movweq	r6, #2094	; 0x82e
     160:	656c0000 	strbvs	r0, [ip]!
     164:	00682e64 	rsbeq	r2, r8, r4, ror #28
     168:	61000003 	tstvs	r0, r3
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
     16c:	682e6364 	stmdavs	lr!, {r2, r5, r6, r8, r9, sp, lr}
     170:	00000300 	andeq	r0, r0, r0, lsl #6
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
     174:	74747562 	ldrbtvc	r7, [r4], #-1378
     178:	682e6e6f 	stmdavs	lr!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     17c:	00000300 	andeq	r0, r0, r0, lsl #6
     180:	2e63696d 	cdpcs	9, 6, cr6, cr3, cr13, {3}
		nextpose_[i] = 512;
     184:	00030068 	andeq	r0, r3, r8, rrx
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
     188:	61737500 	cmnvs	r3, r0, lsl #10
		pose_[i] = 512;
     18c:	682e7472 	stmdavs	lr!, {r1, r4, r5, r6, sl, ip, sp, lr}
		nextpose_[i] = 512;
     190:	00000300 	andeq	r0, r0, r0, lsl #6
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
     194:	02050000 	andeq	r0, r5, #0	; 0x0
     198:	08003134 	stmdaeq	r0, {r2, r4, r5, r8, ip, sp}
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
     19c:	0101ed03 	tsteq	r1, r3, lsl #26
     1a0:	2e7ea903 	cdpcs	9, 7, cr10, cr14, cr3, {0}
	nextframe_ = getMillis();
     1a4:	3d343101 	ldfccs	f3, [r4, #-4]!
     1a8:	304a1503 	subcc	r1, sl, r3, lsl #10
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     1ac:	2010033e 	andscs	r0, r0, lr, lsr r3
     1b0:	3d207003 	stccc	0, cr7, [r0, #-12]!
     1b4:	414b3e41 	cmpmi	fp, r1, asr #28
     1b8:	3f443d3e 	svccc	0x00443d3e
     1bc:	4b3d2f2f 	blmi	f4be80 <__Stack_Size+0xf4ba80>
     1c0:	303e4b4b 	eorscc	r4, lr, fp, asr #22
     1c4:	4b4b3d2f 	blmi	12cf688 <__Stack_Size+0x12cf288>
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1c8:	69315b4b 	ldmdbvs	r1!, {r0, r1, r3, r6, r8, r9, fp, ip, lr}
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
     1cc:	3d3d4e4b 	ldccc	14, cr4, [sp, #-300]!
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d0:	3d31593f 	ldccc	9, cr5, [r1, #-252]!
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1d4:	3e673d3e 	mcrcc	13, 3, r3, cr7, cr14, {1}
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d8:	242c223d 	strtcs	r2, [ip], #-573
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
     1dc:	22242c22 	eorcs	r2, r4, #8704	; 0x2200
     1e0:	2c22242c 	cfstrscs	mvf2, [r2], #-176
		pose_[i] = 512;
		nextpose_[i] = 512;
     1e4:	242c3e24 	strtcs	r3, [ip], #-3620
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1e8:	3c580330 	mrrccc	3, 3, r0, r8, cr0
		nextpose_[i] = 512;
     1ec:	03202b03 	teqeq	r0, #3072	; 0xc00
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
     1f0:	2b032055 	blcs	c834c <__Stack_Size+0xc7f4c>
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
     1f4:	03682f20 	cmneq	r8, #128	; 0x80
     1f8:	37034a4c 	strcc	r4, [r3, -ip, asr #20]
	interpolating = 0;
     1fc:	303d3d2e 	eorscc	r3, sp, lr, lsr #26
	nextframe_ = getMillis();
     200:	2f3e3d2f 	svccs	0x003e3d2f
     204:	2f5a4b3d 	svccs	0x005a4b3d
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     208:	2f4c2f30 	svccs	0x004c2f30
     20c:	593d5a3d 	ldmdbpl	sp!, {r0, r2, r3, r4, r5, r9, fp, ip, lr}
     210:	753d593d 	ldrvc	r5, [sp, #-2365]!
     214:	4b314b5a 	blmi	c52f84 <__Stack_Size+0xc52b84>
     218:	4b304b30 	blmi	c12ee0 <__Stack_Size+0xc12ae0>
     21c:	4b4d4b30 	blmi	1352ee4 <__Stack_Size+0x1352ae4>
     220:	037a4b3d 	cmneq	sl, #62464	; 0xf400
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
     224:	47023c09 	strmi	r3, [r2, -r9, lsl #24]
     228:	94010100 	strls	r0, [r1], #-256
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
     22c:	02000001 	andeq	r0, r0, #1	; 0x1
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
     230:	00006b00 	andeq	r6, r0, r0, lsl #22
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
     234:	fb010200 	blx	40a3e <__Stack_Size+0x4063e>
     238:	01000d0e 	tsteq	r0, lr, lsl #26
	dxl_set_txpacket_parameter(1, 2);
     23c:	00010101 	andeq	r0, r1, r1, lsl #2
     240:	00010000 	andeq	r0, r1, r0
     244:	50410100 	subpl	r0, r1, r0, lsl #2
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     248:	72732f50 	rsbsvc	r2, r3, #320	; 0x140
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
     24c:	74730063 	ldrbtvc	r0, [r3], #-99
     250:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     254:	5f783031 	svcpl	0x00783031
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     258:	2f62696c 	svccs	0x0062696c
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     25c:	00636e69 	rsbeq	r6, r3, r9, ror #28
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     260:	33354d43 	teqcc	r5, #4288	; 0x10c0
     264:	57485f30 	smlaldxpl	r5, r8, r0, pc
     268:	636e692f 	cmnvs	lr, #770048	; 0xbc000
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     26c:	74730000 	ldrbtvc	r0, [r3]
     270:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
     274:	5f783031 	svcpl	0x00783031
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     278:	632e7469 	teqvs	lr, #1761607680	; 0x69000000
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     27c:	00000100 	andeq	r0, r0, r0, lsl #2
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
     280:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     284:	30316632 	eorscc	r6, r1, r2, lsr r6
     288:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
     28c:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
     290:	00000200 	andeq	r0, r0, r0, lsl #4
     294:	72617375 	rsbvc	r7, r1, #-738197503	; 0xd4000001
	dxl_txrx_packet();
     298:	00682e74 	rsbeq	r2, r8, r4, ror lr
	u16 CommStatus = dxl_get_result();
     29c:	00000003 	andeq	r0, r0, r3
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
     2a0:	4c020500 	cfstr32mi	mvfx0, [r2], {0}
		PrintErrorCode();
     2a4:	03080034 	movweq	r0, #32820	; 0x8034
	else
		PrintCommStatus(CommStatus);
     2a8:	03130127 	tsteq	r3, #-1073741815	; 0xc0000009
#endif
}
     2ac:	0f032e0a 	svceq	0x00032e0a
     2b0:	2e0f032e 	cdpcs	3, 0, cr0, cr15, cr14, {1}
     2b4:	032e0f03 	teqeq	lr, #12	; 0xc
     2b8:	03132e0f 	tsteq	r3, #240	; 0xf0
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
     2bc:	03132e0a 	tsteq	r3, #160	; 0xa0
     2c0:	03132e0a 	tsteq	r3, #160	; 0xa0

	if (interpolating == 0)
     2c4:	03132e16 	tsteq	r3, #352	; 0x160
		return 0;
	int i;
	int complete = poseSize;
     2c8:	03132e0a 	tsteq	r3, #160	; 0xa0
	if (!fWait) {
     2cc:	03132e0a 	tsteq	r3, #160	; 0xa0
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
     2d0:	03132e0a 	tsteq	r3, #160	; 0xa0
     2d4:	03132e0a 	tsteq	r3, #160	; 0xa0
     2d8:	03132e0a 	tsteq	r3, #160	; 0xa0
			return (getMillis() - nextframe_); // We still have some time to do something...
     2dc:	03132e0a 	tsteq	r3, #160	; 0xa0
     2e0:	03132e0a 	tsteq	r3, #160	; 0xa0
     2e4:	03132e0a 	tsteq	r3, #160	; 0xa0
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
     2e8:	03132e0a 	tsteq	r3, #160	; 0xa0
     2ec:	03132e0a 	tsteq	r3, #160	; 0xa0
     2f0:	03132e0a 	tsteq	r3, #160	; 0xa0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     2f4:	03132e0a 	tsteq	r3, #160	; 0xa0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     2f8:	03132e0a 	tsteq	r3, #160	; 0xa0
     2fc:	03132e0a 	tsteq	r3, #160	; 0xa0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     300:	03132e0a 	tsteq	r3, #160	; 0xa0
     304:	03132e0a 	tsteq	r3, #160	; 0xa0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     308:	03132e0a 	tsteq	r3, #160	; 0xa0
		int diff = nextpose_[i] - pose_[i];
     30c:	03132e0b 	tsteq	r3, #176	; 0xb0
     310:	03132e0b 	tsteq	r3, #176	; 0xb0
     314:	03132e0b 	tsteq	r3, #176	; 0xb0
     318:	03132e0a 	tsteq	r3, #160	; 0xa0
     31c:	03132e0a 	tsteq	r3, #160	; 0xa0
		if (diff == 0) {
     320:	03132e0a 	tsteq	r3, #160	; 0xa0
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     324:	03132e0a 	tsteq	r3, #160	; 0xa0
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
     328:	03132e0b 	tsteq	r3, #176	; 0xb0
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     32c:	03132e0b 	tsteq	r3, #176	; 0xb0
					pose_[i] = nextpose_[i];
     330:	03132e0a 	tsteq	r3, #160	; 0xa0
					complete--;
     334:	03142e0a 	tsteq	r4, #160	; 0xa0
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     338:	03132e0a 	tsteq	r3, #160	; 0xa0
     33c:	03132e0a 	tsteq	r3, #160	; 0xa0
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     340:	03132e0a 	tsteq	r3, #160	; 0xa0
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     344:	03132e0a 	tsteq	r3, #160	; 0xa0
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     348:	03132e0a 	tsteq	r3, #160	; 0xa0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     34c:	03132e0a 	tsteq	r3, #160	; 0xa0
     350:	03132e0a 	tsteq	r3, #160	; 0xa0
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
     354:	03132e0a 	tsteq	r3, #160	; 0xa0
		interpolating = 0;
     358:	03132e18 	tsteq	r3, #384	; 0x180
	BioloidControllerEx_writePose();
     35c:	03132e18 	tsteq	r3, #384	; 0x180
     360:	03132e0a 	tsteq	r3, #160	; 0xa0
	return 0;
}
     364:	03132e0a 	tsteq	r3, #160	; 0xa0
     368:	03132e0a 	tsteq	r3, #160	; 0xa0
     36c:	03132e0b 	tsteq	r3, #176	; 0xb0
     370:	03132e0b 	tsteq	r3, #176	; 0xb0
     374:	03132e0a 	tsteq	r3, #160	; 0xa0
     378:	03132e0a 	tsteq	r3, #160	; 0xa0
     37c:	03132e0a 	tsteq	r3, #160	; 0xa0
     380:	03132e0a 	tsteq	r3, #160	; 0xa0
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
     384:	03132e0a 	tsteq	r3, #160	; 0xa0
     388:	03132e0a 	tsteq	r3, #160	; 0xa0
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
     38c:	03132e0a 	tsteq	r3, #160	; 0xa0
     390:	03132e18 	tsteq	r3, #384	; 0x180
     394:	03132e0a 	tsteq	r3, #160	; 0xa0
     398:	03132e0a 	tsteq	r3, #160	; 0xa0
     39c:	03132e0a 	tsteq	r3, #160	; 0xa0
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
     3a0:	03132e0a 	tsteq	r3, #160	; 0xa0

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
     3a4:	03132e0b 	tsteq	r3, #176	; 0xb0
     3a8:	302e7fb9 	strhcc	r7, [lr], -r9
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
     3ac:	7edd0330 	mrcvc	3, 6, r0, cr13, cr0, {1}
     3b0:	0330302e 	teqeq	r0, #46	; 0x2e
     3b4:	30302e63 	eorscc	r2, r0, r3, ror #28
     3b8:	2e7cd303 	cdpcs	3, 7, cr13, cr12, cr3, {0}
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
     3bc:	02022f2f 	andeq	r2, r2, #188	; 0xbc
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
     3c0:	7c010100 	stfvcs	f0, [r1], {0}
     3c4:	02000006 	andeq	r0, r0, #6	; 0x6
     3c8:	0000f400 	andeq	pc, r0, r0, lsl #8
     3cc:	fb010200 	blx	40bd6 <__Stack_Size+0x407d6>
     3d0:	01000d0e 	tsteq	r0, lr, lsl #26
     3d4:	00010101 	andeq	r0, r1, r1, lsl #2
     3d8:	00010000 	andeq	r0, r1, r0
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
     3dc:	50410100 	subpl	r0, r1, r0, lsl #2
     3e0:	6e692f50 	mcrvs	15, 3, r2, cr9, cr0, {2}
     3e4:	50410063 	subpl	r0, r1, r3, rrx
     3e8:	72732f50 	rsbsvc	r2, r3, #320	; 0x140
     3ec:	74730063 	ldrbtvc	r0, [r3], #-99
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     3f0:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
     3f4:	5f783031 	svcpl	0x00783031
     3f8:	2f62696c 	svccs	0x0062696c
     3fc:	00636e69 	rsbeq	r6, r3, r9, ror #28
     400:	33354d43 	teqcc	r5, #4288	; 0x10c0
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
     404:	57485f30 	smlaldxpl	r5, r8, r0, pc
     408:	636e692f 	cmnvs	lr, #770048	; 0xbc000
     40c:	68500000 	ldmdavs	r0, {}^
     410:	696e656f 	stmdbvs	lr!, {r0, r1, r2, r3, r5, r6, r8, sl, sp, lr}^
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
     414:	6e495f78 	mcrvs	15, 2, r5, cr9, cr8, {3}
     418:	5f747570 	svcpl	0x00747570
     41c:	6d6d6f43 	stclvs	15, cr6, [sp, #-268]!
     420:	65646e61 	strbvs	r6, [r4, #-3681]!
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
     424:	00682e72 	rsbeq	r2, r8, r2, ror lr
     428:	50000001 	andpl	r0, r0, r1
     42c:	6e656f68 	cdpvs	15, 6, cr6, cr5, cr8, {3}
     430:	445f7869 	ldrbmi	r7, [pc], #2153	; 438 <__Stack_Size+0x38>
     434:	65766972 	ldrbvs	r6, [r6, #-2418]!
     438:	58415f72 	stmdapl	r1, {r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     43c:	682e3231 	stmdavs	lr!, {r0, r4, r5, r9, ip, sp}
     440:	00000100 	andeq	r0, r0, r0, lsl #2
     444:	5f676942 	svcpl	0x00676942
     448:	6e69616d 	powvsez	f6, f1, #5.0
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     44c:	0200632e 	andeq	r6, r0, #-1207959552	; 0xb8000000
     450:	74730000 	ldrbtvc	r0, [r3]
     454:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
     458:	5f783031 	svcpl	0x00783031
     45c:	65707974 	ldrbvs	r7, [r0, #-2420]!
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     460:	0300682e 	movweq	r6, #2094	; 0x82e
     464:	69770000 	ldmdbvs	r7!, {}^
     468:	676e6972 	undefined
     46c:	0100682e 	tsteq	r0, lr, lsr #16
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     470:	68500000 	ldmdavs	r0, {}^
     474:	696e656f 	stmdbvs	lr!, {r0, r1, r2, r3, r5, r6, r8, sl, sp, lr}^
     478:	00682e78 	rsbeq	r2, r8, r8, ror lr
     47c:	64000001 	strvs	r0, [r0], #-1
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
     480:	6d616e79 	stclvs	14, cr6, [r1, #-484]!
     484:	6c657869 	stclvs	8, cr7, [r5], #-420
     488:	6464615f 	strbtvs	r6, [r4], #-351
     48c:	73736572 	cmnvc	r3, #478150656	; 0x1c800000
     490:	6261745f 	rsbvs	r7, r1, #1593835520	; 0x5f000000
     494:	2e73656c 	cdpcs	5, 7, cr6, cr3, cr12, {3}
     498:	00040068 	andeq	r0, r4, r8, rrx
     49c:	61737500 	cmnvs	r3, r0, lsl #10
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     4a0:	682e7472 	stmdavs	lr!, {r1, r4, r5, r6, sl, ip, sp, lr}
     4a4:	00000400 	andeq	r0, r0, r0, lsl #8
     4a8:	6c6f6942 	stclvs	9, cr6, [pc], #-264
     4ac:	4564696f 	strbmi	r6, [r4, #-2415]!
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     4b0:	00682e78 	rsbeq	r2, r8, r8, ror lr
     4b4:	61000001 	tstvs	r0, r1
     4b8:	682e6364 	stmdavs	lr!, {r2, r5, r6, r8, r9, sp, lr}
     4bc:	00000400 	andeq	r0, r0, r0, lsl #8
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     4c0:	02050000 	andeq	r0, r5, #0	; 0x0
     4c4:	00000000 	andeq	r0, r0, r0
     4c8:	0101b403 	tsteq	r1, r3, lsl #8
		GaitPosY[GaitCurrentLegNr] = 0;
     4cc:	211f4b14 	tstcs	pc, r4, lsl fp
     4d0:	302f3022 	eorcc	r3, pc, r2, lsr #32
	}

	//Move body forward
	else {
		GaitPosX[GaitCurrentLegNr] = GaitPosX[GaitCurrentLegNr]
     4d4:	14eb2f2f 	strbtne	r2, [fp], #3887
     4d8:	2e028d03 	cdpcs	13, 0, cr8, cr2, cr3, {0}
     4dc:	4b010c03 	blmi	434f0 <__Stack_Size+0x430f0>
     4e0:	03207603 	teqeq	r0, #3145728	; 0x300000
     4e4:	03222e0a 	teqeq	r2, #160	; 0xa0
     4e8:	21212e74 	teqcs	r1, r4, ror lr
				- (g_InControlState.TravelLength.x
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitPosY[GaitCurrentLegNr] = 0;
     4ec:	21212121 	teqcs	r1, r1, lsr #2
     4f0:	30242121 	eorcc	r2, r4, r1, lsr #2
     4f4:	20032f22 	andcs	r2, r3, r2, lsr #30
		GaitPosZ[GaitCurrentLegNr] = GaitPosZ[GaitCurrentLegNr]
     4f8:	1433149e 	ldrtne	r1, [r3], #-1182
     4fc:	e7030204 	str	r0, [r3, -r4, lsl #4]
     500:	21172e7d 	tstcs	r7, sp, ror lr
     504:	6976283e 	ldmdbvs	r6!, {r1, r2, r3, r4, r5, fp, sp}^
				- (g_InControlState.TravelLength.z
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitRotY[GaitCurrentLegNr] = GaitRotY[GaitCurrentLegNr]
     508:	03030440 	movweq	r0, #13376	; 0x3440
     50c:	152003b5 	strne	r0, [r0, #-949]!
     510:	2e00d103 	mvfcss	f5, f3
     514:	2e3f0314 	mrccs	3, 1, r0, cr15, cr4, {0}
				- (g_InControlState.TravelLength.y
						/ (short) g_InControlState.gaitCur.TLDivFactor);
	}

}
     518:	03246216 	teqeq	r4, #1610612737	; 0x60000001
     51c:	0126020a 	teqeq	r6, sl, lsl #4
     520:	032e7603 	teqeq	lr, #3145728	; 0x300000
     524:	7603200a 	strvc	r2, [r3], -sl
     528:	200a032e 	andcs	r0, sl, lr, lsr #6
     52c:	03207603 	teqeq	r0, #3145728	; 0x300000
     530:	6721200a 	strvs	r2, [r1, -sl]!

}

//--------------------------------------------------------------------
//[GAIT Sequence]
void GaitSeq(void) {
     534:	502a3221 	eorpl	r3, sl, r1, lsr #4
	//Check if the Gait is in motion - If not if we are going to start a motion try to align our Gaitstep to start with a good foot
	// for the direction we are about to go...

	if (fWalking || (g_InControlState.ForceGaitStepCnt != 0))
     538:	311d3169 	tstcc	sp, r9, ror #2
     53c:	93934c6a 	orrsls	r4, r3, #27136	; 0x6a00
     540:	3d2f22a3 	sfmcc	f2, 4, [pc, #-652]!
		TravelRequest = true;   // Is walking or was walking...
     544:	714b4b2c 	cmpvc	fp, ip, lsr #22
     548:	085b4b50 	ldmdaeq	fp, {r4, r6, r8, r9, fp, lr}^
	else {
		TravelRequest = (abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
     54c:	2355235a 	cmpcs	r5, #1744830465	; 0x68000001
     550:	29039430 	stmdbcs	r3, {r4, r5, sl, ip, pc}
     554:	241c2482 	ldrcs	r2, [ip], #-1154
     558:	182d0287 	stmdane	sp!, {r0, r1, r2, r7, r9}
     55c:	4d3d834b 	ldcmi	3, cr8, [sp, #-300]!
     560:	d8ae5e08 	stmiale	lr!, {r3, r9, sl, fp, ip, lr}
     564:	92cc4f84 	sbcls	r4, ip, #528	; 0x210
     568:	ca4f68d8 	bgt	13da8d0 <__Stack_Size+0x13da4d0>
     56c:	78919f9f 	ldmvc	r1, {r0, r1, r2, r3, r4, r7, r8, r9, sl, fp, ip, pc}
     570:	759f83cc 	ldrvc	r8, [pc, #972]	; 944 <__Stack_Size+0x544>
     574:	83170887 	tsthi	r7, #8847360	; 0x870000
     578:	bd4f7575 	cfstr64lt	mvdx7, [pc, #-468]
     57c:	853d1f21 	ldrhi	r1, [sp, #-3873]!
				|| (abs(g_InControlState.TravelLength.y) > cTravelDeadZone);

		if (TravelRequest) {

		} else {    //Clear values under the cTravelDeadZone
			g_InControlState.TravelLength.x = 0;
     580:	7ef80395 	mrcvc	3, 7, r0, cr8, cr5, {4}
			g_InControlState.TravelLength.z = 0;
     584:	4c7524d6 	cfldrdmi	mvd2, [r5], #-856
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     588:	2f238608 	svccs	0x00238608
     58c:	2d592521 	cfldr64cs	mvdx2, [r9, #-132]
     590:	2f2d3d6b 	svccs	0x002d3d6b
		Gait(LegIndex);
     594:	3f212f1f 	svccc	0x00212f1f
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     598:	86033d4b 	strhi	r3, [r3], -fp, asr #26
     59c:	1e149e01 	cdpne	14, 1, cr9, cr4, cr1, {0}
     5a0:	1f4b7522 	svcne	0x004b7522
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5a4:	5b211f2f 	blpl	848268 <__Stack_Size+0x847e68>
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5a8:	03200d03 	teqeq	r0, #192	; 0xc0
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5ac:	0d032073 	stceq	0, cr2, [r3, #-460]
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5b0:	20730320 	rsbscs	r0, r3, r0, lsr #6
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5b4:	273f3e21 	ldrcs	r3, [pc, -r1, lsr #28]!
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
		g_InControlState.GaitStep = 1;
     5b8:	3d207903 	stccc	9, cr7, [r0, #-12]!
     5bc:	594d4b4c 	stmdbpl	sp, {r2, r3, r6, r8, r9, fp, lr}^

	// If we have a force count decrement it now...
	if (g_InControlState.ForceGaitStepCnt)
     5c0:	1f2f1f4b 	svcne	0x002f1f4b
     5c4:	15f85a21 	ldrbne	r5, [r8, #2593]!
		g_InControlState.ForceGaitStepCnt--;
     5c8:	422f231d 	eormi	r2, pc, #1946157056	; 0x74000000
}
     5cc:	595a2508 	ldmdbpl	sl, {r3, r8, sl, sp}^
     5d0:	752d212d 	strvc	r2, [sp, #-301]!
     5d4:	84692f1f 	strbthi	r2, [r9], #-3871
     5d8:	2d212d67 	stccs	13, cr2, [r1, #-412]!
     5dc:	592f1f75 	stmdbpl	pc!, {r0, r2, r4, r5, r6, r8, r9, sl, fp, ip}
}
//--------------------------------------------------------------------
//[BalanceBody]
void BalanceBody(void) {

	TotalTransZ = TotalTransZ / BalanceDivFactor;
     5e0:	2f2d6768 	svccs	0x002d6768
     5e4:	592d3d1f 	pushpl	{r0, r1, r2, r3, r4, r8, sl, fp, ip, sp}
     5e8:	6893211f 	ldmvs	r3, {r0, r1, r2, r3, r4, r8, sp}
     5ec:	1f2f2d67 	svcne	0x002f2d67
     5f0:	1f592d3d 	svcne	0x00592d3d
	TotalTransX = TotalTransX / BalanceDivFactor;
     5f4:	746b0321 	strbtvc	r0, [fp], #-801
     5f8:	2e081703 	cdpcs	7, 0, cr1, cr8, cr3, {0}
     5fc:	231d15b2 	tstcs	sp, #746586112	; 0x2c800000
	TotalTransY = TotalTransY / BalanceDivFactor;
     600:	6768503d 	undefined
     604:	2f211f75 	svccs	0x00211f75
     608:	752fbb75 	strvc	fp, [pc, #-2933]!	; fffffa9b <SCS_BASE+0x1fff1a9b>
     60c:	b0211f67 	eorlt	r1, r1, r7, ror #30

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     610:	01cb9321 	biceq	r9, fp, r1, lsr #6
     614:	1f3c0a03 	svcne	0x003c0a03
	TotalTransX = TotalTransX / BalanceDivFactor;
	TotalTransY = TotalTransY / BalanceDivFactor;

#ifndef QUADMODE // ??? on PhantomX Hex at no movment YBal1 = 1800, on Quad = 0...  Need to experiment
	if (TotalYBal1 > 0)        //Rotate balance circle by +/- 180 deg
		TotalYBal1 -= 1800;
     618:	2d3d3d5b 	ldccs	13, cr3, [sp, #-364]!
     61c:	7a032131 	bvc	c8ae8 <__Stack_Size+0xc86e8>
	else
		TotalYBal1 += 1800;
     620:	2e090320 	cdpcs	3, 0, cr0, cr9, cr0, {1}
#endif

	if (TotalZBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     624:	212d1328 	teqcs	sp, r8, lsr #6
     628:	212d212d 	teqcs	sp, sp, lsr #2
     62c:	d84c212d 	stmdale	ip, {r0, r2, r3, r5, r8, sp}^
		TotalZBal1 += 3600;
     630:	302c3021 	eorcc	r3, ip, r1, lsr #32
     634:	7ed8034c 	cdpvc	3, 13, cr0, cr8, cr12, {2}

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     638:	79033590 	stmdbvc	r3, {r4, r7, r8, sl, ip, sp}
     63c:	1f2f2720 	svcne	0x002f2720
		TotalXBal1 += 3600;
     640:	231d3121 	tstcs	sp, #1073741832	; 0x40000008
     644:	262f1b25 	strtcs	r1, [pc], -r5, lsr #22

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     648:	26207a03 	strtcs	r7, [r0], -r3, lsl #20
     64c:	2f207a03 	svccs	0x00207a03
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     650:	1e221e22 	cdpne	14, 2, cr1, cr2, cr2, {1}
     654:	3d221e22 	stccc	14, cr1, [r2, #-136]!
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     658:	3e084be6 	fnmacdcc	d4, d24, d22
	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     65c:	0314084b 	tsteq	r4, #4915200	; 0x4b0000
     660:	3c0801a1 	stfccs	f0, [r8], {161}
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     664:	03200c03 	teqeq	r0, #768	; 0x300
     668:	03202074 	teqeq	r0, #116	; 0x74

}
     66c:	7403200c 	strvc	r2, [r3], #-12
     670:	200c0320 	andcs	r0, ip, r0, lsr #6
     674:	03207403 	teqeq	r0, #50331648	; 0x3000000
     678:	7403200c 	strvc	r2, [r3], #-12
     67c:	2e0c0320 	cdpcs	3, 0, cr0, cr12, cr0, {1}
     680:	3d221e3e 	stccc	14, cr1, [r2, #-248]!
     684:	03201603 	teqeq	r0, #3145728	; 0x300000
     688:	0360206a 	cmneq	r0, #106	; 0x6a
//sin4        - Output Sinus of AngleDeg
//cos4          - Output Cosinus of AngleDeg
void GetSinCos(short AngleDeg1) {
	short ABSAngleDeg1;   //Absolute value of the Angle in Degrees, decimals = 1
	//Get the absolute value of AngleDeg
	if (AngleDeg1 < 0)
     68c:	03282078 	teqeq	r8, #120	; 0x78
     690:	4e282e78 	mcrmi	14, 1, r2, cr8, cr8, {3}
		ABSAngleDeg1 = AngleDeg1 * -1;
     694:	221e231d 	andscs	r2, lr, #1946157056	; 0x74000000
     698:	221e231d 	andscs	r2, lr, #1946157056	; 0x74000000
	else
		ABSAngleDeg1 = AngleDeg1;

	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
     69c:	2f22211d 	svccs	0x0022211d
     6a0:	1e231d23 	cdpne	13, 2, cr1, cr3, cr3, {1}
     6a4:	88222c22 	stmdahi	r2!, {r1, r5, sl, fp, sp}
     6a8:	1c164a02 	ldcne	10, cr4, [r6], {2}
     6ac:	03242a24 	teqeq	r4, #147456	; 0x24000
     6b0:	01610209 	cmneq	r1, r9, lsl #4
     6b4:	032e7703 	teqeq	lr, #786432	; 0xc0000
     6b8:	09037409 	stmdbeq	r3, {r0, r3, sl, ip, sp, lr}
     6bc:	03015202 	movweq	r5, #4610	; 0x1202
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
     6c0:	03ba080f 	undefined instruction 0x03ba080f
     6c4:	72033c0e 	andvc	r3, r3, #3584	; 0xe00
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6c8:	200e0320 	andcs	r0, lr, r0, lsr #6
     6cc:	7803fa2f 	stmdavc	r3, {r0, r1, r2, r3, r5, r9, fp, ip, sp, lr, pc}
     6d0:	78032820 	stmdavc	r3, {r5, fp, sp}
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6d4:	23ce3620 	biccs	r3, lr, #33554432	; 0x2000000
     6d8:	03587703 	cmpeq	r8, #786432	; 0xc0000
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6dc:	e6362009 	ldrt	r2, [r6], -r9
     6e0:	2408a01e 	strcs	sl, [r8], #-30
     6e4:	0335321c 	teqeq	r5, #-1073741823	; 0xc0000001
     6e8:	f4272079 	vld4.16	{d2-d5}, [r7, :256], r9
     6ec:	a2322af6 	eorsge	r2, r2, #1007616	; 0xf6000
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6f0:	3f3e4e3e 	svccc	0x003e4e3e
     6f4:	16182202 	ldrne	r2, [r8], -r2, lsl #4
     6f8:	7b40251c 	blvc	1009b70 <__Stack_Size+0x1009770>
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
     6fc:	232b1533 	teqcs	fp, #213909504	; 0xcc00000
     700:	206b032f 	rsbcs	r0, fp, pc, lsr #6
     704:	20120325 	andscs	r0, r2, r5, lsr #6
     708:	2f2e6903 	svccs	0x002e6903
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     70c:	1503615c 	strne	r6, [r3, #-348]
     710:	2e6b0320 	cdpcs	3, 6, cr0, cr11, cr0, {1}
     714:	036f5c2f 	cmneq	pc, #12032	; 0x2f00
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     718:	69032017 	stmdbvs	r3, {r0, r1, r2, r4, sp}
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     71c:	036a2f2e 	cmneq	sl, #184	; 0xb8
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     720:	7a037415 	bvc	dd77c <__Stack_Size+0xdd37c>
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     724:	580c033c 	stmdapl	ip, {r2, r3, r4, r5, r8, r9}
     728:	3d145e08 	ldccc	14, cr5, [r4, #-32]
     72c:	34d93dd7 	ldrbcc	r3, [r9], #3543
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     730:	48221e14 	stmdami	r2!, {r2, r4, r9, sl, fp, ip}
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     734:	03bb2322 	undefined instruction 0x03bb2322
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     738:	0328820e 	teqeq	r8, #-536870912	; 0xe0000000
     73c:	03442078 	movteq	r2, #16504	; 0x4078
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
     740:	03522078 	cmpeq	r2, #120	; 0x78
     744:	03282078 	teqeq	r8, #120	; 0x78
     748:	0321200a 	teqeq	r1, #10	; 0xa
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     74c:	4c332078 	ldcmi	0, cr2, [r3], #-480
     750:	0903b5bb 	stmdbeq	r3, {r0, r1, r3, r4, r5, r7, r8, sl, ip, sp, pc}
     754:	2708592e 	strcs	r5, [r8, -lr, lsr #18]
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     758:	33010b03 	movwcc	r0, #6915	; 0x1b03
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     75c:	03011303 	movweq	r1, #4867	; 0x1303
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     760:	1c242e09 	stcne	14, cr2, [r4], #-36
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     764:	26343e24 	ldrtcs	r3, [r4], -r4, lsr #28
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     768:	34207a03 	strtcc	r7, [r0], #-2563
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     76c:	6c207a03 	stcvs	10, cr7, [r0], #-12
     770:	0331212f 	teqeq	r1, #-1073741813	; 0xc000000b
     774:	256679f1 	strbcs	r7, [r6, #-2545]!
     778:	0334251b 	teqeq	r4, #113246208	; 0x6c00000
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     77c:	03342e7a 	teqeq	r4, #1952	; 0x7a0
     780:	24342e7a 	ldrtcs	r2, [r4], #-3706
     784:	200b036a 	andcs	r0, fp, sl, ror #6
     788:	72033d4c 	andvc	r3, r3, #4864	; 0x1300
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
     78c:	21212120 	teqcs	r1, r0, lsr #2
     790:	21212121 	teqcs	r1, r1, lsr #2
     794:	31212423 	teqcc	r1, r3, lsr #8
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     798:	314b4e5a 	cmpcc	fp, sl, asr lr
     79c:	02046b5a 	andeq	r6, r4, #92160	; 0x16800
     7a0:	ac7d8c03 	ldclge	12, cr8, [sp], #-12
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7a4:	33211f21 	teqcc	r1, #132	; 0x84
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7a8:	4403303d 	strmi	r3, [r3], #-61
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7ac:	221e224a 	andscs	r2, lr, #-1610612732	; 0xa0000004
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b0:	21211f3d 	teqcs	r1, sp, lsr pc
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7b4:	03955a2f 	orrseq	r5, r5, #192512	; 0x2f000
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b8:	03907edd 	orrseq	r7, r0, #3536	; 0xdd0
     7bc:	6b033c15 	blvs	cf818 <__Stack_Size+0xcf418>
     7c0:	20150320 	andscs	r0, r5, r0, lsr #6
     7c4:	6a4b3d2f 	bvs	12cfc88 <__Stack_Size+0x12cf888>
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7c8:	21657575 	smccs	22357
     7cc:	306a6d2a 	rsbcc	r6, sl, sl, lsr #26
     7d0:	303e2f30 	eorscc	r2, lr, r0, lsr pc
	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));
     7d4:	6600fc03 	strvs	pc, [r0], -r3, lsl #24
     7d8:	2a404024 	bcs	1010870 <__Stack_Size+0x1010470>
     7dc:	231d6824 	tstcs	sp, #2359296	; 0x240000
     7e0:	4d31422b 	lfmmi	f4, 4, [r1, #-172]!
     7e4:	7dd2033f 	ldclvc	3, cr0, [r2, #252]
     7e8:	4231309e 	eorsmi	r3, r1, #158	; 0x9e
     7ec:	262e7a03 	strtcs	r7, [lr], -r3, lsl #20
     7f0:	033f413b 	teqeq	pc, #-1073741810	; 0xc000000e
     7f4:	229001db 	addscs	r0, r0, #-1073741770	; 0xc0000036
     7f8:	4d30221e 	lfmmi	f2, 4, [r0, #-120]!
	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
	}
}
     7fc:	3265231d 	rsbcc	r2, r5, #1946157056	; 0x74000000
     800:	7dba033e 	ldcvc	3, cr0, [sl, #248]!
     804:	373e2366 	ldrcc	r2, [lr, -r6, ror #6]!
     808:	4c413526 	cfstr64mi	mvdx3, [r1], {38}
     80c:	d5030304 	strle	r0, [r3, #-772]
//cos4        - Input Cosinus
//AngleRad4     - Output Angle in AngleRad4
long GetArcCos(short cos4) {
	boolean NegativeValue/*:1*/;    //If the the value is Negative
	//Check for negative value
	if (cos4 < 0) {
     810:	2c149004 	ldccs	0, cr9, [r4], {4}
     814:	313e2122 	teqcc	lr, r2, lsr #2
     818:	241c4030 	ldrcs	r4, [ip], #-48
		cos4 = -cos4;
     81c:	4b2c3d2f 	blmi	b0fce0 <__Stack_Size+0xb0f8e0>
     820:	0a03714b 	beq	dcd54 <__Stack_Size+0xdc954>
		NegativeValue = 1;
	} else
		NegativeValue = 0;

	//Limit cos4 to his maximal value
	cos4 = min(cos4, c4DEC);
     824:	2076033c 	rsbscs	r0, r6, ip, lsr r3
     828:	4b200a03 	blmi	80303c <__Stack_Size+0x802c3c>
     82c:	23212f31 	teqcs	r1, #196	; 0xc4

	if ((cos4 >= 0) && (cos4 < 9000)) {
     830:	21212121 	teqcs	r1, r1, lsr #2
     834:	302f2321 	eorcc	r2, pc, r1, lsr #6
     838:	01a2032f 	undefined instruction 0x01a2032f
		AngleRad4 = (byte) pgm_read_byte(&GetACos[cos4 / 79]);
     83c:	7edc033c 	mrcvc	3, 6, r0, cr12, cr12, {1}
     840:	01a40320 	undefined instruction 0x01a40320
     844:	7edc032e 	cdpvc	3, 13, cr0, cr12, cr14, {1}
		AngleRad4 = ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255) ;
     848:	01a40320 	undefined instruction 0x01a40320
     84c:	01042220 	tsteq	r4, r0, lsr #4
	} else if ((cos4 >= 9000) && (cos4 < 9900)) {
     850:	587a9903 	ldmdapl	sl!, {r0, r1, r8, fp, ip, pc}^
     854:	22211f4b 	eorcs	r1, r1, #300	; 0x12c
     858:	c6030304 	strgt	r0, [r3], -r4, lsl #6
     85c:	01042004 	tsteq	r4, r4
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9000) / 8 + 114]);
     860:	207bba03 	rsbscs	fp, fp, r3, lsl #20
     864:	2f302f22 	svccs	0x00302f22
     868:	c0030304 	andgt	r0, r3, r4, lsl #6
     86c:	2f2f2e04 	svccs	0x002f2e04
     870:	03020430 	movweq	r0, #9264	; 0x2430
     874:	2b027ccd 	blcs	9fbb0 <__Stack_Size+0x9f7b0>
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     878:	251b2501 	ldrcs	r2, [fp, #-1281]
	} else if ((cos4 >= 9900) && (cos4 <= 10000)) {
     87c:	1d03251b 	cfstr32ne	mvfx2, [r3, #-108]
     880:	4b3d3d2e 	blmi	f4fd40 <__Stack_Size+0xf4f940>
     884:	232b7794 	teqcs	fp, #38797312	; 0x2500000
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9900) / 2 + 227]);
     888:	211fad59 	tstcs	pc, r9, asr sp
     88c:	1f21213b 	svcne	0x0021213b
     890:	7803753d 	stmdavc	r3, {r0, r2, r3, r4, r5, r8, sl, ip, sp, lr}
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     894:	740b0382 	strvc	r0, [fp], #-898
     898:	2f30306a 	svccs	0x0030306a
     89c:	0343403e 	movteq	r4, #12350	; 0x303e
     8a0:	18ba7eb5 	ldmne	sl!, {r0, r2, r4, r5, r7, r9, sl, fp, ip, sp, lr}
     8a4:	263c7a03 	ldrtcs	r7, [ip], -r3, lsl #20
     8a8:	20790359 	rsbscs	r0, r9, r9, asr r3
     8ac:	1e302f26 	cdpne	15, 3, cr2, cr0, cr6, {1}
	}

	//Add negative sign
	if (NegativeValue)
		AngleRad4 = 31416 - AngleRad4;
     8b0:	7477033e 	ldrbtvc	r0, [r7], #-830
     8b4:	23200903 	teqcs	r0, #49152	; 0xc000
     8b8:	2131331b 	teqcs	r1, fp, lsl r3
     8bc:	2f2f1e21 	svccs	0x002f1e21
     8c0:	1d3f5b5c 	vldmdbne	pc!, {d5-<overflow reg d50>}

	return AngleRad4;
}
     8c4:	03045131 	movweq	r5, #16689	; 0x4131
     8c8:	9e049503 	cfsh32ls	mvfx9, mvfx4, #3
     8cc:	241c6a32 	ldrcs	r6, [ip], #-2610
     8d0:	03102802 	tsteq	r0, #131072	; 0x20000
     8d4:	02042e0c 	andeq	r2, r4, #192	; 0xc0
     8d8:	d67b8103 	ldrbtle	r8, [fp], -r3, lsl #2

unsigned long isqrt32(unsigned long n) //
{
     8dc:	272bf521 	strcs	pc, [fp, -r1, lsr #10]!
     8e0:	212d3d5a 	teqcs	sp, sl, asr sp

	root = 0;
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
     8e4:	03010443 	movweq	r0, #5187	; 0x1443
     8e8:	038202f1 	orreq	r0, r2, #268435471	; 0x1000000f
     8ec:	4b4c2e39 	blmi	130c1d8 <__Stack_Size+0x130bdd8>
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
     8f0:	4b4b4b4b 	blmi	12d3624 <__Stack_Size+0x12d3224>
			remainder = remainder - root - place;
     8f4:	034a1903 	movteq	r1, #43267	; 0xa903
     8f8:	31f27cdb 	ldrsbcc	r7, [r2, #203]!
			root = root + (place << 1);
     8fc:	bc43597a 	mcrrlt	9, 7, r5, r3, cr10

	while (place > remainder)
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
			remainder = remainder - root - place;
     900:	213b2183 	teqcs	fp, r3, lsl #3
			root = root + (place << 1);
		}
		root = root >> 1;
		place = place >> 2;
     904:	4b5a4d2f 	blmi	1693dc8 <__Stack_Size+0x16939c8>
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
		place = place >> 2;
	while (place) {
     908:	219fbc7a 	orrscs	fp, pc, sl, ror ip
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
	XYhyp2 = isqrt32(
     90c:	bb5d594c 	bllt	1756e44 <__Stack_Size+0x1756a44>
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     910:	2c223e59 	stccs	14, cr3, [r2], #-356
	XYhyp2 = isqrt32(
     914:	2c305130 	ldfcss	f5, [r0], #-192
     918:	bb5b4b3d 	bllt	16d3614 <__Stack_Size+0x16d3214>
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     91c:	080b0321 	stmdaeq	fp, {r0, r5, r8, r9}
	XYhyp2 = isqrt32(
     920:	3d59ad20 	ldclcc	13, cr10, [r9, #-128]
     924:	21674030 	cmncs	r7, r0, lsr r0
     928:	034c222d 	movteq	r2, #49709	; 0xc22d
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);
     92c:	0375746c 	cmneq	r5, #1811939328	; 0x6c000000
     930:	69038216 	stmdbvs	r3, {r1, r2, r4, r9, pc}
     934:	2e17032e 	cdpcs	3, 1, cr0, cr7, cr14, {1}
     938:	ea085b40 	b	217640 <__Stack_Size+0x217240>
     93c:	1f2f1f21 	svcne	0x002f1f21
     940:	212f1f2f 	teqcs	pc, pc, lsr #30
     944:	04595968 	ldrbeq	r5, [r9], #-2408

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
     948:	04db0303 	ldrbeq	r0, [fp], #771
		Atan4 = -AngleRad4;
     94c:	0104763c 	tsteq	r4, ip, lsr r6
	else
		Atan4 = AngleRad4;
     950:	907ba903 	rsbsls	sl, fp, r3, lsl #18
	XYhyp2 = isqrt32(
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
		Atan4 = -AngleRad4;
     954:	4b75599f 	blmi	1d56fd8 <__Stack_Size+0x1d56bd8>
	else
		Atan4 = AngleRad4;
     958:	221e304b 	andscs	r3, lr, #75	; 0x4b
     95c:	1f69a024 	svcne	0x0069a024
	return Atan4;
}
     960:	5968942f 	stmdbpl	r8!, {r0, r1, r2, r3, r5, sl, ip, pc}^
     964:	3dbf5940 	ldccc	9, cr5, [pc, #256]!
     968:	4c4b5f68 	mcrrmi	15, 6, r5, fp, cr8
     96c:	2f1fadf3 	svccs	0x001fadf3

}

//--------------------------------------------------------------------
//[BalCalcOneLeg]
void BalCalcOneLeg(long PosX, long PosZ, long PosY, byte BalLegNr) {
     970:	4a7a0388 	bmi	1e81798 <__Stack_Size+0x1e81398>
	long CPR_Y;            //Final Y value for centerpoint of rotation
	long CPR_Z;            //Final Z value for centerpoint of rotation

	long lAtan;
	//Calculating totals from center of the body to the feet
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BalLegNr]) + PosZ;
     974:	587a0326 	ldmdapl	sl!, {r1, r2, r5, r8, r9}^
     978:	1f303226 	svcne	0x00303226
	CPR_X = (short) pgm_read_word(&cOffsetX[BalLegNr]) + PosX;
     97c:	2f1e3021 	svccs	0x001e3021
     980:	a321221e 	teqge	r1, #-536870911	; 0xe0000001
	CPR_Y = 150 + PosY; // using the value 150 to lower the centerpoint of rotation 'g_InControlState.BodyPos.y +

	TotalTransY += (long) PosY;
     984:	4d599f31 	ldclmi	15, cr9, [r9, #-196]
     988:	10032139 	andne	r2, r3, r9, lsr r1
     98c:	211f2f3c 	tstcs	pc, ip, lsr pc
	TotalTransZ += (long) CPR_Z;
     990:	1b4f1f3d 	blne	13c868c <__Stack_Size+0x13c828c>
     994:	29251b25 	stmdbcs	r5!, {r0, r2, r5, r8, r9, fp, ip}
     998:	88596725 	ldmdahi	r9, {r0, r2, r5, r8, r9, sl, sp, lr}^
	TotalTransX += (long) CPR_X;
     99c:	4dae9308 	stcmi	3, cr9, [lr, #32]!
     9a0:	503e2f3d 	eorspl	r2, lr, sp, lsr pc
     9a4:	4b305940 	blmi	c16eac <__Stack_Size+0xc16aac>
     9a8:	912f5b4b 	teqls	pc, fp, asr #22

	lAtan = GetATan2(CPR_X, CPR_Z);
     9ac:	03030432 	movweq	r0, #13362	; 0x3432
	TotalYBal1 += (lAtan * 1800) / 31415;
     9b0:	012f020a 	teqeq	pc, sl, lsl #4
     9b4:	27032f31 	smladxcs	r3, r1, pc, r2
     9b8:	2e60032e 	cdpcs	3, 6, cr0, cr0, cr14, {1}
     9bc:	4b2f305e 	blmi	bccb3c <__Stack_Size+0xbcc73c>
     9c0:	30312f32 	eorscc	r2, r1, r2, lsr pc
     9c4:	3d3d4b31 	fldmdbxcc	sp!, {d4-d27}
     9c8:	683e3d3d 	ldmdavs	lr!, {r0, r2, r3, r4, r5, r8, sl, fp, ip, sp}
     9cc:	082f7323 	stmdaeq	pc!, {r0, r1, r5, r8, r9, ip, sp, lr}

	lAtan = GetATan2(CPR_X, CPR_Y);
     9d0:	660a03c5 	strvs	r0, [sl], -r5, asr #7
     9d4:	082f573e 	stmdaeq	pc!, {r1, r2, r3, r4, r5, r8, r9, sl, ip, lr}
	TotalZBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     9d8:	3d326eaa 	ldccc	14, cr6, [r2, #-680]!
     9dc:	26211b25 	strtcs	r1, [r1], -r5, lsr #22
     9e0:	33207a03 	teqcc	r0, #12288	; 0x3000
     9e4:	0209032f 	andeq	r0, r9, #-1140850688	; 0xbc000000
     9e8:	75030130 	strvc	r0, [r3, #-304]
     9ec:	03013902 	movweq	r3, #6402	; 0x1902
     9f0:	2f4b6615 	svccs	0x004b6615
     9f4:	031a3402 	tsteq	sl, #33554432	; 0x2000000
     9f8:	013e0276 	teqeq	lr, r6, ror r2
     9fc:	31741403 	cmncc	r4, r3, lsl #8

	lAtan = GetATan2(CPR_Z, CPR_Y);
     a00:	59592259 	ldmdbpl	r9, {r0, r3, r4, r6, r9, sp}^
     a04:	a369085d 	cmnge	r9, #6094848	; 0x5d0000
	TotalXBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     a08:	4d212529 	cfstr32mi	mvfx2, [r1, #-164]!
     a0c:	3d342f5d 	ldccc	15, cr2, [r4, #-372]!
     a10:	7903a508 	stmdbvc	r3, {r3, r8, sl, sp, pc}
     a14:	03672720 	cmneq	r7, #8388608	; 0x800000
     a18:	0c032077 	stceq	0, cr2, [r3], {119}
     a1c:	5b3d3d3c 	blpl	f4ff14 <__Stack_Size+0xf4fb14>
     a20:	2f660903 	svccs	0x00660903
     a24:	5b4a0a03 	blpl	1283238 <__Stack_Size+0x1282e38>

}
     a28:	033c1b03 	teqeq	ip, #3072	; 0xc00
     a2c:	2f4b3c66 	svccs	0x004b3c66
     a30:	5b59593e 	blpl	1656f30 <__Stack_Size+0x1656b30>
     a34:	0c032f52 	stceq	15, cr2, [r3], {82}
     a38:	4d3e2f4a 	ldcmi	15, cr2, [lr, #-296]!
     a3c:	3c02223d 	sfmcc	f2, 4, [r2], {61}
     a40:	7f010100 	svcvc	0x00010100
     a44:	02000001 	andeq	r0, r0, #1	; 0x1
     a48:	00009d00 	andeq	r9, r0, r0, lsl #26
     a4c:	fb010200 	blx	41256 <__Stack_Size+0x40e56>
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a50:	01000d0e 	tsteq	r0, lr, lsl #26
     a54:	00010101 	andeq	r0, r1, r1, lsl #2
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a58:	00010000 	andeq	r0, r1, r0
     a5c:	50410100 	subpl	r0, r1, r0, lsl #2
     a60:	72732f50 	rsbsvc	r2, r3, #320	; 0x140
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a64:	74730063 	ldrbtvc	r0, [r3], #-99
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a68:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
     a6c:	5f783031 	svcpl	0x00783031
     a70:	2f62696c 	svccs	0x0062696c
     a74:	00636e69 	rsbeq	r6, r3, r9, ror #28

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     a78:	2f505041 	svccs	0x00505041

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a7c:	00636e69 	rsbeq	r6, r3, r9, ror #28
     a80:	33354d43 	teqcc	r5, #4288	; 0x10c0
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a84:	57485f30 	smlaldxpl	r5, r8, r0, pc
     a88:	636e692f 	cmnvs	lr, #770048	; 0xbc000

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a8c:	69420000 	stmdbvs	r2, {}^
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a90:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^
     a94:	2e784564 	cdpcs	5, 7, cr4, cr8, cr4, {3}
	SinG4 = sin4;
     a98:	00010063 	andeq	r0, r1, r3, rrx
	CosG4 = cos4;
     a9c:	6d747300 	ldclvs	3, cr7, [r4]
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa0:	31663233 	cmncc	r6, r3, lsr r2
	CosG4 = cos4;
     aa4:	745f7830 	ldrbvc	r7, [pc], #2096	; aac <__Stack_Size+0x6ac>
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa8:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
	CosG4 = cos4;

	GetSinCos(g_InControlState.BodyRot1.z + TotalZBal1);
     aac:	00020068 	andeq	r0, r2, r8, rrx
	SinB4 = sin4;
     ab0:	6f694200 	svcvs	0x00694200
     ab4:	64696f6c 	strbtvs	r6, [r9], #-3948
	CosB4 = cos4;
     ab8:	682e7845 	stmdavs	lr!, {r0, r2, r6, fp, ip, sp, lr}

	GetSinCos(g_InControlState.BodyRot1.y + (RotationY * c1DEC) + TotalYBal1);
     abc:	00000300 	andeq	r0, r0, r0, lsl #6
     ac0:	616e7964 	cmnvs	lr, r4, ror #18
     ac4:	6578696d 	ldrbvs	r6, [r8, #-2413]!
     ac8:	64615f6c 	strbtvs	r5, [r1], #-3948
     acc:	73657264 	cmnvc	r5, #1073741830	; 0x40000006

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     ad0:	61745f73 	cmnvs	r4, r3, ror pc
     ad4:	73656c62 	cmnvc	r5, #25088	; 0x6200
     ad8:	0400682e 	streq	r6, [r0], #-2094
     adc:	73750000 	cmnvc	r5, #0	; 0x0
     ae0:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
     ae4:	00040068 	andeq	r0, r4, r8, rrx
     ae8:	05000000 	streq	r0, [r0]
     aec:	00000002 	andeq	r0, r0, r2
     af0:	00cd0300 	sbceq	r0, sp, r0, lsl #6
     af4:	4b2f1301 	blmi	bc5700 <__Stack_Size+0xbc5300>
     af8:	144d3001 	strbne	r3, [sp], #-1
     afc:	64302c4d 	ldrtvs	r2, [r0], #-3149
     b00:	01950331 	orrseq	r0, r5, r1, lsr r3
     b04:	221e1466 	andscs	r1, lr, #1711276032	; 0x66000000
     b08:	5e47762f 	cdppl	6, 4, cr7, cr7, cr15, {1}
     b0c:	221e1484 	andscs	r1, lr, #-2080374784	; 0x84000000
     b10:	5e47762f 	cdppl	6, 4, cr7, cr7, cr15, {1}
     b14:	221e1484 	andscs	r1, lr, #-2080374784	; 0x84000000
     b18:	43475a3d 	movtmi	r5, #31293	; 0x7a3d
     b1c:	4c3e1377 	ldcmi	3, cr1, [lr], #-476
     b20:	587ef803 	ldmdapl	lr!, {r0, r1, fp, ip, sp, lr, pc}^
     b24:	200c0322 	andcs	r0, ip, r2, lsr #6
     b28:	4b207403 	blmi	81db3c <__Stack_Size+0x81d73c>
     b2c:	033c0a03 	teqeq	ip, #12288	; 0x3000
     b30:	0b032076 	bleq	c8d10 <__Stack_Size+0xc8910>
     b34:	2075032e 	rsbscs	r0, r5, lr, lsr #6
     b38:	75200a03 	strvc	r0, [r0, #-2563]!
     b3c:	03623e3d 	cmneq	r2, #976	; 0x3d0
     b40:	033d4a0f 	teqeq	sp, #61440	; 0xf000
     b44:	28e47f8d 	stmiacs	r4!, {r0, r2, r3, r7, r8, r9, sl, fp, ip, sp, lr}^
     b48:	28207803 	stmdacs	r0!, {r0, r1, fp, ip, sp, lr}
     b4c:	3a3d214c 	bcc	f49084 <__Stack_Size+0xf48c84>
     b50:	5d2b2f21 	stcpl	15, cr2, [fp, #-132]!
     b54:	5303503d 	movwpl	r5, #12349	; 0x303d
     b58:	200b03e4 	andcs	r0, fp, r4, ror #7
     b5c:	7603212c 	strvc	r2, [r3], -ip, lsr #2
     b60:	2e0a032e 	cdpcs	3, 0, cr0, cr10, cr14, {1}
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b64:	2f1f4c2d 	svccs	0x001f4c2d
     b68:	3d3d3339 	ldccc	3, cr3, [sp, #-228]!

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     b6c:	d63e0350 	undefined
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b70:	2f221e22 	svccs	0x00221e22
     b74:	2d6b4b3d 	fstmdbxcs	fp!, {d20-d49}
     b78:	2f2f1f21 	svccs	0x002f1f21
     b7c:	65752f1f 	ldrbvs	r2, [r5, #-3871]!
     b80:	676d2921 	strbvs	r2, [sp, -r1, lsr #18]!
     b84:	3e2f302f 	cdpcc	0, 2, cr3, cr15, cr15, {1}
     b88:	82240330 	eorhi	r0, r4, #-1073741824	; 0xc0000000
     b8c:	3f221e22 	svccc	0x00221e22
     b90:	6075212f 	rsbsvs	r2, r5, pc, lsr #2
     b94:	7903436d 	stmdbvc	r3, {r0, r2, r3, r5, r6, r8, r9, lr}
     b98:	79032720 	stmdbvc	r3, {r5, r8, r9, sl, sp}
     b9c:	913d5120 	teqls	sp, r0, lsr #2
     ba0:	2a322131 	bcs	c8906c <__Stack_Size+0xc88c6c>
     ba4:	4e322f21 	cdpmi	15, 3, cr2, cr2, cr1, {1}
     ba8:	70032438 	andvc	r2, r3, r8, lsr r4
     bac:	4a1e032e 	bmi	78186c <__Stack_Size+0x78146c>
     bb0:	033e3d2f 	teqeq	lr, #3008	; 0xbc0
     bb4:	12087ef0 	andne	r7, r8, #3840	; 0xf00
     bb8:	03982243 	orrseq	r2, r8, #805306372	; 0x30000004
     bbc:	0c033c76 	stceq	12, cr3, [r3], {118}
     bc0:	0008024a 	andeq	r0, r8, sl, asr #4
     bc4:	021f0101 	andseq	r0, pc, #1073741824	; 0x40000000
     bc8:	00020000 	andeq	r0, r2, r0
     bcc:	00000083 	andeq	r0, r0, r3, lsl #1
     bd0:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     bd4:	0101000d 	tsteq	r1, sp
     bd8:	00000101 	andeq	r0, r0, r1, lsl #2
     bdc:	00000100 	andeq	r0, r0, r0, lsl #2
     be0:	50504101 	subspl	r4, r0, r1, lsl #2
     be4:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
     be8:	6d747300 	ldclvs	3, cr7, [r4]
     bec:	31663233 	cmncc	r6, r3, lsr r2
     bf0:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
     bf4:	692f6269 	stmdbvs	pc!, {r0, r3, r5, r6, r9, sp, lr}
     bf8:	4300636e 	movwmi	r6, #878	; 0x36e
     bfc:	3033354d 	eorscc	r3, r3, sp, asr #10
     c00:	2f57485f 	svccs	0x0057485f
     c04:	00636e69 	rsbeq	r6, r3, r9, ror #28
     c08:	72657300 	rsbvc	r7, r5, #0	; 0x0
     c0c:	2e6c6169 	powcsez	f6, f4, #1.0
     c10:	00010063 	andeq	r0, r1, r3, rrx
     c14:	6d747300 	ldclvs	3, cr7, [r4]
     c18:	31663233 	cmncc	r6, r3, lsr r2
     c1c:	745f7830 	ldrbvc	r7, [pc], #2096	; c24 <__Stack_Size+0x824>
     c20:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
     c24:	00020068 	andeq	r0, r2, r8, rrx
     c28:	6e796400 	cdpvs	4, 7, cr6, cr9, cr0, {0}
     c2c:	78696d61 	stmdavc	r9!, {r0, r5, r6, r8, sl, fp, sp, lr}^
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c30:	615f6c65 	cmpvs	pc, r5, ror #24
	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     c34:	65726464 	ldrbvs	r6, [r2, #-1124]!
     c38:	745f7373 	ldrbvc	r7, [pc], #883	; c40 <__Stack_Size+0x840>
     c3c:	656c6261 	strbvs	r6, [ip, #-609]!
     c40:	00682e73 	rsbeq	r2, r8, r3, ror lr
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c44:	75000003 	strvc	r0, [r0, #-3]
     c48:	74726173 	ldrbtvc	r6, [r2], #-371
     c4c:	0300682e 	movweq	r6, #2094	; 0x82e
     c50:	00000000 	andeq	r0, r0, r0
     c54:	35800205 	strcc	r0, [r0, #517]
     c58:	0d030800 	stceq	8, cr0, [r3]
     c5c:	59781301 	ldmdbpl	r8!, {r0, r8, r9, ip}^
     c60:	4c4b9416 	cfstrdmi	mvd9, [fp], {22}
     c64:	7403ce03 	strvc	ip, [r3], #-3587
     c68:	24201c24 	strtcs	r1, [r0], #-3108
     c6c:	3d6b2f22 	stclcc	15, cr2, [fp, #-136]!
     c70:	1f5a8522 	svcne	0x005a8522
     c74:	5876032f 	ldmdapl	r6!, {r0, r1, r2, r3, r5, r8, r9}^
     c78:	674a0d03 	strbvs	r0, [sl, -r3, lsl #26]
     c7c:	27664203 	strbcs	r4, [r6, -r3, lsl #4]!
     c80:	20207903 	eorcs	r7, r0, r3, lsl #18
     c84:	1f974c27 	svcne	0x00974c27
     c88:	8759843d 	smmlarhi	r9, sp, r4, r8
     c8c:	71034b69 	tstvc	r3, r9, ror #22
     c90:	4a12033c 	bmi	481988 <__Stack_Size+0x481588>
     c94:	5a211f2f 	bpl	848958 <__Stack_Size+0x848558>
     c98:	4a7fb903 	bmi	1fef0ac <__Stack_Size+0x1feecac>
     c9c:	20790327 	rsbscs	r0, r9, r7, lsr #6
     ca0:	964c2720 	strbls	r2, [ip], -r0, lsr #14
     ca4:	7959843d 	ldmdbvc	r9, {r0, r2, r3, r4, r5, sl, pc}^
     ca8:	3c72035b 	ldclcc	3, cr0, [r2], #-364
     cac:	2f661203 	svccs	0x00661203
     cb0:	035a211f 	cmpeq	sl, #-1073741817	; 0xc0000007
     cb4:	3c587fbf 	mrrccc	15, 11, r7, r8, cr15
     cb8:	2f3c0903 	svccs	0x003c0903
     cbc:	4b318722 	blmi	c6294c <__Stack_Size+0xc6254c>
     cc0:	033c7203 	teqeq	ip, #805306368	; 0x30000000
     cc4:	2f1f4a12 	svccs	0x001f4a12
     cc8:	7447034c 	strbvc	r0, [r7], #-844
     ccc:	222f523c 	eorcs	r5, pc, #-1073741821	; 0xc0000003
     cd0:	034b3187 	movteq	r3, #45447	; 0xb187
     cd4:	11033c72 	tstne	r3, r2, ror ip
     cd8:	211f2f4a 	tstcs	pc, sl, asr #30
     cdc:	4a5a035a 	bmi	1681a4c <__Stack_Size+0x168164c>
     ce0:	48221e14 	stmdami	r2!, {r2, r4, r9, sl, fp, ip}
     ce4:	3d232b23 	fstmdbxcc	r3!, {d2-d18}
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * SinG4 / c4DEC
					+ (long) CPR_Z * c2DEC * CosG4 / c4DEC * SinA4 / c4DEC
							* SinB4 / c4DEC
					+ (long) CPR_Y * c2DEC * CosB4 / c4DEC * CosG4 / c4DEC))
			/ c2DEC;
}
     ce8:	4b211f83 	blmi	848afc <__Stack_Size+0x8486fc>
     cec:	ce03ad59 	mcrgt	13, 0, sl, cr3, cr9, {2}
     cf0:	1f13747d 	svcne	0x0013747d
     cf4:	212a2520 	teqcs	sl, r0, lsr #10
     cf8:	0332223d 	teqeq	r2, #-805306365	; 0xd0000003
     cfc:	2f2e019a 	svccs	0x002e019a
     d00:	7ee7032f 	cdpvc	3, 14, cr0, cr7, cr15, {1}
     d04:	3b313c2e 	blcc	c4fdc4 <__Stack_Size+0xc4f9c4>
     d08:	02840340 	addeq	r0, r4, #1	; 0x1
     d0c:	221e223c 	andscs	r2, lr, #-1073741821	; 0xc0000003
     d10:	2f3e3d2f 	svccs	0x003e3d2f
     d14:	3e212f1f 	mcrcc	15, 1, r2, cr1, cr15, {0}
     d18:	212f1f4b 	teqcs	pc, fp, asr #30
     d1c:	55034c3e 	strpl	r4, [r3, #-3134]
//FemurAngle1           - Output Angle of Femur in degrees
//TibiaAngle1           - Output Angle of Tibia in degrees
//CoxaAngle1            - Output Angle of Coxa in degrees
//--------------------------------------------------------------------
void LegIK(short IKFeetPosX, short IKFeetPosY, short IKFeetPosZ,
		byte LegIKLegNr) {
     d20:	221e223c 	andscs	r2, lr, #-1073741821	; 0xc0000003
     d24:	2f3e3d2f 	svccs	0x003e3d2f
     d28:	3e212f1f 	mcrcc	15, 1, r2, cr1, cr15, {0}
	long Temp1;
	long Temp2;
	long T3;

	//Calculate IKCoxaAngle and IKFeetPosXZ
	GetATan2(IKFeetPosX, IKFeetPosZ);
     d2c:	212f1f4b 	teqcs	pc, fp, asr #30
	CoxaAngle1[LegIKLegNr] = (((long) Atan4 * 180) / 3141)
     d30:	2f1f4b3e 	svccs	0x001f4b3e
     d34:	1f4b3e21 	svcne	0x004b3e21
     d38:	4c3e212f 	ldfmis	f2, [lr], #-188
     d3c:	033c4203 	teqeq	ip, #805306368	; 0x30000000
     d40:	032f2e09 	teqeq	pc, #144	; 0x90
     d44:	76032009 	strvc	r2, [r3], -r9
     d48:	2f2f322e 	svccs	0x002f322e
     d4c:	7a035931 	bvc	d7218 <__Stack_Size+0xd6e18>
     d50:	764d363c 	undefined
     d54:	3a1d213d 	bcc	749250 <__Stack_Size+0x748e50>
	//Length between the Coxa and tars [foot]
	IKFeetPosXZ = XYhyp2 / c2DEC;

	//Using GetAtan2 for solving IKA1 and IKSW
	//IKA14 - Angle between SW line and the ground in radians
	IKA14 = GetATan2(IKFeetPosY - TarsOffsetY,
     d58:	3e4a0a03 	fmacscc	s1, s20, s6
     d5c:	747fbf03 	ldrbtvc	fp, [pc], #3843	; d64 <__Stack_Size+0x964>
     d60:	033c0b03 	teqeq	ip, #3072	; 0xc00
     d64:	0a032e75 	beq	cc740 <__Stack_Size+0xcc340>
     d68:	312f2a20 	teqcc	pc, r0, lsr #20
     d6c:	4a7a0359 	bmi	1e81ad8 <__Stack_Size+0x1e816d8>
     d70:	3d764d36 	ldclcc	13, cr4, [r6, #-216]!

	//IKSW2 - Length between femur axis and tars
	IKSW2 = XYhyp2;

	//IKA2 - Angle of the line S>W with respect to the femur in radians
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     d74:	033a1d21 	teqeq	sl, #2112	; 0x840
     d78:	034c4a0a 	movteq	r4, #51722	; 0xca0a
     d7c:	2f2f6656 	svccs	0x002f6656
     d80:	132e4203 	teqne	lr, #805306368	; 0x30000000
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			+ ((long) IKSW2 * IKSW2));
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);
     d84:	2121202d 	teqcs	r1, sp, lsr #32
     d88:	3d3e3d3e 	ldccc	13, cr3, [lr, #-248]!
     d8c:	3d3e3d3e 	ldccc	13, cr3, [lr, #-248]!
     d90:	3d3e3d3f 	ldccc	13, cr3, [lr, #-252]!
     d94:	08403d3e 	stmdaeq	r0, {r1, r2, r3, r4, r5, r8, sl, fp, ip, sp}^
     d98:	211f2123 	tstcs	pc, r3, lsr #2
     d9c:	3e593e4b 	cdpcc	14, 5, cr3, cr9, cr11, {2}
     da0:	3e593e59 	mrccc	14, 2, r3, cr9, cr9, {2}
     da4:	3e593e59 	mrccc	14, 2, r3, cr9, cr9, {2}
     da8:	ad033d59 	stcge	13, cr3, [r3, #-356]
     dac:	4020f27f 	eormi	pc, r0, pc, ror r2
     db0:	233d763d 	teqcs	sp, #63963136	; 0x3d00000
     db4:	21812f33 	orrcs	r2, r1, r3, lsr pc

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     db8:	03402321 	movteq	r2, #801	; 0x321
     dbc:	1a033c6a 	bne	cff6c <__Stack_Size+0xcfb6c>
     dc0:	00c8034a 	sbceq	r0, r8, sl, asr #6
     dc4:	032f2f3c 	teqeq	pc, #240	; 0xf0
     dc8:	232e7ee1 	teqcs	lr, #3600	; 0xe10
     dcc:	762f231d 	undefined
     dd0:	0340305b 	movteq	r3, #91	; 0x5b
     dd4:	2f2e0189 	svccs	0x002e0189
     dd8:	7ecc032f 	cdpvc	3, 12, cr0, cr12, cr15, {1}
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     ddc:	032f2f2e 	teqeq	pc, #184	; 0xb8
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     de0:	5c2f2e76 	stcpl	14, cr2, [pc], #-472
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     de4:	01000202 	tsteq	r0, r2, lsl #4
     de8:	00024201 	andeq	r4, r2, r1, lsl #4
			+ ((long) (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr])
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);
     dec:	d1000200 	tstle	r0, r0, lsl #4
     df0:	02000000 	andeq	r0, r0, #0	; 0x0
     df4:	0d0efb01 	vstreq	d15, [lr, #-4]
     df8:	01010100 	tsteq	r1, r0, lsl #2
     dfc:	00000001 	andeq	r0, r0, r1
     e00:	01000001 	tsteq	r0, r1
     e04:	2f505041 	svccs	0x00505041
     e08:	00637273 	rsbeq	r7, r3, r3, ror r2

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e0c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     e10:	30316632 	eorscc	r6, r1, r2, lsr r6
     e14:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     e18:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
     e1c:	4d430063 	stclmi	0, cr0, [r3, #-396]
     e20:	5f303335 	svcpl	0x00303335
     e24:	692f5748 	stmdbvs	pc!, {r3, r6, r8, r9, sl, ip, lr}
     e28:	6300636e 	movwvs	r6, #878	; 0x36e
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e2c:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e30:	6d72616e 	ldfvse	f6, [r2, #-440]!
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e34:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
     e38:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
     e3c:	2f2e2e2f 	svccs	0x002e2e2f
     e40:	612f2e2e 	teqvs	pc, lr, lsr #28
     e44:	652d6d72 	strvs	r6, [sp, #-3442]!
			< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
					+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]) - 30)
					* c2DEC))
		IKSolution = 1;
     e48:	2f696261 	svccs	0x00696261
	else {
		if (IKSW2
     e4c:	6c636e69 	stclvs	14, cr6, [r3], #-420
     e50:	00656475 	rsbeq	r6, r5, r5, ror r4
				< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
						+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))
						* c2DEC))
			IKSolutionWarning = 1;
     e54:	2f505041 	svccs	0x00505041
     e58:	00636e69 	rsbeq	r6, r3, r9, ror #28
		else
			IKSolutionError = 1;
     e5c:	6e796400 	cdpvs	4, 7, cr6, cr9, cr0, {0}
	}

}
     e60:	78696d61 	stmdavc	r9!, {r0, r5, r6, r8, sl, fp, sp, lr}^
     e64:	632e6c65 	teqvs	lr, #25856	; 0x6500
     e68:	00000100 	andeq	r0, r0, r0, lsl #2
     e6c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     e70:	30316632 	eorscc	r6, r1, r2, lsr r6
     e74:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     e78:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
     e7c:	00000200 	andeq	r0, r0, r0, lsl #4
     e80:	616e7964 	cmnvs	lr, r4, ror #18
     e84:	6578696d 	ldrbvs	r6, [r8, #-2413]!
     e88:	64615f6c 	strbtvs	r5, [r1], #-3948
     e8c:	73657264 	cmnvc	r5, #1073741830	; 0x40000006
     e90:	61745f73 	cmnvs	r4, r3, ror pc
     e94:	73656c62 	cmnvc	r5, #25088	; 0x6200
     e98:	0300682e 	movweq	r6, #2094	; 0x82e
     e9c:	74730000 	ldrbtvc	r0, [r3]
     ea0:	746e6964 	strbtvc	r6, [lr], #-2404
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ea4:	0400682e 	streq	r6, [r0], #-2094
	if (sVal < s) {
     ea8:	79740000 	ldmdbvc	r4!, {}^
     eac:	65646570 	strbvs	r6, [r4, #-1392]!
		return s;
	}

	s = (short) pgm_read_word(sMax);
     eb0:	682e7366 	stmdavs	lr!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}
     eb4:	00000500 	andeq	r0, r0, r0, lsl #10
     eb8:	72617375 	rsbvc	r7, r1, #-738197503	; 0xd4000001

		return s;
	}
	return sVal;

}
     ebc:	00682e74 	rsbeq	r2, r8, r4, ror lr
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec0:	00000003 	andeq	r0, r0, r3
}

//--------------------------------------------------------------------
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
     ec4:	38020500 	stmdacc	r2, {r8, sl}
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec8:	0308003c 	movweq	r0, #32828	; 0x803c
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ecc:	130101e4 	movwne	r0, #4580	; 0x11e4
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     ed0:	2f133f3d 	svccs	0x00133f3d
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ed4:	4d2f134d 	stcmi	3, cr1, [pc, #-308]!
	if (sVal < s) {
     ed8:	133f3d13 	teqne	pc, #1216	; 0x4c0
     edc:	cf134d2f 	svcgt	0x00134d2f
     ee0:	2f77135b 	svccs	0x0077135b
		return s;
	}

	s = (short) pgm_read_word(sMax);
     ee4:	3d77135b 	ldclcc	3, cr1, [r7, #-364]!
     ee8:	233f1669 	teqcs	pc, #110100480	; 0x6900000
     eec:	01232301 	teqeq	r3, r1, lsl #6
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
     ef0:	00e70323 	rsceq	r0, r7, r3, lsr #6
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ef4:	4c2f1320 	stcmi	3, cr1, [pc], #-128
	if (sVal < s) {
     ef8:	3b21211e 	blcc	849378 <__Stack_Size+0x848f78>
     efc:	d103765c 	tstle	r3, ip, asr r6
     f00:	1c244a7d 	stcne	10, cr4, [r4], #-500
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f04:	6c304d24 	ldcvs	13, cr4, [r0], #-144
     f08:	a13f3d4b 	teqge	pc, fp, asr #26
     f0c:	1f211f2f 	svcne	0x00211f2f
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f10:	0b032121 	bleq	c939c <__Stack_Size+0xc8f9c>
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f14:	211d234a 	tstcs	sp, sl, asr #6
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f18:	7303311f 	movwvc	r3, #12575	; 0x311f
	if (sVal < s) {
     f1c:	523e3d3c 	eorspl	r3, lr, #3840	; 0xf00
     f20:	2f526384 	svccs	0x00526384
     f24:	404d812f 	submi	r8, sp, pc, lsr #2
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f28:	4e4b677a 	mcrmi	7, 2, r6, cr11, cr10, {3}
     f2c:	21211f3d 	teqcs	r1, sp, lsr pc
     f30:	211f2f68 	tstcs	pc, r8, ror #30
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
				FemurAngle1[LegIndex], &cFemurMin1[LegIndex],
				&cFemurMax1[LegIndex]);
		TibiaAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f34:	0327211f 	teqeq	r7, #-1073741817	; 0xc0000007
     f38:	575f667a 	undefined
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     f3c:	263b914e 	ldrtcs	r9, [fp], -lr, asr #2
     f40:	eb032f3d 	bl	ccc3c <__Stack_Size+0xcc83c>
				TibiaAngle1[LegIndex], &cTibiaMin1[LegIndex],
				&cTibiaMax1[LegIndex]);

	}
#endif
}
     f44:	2925d67e 	stmdbcs	r5!, {r1, r2, r3, r4, r5, r6, r9, sl, ip, lr, pc}
     f48:	221e4f25 	andscs	r4, lr, #148	; 0x94
     f4c:	1e22302c 	cdpne	0, 2, cr3, cr2, cr12, {1}
     f50:	ec5d3d22 	mrrc	13, 2, r3, sp, cr2
     f54:	214b4059 	qdaddcs	r4, r9, fp
     f58:	5a4c5759 	bpl	1316cc4 <__Stack_Size+0x13168c4>
     f5c:	1f2f3193 	svcne	0x002f3193
     f60:	672f3e2f 	strvs	r3, [pc, -pc, lsr #28]!
     f64:	3e4c3d4e 	cdpcc	13, 4, cr3, cr12, cr14, {2}
     f68:	00de034b 	sbcseq	r0, lr, fp, asr #6
     f6c:	03302290 	teqeq	r0, #9	; 0x9
// SmoothControl (From Zenta) -  This function makes the body
//            rotation and translation much smoother
//--------------------------------------------------------------------
short SmoothControl(short CtrlMoveInp, short CtrlMoveOut, byte CtrlDivider) {

	if (CtrlMoveOut < (CtrlMoveInp - 4))
     f70:	2f5801c8 	svccs	0x005801c8
     f74:	21211e4c 	teqcs	r1, ip, asr #28
		return CtrlMoveOut + abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f78:	c0035c3b 	andgt	r5, r3, fp, lsr ip
     f7c:	2f1e747e 	svccs	0x001e747e
     f80:	ca03523d 	bgt	d587c <__Stack_Size+0xd547c>
     f84:	1c326601 	ldcne	6, cr6, [r2], #-4
     f88:	033f3220 	teqeq	pc, #2	; 0x2
     f8c:	412e7eb8 	strhmi	r7, [lr, -r8]!
     f90:	01cd0333 	biceq	r0, sp, r3, lsr r3
	else if (CtrlMoveOut > (CtrlMoveInp + 4))
     f94:	7eb303ac 	cdpvc	3, 11, cr0, cr3, cr12, {5}
		return CtrlMoveOut - abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f98:	01d30366 	bicseq	r0, r3, r6, ror #6
     f9c:	ad039e08 	stcge	14, cr9, [r3, #-32]
     fa0:	cd03207e 	stcgt	0, cr2, [r3, #-504]
     fa4:	b3035801 	movwlt	r5, #14337	; 0x3801
     fa8:	cd03207e 	stcgt	0, cr2, [r3, #-504]
     fac:	b8032e01 	stmdalt	r3, {r0, r9, sl, fp, sp}
     fb0:	d603207e 	undefined

	return CtrlMoveInp;
}
     fb4:	03315801 	teqeq	r1, #65536	; 0x10000
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
     fb8:	2f747faf 	svccs	0x00747faf
     fbc:	213f211f 	teqcs	pc, pc, lsl r1
     fc0:	251b3d31 	ldrcs	r3, [fp, #-3377]

//--------------------------------------------------------------------
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
     fc4:	3032211d 	eorscc	r2, r2, sp, lsl r1
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
		return g_wLegsXZLength;

	return isqrt32((LegPosX[0] * LegPosX[0]) + (LegPosZ[0] * LegPosZ[0]));
     fc8:	825e033d 	subshi	r0, lr, #-201326592	; 0xf4000000
     fcc:	3f211f21 	svccc	0x00211f21
     fd0:	2a213021 	bcs	84d05c <__Stack_Size+0x84cc5c>
     fd4:	03302422 	teqeq	r0, #570425344	; 0x22000000
     fd8:	30747fa2 	rsbscc	r7, r4, r2, lsr #31
     fdc:	4a00e103 	bmi	393f0 <__Stack_Size+0x38ff0>
}
     fe0:	2fac5f03 	svccs	0x00ac5f03
     fe4:	213f211f 	teqcs	pc, pc, lsl r1
     fe8:	1e241c31 	mcrne	12, 1, r1, cr4, cr1, {1}
     fec:	3d303121 	ldfccs	f3, [r0, #-132]!

#ifndef MAX_XZ_LEG_ADJUST
#define MAX_XZ_LEG_ADJUST   (word)(cCoxaLength[0]+cTibiaLength[0] + cFemurLength[0]/4)
#endif

void AdjustLegPositions(word XZLength1) {
     ff0:	03903403 	orrseq	r3, r0, #50331648	; 0x3000000
     ff4:	77032009 	strvc	r2, [r3, -r9]
     ff8:	20090320 	andcs	r0, r9, r0, lsr #6
     ffc:	7fa2033d 	svcvc	0x00a2033d
    1000:	211f212e 	tstcs	pc, lr, lsr #2
		XZLength1 = MAX_XZ_LEG_ADJUST;
	if (XZLength1 < MIN_XZ_LEG_ADJUST)
		XZLength1 = MIN_XZ_LEG_ADJUST;

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
    1004:	2f30213f 	svccs	0x0030213f
    1008:	3024222a 	eorcc	r2, r4, sl, lsr #4
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    100c:	54032f77 	strpl	r2, [r3], #-3959

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
		return;

	g_wLegsXZLength = XZLength1;
    1010:	211f219e 	ldrbcs	r2, [pc, -lr]

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));
    1014:	2c2f213f 	stfcss	f2, [pc], #-252
    1018:	3e4e3124 	dvfccep	f3, f6, f4

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
    101c:	7de3037c 	stclvc	3, cr0, [r3, #496]!
    1020:	032f2f9e 	teqeq	pc, #632	; 0x278
    1024:	3f2f2e73 	svccc	0x002f2e73
    1028:	07024d4b 	streq	r4, [r2, -fp, asr #26]
    102c:	2d010100 	stfcss	f0, [r1]
    1030:	02000001 	andeq	r0, r0, #1	; 0x1
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    1034:	00006500 	andeq	r6, r0, r0, lsl #10
    1038:	fb010200 	blx	41842 <__Stack_Size+0x41442>
    103c:	01000d0e 	tsteq	r0, lr, lsl #26
    1040:	00010101 	andeq	r0, r1, r1, lsl #2
    1044:	00010000 	andeq	r0, r1, r0
    1048:	50410100 	subpl	r0, r1, r0, lsl #2
		return;

	g_wLegsXZLength = XZLength1;

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    104c:	72732f50 	rsbsvc	r2, r3, #320	; 0x140
		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
	}

	// Make sure we cycle through one gait to have the legs all move into their new locations...
	g_InControlState.ForceGaitStepCnt = g_InControlState.gaitCur.StepsInGait;
    1050:	74730063 	ldrbtvc	r0, [r3], #-99
    1054:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
}
    1058:	5f783031 	svcpl	0x00783031
    105c:	2f62696c 	svccs	0x0062696c
    1060:	00636e69 	rsbeq	r6, r3, r9, ror #28
    1064:	33354d43 	teqcc	r5, #4288	; 0x10c0
    1068:	57485f30 	smlaldxpl	r5, r8, r0, pc
    106c:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    1070:	697a0000 	ldmdbvs	sl!, {}^
    1074:	65656267 	strbvs	r6, [r5, #-615]!
    1078:	0100632e 	tsteq	r0, lr, lsr #6
		g_InControlState.aCoxaInitAngle1[LegIndex] = (short)pgm_read_word(&cCoxaAngle1[LegIndex]);
#endif
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    107c:	74730000 	ldrbtvc	r0, [r3]
		else if (g_InControlState.aCoxaInitAngle1[LegIndex] < -700)
		g_InControlState.aCoxaInitAngle1[LegIndex] = -700;
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    1080:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
//     to be appropriate for the current y location of the body...
//--------------------------------------------------------------------

u8 g_iLegInitIndex = 0x00; // remember which index we are currently using...

void AdjustLegPositionsToBodyHeight() {
    1084:	5f783031 	svcpl	0x00783031
    1088:	65707974 	ldrbvs	r7, [r0, #-2420]!
#ifdef CNT_HEX_INITS
	// Lets see which of our units we should use...
	// Note: We will also limit our body height here...
	if (g_InControlState.BodyPos.y
    108c:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
			> (short) pgm_read_byte(&g_abHexMaxBodyY[CNT_HEX_INITS-1]))
		g_InControlState.BodyPos.y = (short) pgm_read_byte(
    1090:	73750000 	cmnvc	r5, #0	; 0x0
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    1094:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
    1098:	00030068 	andeq	r0, r3, r8, rrx
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    109c:	05000000 	streq	r0, [r0]
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    10a0:	00424802 	subeq	r4, r2, r2, lsl #16
    10a4:	018b0308 	orreq	r0, fp, r8, lsl #6
    10a8:	035a1301 	cmpeq	sl, #67108864	; 0x4000000
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    10ac:	015800fe 	ldrsheq	r0, [r8, #-14]
		g_iLegInitIndex = i;  // remember the current index...
		AdjustLegPositions(XZLength1);
    10b0:	31014d31 	tstcc	r1, r1, lsr sp
	}
#endif // CNT_HEX_INITS
}
    10b4:	4d31014d 	ldfmis	f0, [r1, #-308]!
    10b8:	014d3101 	cmpeq	sp, r1, lsl #2
    10bc:	3f134d31 	svccc	0x00134d31
}
//--------------------------------------------------------------------
//[CHECK VOLTAGE]
//Reads the input voltage and shuts down the bot when the power drops
byte s_bLVBeepCnt;
boolean CheckVoltage() {
    10c0:	3f3f015b 	svccc	0x003f015b
    10c4:	013f3f01 	teqeq	pc, r1, lsl #30
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10c8:	3f013f3f 	svccc	0x00013f3f

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10cc:	0378133e 	cmneq	r8, #-134217728	; 0xf8000000
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d0:	27587ec5 	ldrbcs	r7, [r8, -r5, asr #29]

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10d4:	4076506e 	rsbsmi	r5, r6, lr, rrx
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d8:	5a3a2279 	bpl	e89ac4 <__Stack_Size+0xe896c4>

	if (!g_fLowVoltageShutdown) {
		/**PrintString("Voltage : ");
		Printu32d(Voltage);
		PrintString("\n");*/
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {
    10dc:	79033d30 	stmdbvc	r3, {r4, r5, r8, sl, fp, ip, sp}
    10e0:	2e0c032e 	cdpcs	3, 0, cr0, cr12, cr14, {1}
    10e4:	43683122 	cmnmi	r8, #-2147483640	; 0x80000008


			//Turn off
			g_InControlState.BodyPos.x = 0;
    10e8:	4d4f4f63 	stclmi	15, cr4, [pc, #-396]
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;

#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
    10ec:	2f740f03 	svccs	0x00740f03
    10f0:	2d21211f 	stfcss	f2, [r1, #-124]!
#endif
			g_fLowVoltageShutdown = 1;
    10f4:	2f1f2121 	svccs	0x001f2121
			s_bLVBeepCnt = 0;    // how many times we beeped...
    10f8:	03211f21 	teqeq	r1, #132	; 0x84
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {


			//Turn off
			g_InControlState.BodyPos.x = 0;
			g_InControlState.BodyPos.y = 0;
    10fc:	6b032015 	blvs	c9158 <__Stack_Size+0xc8d58>
			g_InControlState.BodyPos.z = 0;
			g_InControlState.BodyRot1.x = 0;
    1100:	1403213c 	strne	r2, [r3], #-316
			g_InControlState.BodyRot1.y = 0;
			g_InControlState.BodyRot1.z = 0;
    1104:	206c032e 	rsbcs	r0, ip, lr, lsr #6
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;
    1108:	77201403 	strvc	r1, [r0, -r3, lsl #8]!
#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
#endif
			g_fLowVoltageShutdown = 1;
			s_bLVBeepCnt = 0;    // how many times we beeped...
    110c:	3d313d40 	ldccc	13, cr3, [r1, #-256]!
			g_InControlState.fRobotOn = false;
    1110:	087eb803 	ldmdaeq	lr!, {r0, r1, fp, ip, sp, pc}^
		}
#ifdef cTurnOnVol
	} else if ((Voltage > cTurnOnVol) && (Voltage < 1999)) {
    1114:	251b252e 	ldrcs	r2, [fp, #-1326]
    1118:	40764c5c 	rsbsmi	r4, r6, ip, asr ip

		g_fLowVoltageShutdown = 0;
    111c:	5a3a2278 	bpl	e89b04 <__Stack_Size+0xe89704>
    1120:	79033d30 	stmdbvc	r3, {r4, r5, r8, sl, fp, ip, sp}

#endif
	} else {
		if (s_bLVBeepCnt < 5) {
    1124:	2e0c032e 	cdpcs	3, 0, cr0, cr12, cr14, {1}
    1128:	42673122 	rsbmi	r3, r7, #-2147483640	; 0x80000008
			s_bLVBeepCnt++;
    112c:	4c4f4e64 	mcrrmi	14, 6, r4, pc, cr4

			//MSound( 1, 45, 2000);
			Buzzed(45, 2000);
    1130:	4b777777 	blmi	1ddef14 <__Stack_Size+0x1ddeb14>
    1134:	3d313d40 	ldccc	13, cr3, [r1, #-256]!
    1138:	ac7fa503 	cfldr64ge	mvdx10, [pc], #-12
		}
		mDelay(2000);
    113c:	26231e22 	strtcs	r1, [r3], -r2, lsr #28
    1140:	3029332a 	eorcc	r3, r9, sl, lsr #6
    1144:	3030222d 	eorscc	r2, r0, sp, lsr #4
	}
#endif

	return g_fLowVoltageShutdown;
}
    1148:	303c7a03 	eorscc	r7, ip, r3, lsl #20
    114c:	6a036a32 	bvs	dba1c <__Stack_Size+0xdb61c>
    1150:	032f2f2e 	teqeq	pc, #184	; 0xb8
    1154:	3f2f2e72 	svccc	0x002f2e72
    1158:	023e4b3d 	eorseq	r4, lr, #62464	; 0xf400

//==============================================================================
// BackgroundProcess - Allows us to have some background processing for those
//    servo drivers that need us to do things like polling...
//==============================================================================
void BackgroundProcess(void) {
    115c:	01010009 	tsteq	r1, r9
    1160:	0000024e 	andeq	r0, r0, lr, asr #4
	if (g_fAXSpeedControl)
    1164:	00da0002 	sbcseq	r0, sl, r2
		return;  // nothing to do in this mode...

	if (ServosEnabled) {
		//DebugToggle(A3);
		BioloidControllerEx_interpolateStep(false); // Do our background stuff...
    1168:	01020000 	tsteq	r2, r0
		Battery_Monitor_Alarm();
    116c:	000d0efb 	strdeq	r0, [sp], -fp
	}
}
    1170:	01010101 	tsteq	r1, r1, lsl #2
    1174:	01000000 	tsteq	r0, r0
//Function that gets called from the main loop if the robot is not logically
//     on.  Gives us a chance to play some...
//--------------------------------------------------------------------
static u8 g_iIdleServoNum = (u8) - 1;
static u8 g_iIdleLedState = 1;  // what state to we wish to set...
void IdleTime(void) {
    1178:	41010000 	tstmi	r1, r0
    117c:	732f5050 	teqvc	pc, #80	; 0x50
	// Each time we call this set servos LED on or off...
	g_iIdleServoNum++;
    1180:	63006372 	movwvs	r6, #882	; 0x372
	if (g_iIdleServoNum >= NUMSERVOS) {
    1184:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
    1188:	6d72616e 	ldfvse	f6, [r2, #-440]!
		g_iIdleServoNum = 0;
    118c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
		g_iIdleLedState = 1 - g_iIdleLedState;
    1190:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    1194:	2f2e2e2f 	svccs	0x002e2e2f
	}
	dxl_write_byte(pgm_read_byte(&cPinTable[g_iIdleServoNum]), AXM_LED,
    1198:	612f2e2e 	teqvs	pc, lr, lsr #28
    119c:	652d6d72 	strvs	r6, [sp, #-3442]!
    11a0:	2f696261 	svccs	0x00696261
    11a4:	6c636e69 	stclvs	14, cr6, [r3], #-420
    11a8:	00656475 	rsbeq	r6, r5, r5, ror r4
			g_iIdleLedState);
	//ax12ReadPacket(6);  // get the response...


}
    11ac:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    11b0:	30316632 	eorscc	r6, r1, r2, lsr r6
    11b4:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    11b8:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}

//--------------------------------------------------------------------
//[SetRegOnAllServos] Function that is called to set the state of one
//  register in all of the servos, like Torque on...
//--------------------------------------------------------------------
void SetRegOnAllServos(u8 bReg, u8 bVal) {
    11bc:	50410063 	subpl	r0, r1, r3, rrx
    11c0:	6e692f50 	mcrvs	15, 3, r2, cr9, cr0, {2}
    11c4:	4d430063 	stclmi	0, cr0, [r3, #-396]
	 ax12write(bVal);

  }
  ax12write(0xff - (checksum % 256));
  setRX(0);*/
	 dxl_set_txpacket_id (BROADCAST_ID);
    11c8:	5f303335 	svcpl	0x00303335
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    11cc:	692f5748 	stmdbvs	pc!, {r3, r6, r8, r9, sl, ip, lr}
	dxl_set_txpacket_parameter(0,bReg);
    11d0:	0000636e 	andeq	r6, r0, lr, ror #6
    11d4:	69746f6d 	ldmdbvs	r4!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
	dxl_set_txpacket_parameter(1,2);
    11d8:	632e6e6f 	teqvs	lr, #1776	; 0x6f0
    11dc:	00000100 	andeq	r0, r0, r0, lsl #2
    11e0:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
    11e4:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
    11e8:	00000200 	andeq	r0, r0, r0, lsl #4
    11ec:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    11f0:	30316632 	eorscc	r6, r1, r2, lsr r6
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    11f4:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    11f8:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
    11fc:	00000300 	andeq	r0, r0, r0, lsl #6
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1200:	65707974 	ldrbvs	r7, [r0, #-2420]!
    1204:	73666564 	cmnvc	r6, #419430400	; 0x19000000
    1208:	0400682e 	streq	r6, [r0], #-2094
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    120c:	6f6d0000 	svcvs	0x006d0000
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1210:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
	 dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0,bReg);
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
    1214:	0400682e 	streq	r6, [r0], #-2094
    1218:	79640000 	stmdbvc	r4!, {}^
    121c:	696d616e 	stmdbvs	sp!, {r1, r2, r3, r5, r6, r8, sp, lr}^
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
	}

	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
    1220:	5f6c6578 	svcpl	0x006c6578
    1224:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    1228:	5f737365 	svcpl	0x00737365
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- SetRegOnAllServos ---\n");
#endif
	dxl_txrx_packet();
    122c:	6c626174 	stfvse	f6, [r2], #-464

	u16 CommStatus = dxl_get_result();
    1230:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
    1234:	00000500 	andeq	r0, r0, r0, lsl #10
		PrintErrorCode();
    1238:	72617375 	rsbvc	r7, r1, #-738197503	; 0xd4000001
	else
		PrintCommStatus(CommStatus);
    123c:	00682e74 	rsbeq	r2, r8, r4, ror lr
#endif
}
    1240:	00000005 	andeq	r0, r0, r5
    1244:	88020500 	stmdahi	r2, {r8, sl}
    1248:	03080045 	movweq	r0, #32837	; 0x8045
//--------------------------------------------------------------------
//[MakeSureServosAreOn] Function that is called to handle when you are
//  transistioning from servos all off to being on.  May need to read
//  in the current pose...
//--------------------------------------------------------------------
void MakeSureServosAreOn(void) {
    124c:	010107d8 	ldrdeq	r0, [r1, -r8]

	if (ServosEnabled) {

		if (!g_fServosFree)
    1250:	4a110368 	bmi	441ff8 <__Stack_Size+0x441bf8>
			return;    // we are not free

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {
    1254:	3d3d3d13 	ldccc	13, cr3, [sp, #-76]!
    1258:	4d300179 	ldfmis	f0, [r0, #-484]!

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
    125c:	3d211e22 	stccc	14, cr1, [r1, #-136]!
    1260:	3af53de7 	bcc	ffd50a04 <SCS_BASE+0x1fd42a04>
    1264:	03322c22 	teqeq	r2, #8704	; 0x2200
    1268:	0a033c78 	beq	d0450 <__Stack_Size+0xd0050>
						AXM_PRESENT_POSITION_L);
				mDelay(25);
    126c:	231d3f66 	tstcs	sp, #408	; 0x198
    1270:	322c222c 	eorcc	r2, ip, #-1073741822	; 0xc0000002

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
    1274:	7eef033d 	mcrvc	3, 7, r0, cr15, cr13, {1}
    1278:	03332008 	teqeq	r3, #8	; 0x8
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
						AXM_PRESENT_POSITION_L);
				mDelay(25);
			}
		} else {
			BioloidControllerEx_readPose();
    127c:	a603f216 	undefined
		}

		SetRegOnAllServos(AXM_TORQUE_ENABLE, 1);  // Use sync write to do it.
    1280:	1b17827f 	blne	5e1c84 <__Stack_Size+0x5e1884>
    1284:	09032520 	stmdbeq	r3, {r5, r8, sl, sp}

		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = false;
    1288:	22643058 	rsbcs	r3, r4, #88	; 0x58
	}

}
    128c:	275e2576 	undefined
    1290:	20207903 	eorcs	r7, r0, r3, lsl #18
    1294:	1f3d5b27 	svcne	0x003d5b27
    1298:	77306721 	ldrvc	r6, [r0, -r1, lsr #14]!
    129c:	03580903 	cmpeq	r8, #49152	; 0xc000

//------------------------------------------------------------------------------------------
//[BeginServoUpdate] Does whatever preperation that is needed to starrt a move of our servos
//------------------------------------------------------------------------------------------
void BeginServoUpdate(void)    // Start the update
		{
    12a0:	18034a6b 	stmdane	r3, {r0, r1, r3, r5, r6, r9, fp, lr}

	MakeSureServosAreOn();
    12a4:	7e92033c 	mrcvc	3, 4, r0, cr2, cr12, {1}
	if (ServosEnabled) {

		if (g_fAXSpeedControl) {
    12a8:	221e22ac 	andscs	r2, lr, #-1073741814	; 0xc000000a
    12ac:	4b31222c 	blmi	c49b64 <__Stack_Size+0xc49764>

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awCurAXPos[i] = g_awGoalAXPos[i];
    12b0:	1e30764b 	cfmsuba32ne	mvax2, mvax7, mvfx0, mvfx11
    12b4:	80413d21 	subhi	r3, r1, r1, lsr #26
    12b8:	3e740903 	cdpcc	9, 7, cr0, cr4, cr3, {0}
		if (g_fAXSpeedControl) {

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
    12bc:	5923223a 	stmdbpl	r3!, {r1, r3, r4, r5, r9, sp}
				g_awCurAXPos[i] = g_awGoalAXPos[i];
			}
#endif
		} else
			BioloidControllerEx_interpolateStep(true); // Make sure we call at least once
    12c0:	78033d08 	stmdavc	r3, {r3, r8, sl, fp, ip, sp}
    12c4:	7803284a 	stmdavc	r3, {r1, r3, r6, fp, sp}

	}
}
    12c8:	2e0c032e 	cdpcs	3, 0, cr0, cr12, cr14, {1}
    12cc:	032e7203 	teqeq	lr, #805306368	; 0x30000000
    12d0:	033d200e 	teqeq	sp, #14	; 0xe
    12d4:	0f032e71 	svceq	0x00032e71
}

//--------------------------------------------------------------------
//[FREE SERVOS] Frees all the servos
//--------------------------------------------------------------------
void FreeServos(void) {
    12d8:	2d4b3f20 	stclcs	15, cr3, [fp, #-128]
    12dc:	032f1f21 	teqeq	pc, #132	; 0x84

	if (!g_fServosFree) {
    12e0:	17032e6d 	strne	r2, [r3, -sp, ror #28]
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
    12e4:	01eb03f2 	strdeq	r0, [fp, #50]!
    12e8:	200a03d6 	ldrdcs	r0, [sl], -r6
    12ec:	032e7603 	teqeq	lr, #3145728	; 0x300000
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
			Relax(pgm_read_byte(&cPinTable[i]));
    12f0:	3423200a 	strtcc	r2, [r3], #-10
    12f4:	25207a03 	strcs	r7, [r0, #-2563]!
    12f8:	593d1f3d 	ldmdbpl	sp!, {r0, r2, r3, r4, r5, r8, r9, sl, fp, ip}

	if (!g_fServosFree) {
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
    12fc:	353f3662 	ldrcc	r3, [pc, #-1634]!	; ca2 <__Stack_Size+0x8a2>
			Relax(pgm_read_byte(&cPinTable[i]));
		}
		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = true;
    1300:	68303157 	ldmdavs	r0!, {r0, r1, r2, r4, r6, r8, ip, sp}
	}
}
    1304:	72033d31 	andvc	r3, r3, #3136	; 0xc40
    1308:	1503b72e 	strne	fp, [r3, #-1838]
    130c:	09034482 	stmdbeq	r3, {r1, r7, sl, lr}
extern void SetRegOnAllServos(u8 bReg, u8 bVal);

//--------------------------------------------------------------------
//Init
//--------------------------------------------------------------------
void Servo_Init(void) {
    1310:	241c2490 	ldrcs	r2, [ip], #-1168
	// First lets get the actual servo positions for all of our servos...
	//pinMode(0, OUTPUT);
	g_fServosFree = true;
    1314:	03302222 	teqeq	r0, #536870914	; 0x20000002

  poseSize = NUMSERVOS;
    1318:	245878f3 	ldrbcs	r7, [r8], #-2291
    131c:	5b242038 	blpl	909404 <__Stack_Size+0x909004>
  BioloidControllerEx_readPose();
    1320:	4a7a033d 	bmi	1e8201c <__Stack_Size+0x1e81c1c>
#ifdef cVoltagePin
	for (byte i=0; i < 8; i++)
	GetBatteryVoltage();  // init the voltage pin
#endif

	g_fAXSpeedControl = false;
    1324:	3c01fc03 	stccc	12, cr15, [r1], {3}
    1328:	78032898 	stmdavc	r3, {r3, r4, r7, fp, sp}



	// Added - try to speed things up later if we do a query...
	SetRegOnAllServos(AXM_RETURN_DELAY_TIME, 0); // tell servos to give us back their info as quick as they can...
    132c:	d8402820 	stmdale	r0, {r5, fp, sp}^
    1330:	302e1103 	eorcc	r1, lr, r3, lsl #2

}
    1334:	79353fd9 	ldmdbvc	r5!, {r0, r3, r4, r6, r7, r8, r9, sl, fp, ip, sp}
    1338:	2259251b 	subscs	r2, r9, #113246208	; 0x6c00000
    133c:	03595959 	cmpeq	r9, #1458176	; 0x164000
    1340:	0c032078 	stceq	0, cr2, [r3], {120}

}

void setupPhoenix() {

	g_fShowDebugPrompt = true;
    1344:	6785322e 	strvs	r3, [r5, lr, lsr #4]
void readSensors(){


}

void setupPhoenix() {
    1348:	2e0e0359 	mcrcs	3, 0, r0, cr14, cr9, {2}

	g_fShowDebugPrompt = true;
	g_fDebugOutput = false;
    134c:	30684cd8 	ldrdcc	r4, [r8], #-200
    1350:	342f4d3d 	strtcc	r4, [pc], #3389	; 1358 <__Stack_Size+0xf58>
	//init BioloidEx
	BioloidControllerEx();
    1354:	2f41303f 	svccs	0x0041303f

	// Init our ServoDriver
	Servo_Init();
    1358:	31845a4e 	orrcc	r5, r4, lr, asr #20

	mDelay(10);
    135c:	2132213e 	teqcs	r2, lr, lsr r1

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1360:	3d685a41 	fstmdbscc	r8!, {s11-s75}
    1364:	59311f21 	ldmdbpl	r1!, {r0, r5, r8, r9, sl, fp, ip}
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    1368:	41593e31 	cmpmi	r9, r1, lsr lr
    136c:	3e59334b 	cdpcc	3, 5, cr3, cr9, cr11, {2}
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1370:	221f213d 	andscs	r2, pc, #1073741839	; 0x4000000f

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1374:	51305969 	teqpl	r0, r9, ror #18
    1378:	4e4b934d 	cdpmi	3, 4, cr9, cr11, cr13, {2}
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    137c:	4b316940 	blmi	c5b884 <__Stack_Size+0xc5b484>
    1380:	343d5e3d 	ldrtcc	r5, [sp], #-3645
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1384:	a13fbd69 	teqge	pc, r9, ror #26
    1388:	84301e22 	ldrthi	r1, [r0], #-3618
    138c:	20780336 	rsbscs	r0, r8, r6, lsr r3
	Servo_Init();

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1390:	3d778552 	cfldr64cc	mvdx8, [r7, #-328]!
    1394:	4b304b2f 	blmi	c14058 <__Stack_Size+0xc13c58>
    1398:	683f242d 	ldmdavs	pc!, {r0, r2, r3, r5, sl, sp}

	ResetLegInitAngles();

	//Single leg control. Make sure no leg is selected
#ifdef OPT_SINGLELEG
	g_InControlState.SelectedLeg = 255; // No Leg selected
    139c:	221f213d 	andscs	r2, pc, #1073741839	; 0x4000000f
    13a0:	3d321f4b 	ldccc	15, cr1, [r2, #-300]!
	g_InControlState.PrevSelectedLeg = 255;
    13a4:	33211e22 	teqcc	r1, #544	; 0x220
#endif
	//Body Positions
	g_InControlState.BodyPos.x = 0;
    13a8:	362f2121 	strtcc	r2, [pc], -r1, lsr #2
	g_InControlState.BodyPos.y = 0;
	g_InControlState.BodyPos.z = 0;
    13ac:	002c022f 	eoreq	r0, ip, pc, lsr #4

//Body Rotations
	g_InControlState.BodyRot1.x = 0;
	g_InControlState.BodyRot1.y = 0;
    13b0:	00a20101 	adceq	r0, r2, r1, lsl #2
	g_InControlState.BodyRot1.z = 0;
	g_InControlState.BodyRotOffset.x = 0;
    13b4:	00020000 	andeq	r0, r2, r0
	g_InControlState.BodyRotOffset.y = 0; //Input Y offset value to adjust centerpoint of rotation
	g_InControlState.BodyRotOffset.z = 0;
    13b8:	0000009c 	muleq	r0, ip, r0

	//Gait
	g_InControlState.GaitType = 0;
    13bc:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
	g_InControlState.BalanceMode = 0;
    13c0:	0101000d 	tsteq	r1, sp
	g_InControlState.LegLiftHeight = 50;
	g_InControlState.ForceGaitStepCnt = 0; // added to try to adjust starting positions depending on height...
    13c4:	00000101 	andeq	r0, r0, r1, lsl #2
	g_InControlState.GaitStep = 1;
    13c8:	00000100 	andeq	r0, r0, r0, lsl #2
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    13cc:	2f3a6301 	svccs	0x003a6301
	g_InControlState.BodyRotOffset.z = 0;

	//Gait
	g_InControlState.GaitType = 0;
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
    13d0:	616e6977 	smcvs	59031
    13d4:	6c2f6d72 	stcvs	13, cr6, [pc], #-456
void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    13d8:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    13dc:	2e2f6363 	cdpcs	3, 2, cr6, cr15, cr3, {3}
    13e0:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
//==============================================================================

// If both PS2 and XBee are defined then we will become secondary to the xbee
void CommanderInputController_Init(void) {

	g_BodyYOffset = 0;
    13e4:	6d72612f 	ldfvse	f6, [r2, #-188]!
    13e8:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    13ec:	6e692f69 	cdpvs	15, 6, cr2, cr9, cr9, {3}
	g_BodyYShift = 0;
	//begin(XBEE_BAUD);
	GPSeq = 0;  // init to something...
    13f0:	64756c63 	ldrbtvs	r6, [r5], #-3171
    13f4:	74730065 	ldrbtvc	r0, [r3], #-101

	ControlMode = WALKMODE;
    13f8:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
	HeightSpeedMode = NORM_NORM;
    13fc:	5f783031 	svcpl	0x00783031
	//    DoubleHeightOn = false;
	DoubleTravelOn = false;
    1400:	2f62696c 	svccs	0x0062696c
	bJoystickWalkMode = 0;
    1404:	00636e69 	rsbeq	r6, r3, r9, ror #28
	GaitSelect();

	CommanderInputController_Init();

	// Servo Driver
	ServoMoveTime = 150;
    1408:	2f505041 	svccs	0x00505041
	g_InControlState.fRobotOn = 0;
    140c:	00636e69 	rsbeq	r6, r3, r9, ror #28
	g_fLowVoltageShutdown = false;
    1410:	2f505041 	svccs	0x00505041

}
    1414:	00637273 	rsbeq	r7, r3, r3, ror r2
    1418:	64747300 	ldrbtvs	r7, [r4], #-768
    141c:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    1420:	00010068 	andeq	r0, r1, r8, rrx
    1424:	6d747300 	ldclvs	3, cr7, [r4]
    1428:	31663233 	cmncc	r6, r3, lsr r2
    142c:	745f7830 	ldrbvc	r7, [pc], #2096	; 1434 <__Stack_Size+0x1034>
    1430:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
    1434:	00020068 	andeq	r0, r2, r8, rrx
    1438:	70797400 	rsbsvc	r7, r9, r0, lsl #8
    143c:	66656465 	strbtvs	r6, [r5], -r5, ror #8
    1440:	00682e73 	rsbeq	r2, r8, r3, ror lr
    1444:	67000003 	strvs	r0, [r0, -r3]
    1448:	61626f6c 	cmnvs	r2, ip, ror #30
    144c:	7461446c 	strbtvc	r4, [r1], #-1132
    1450:	00632e61 	rsbeq	r2, r3, r1, ror #28
    1454:	00000004 	andeq	r0, r0, r4
    1458:	000001d7 	ldrdeq	r0, [r0], -r7
    145c:	00b80002 	adcseq	r0, r8, r2
    1460:	01020000 	tsteq	r2, r0
    1464:	000d0efb 	strdeq	r0, [sp], -fp
//[CommitServoDriver Updates the positions of the servos - This outputs
//         as much of the command as we can without committing it.  This
//         allows us to once the previous update was completed to quickly
//        get the next command to start
//--------------------------------------------------------------------
void CommitServoDriver(word wMoveTime) {
    1468:	01010101 	tsteq	r1, r1, lsl #2
    146c:	01000000 	tsteq	r0, r0
    1470:	41010000 	tstmi	r1, r0


	CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1474:	732f5050 	teqvc	pc, #80	; 0x50

      }
      ax12write(0xff - (checksum % 256));
      setRX(0);
*/
  	    dxl_set_txpacket_id (BROADCAST_ID);
    1478:	63006372 	movwvs	r6, #882	; 0x372
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    147c:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
    1480:	6d72616e 	ldfvse	f6, [r2, #-440]!
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
    1484:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    1488:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
		dxl_set_txpacket_parameter(1, 2);
    148c:	2f2e2e2f 	svccs	0x002e2e2f
    1490:	612f2e2e 	teqvs	pc, lr, lsr #28
    1494:	652d6d72 	strvs	r6, [sp, #-3442]!
    1498:	2f696261 	svccs	0x00696261
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
			wSpeed = CalculateAX12MoveSpeed(g_awCurAXPos[i], g_awGoalAXPos[i], wMoveTime);    // What order should we store these values?
    149c:	6c636e69 	stclvs	14, cr6, [r3], #-420
    14a0:	00656475 	rsbeq	r6, r5, r5, ror r4
    14a4:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    14a8:	30316632 	eorscc	r6, r1, r2, lsr r6
			//dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
			byte id = pgm_read_byte(&cPinTable[i]);
			dxl_set_txpacket_parameter(2 + 3 * i, id);
    14ac:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    14b0:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
    14b4:	50410063 	subpl	r0, r1, r3, rrx
    14b8:	6e692f50 	mcrvs	15, 3, r2, cr9, cr0, {2}
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(g_awGoalAXPos[i]));
    14bc:	4d430063 	stclmi	0, cr0, [r3, #-396]
    14c0:	5f303335 	svcpl	0x00303335
    14c4:	692f5748 	stmdbvs	pc!, {r3, r6, r8, r9, sl, ip, lr}
    14c8:	0000636e 	andeq	r6, r0, lr, ror #6
    14cc:	65736f70 	ldrbvs	r6, [r3, #-3952]!
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
    14d0:	0100632e 	tsteq	r0, lr, lsr #6
    14d4:	74730000 	ldrbtvc	r0, [r3]
    14d8:	746e6964 	strbtvc	r6, [lr], #-2404
    14dc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    14e0:	74730000 	ldrbtvc	r0, [r3]
    14e4:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
    14e8:	5f783031 	svcpl	0x00783031
    14ec:	65707974 	ldrbvs	r7, [r0, #-2420]!
    14f0:	0300682e 	movweq	r6, #2094	; 0x82e
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
    14f4:	79740000 	ldmdbvc	r4!, {}^
    14f8:	65646570 	strbvs	r6, [r4, #-1392]!
    14fc:	682e7366 	stmdavs	lr!, {r1, r2, r5, r6, r8, r9, ip, sp, lr}
    1500:	00000400 	andeq	r0, r0, r0, lsl #8
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
		dxl_set_txpacket_parameter(1, 2);
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
    1504:	65736f70 	ldrbvs	r6, [r3, #-3952]!
    1508:	0400682e 	streq	r6, [r0], #-2094
    150c:	73750000 	cmnvc	r5, #0	; 0x0
    1510:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
		}

		dxl_set_txpacket_length((4 + 1) * poseSize + 4);
    1514:	00050068 	andeq	r0, r5, r8, rrx
    1518:	05000000 	streq	r0, [r0]
    151c:	004d1402 	subeq	r1, sp, r2, lsl #8
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- CommitServoDriver ---\n");
#endif
		dxl_txrx_packet();
    1520:	01980308 	orrseq	r0, r8, r8, lsl #6

			u16 CommStatus = dxl_get_result();
    1524:	68ae1801 	stmiavs	lr!, {r0, fp, ip}
#ifdef USING_PC_UART
			if (CommStatus == DXL_RXSUCCESS)
    1528:	0326303f 	teqeq	r6, #63	; 0x3f
				PrintErrorCode();
    152c:	0a032e7a 	beq	ccf1c <__Stack_Size+0xccb1c>
			else
				PrintCommStatus(CommStatus);
    1530:	2f4b2a20 	svccs	0x004b2a20
    1534:	3f21232d 	svccc	0x0021232d
#endif
#endif
		} else {
			BioloidControllerEx_interpolateSetup(wMoveTime);
    1538:	032e7503 	teqeq	lr, #12582912	; 0xc00000

	}

	CommanderInputController_AllowControllerInterrupts(true);

}
    153c:	d5032e0e 	strle	r2, [r3, #-3598]
    1540:	1e145800 	cdpne	8, 1, cr5, cr4, cr0, {0}
    1544:	03314922 	teqeq	r1, #557056	; 0x88000
    1548:	4c014a14 	stcmi	10, cr4, [r1], {20}
    154c:	4d4c014c 	stfmie	f0, [ip, #-304]
    1550:	144d2f13 	strbne	r2, [sp], #-3859
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    1554:	3603354f 	strcc	r3, [r3], -pc, asr #10
    1558:	3c4a032e 	mcrrcc	3, 2, r0, sl, cr14
    155c:	03203603 	teqeq	r0, #3145728	; 0x300000
    1560:	2d034a53 	fstscs	s8, [r3, #-332]
    1564:	2053032e 	subscs	r0, r3, lr, lsr #6


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1568:	033c2d03 	teqeq	ip, #192	; 0xc0
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    156c:	3f3d2053 	svccc	0x003d2053
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1570:	24229241 	strtcs	r9, [r2], #-577
    1574:	7caf2446 	cfstrsvc	mvf2, [pc], #280
    1578:	033c7803 	teqeq	ip, #196608	; 0x30000
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    157c:	1f832009 	svcne	0x00832009
    1580:	9f3e302d 	svcls	0x003e302d
    1584:	20090323 	andcs	r0, r9, r3, lsr #6


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1588:	032e7703 	teqeq	lr, #786432	; 0xc0000
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    158c:	21f42009 	mvnscs	r2, r9
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1590:	2f4b211f 	svccs	0x004b211f
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1594:	5847034b 	stmdapl	r7, {r0, r1, r3, r6, r8, r9}^
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    1598:	03203903 	teqeq	r0, #49152	; 0xc000

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
    159c:	3d032047 	stccc	0, cr2, [r3, #-284]
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    15a0:	03932320 	orrseq	r2, r3, #-2147483648	; 0x80000000
			g_awGoalAXPos[FIRSTTIBIAPIN + LegIndex] = wTibiaSDV;
    15a4:	58087f93 	stmdapl	r8, {r0, r1, r4, r7, r8, r9, sl, fp, ip, sp, lr}
    15a8:	3d203b13 	fstmdbxcc	r0!, {d3-d11}
    15ac:	3d5a3e21 	ldclcc	14, cr3, [sl, #-132]

#endif
		} else {
			BioloidControllerEx_setNextPose(
    15b0:	9e71033e 	mrcls	3, 3, r0, cr1, cr14, {1}
    15b4:	30212d21 	eorcc	r2, r1, r1, lsr #26
					pgm_read_byte(&cPinTable[FIRSTCOXAPIN + LegIndex]),
					wCoxaSDV);
			BioloidControllerEx_setNextPose(
    15b8:	2e7ead03 	cdpcs	13, 7, cr10, cr14, cr3, {0}
    15bc:	2010032e 	andscs	r0, r0, lr, lsr #6
    15c0:	032e7003 	teqeq	lr, #3	; 0x3
					pgm_read_byte(&cPinTable[FIRSTFEMURPIN + LegIndex]),
					wFemurSDV);
			BioloidControllerEx_setNextPose(
    15c4:	674b2e0f 	strbvs	r2, [fp, -pc, lsl #28]
    15c8:	032f522a 	teqeq	pc, #-1610612734	; 0xa0000002
					wTibiaSDV);

		}
	}
	CommanderInputController_AllowControllerInterrupts(true); // Ok for hserial again...
}
    15cc:	2a245860 	bcs	917754 <__Stack_Size+0x917354>
    15d0:	033f6524 	teqeq	pc, #150994944	; 0x9000000
    15d4:	422e5824 	eormi	r5, lr, #2359296	; 0x240000
    15d8:	2e0f033d 	mcrcs	3, 0, r0, cr15, cr13, {1}
    15dc:	03207103 	teqeq	r0, #-1073741824	; 0xc0000000

void StartUpdateServos() {
    15e0:	3e672e0f 	cdpcc	14, 6, cr2, cr7, cr15, {0}
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update
    15e4:	1d23302c 	stcne	0, cr3, [r3, #-176]!
    15e8:	513d4d23 	teqpl	sp, r3, lsr #26
    15ec:	2066034b 	rsbcs	r0, r6, fp, asr #6

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		OutputServoInfoForLeg(LegIndex,
    15f0:	86201a03 	strthi	r1, [r0], -r3, lsl #20
    15f4:	03586203 	cmpeq	r8, #805306368	; 0x30000000
    15f8:	2f033c24 	svccs	0x00033c24
    15fc:	231d234a 	tstcs	sp, #671088641	; 0x28000001
    1600:	3323207f 	teqcc	r3, #127	; 0x7f
    1604:	207a0321 	rsbscs	r0, sl, r1, lsr #6
    1608:	343a2f25 	ldrtcc	r2, [sl], #-3877
    160c:	326c5d41 	rsbcc	r5, ip, #4160	; 0x1040
    1610:	20790335 	rsbscs	r0, r9, r5, lsr r3
    1614:	59225927 	stmdbpl	r2!, {r0, r1, r2, r5, r8, fp, ip, lr}
    1618:	03747a03 	cmneq	r4, #12288	; 0x3000
    161c:	6e034a12 	mcrvs	10, 0, r4, cr3, cr2, {0}
    1620:	20120320 	andscs	r0, r2, r0, lsr #6
    1624:	2230323b 	eorscs	r3, r0, #-1342177277	; 0xb0000003
    1628:	1e221608 	cfmadda32ne	mvax0, mvax1, mvfx2, mvfx8
    162c:	04025922 	streq	r5, [r2], #-2338
    1630:	0c010100 	stfeqs	f0, [r1], {0}
    1634:	02000001 	andeq	r0, r0, #1	; 0x1
    1638:	0000ae00 	andeq	sl, r0, r0, lsl #28
    163c:	fb010200 	blx	41e46 <__Stack_Size+0x41a46>
    1640:	01000d0e 	tsteq	r0, lr, lsl #26
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1644:	00010101 	andeq	r0, r1, r1, lsl #2
				cTibiaInv[LegIndex] ?
						-TibiaAngle1[LegIndex] : TibiaAngle1[LegIndex]);

	}

}
    1648:	00010000 	andeq	r0, r1, r0
    164c:	50410100 	subpl	r0, r1, r0, lsl #2
    1650:	72732f50 	rsbsvc	r2, r3, #320	; 0x140
    1654:	3a630063 	bcc	18c17e8 <__Stack_Size+0x18c13e8>
    1658:	6e69772f 	cdpvs	7, 6, cr7, cr9, cr15, {1}
    165c:	2f6d7261 	svccs	0x006d7261
    1660:	2f62696c 	svccs	0x0062696c
#else
word g_wLastVoltage = 0xffff;    // save the last voltage we retrieved...
byte g_bLegVoltage = 0;		// what leg did we last check?
unsigned long g_ulTimeLastBatteryVoltage;
#define VOLTAGE_REPEAT_MAX  3
word GetBatteryVoltage(void) {
    1664:	2f636367 	svccs	0x00636367
	if (interpolating && (g_wLastVoltage != 0xffff)
    1668:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    166c:	72612f2e 	rsbvc	r2, r1, #184	; 0xb8
    1670:	61652d6d 	cmnvs	r5, sp, ror #26
    1674:	692f6962 	stmdbvs	pc!, {r1, r5, r6, r8, fp, sp, lr}
    1678:	756c636e 	strbvc	r6, [ip, #-878]!
    167c:	73006564 	movwvc	r6, #1380	; 0x564
    1680:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    1684:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
			&& ((getMillis() - g_ulTimeLastBatteryVoltage)
					< VOLTAGE_MAX_TIME_BETWEEN_CALLS))
		return g_wLastVoltage;
    1688:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
    168c:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    1690:	50504100 	subspl	r4, r0, r0, lsl #2
    1694:	636e692f 	cmnvs	lr, #770048	; 0xbc000
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    1698:	354d4300 	strbcc	r4, [sp, #-768]
			g_wLastVoltage = wVoltage * 10;
    169c:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    16a0:	6e692f57 	mcrvs	15, 3, r2, cr9, cr7, {2}
			g_wLastVoltage = wVoltage * 10;
    16a4:	77000063 	strvc	r0, [r0, -r3, rrx]
		}
	} while (--bLoopCnt);

	return 0;

}
    16a8:	2e6b6c61 	cdpcs	12, 6, cr6, cr11, cr1, {3}
    16ac:	00010063 	andeq	r0, r1, r3, rrx
    16b0:	64747300 	ldrbtvs	r7, [r4], #-768
    16b4:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
// ReadMsgs
//==============================================================================

/* process messages coming from Commander
 *  format = 0xFF RIGHT_H RIGHT_V LEFT_H LEFT_V BUTTONS EXT CHECKSUM */
int Commander_ReadMsgs() {
    16b8:	00020068 	andeq	r0, r2, r8, rrx
	 }
	 #endif
	 */
	//while (CheckZBNewArrive() > 0) {
	while (1) {
		if (zgb_rx_check_arduino() == 1) {
    16bc:	6d747300 	ldclvs	3, cr7, [r4]
    16c0:	31663233 	cmncc	r6, r3, lsr r2

			leftV = (signed char) (zgb_rx_data_right_V_());
    16c4:	745f7830 	ldrbvc	r7, [pc], #2096	; 16cc <__Stack_Size+0x12cc>
    16c8:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
			leftH = (signed char) (zgb_rx_data_right_H_());
    16cc:	00030068 	andeq	r0, r3, r8, rrx
    16d0:	70797400 	rsbsvc	r7, r9, r0, lsl #8
			rightV = (signed char) (zgb_rx_data_left_V_());
    16d4:	66656465 	strbtvs	r6, [r5], -r5, ror #8
    16d8:	00682e73 	rsbeq	r2, r8, r3, ror lr
			rightH = (signed char) (zgb_rx_data_left_H_());
    16dc:	75000004 	strvc	r0, [r0, #-4]
    16e0:	74726173 	ldrbtvc	r6, [r2], #-371
			buttons = zgb_rx_data_buttons();
    16e4:	0500682e 	streq	r6, [r0, #-2094]
    16e8:	00000000 	andeq	r0, r0, r0
			ext = zgb_rx_data_extra();
    16ec:	51180205 	tstpl	r8, r5, lsl #4
    16f0:	c0030800 	andgt	r0, r3, r0, lsl #16

	}

	return 0;

}
    16f4:	2f140100 	svccs	0x00140100
    16f8:	0331014f 	teqeq	r1, #-1073741805	; 0xc0000013
    16fc:	97144a0a 	ldrls	r4, [r4, -sl, lsl #20]
    1700:	4d32c0a1 	ldcmi	0, cr12, [r2, #-644]!
    1704:	508532c0 	addpl	r3, r5, r0, asr #5
    1708:	2f508532 	svccs	0x00508532
    170c:	32c06934 	sbccc	r6, r0, #851968	; 0xd0000
    1710:	3f2fc04d 	svccc	0x002fc04d

//==============================================================================
// This is The main code to input function to read inputs from the Commander and then
//process any commands.
//==============================================================================
void CommanderInputController_ControlInput(void) {
    1714:	85325085 	ldrhi	r5, [r2, #-133]!

	// See if we have a new command available...
	if (Commander_ReadMsgs() > 0) {
    1718:	26592f50 	usubaddxcs	r2, r9, r0
    171c:	14820903 	strne	r0, [r2], #2307
    1720:	2d3d6a41 	fldmdbscs	sp!, {s12-s76}
    1724:	3c090321 	stccc	3, cr0, [r9], {33}
		// If we receive a valid message than turn robot on...
		boolean fAdjustLegPositions = false;
		short sLegInitXZAdjust = 0;
		short sLegInitAngleAdjust = 0;

		if (!g_InControlState.fRobotOn) {
    1728:	1f3d4e41 	svcne	0x003d4e41
    172c:	03283d21 	teqeq	r8, #2112	; 0x840
			g_InControlState.fRobotOn = true;
    1730:	21827eb0 	strhcs	r7, [r2, r0]
    1734:	3d32211f 	ldfccs	f2, [r2, #-124]!
		}

		// [SWITCH MODES]

		// Cycle through modes...
		if ((buttons & BUT_LT) && !(buttonsPrev & BUT_LT)) {
    1738:	3d231c24 	stccc	12, cr1, [r3, #-144]!
    173c:	0b025931 	bleq	97c08 <__Stack_Size+0x97808>
    1740:	df010100 	svcle	0x00010100
    1744:	02000000 	andeq	r0, r0, #0	; 0x0
    1748:	00008900 	andeq	r8, r0, r0, lsl #18
    174c:	fb010200 	blx	41f56 <__Stack_Size+0x41b56>

			if (++ControlMode >= MODECNT) {
    1750:	01000d0e 	tsteq	r0, lr, lsl #26
    1754:	00010101 	andeq	r0, r1, r1, lsl #2
    1758:	00010000 	andeq	r0, r1, r0
    175c:	4d430100 	stfmie	f0, [r3]
				ControlMode = WALKMODE;    // cycled back around...
				Buzzed(50, 2000);
    1760:	5f303335 	svcpl	0x00303335
    1764:	732f5748 	teqvc	pc, #18874368	; 0x1200000
    1768:	73006372 	movwvc	r6, #882	; 0x372
				Buzzed(50, 3000);
    176c:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    1770:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}

			} else {
				Buzzed(50, 2000);
    1774:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    1778:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    177c:	354d4300 	strbcc	r4, [sp, #-768]
			}
			if (ControlMode != SINGLELEGMODE)
    1780:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
    1784:	6e692f57 	mcrvs	15, 3, r2, cr9, cr7, {2}
				g_InControlState.SelectedLeg = 255;
    1788:	61000063 	tstvs	r0, r3, rrx
    178c:	632e6364 	teqvs	lr, #-1879048191	; 0x90000001
    1790:	00000100 	andeq	r0, r0, r0, lsl #2

		}

		//[Common functions]
		//Switch Balance mode on/off
		if ((buttons & BUT_L4) && !(buttonsPrev & BUT_L4)) {
    1794:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    1798:	30316632 	eorscc	r6, r1, r2, lsr r6
    179c:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    17a0:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
    17a4:	00000200 	andeq	r0, r0, r0, lsl #4
    17a8:	336d7473 	cmncc	sp, #1929379840	; 0x73000000

			g_InControlState.BalanceMode = !g_InControlState.BalanceMode;
    17ac:	30316632 	eorscc	r6, r1, r2, lsr r6
    17b0:	616d5f78 	smcvs	54776
    17b4:	00682e70 	rsbeq	r2, r8, r0, ror lr
    17b8:	61000002 	tstvs	r0, r2
    17bc:	682e6364 	stmdavs	lr!, {r2, r5, r6, r8, r9, sp, lr}
			if (g_InControlState.BalanceMode) {
    17c0:	00000300 	andeq	r0, r0, r0, lsl #6
				Buzzed(250, 1500);
    17c4:	74737973 	ldrbtvc	r7, [r3], #-2419
    17c8:	695f6d65 	ldmdbvs	pc, {r0, r2, r5, r6, r8, sl, fp, sp, lr}^
			} else {
				Buzzed(100, 2000);
    17cc:	2e74696e 	cdpcs	9, 7, cr6, cr4, cr14, {3}
    17d0:	00030068 	andeq	r0, r3, r8, rrx
				Buzzed(50, 4000);
    17d4:	05000000 	streq	r0, [r0]
    17d8:	00530c02 	subseq	r0, r3, r2, lsl #24
    17dc:	011c0308 	tsteq	ip, r8, lsl #6
			}
		}

		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
    17e0:	6776214b 	ldrbvs	r2, [r6, -fp, asr #2]!
    17e4:	03a0214e 	moveq	r2, #-2147483629	; 0x80000013
    17e8:	4ba05812 	blmi	fe817838 <SCS_BASE+0x1e809838>
    17ec:	a0581103 	subsge	r1, r8, r3, lsl #2
    17f0:	223e4c4b 	eorscs	r4, lr, #19200	; 0x4b00
    17f4:	4b323d4b 	blmi	c90d28 <__Stack_Size+0xc90928>
			if (g_BodyYOffset > 0)
    17f8:	685c5b3d 	ldmdavs	ip, {r0, r2, r3, r4, r5, r8, r9, fp, ip, lr}^
    17fc:	3f3d4b3d 	svccc	0x003d4b3d
				g_BodyYOffset = 0;
    1800:	415a231d 	cmpmi	sl, sp, lsl r3
    1804:	21821303 	orrcs	r1, r2, r3, lsl #6
			else
				g_BodyYOffset = 35;
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1808:	4b36211f 	blmi	d89c8c <__Stack_Size+0xd8988c>
		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
			if (g_BodyYOffset > 0)
				g_BodyYOffset = 0;
			else
				g_BodyYOffset = 35;
    180c:	6e596759 	mrcvs	7, 2, r6, cr9, cr9, {2}
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1810:	233c5b03 	teqcs	ip, #3072	; 0xc00
    1814:	2f231c2f 	svccs	0x00231c2f

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1818:	3d4c2f1f 	stclcc	15, cr2, [ip, #-124]
		int ly = leftV;
		if (buttons & BUT_L6) {
    181c:	3d221e3e 	stccc	14, cr1, [r2, #-248]!

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1820:	0002024d 	andeq	r0, r2, sp, asr #4
    1824:	00a80101 	adceq	r0, r8, r1, lsl #2
		int ly = leftV;
    1828:	00020000 	andeq	r0, r2, r0
    182c:	0000008f 	andeq	r0, r0, pc, lsl #1
		if (buttons & BUT_L6) {
    1830:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    1834:	0101000d 	tsteq	r1, sp
			// raise or lower the robot on the joystick up /down
			// Maybe should have Min/Max
			int delta = rightV / 25;
    1838:	00000101 	andeq	r0, r0, r1, lsl #2
    183c:	00000100 	andeq	r0, r0, r0, lsl #2
    1840:	354d4301 	strbcc	r4, [sp, #-769]
    1844:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
    1848:	72732f57 	rsbsvc	r2, r3, #348	; 0x15c
    184c:	74730063 	ldrbtvc	r0, [r3], #-99
			if (delta) {
    1850:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
    1854:	5f783031 	svcpl	0x00783031
    1858:	2f62696c 	svccs	0x0062696c
    185c:	00636e69 	rsbeq	r6, r3, r9, ror #28
    1860:	33354d43 	teqcc	r5, #4288	; 0x10c0
    1864:	57485f30 	smlaldxpl	r5, r8, r0, pc
    1868:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    186c:	75620000 	strbvc	r0, [r2]!
    1870:	6e6f7474 	mcrvs	4, 3, r7, cr15, cr4, {3}
    1874:	0100632e 	tsteq	r0, lr, lsr #6
			sLegInitAngleAdjust = ly / 8;
			lx = 0;
			ly = 0;

			// Likewise for Speed control
			delta = rightH / 16;   //
    1878:	74730000 	ldrbtvc	r0, [r3]
    187c:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1880:	5f783031 	svcpl	0x00783031
    1884:	65707974 	ldrbvs	r7, [r0, #-2420]!
    1888:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
			if ((delta < 0) && g_InControlState.SpeedControl) {
    188c:	74730000 	ldrbtvc	r0, [r3]
    1890:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1894:	5f783031 	svcpl	0x00783031
				if ((word)(-delta) < g_InControlState.SpeedControl)
    1898:	2e70616d 	rpwcssz	f6, f0, #5.0
					g_InControlState.SpeedControl += delta;
    189c:	00020068 	andeq	r0, r2, r8, rrx
				else
					g_InControlState.SpeedControl = 0;
    18a0:	74756200 	ldrbtvc	r6, [r5], #-512
    18a4:	2e6e6f74 	mcrcs	15, 3, r6, cr14, cr4, {3}

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
    18a8:	00030068 	andeq	r0, r3, r8, rrx
    18ac:	73797300 	cmnvc	r9, #0	; 0x0
    18b0:	5f6d6574 	svcpl	0x006d6574
				g_InControlState.SpeedControl += delta;
				if (g_InControlState.SpeedControl > 2000)
    18b4:	74696e69 	strbtvc	r6, [r9], #-3689
					g_InControlState.SpeedControl = 0;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
				g_InControlState.SpeedControl += delta;
    18b8:	0300682e 	movweq	r6, #2094	; 0x82e
				if (g_InControlState.SpeedControl > 2000)
					g_InControlState.SpeedControl = 2000;
    18bc:	00000000 	andeq	r0, r0, r0
    18c0:	54ac0205 	strtpl	r0, [ip], #517

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
    18c4:	10030800 	andne	r0, r3, r0, lsl #16
    18c8:	211f2101 	tstcs	pc, r1, lsl #2
    18cc:	000402af 	andeq	r0, r4, pc, lsr #5
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18d0:	00a20101 	adceq	r0, r2, r1, lsl #2
    18d4:	00020000 	andeq	r0, r2, r0
    18d8:	00000089 	andeq	r0, r0, r9, lsl #1
    18dc:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
			sLegInitAngleAdjust = ly / 8;
    18e0:	0101000d 	tsteq	r1, sp
    18e4:	00000101 	andeq	r0, r0, r1, lsl #2
    18e8:	00000100 	andeq	r0, r0, r0, lsl #2
    18ec:	354d4301 	strbcc	r4, [sp, #-769]
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f0:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18f4:	72732f57 	rsbsvc	r2, r3, #348	; 0x15c
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f8:	74730063 	ldrbtvc	r0, [r3], #-99
		}

		//[Walk functions]
		if (ControlMode == WALKMODE) {
    18fc:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1900:	5f783031 	svcpl	0x00783031
    1904:	2f62696c 	svccs	0x0062696c

			//Switch gates
			if (((buttons & BUT_R1) && !(buttonsPrev & BUT_R1))
    1908:	00636e69 	rsbeq	r6, r3, r9, ror #28
    190c:	33354d43 	teqcc	r5, #4288	; 0x10c0
    1910:	57485f30 	smlaldxpl	r5, r8, r0, pc
    1914:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    1918:	656c0000 	strbvs	r0, [ip]!
    191c:	00632e64 	rsbeq	r2, r3, r4, ror #28
    1920:	73000001 	movwvc	r0, #1	; 0x1
    1924:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    1928:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    192c:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    1930:	00682e65 	rsbeq	r2, r8, r5, ror #28
    1934:	73000002 	movwvc	r0, #2	; 0x2
    1938:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    193c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    1940:	70616d5f 	rsbvc	r6, r1, pc, asr sp
    1944:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1948:	656c0000 	strbvs	r0, [ip]!
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    194c:	00682e64 	rsbeq	r2, r8, r4, ror #28
    1950:	73000003 	movwvc	r0, #3	; 0x3
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1954:	65747379 	ldrbvs	r7, [r4, #-889]!
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    1958:	6e695f6d 	cdpvs	15, 6, cr5, cr9, cr13, {3}
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
					Buzzed(50, 2000);
    195c:	682e7469 	stmdavs	lr!, {r0, r3, r5, r6, sl, ip, sp, lr}
    1960:	00000300 	andeq	r0, r0, r0, lsl #6
    1964:	02050000 	andeq	r0, r5, #0	; 0x0
				} else {
					Buzzed(50, 2000);
    1968:	080054d0 	stmdaeq	r0, {r4, r6, r7, sl, ip, lr}
    196c:	4b011203 	blmi	46180 <__Stack_Size+0x45d80>
    1970:	02677621 	rsbeq	r7, r7, #34603008	; 0x2100000
					Buzzed(50, 2250);
    1974:	01010004 	tsteq	r1, r4
    1978:	000000ae 	andeq	r0, r0, lr, lsr #1
					g_InControlState.GaitType = 0;
    197c:	00890002 	addeq	r0, r9, r2
    1980:	01020000 	tsteq	r2, r0
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    1984:	000d0efb 	strdeq	r0, [sp], -fp
    1988:	01010101 	tsteq	r1, r1, lsl #2
    198c:	01000000 	tsteq	r0, r0

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    1990:	43010000 	movwmi	r0, #4096	; 0x1000
    1994:	3033354d 	eorscc	r3, r3, sp, asr #10
    1998:	2f57485f 	svccs	0x0057485f
    199c:	00637273 	rsbeq	r7, r3, r3, ror r2
    19a0:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
				}
				GaitSelect();
			}

			//Double leg lift height
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    19a4:	30316632 	eorscc	r6, r1, r2, lsr r6
    19a8:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    19ac:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
    19b0:	4d430063 	stclmi	0, cr0, [r3, #-396]
    19b4:	5f303335 	svcpl	0x00303335
				Buzzed(50, 2000);
    19b8:	692f5748 	stmdbvs	pc!, {r3, r6, r8, r9, sl, ip, lr}
    19bc:	0000636e 	andeq	r6, r0, lr, ror #6
				HeightSpeedMode = (HeightSpeedMode + 1) & 0x3; // wrap around mode
    19c0:	2e63696d 	cdpcs	9, 6, cr6, cr3, cr13, {3}
    19c4:	00010063 	andeq	r0, r1, r3, rrx
    19c8:	6d747300 	ldclvs	3, cr7, [r4]
    19cc:	31663233 	cmncc	r6, r3, lsr r2
				DoubleTravelOn = HeightSpeedMode & 0x1;
    19d0:	745f7830 	ldrbvc	r7, [pc], #2096	; 19d8 <__Stack_Size+0x15d8>
    19d4:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
				if (HeightSpeedMode & 0x2)
    19d8:	00020068 	andeq	r0, r2, r8, rrx
    19dc:	6d747300 	ldclvs	3, cr7, [r4]
					g_InControlState.LegLiftHeight = 80;
    19e0:	31663233 	cmncc	r6, r3, lsr r2
    19e4:	6d5f7830 	ldclvs	8, cr7, [pc, #-192]
				else
					g_InControlState.LegLiftHeight = 50;
			}

			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {
    19e8:	682e7061 	stmdavs	lr!, {r0, r5, r6, ip, sp, lr}
    19ec:	00000200 	andeq	r0, r0, r0, lsl #4
    19f0:	2e63696d 	cdpcs	9, 6, cr6, cr3, cr13, {3}
    19f4:	00030068 	andeq	r0, r3, r8, rrx
    19f8:	73797300 	cmnvc	r9, #0	; 0x0

				if ((++bJoystickWalkMode) > 1)
    19fc:	5f6d6574 	svcpl	0x006d6574
    1a00:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
    1a04:	0300682e 	movweq	r6, #2094	; 0x82e

					bJoystickWalkMode = 0;
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a08:	00000000 	andeq	r0, r0, r0
			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {

				if ((++bJoystickWalkMode) > 1)

					bJoystickWalkMode = 0;
    1a0c:	54fc0205 	ldrbtpl	r0, [ip], #517
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a10:	0d030800 	stceq	8, cr0, [r3]
    1a14:	10032e01 	andne	r2, r3, r1, lsl #28
    1a18:	4b3e1f20 	blmi	f896a0 <__Stack_Size+0xf892a0>
    1a1c:	42384b3d 	eorsmi	r4, r8, #62464	; 0xf400
			}

			//Walking
			switch (bJoystickWalkMode) {
    1a20:	211f2169 	tstcs	pc, r9, ror #2
    1a24:	0002022f 	andeq	r0, r2, pc, lsr #4
    1a28:	01000101 	tsteq	r0, r1, lsl #2
			case 0:
				g_InControlState.TravelLength.x = -lx;
    1a2c:	00020000 	andeq	r0, r2, r0
    1a30:	0000006d 	andeq	r0, r0, sp, rrx
    1a34:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
				g_InControlState.TravelLength.z = -ly;
    1a38:	0101000d 	tsteq	r1, sp
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
				break;
			case 1:
				g_InControlState.TravelLength.z = (rightV); //Right Stick Up/Down
    1a3c:	00000101 	andeq	r0, r0, r1, lsl #2
    1a40:	00000100 	andeq	r0, r0, r0, lsl #2
    1a44:	354d4301 	strbcc	r4, [sp, #-769]
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
    1a48:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
    1a4c:	72732f57 	rsbsvc	r2, r3, #348	; 0x15c
    1a50:	74730063 	ldrbtvc	r0, [r3], #-99
    1a54:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1a58:	5f783031 	svcpl	0x00783031
    1a5c:	2f62696c 	svccs	0x0062696c
				break;

			}

			if (!DoubleTravelOn) {  //(Double travel length)
    1a60:	00636e69 	rsbeq	r6, r3, r9, ror #28
				g_InControlState.TravelLength.x =
    1a64:	33354d43 	teqcc	r5, #4288	; 0x10c0
    1a68:	57485f30 	smlaldxpl	r5, r8, r0, pc
    1a6c:	636e692f 	cmnvs	lr, #770048	; 0xbc000
						g_InControlState.TravelLength.x / 2;
				g_InControlState.TravelLength.z =
    1a70:	79730000 	ldmdbvc	r3!, {}^
    1a74:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    1a78:	6e75665f 	mrcvs	6, 3, r6, cr5, cr15, {2}
			}

		}

		//[Translate functions]
		g_BodyYShift = 0;
    1a7c:	00632e63 	rsbeq	r2, r3, r3, ror #28
    1a80:	73000001 	movwvc	r0, #1	; 0x1
		if (ControlMode == TRANSLATEMODE) {
    1a84:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    1a88:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
    1a8c:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    1a90:	00682e65 	rsbeq	r2, r8, r5, ror #28
    1a94:	6c000002 	stcvs	0, cr0, [r0], {2}
    1a98:	682e6465 	stmdavs	lr!, {r0, r2, r5, r6, sl, sp, lr}
    1a9c:	00000300 	andeq	r0, r0, r0, lsl #6
    1aa0:	02050000 	andeq	r0, r5, #0	; 0x0
    1aa4:	08005548 	stmdaeq	r0, {r3, r6, r8, sl, ip, lr}
    1aa8:	13012d03 	movwne	r2, #7427	; 0x1d03
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1aac:	580d033d 	stmdapl	sp, {r0, r2, r3, r4, r5, r8, r9}
    1ab0:	25335a3d 	ldrcs	r5, [r3, #-2621]!
    1ab4:	033e251b 	teqeq	lr, #113246208	; 0x6c00000
    1ab8:	4921825d 	stmdbmi	r1!, {r0, r2, r3, r4, r6, r9, pc}
    1abc:	3c033d21 	stccc	13, cr3, [r3], {33}
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac0:	603d133c 	eorsvs	r1, sp, ip, lsr r3
		//[Translate functions]
		g_BodyYShift = 0;
		if (ControlMode == TRANSLATEMODE) {

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1ac4:	135b325d 	cmpne	fp, #-805306363	; 0xd0000005
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac8:	580e033d 	stmdapl	lr, {r0, r2, r3, r4, r5, r8, r9}
    1acc:	32335a3d 	eorscc	r5, r3, #249856	; 0x3d000
    1ad0:	033d1385 	teqeq	sp, #335544322	; 0x14000002
    1ad4:	5a3d580e 	bpl	f57b14 <__Stack_Size+0xf57714>


			//      g_InControlState.BodyPos.x = (lx)/2;
			//      g_InControlState.BodyPos.z = -(ly)/3;
			//      g_InControlState.BodyRot1.y = (rightH)*2;
			g_BodyYShift = (-(rightV) / 2);
    1ad8:	15853233 	strne	r3, [r5, #563]
    1adc:	66120367 	ldrvs	r0, [r2], -r7, ror #6
    1ae0:	144d4b14 	strbne	r4, [sp], #-2836
    1ae4:	4b3f221e 	blmi	fca364 <__Stack_Size+0xfc9f64>
    1ae8:	5c3d2f4b 	ldcpl	15, cr2, [sp], #-300
    1aec:	3e4e424b 	cdpcc	2, 4, cr4, cr14, cr11, {2}
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
    1af0:	214b2f59 	cmpcs	fp, r9, asr pc
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1af4:	4b4e2f1f 	blmi	138d778 <__Stack_Size+0x138d378>
    1af8:	5c3d2f4b 	ldcpl	15, cr2, [sp], #-300
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1afc:	3d2f4b4b 	fstmdbxcc	pc!, {d4-d40}
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1b00:	2f4b4b5c 	svccs	0x004b4b5c
			g_BodyYShift = (-(rightV) / 2);
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
    1b04:	5816033d 	ldmdapl	r6, {r0, r2, r3, r4, r5, r8, r9}
			g_InControlState.BodyRot1.y = (rightH) * 2;
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1b08:	f27eac03 	undefined instruction 0xf27eac03
    1b0c:	2f211f21 	svccs	0x00211f21
    1b10:	4a0a0360 	bmi	282898 <__Stack_Size+0x282498>
    1b14:	25207603 	strcs	r7, [r0, #-1539]!
    1b18:	2f251b25 	svccs	0x00251b25
		}

		//[Single leg functions]
#ifdef OPT_SINGLELEG
		if (ControlMode == SINGLELEGMODE) {
    1b1c:	7400de03 	strvc	sp, [r0], #-3587

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
    1b20:	21211f21 	teqcs	r1, r1, lsr #30
    1b24:	682f2131 	stmdavs	pc!, {r0, r4, r5, r8, sp}
    1b28:	000602ca 	andeq	r0, r6, sl, asr #5
    1b2c:	01ed0101 	mvneq	r0, r1, lsl #2
    1b30:	00020000 	andeq	r0, r2, r0
				Buzzed(50,2000);
    1b34:	000000ce 	andeq	r0, r0, lr, asr #1
    1b38:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    1b3c:	0101000d 	tsteq	r1, sp
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b40:	00000101 	andeq	r0, r0, r1, lsl #2
    1b44:	00000100 	andeq	r0, r0, r0, lsl #2
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
				} else {
					g_InControlState.SelectedLeg = 0;
    1b48:	354d4301 	strbcc	r4, [sp, #-769]
		if (ControlMode == SINGLELEGMODE) {

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
				Buzzed(50,2000);
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b4c:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
    1b50:	72732f57 	rsbsvc	r2, r3, #348	; 0x15c
			   g_InControlState.SLLeg.x= (signed char)((int)((int)lx+128)/2); //Left Stick Right/Left
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
    1b54:	74730063 	ldrbtvc	r0, [r3], #-99
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b58:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1b5c:	5f783031 	svcpl	0x00783031
    1b60:	2f62696c 	svccs	0x0062696c
    1b64:	00636e69 	rsbeq	r6, r3, r9, ror #28
    1b68:	33354d43 	teqcc	r5, #4288	; 0x10c0
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b6c:	57485f30 	smlaldxpl	r5, r8, r0, pc
    1b70:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    1b74:	79730000 	ldmdbvc	r3!, {}^
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b78:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b7c:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    1b80:	00632e74 	rsbeq	r2, r3, r4, ror lr
    1b84:	73000001 	movwvc	r0, #1	; 0x1
				Buzzed(50,2000);
    1b88:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    1b8c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
				g_InControlState.fSLHold = !g_InControlState.fSLHold;
    1b90:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    1b94:	00682e65 	rsbeq	r2, r8, r5, ror #28
    1b98:	73000002 	movwvc	r0, #2	; 0x2
    1b9c:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
			}
		}
#endif

		//Calculate walking time delay
		g_InControlState.InputTimeDelay = 128- max(max(abs(lx), abs(ly)), abs(rightH));
    1ba0:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    1ba4:	70616d5f 	rsbvc	r6, r1, pc, asr sp
    1ba8:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    1bac:	74730000 	ldrbtvc	r0, [r3]
    1bb0:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1bb4:	5f783031 	svcpl	0x00783031
    1bb8:	6f697067 	svcvs	0x00697067
    1bbc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    1bc0:	74730000 	ldrbtvc	r0, [r3]
    1bc4:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1bc8:	5f783031 	svcpl	0x00783031
    1bcc:	6369766e 	cmnvs	r9, #115343360	; 0x6e00000
    1bd0:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000

		//Calculate g_InControlState.BodyPos.y
		g_InControlState.BodyPos.y = max(g_BodyYOffset + g_BodyYShift, 0);
    1bd4:	74730000 	ldrbtvc	r0, [r3]
    1bd8:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1bdc:	5f783031 	svcpl	0x00783031
    1be0:	2e636461 	cdpcs	4, 6, cr6, cr3, cr1, {3}
    1be4:	00020068 	andeq	r0, r2, r8, rrx
    1be8:	61737500 	cmnvs	r3, r0, lsl #10

		if (sLegInitXZAdjust || sLegInitAngleAdjust) {
    1bec:	682e7472 	stmdavs	lr!, {r1, r4, r5, r6, sl, ip, sp, lr}
    1bf0:	00000300 	andeq	r0, r0, r0, lsl #6
			// User asked for manual leg adjustment - only do when we have finished any previous adjustment

			if (!g_InControlState.ForceGaitStepCnt) {
    1bf4:	74737973 	ldrbtvc	r7, [r3], #-2419
				if (sLegInitXZAdjust)
    1bf8:	665f6d65 	ldrbvs	r6, [pc], -r5, ror #26
					g_fDynamicLegXZLength = true;
    1bfc:	2e636e75 	mcrcs	14, 3, r6, cr3, cr5, {3}
    1c00:	00030068 	andeq	r0, r3, r8, rrx

				sLegInitXZAdjust += GetLegsXZLength(); // Add on current length to our adjustment...
    1c04:	05000000 	streq	r0, [r0]
    1c08:	0057d802 	subseq	sp, r7, r2, lsl #16
				// Handle maybe change angles...
				if (sLegInitAngleAdjust)
					RotateLegInitAngles(sLegInitAngleAdjust);

				// Give system time to process previous calls
				AdjustLegPositions(sLegInitXZAdjust);
    1c0c:	02ce0308 	sbceq	r0, lr, #536870912	; 0x20000000
			}
		}

		if (fAdjustLegPositions && !g_fDynamicLegXZLength)
    1c10:	241c2401 	ldrcs	r2, [ip], #-1025
    1c14:	4e3d4e2f 	cdpmi	14, 3, cr4, cr13, cr15, {1}
    1c18:	55034d3d 	strpl	r4, [r3, #-3389]
			AdjustLegPositionsToBodyHeight(); // Put main workings into main program file
    1c1c:	20090390 	mulcs	r9, r0, r3
		// Save away the buttons state as to not process the same press twice.
		buttonsPrev = buttons;
    1c20:	03207703 	teqeq	r0, #786432	; 0xc0000
    1c24:	3f342009 	svccc	0x00342009
		extPrev = ext;
    1c28:	a5033d3f 	strge	r3, [r3, #-3391]
    1c2c:	4d314a7f 	fldmdbsmi	r1!, {s8-s134}
		g_ulLastMsgTime = getMillis();
    1c30:	2c321e25 	ldccs	14, cr1, [r2], #-148
    1c34:	2f2f2129 	svccs	0x002f2129
	} else {
		// We did not receive a valid packet.  check for a timeout to see if we should turn robot off...
		if (g_InControlState.fRobotOn) {
    1c38:	22352321 	eorscs	r2, r5, #-2080374784	; 0x84000000
			if ((getMillis() - g_ulLastMsgTime) > ARBOTIX_TO)
    1c3c:	2f21292c 	svccs	0x0021292c
    1c40:	3223212f 	eorcc	r2, r3, #-1073741813	; 0xc000000b
    1c44:	4e4b6d6e 	cdpmi	13, 4, cr6, cr11, cr14, {3}
    1c48:	5d675b3d 	fstmdbxpl	r7!, {d21-d50}
    1c4c:	5c675b67 	stclpl	11, cr5, [r7], #-412
				CommanderTurnRobotOff();
    1c50:	e1034b75 	tst	r3, r5, ror fp
		}
	}

}
    1c54:	2730747e 	undefined
    1c58:	25207903 	strcs	r7, [r0, #-2307]!
    1c5c:	321d341b 	andscc	r3, sp, #452984832	; 0x1b000000
    1c60:	2f2f302a 	svccs	0x002f302a
    1c64:	2f2b3130 	svccs	0x002b3130
    1c68:	4c302f2f 	ldcmi	15, cr2, [r0], #-188
    1c6c:	2f1f2f1f 	svccs	0x001f2f1f
    1c70:	361f4c30 	undefined
    1c74:	1f2e7903 	svcne	0x002e7903
    1c78:	2a32312f 	bcs	c8e13c <__Stack_Size+0xc8dd3c>
    1c7c:	302f2f30 	eorcc	r2, pc, r0, lsr pc
    1c80:	2f2f2b31 	svccs	0x002f2b31
    1c84:	1f4c302f 	svcne	0x004c302f
    1c88:	302f1f2f 	eorcc	r1, pc, pc, lsr #30
    1c8c:	1f2f1f4d 	svcne	0x002f1f4d
    1c90:	4c30302d 	ldcmi	0, cr3, [r0], #-180
    1c94:	7903361f 	stmdbvc	r3, {r0, r1, r2, r3, r4, r9, sl, ip, sp}
    1c98:	312f1f2e 	teqcc	pc, lr, lsr #30
    1c9c:	2f302a32 	svccs	0x00302a32
    1ca0:	2b31302f 	blcs	c4dd64 <__Stack_Size+0xc4d964>
    1ca4:	302f2f2f 	eorcc	r2, pc, pc, lsr #30
    1ca8:	2f2f2b31 	svccs	0x002f2b31
    1cac:	1f4d302f 	svcne	0x004d302f

extern void setupPhoenix(void);
extern void readSensors(void);


int Big_main(void) {
    1cb0:	302d1f2f 	eorcc	r1, sp, pc, lsr #30

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
    1cb4:	2f1f4c30 	svccs	0x001f4c30
	setupPhoenix();
    1cb8:	4c302f1f 	ldcmi	15, cr2, [r0], #-124
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1cbc:	2f1f2f1f 	svccs	0x001f2f1f

	while (1){
		while (1) {
			//Start time
			unsigned long lTimeWaitEnd;
			lTimerStart = getMillis();
    1cc0:	2f1f4c30 	svccs	0x001f4c30
    1cc4:	30312f1f 	eorscc	r2, r1, pc, lsl pc
    1cc8:	302f2f2c 	eorcc	r2, pc, ip, lsr #30
#ifdef MILLIS
			PrintString("Barebones lTimerStart ");
			Printu32d(lTimerStart);
			PrintString("\n");
#endif
			DoBackgroundProcess();
    1ccc:	80034b4b 	andhi	r4, r3, fp, asr #22
			//Read input
			CheckVoltage();        // check our voltages...
    1cd0:	0328907f 	teqeq	r8, #127	; 0x7f
			if (!g_fLowVoltageShutdown) {
    1cd4:	03282e78 	teqeq	r8, #1920	; 0x780
    1cd8:	79034a0c 	stmdbvc	r3, {r2, r3, r9, fp, lr}
				CommanderInputController_ControlInput();
    1cdc:	211e4f20 	tstcs	lr, r0, lsr #30
			}
			WriteOutputs();        // Write Outputs
			//Single leg control
			SingleLegControl();
    1ce0:	2f2f1c23 	svccs	0x002f1c23
			DoBackgroundProcess();
    1ce4:	40312f2f 	eorsmi	r2, r1, pc, lsr #30

			//Gait
			GaitSeq();
    1ce8:	2f303b1e 	svccs	0x00303b1e

			DoBackgroundProcess();
    1cec:	1f1e4031 	svcne	0x001e4031

			//Balance calculations
			TotalTransX = 0;     //reset values used for calculation of balance
    1cf0:	2f2f2f2f 	svccs	0x002f2f2f
    1cf4:	3c7f9803 	ldclcc	8, cr9, [pc], #-12
			TotalTransZ = 0;
    1cf8:	304d3131 	subcc	r3, sp, r1, lsr r1
			TotalTransY = 0;
    1cfc:	3f3f3f30 	svccc	0x003f3f30
    1d00:	3f694d3f 	svccc	0x00694d3f
			TotalXBal1 = 0;
    1d04:	5e513f5c 	mrcpl	15, 2, r3, cr1, cr12, {2}
			TotalYBal1 = 0;
    1d08:	3d5b5c5c 	ldclcc	12, cr5, [fp, #-368]
    1d0c:	2e7fa503 	cdpcs	5, 7, cr10, cr15, cr3, {0}
			TotalZBal1 = 0;
    1d10:	23232b23 	teqcs	r3, #35840	; 0x8c00

			if (g_InControlState.BalanceMode) {
    1d14:	31313131 	teqcc	r1, r1, lsr r1
    1d18:	05022f31 	streq	r2, [r2, #-3889]
    1d1c:	08010100 	stmdaeq	r1, {r8}

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d20:	02000002 	andeq	r0, r0, #2	; 0x2

					DoBackgroundProcess();
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d24:	0000ab00 	andeq	sl, r0, r0, lsl #22
    1d28:	fb010200 	blx	42532 <__Stack_Size+0x42132>
    1d2c:	01000d0e 	tsteq	r0, lr, lsl #26

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs

					DoBackgroundProcess();
    1d30:	00010101 	andeq	r0, r1, r1, lsl #2
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d34:	00010000 	andeq	r0, r1, r0
    1d38:	4d430100 	stfmie	f0, [r3]
    1d3c:	5f303335 	svcpl	0x00303335
    1d40:	732f5748 	teqvc	pc, #18874368	; 0x1200000
    1d44:	73006372 	movwvc	r6, #882	; 0x372
    1d48:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    1d4c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    1d50:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    1d54:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    1d58:	354d4300 	strbcc	r4, [sp, #-768]
    1d5c:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
    1d60:	6e692f57 	mcrvs	15, 3, r2, cr9, cr7, {2}
    1d64:	75000063 	strvc	r0, [r0, #-99]
    1d68:	74726173 	ldrbtvc	r6, [r2], #-371
    1d6c:	0100632e 	tsteq	r0, lr, lsr #6
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d70:	74730000 	ldrbtvc	r0, [r3]
    1d74:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1d78:	5f783031 	svcpl	0x00783031
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1d7c:	65707974 	ldrbvs	r7, [r0, #-2420]!
    1d80:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
					DoBackgroundProcess();
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d84:	74730000 	ldrbtvc	r0, [r3]
    1d88:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
					DoBackgroundProcess();
    1d8c:	5f783031 	svcpl	0x00783031
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d90:	2e70616d 	rpwcssz	f6, f0, #5.0
    1d94:	00020068 	andeq	r0, r2, r8, rrx
    1d98:	6d747300 	ldclvs	3, cr7, [r4]
    1d9c:	31663233 	cmncc	r6, r3, lsr r2
    1da0:	755f7830 	ldrbvc	r7, [pc, #-2096]	; 1578 <__Stack_Size+0x1178>
    1da4:	74726173 	ldrbtvc	r6, [r2], #-371
    1da8:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    1dac:	73750000 	cmnvc	r5, #0	; 0x0
    1db0:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
    1db4:	00030068 	andeq	r0, r3, r8, rrx
    1db8:	73797300 	cmnvc	r9, #0	; 0x0
    1dbc:	5f6d6574 	svcpl	0x006d6574
    1dc0:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
    1dc4:	0300682e 	movweq	r6, #2094	; 0x82e
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1dc8:	656c0000 	strbvs	r0, [ip]!
    1dcc:	00682e64 	rsbeq	r2, r8, r4, ror #28
    1dd0:	00000003 	andeq	r0, r0, r3
							LegPosZ[LegIndex] + GaitPosZ[LegIndex],
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}
				BalanceBody();
    1dd4:	2c020500 	cfstr32cs	mvfx0, [r2], {0}
			}

			//Reset IKsolution indicators
			IKSolution = 0;
    1dd8:	0308005c 	movweq	r0, #32860	; 0x805c
    1ddc:	130100c5 	movwne	r0, #4293	; 0x10c5
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1de0:	4a0f036a 	bmi	3c2b90 <__Stack_Size+0x3c2790>
			}

			//Reset IKsolution indicators
			IKSolution = 0;
			IKSolutionWarning = 0;
			IKSolutionError = 0;
    1de4:	4b848513 	blmi	fe123238 <SCS_BASE+0x1e115238>
    1de8:	8513783f 	ldrhi	r7, [r3, #-2111]

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
				DoBackgroundProcess();
    1dec:	742e035b 	strtvc	r0, [lr], #-859
				BodyFK(
    1df0:	6a2f4b13 	bvs	bd4a44 <__Stack_Size+0xbd4644>
    1df4:	66790313 	undefined
    1df8:	3c0b033d 	stccc	3, cr0, [fp], {61}
    1dfc:	0375764b 	cmneq	r5, #78643200	; 0x4b00000
    1e00:	586601d5 	stmdapl	r6!, {r0, r2, r4, r6, r7, r8}^
    1e04:	2a222224 	bcs	88a69c <__Stack_Size+0x88a29c>
    1e08:	2d21755a 	cfstr32cs	mvfx7, [r1, #-360]!
    1e0c:	4a7a0321 	bmi	1e82a98 <__Stack_Size+0x1e82698>
    1e10:	033c0d03 	teqeq	ip, #192	; 0xc0
    1e14:	169000d5 	undefined
    1e18:	2f1f241c 	svccs	0x001f241c
    1e1c:	2f4b302d 	svccs	0x004b302d
    1e20:	58741903 	ldmdapl	r4!, {r0, r1, r8, fp, ip}^
    1e24:	3a212123 	bcc	84a2b8 <__Stack_Size+0x849eb8>
    1e28:	2d218359 	stccs	3, cr8, [r1, #-356]!
    1e2c:	0a03542f 	beq	d6ef0 <__Stack_Size+0xd6af0>
    1e30:	6a13983c 	bvs	4e7f28 <__Stack_Size+0x4e7b28>
    1e34:	221e224d 	andscs	r2, lr, #-805306364	; 0xd0000004
    1e38:	24464067 	strbcs	r4, [r6], #-103
    1e3c:	3f3d683d 	svccc	0x003d683d
    1e40:	3d594b67 	vldrcc	d20, [r9, #-412]
    1e44:	219e6103 	orrscs	r6, lr, r3, lsl #2
    1e48:	033d212d 	teqeq	sp, #1073741835	; 0x4000000b
    1e4c:	4e203c59 	mcrmi	12, 1, r3, cr0, cr9, {2}
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);

				LegIK(
    1e50:	6a4b4c4c 	bvs	12d4f88 <__Stack_Size+0x12d4b88>
    1e54:	5873034c 	ldmdapl	r3!, {r2, r3, r6, r8, r9}^
    1e58:	033c1103 	teqeq	ip, #-1073741824	; 0xc0000000
    1e5c:	1e22745d 	mcrne	4, 1, r7, cr2, cr13, {2}
    1e60:	84033d22 	strhi	r3, [r3], #-3362
    1e64:	1e224a7f 	mcrne	10, 1, r4, cr2, cr15, {3}
    1e68:	03593f22 	cmpeq	r9, #136	; 0x88
    1e6c:	22747dca 	rsbscs	r7, r4, #12928	; 0x3280
    1e70:	033d221e 	teqeq	sp, #-536870911	; 0xe0000001
    1e74:	2e4a038a 	cdpcs	3, 4, cr0, cr10, cr10, {4}
    1e78:	03283e23 	teqeq	r8, #560	; 0x230
    1e7c:	2f4b2079 	svccs	0x004b2079
    1e80:	4c1e322f 	lfmmi	f3, 4, [lr], {47}
    1e84:	694d3e2f 	stmdbvs	sp, {r0, r1, r2, r3, r5, r9, sl, fp, ip, sp}^
    1e88:	034a6d03 	movteq	r6, #44291	; 0xad03
    1e8c:	ea032016 	b	c9eec <__Stack_Size+0xc9aec>
    1e90:	232e587e 	teqcs	lr, #8257536	; 0x7e0000
    1e94:	7a03273e 	bvc	cbb94 <__Stack_Size+0xcb794>
    1e98:	2f2f4b20 	svccs	0x002f4b20
    1e9c:	2f4c1e31 	svccs	0x004c1e31
    1ea0:	4e694d3e 	mcrmi	13, 3, r4, cr9, cr14, {1}
    1ea4:	03586a03 	cmpeq	r8, #12288	; 0x3000
    1ea8:	b6032019 	undefined
    1eac:	232e827d 	teqcs	lr, #-805306361	; 0xd0000007
    1eb0:	7a03273e 	bvc	cbbb0 <__Stack_Size+0xcb7b0>
    1eb4:	2f2f4b20 	svccs	0x002f4b20
    1eb8:	2f4c1e31 	svccs	0x004c1e31
    1ebc:	03694d3e 	cmneq	r9, #3968	; 0xf80
    1ec0:	17034a6e 	strne	r4, [r3, -lr, ror #20]
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1ec4:	02e20320 	rsceq	r0, r2, #-2147483648	; 0x80000000
    1ec8:	4b762258 	blmi	1d8a830 <__Stack_Size+0x1d8a430>
    1ecc:	03304e3d 	teqeq	r0, #976	; 0x3d0
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1ed0:	7503200b 	strvc	r2, [r3, #-11]
    1ed4:	200b032e 	andcs	r0, fp, lr, lsr #6
				DoBackgroundProcess();
    1ed8:	2f5c5a30 	svccs	0x005c5a30
				BodyFK(
    1edc:	4b4b6731 	blmi	12dbba8 <__Stack_Size+0x12db7a8>
    1ee0:	b3034b30 	movwlt	r4, #15152	; 0x3b30
    1ee4:	4e20ac7f 	mcrmi	12, 1, sl, cr0, cr15, {3}
    1ee8:	03684b4c 	cmneq	r8, #77824	; 0x13000
    1eec:	0b035879 	bleq	d80d8 <__Stack_Size+0xd7cd8>
    1ef0:	7df4033c 	ldclvc	3, cr0, [r4, #240]!
    1ef4:	4b762258 	blmi	1d8a85c <__Stack_Size+0x1d8a45c>
    1ef8:	03304c3d 	teqeq	r0, #15616	; 0x3d00
    1efc:	7603200a 	strvc	r2, [r3], -sl
    1f00:	200a032e 	andcs	r0, sl, lr, lsr #6
    1f04:	3d6a7630 	stclcc	6, cr7, [sl, #-192]!
    1f08:	594b673f 	stmdbpl	fp, {r0, r1, r2, r3, r4, r5, r8, r9, sl, sp, lr}^
    1f0c:	19034b3e 	stmdbne	r3, {r1, r2, r3, r4, r5, r8, r9, fp, lr}
    1f10:	032f2fba 	teqeq	pc, #744	; 0x2e8
    1f14:	202e7f9b 	mlacs	lr, fp, pc, r7
    1f18:	301e3021 	andscc	r3, lr, r1, lsr #32
    1f1c:	034b684b 	movteq	r6, #47179	; 0xb84b
    1f20:	1e303c69 	cdpne	12, 3, cr3, cr0, cr9, {3}
    1f24:	02024b22 	andeq	r4, r2, #34816	; 0x8800
    1f28:	0d010100 	stfeqs	f0, [r1]
    1f2c:	02000002 	andeq	r0, r0, #2	; 0x2
    1f30:	00008400 	andeq	r8, r0, r0, lsl #8
    1f34:	fb010200 	blx	4273e <__Stack_Size+0x4233e>
    1f38:	01000d0e 	tsteq	r0, lr, lsl #26
    1f3c:	00010101 	andeq	r0, r1, r1, lsl #2
    1f40:	00010000 	andeq	r0, r1, r0
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);
				LegIK(
    1f44:	74730100 	ldrbtvc	r0, [r3], #-256
    1f48:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1f4c:	5f783031 	svcpl	0x00783031
    1f50:	2f62696c 	svccs	0x0062696c
    1f54:	00637273 	rsbeq	r7, r3, r3, ror r2
    1f58:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    1f5c:	30316632 	eorscc	r6, r1, r2, lsr r6
    1f60:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1f64:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
    1f68:	73000063 	movwvc	r0, #99	; 0x63
    1f6c:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    1f70:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    1f74:	6364615f 	cmnvs	r4, #-1073741801	; 0xc0000017
    1f78:	0100632e 	tsteq	r0, lr, lsr #6
    1f7c:	74730000 	ldrbtvc	r0, [r3]
    1f80:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1f84:	5f783031 	svcpl	0x00783031
    1f88:	65707974 	ldrbvs	r7, [r0, #-2420]!
    1f8c:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    1f90:	74730000 	ldrbtvc	r0, [r3]
    1f94:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    1f98:	5f783031 	svcpl	0x00783031
    1f9c:	2e70616d 	rpwcssz	f6, f0, #5.0
    1fa0:	00020068 	andeq	r0, r2, r8, rrx
    1fa4:	6d747300 	ldclvs	3, cr7, [r4]
    1fa8:	31663233 	cmncc	r6, r3, lsr r2
    1fac:	615f7830 	cmpvs	pc, r0, lsr r8
    1fb0:	682e6364 	stmdavs	lr!, {r2, r5, r6, r8, r9, sp, lr}
    1fb4:	00000200 	andeq	r0, r0, r0, lsl #4
    1fb8:	02050000 	andeq	r0, r5, #0	; 0x0
    1fbc:	08006210 	stmdaeq	r0, {r4, r9, sp, lr}
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1fc0:	0101ae03 	tsteq	r1, r3, lsl #28
    1fc4:	26010f03 	strcs	r0, [r1], -r3, lsl #30
    1fc8:	200b0392 	mulcs	fp, r2, r3
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Check mechanical limits
			CheckAngles();
    1fcc:	352e7903 	strcc	r7, [lr, #-2307]!

			//Drive Servos
			if (g_InControlState.fRobotOn) {
    1fd0:	200a0385 	andcs	r0, sl, r5, lsl #7
    1fd4:	26207a03 	strtcs	r7, [r0], -r3, lsl #20
    1fd8:	213e321c 	teqcs	lr, ip, lsl r2
				if (g_InControlState.fRobotOn && !g_InControlState.fPrev_RobotOn) {
					// MSound(3, 60, 2000, 80, 2250, 100, 2500);
					Buzzed(30, 2000);
    1fdc:	153c0b03 	ldrne	r0, [ip, #-2819]!
    1fe0:	23232331 	teqcs	r3, #-1006632960	; 0xc4000000
    1fe4:	0c032f23 	stceq	15, cr2, [r3], {35}
					Buzzed(80, 2250);
    1fe8:	4f23172e 	svcmi	0x0023172e
    1fec:	200d034c 	andcs	r0, sp, ip, asr #6
					Buzzed(100, 2500);
    1ff0:	4c4f2317 	mcrrmi	3, 1, r2, pc, cr7
    1ff4:	03201203 	teqeq	r0, #805306368	; 0x30000000
    1ff8:	23220109 	teqcs	r2, #1073741826	; 0x40000002

				}

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
    1ffc:	0a034c4f 	beq	d5140 <__Stack_Size+0xd4d40>
    2000:	034b172e 	movteq	r1, #46894	; 0xb72e
    2004:	03192e0a 	tsteq	r9, #160	; 0xa0
    2008:	0a034a0d 	beq	d4844 <__Stack_Size+0xd4444>
    200c:	034b172e 	movteq	r1, #46894	; 0xb72e
    2010:	03192e0a 	tsteq	r9, #160	; 0xa0
    2014:	0c034a0d 	stceq	10, cr4, [r3], {13}
    2018:	5024172e 	eorpl	r1, r4, lr, lsr #14
    201c:	200a034c 	andcs	r0, sl, ip, asr #6
    2020:	4a0d0319 	bmi	342c8c <__Stack_Size+0x34288c>
    2024:	032e0d03 	teqeq	lr, #192	; 0xc0
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2028:	1d250109 	stfnes	f0, [r5, #-36]!
    202c:	03213031 	teqeq	r1, #49	; 0x31
    2030:	2317200e 	tstcs	r7, #14	; 0xe
    2034:	2c034c4f 	stccs	12, cr4, [r3], {79}
    2038:	010a0320 	tsteq	sl, r0, lsr #6
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
    203c:	20207603 	eorcs	r7, r0, r3, lsl #12

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2040:	25580a03 	ldrbcs	r0, [r8, #-2563]
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
						ServoMoveTime = ServoMoveTime + BALANCE_DELAY;
    2044:	78033230 	stmdavc	r3, {r4, r5, r9, ip, sp}
    2048:	2232242e 	eorscs	r2, r2, #771751936	; 0x2e000000
				} else
					//Movement speed excl. Walking
					ServoMoveTime = 200 + g_InControlState.SpeedControl;
    204c:	03322235 	teqeq	r2, #1342177283	; 0x50000003
    2050:	32242e78 	eorcc	r2, r4, #1920	; 0x780
    2054:	3e412322 	cdpcc	3, 4, cr2, cr1, cr2, {1}

				// note we broke up the servo driver into start/commit that way we can output all of the servo information
				// before we wait and only have the termination information to output after the wait.  That way we hopefully
				// be more accurate with our timings...
				DoBackgroundProcess();
    2058:	2e780332 	mrccs	3, 3, r0, cr8, cr2, {1}
				StartUpdateServos();
    205c:	31223224 	teqcc	r2, r4, lsr #4

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    2060:	0332305d 	teqeq	r2, #93	; 0x5d
					if ((GaitPosX[LegIndex] > cGPlimit)
    2064:	32242e78 	eorcc	r2, r4, #1920	; 0x780
    2068:	32303622 	eorscc	r3, r0, #35651584	; 0x2200000
    206c:	242e7803 	strtcs	r7, [lr], #-2051
    2070:	03222232 	teqeq	r2, #536870915	; 0x20000003
    2074:	23172e0d 	tstcs	r7, #208	; 0xd0
    2078:	0a034c4f 	beq	d51bc <__Stack_Size+0xd4dbc>
    207c:	032f1720 	teqeq	pc, #8388608	; 0x800000
    2080:	2f142e09 	svccs	0x00142e09
    2084:	174a0e03 	strbne	r0, [sl, -r3, lsl #28]
    2088:	034c4f23 	movteq	r4, #53027	; 0xcf23
    208c:	2317200e 	tstcs	r7, #14	; 0xe
    2090:	29034c4f 	stmdbcs	r3, {r0, r1, r2, r3, r6, sl, fp, lr}
    2094:	30221a20 	eorcc	r1, r2, r0, lsr #20
    2098:	0e032122 	adfeqsp	f2, f3, f2
    209c:	4f231720 	svcmi	0x00231720
							|| (GaitPosZ[LegIndex] > cGPlimit)
							|| (GaitPosZ[LegIndex] < -cGPlimit)
							|| (GaitRotY[LegIndex] > cGPlimit)
							|| (GaitRotY[LegIndex] < -cGPlimit)) {

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
    20a0:	200e034c 	andcs	r0, lr, ip, asr #6
    20a4:	4c502417 	cfldrdmi	mvd2, [r0], {23}
    20a8:	19200a03 	stmdbne	r0!, {r0, r1, r9, fp}

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    20ac:	034a0d03 	movteq	r0, #44291	; 0xad03
    20b0:	0a032e2c 	beq	cd968 <__Stack_Size+0xcd568>

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
						break;
					}
				}
				if (bExtraCycle > 0) {
    20b4:	20760301 	rsbscs	r0, r6, r1, lsl #6
					bExtraCycle--;
    20b8:	580a0320 	stmdapl	sl, {r5, r8, r9}
    20bc:	03323025 	teqeq	r2, #37	; 0x25
					fWalking = !(bExtraCycle == 0);
    20c0:	32242e78 	eorcc	r2, r4, #1920	; 0x780
    20c4:	32223522 	eorcc	r3, r2, #142606336	; 0x8800000

					//Get endtime and calculate wait time
					lTimeWaitEnd = lTimerStart + PrevServoMoveTime;
    20c8:	242e7803 	strtcs	r7, [lr], #-2051
    20cc:	26252232 	undefined
    20d0:	2a24921e 	bcs	926950 <__Stack_Size+0x926550>
					PrintString("\n");
#endif
					//DebugWrite(A1, HIGH);
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    20d4:	03212232 	teqeq	r1, #536870915	; 0x20000003
					} while (getMillis() < lTimeWaitEnd);
    20d8:	09032e0c 	stmdbeq	r3, {r2, r3, r9, sl, fp, sp}
    20dc:	311d2501 	tstcc	sp, r1, lsl #10
					PrintString("\n");
#endif

				}
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
    20e0:	13032130 	movwne	r2, #12592	; 0x3130
    20e4:	03212720 	teqeq	r1, #8388608	; 0x800000
    20e8:	26202e10 	undefined
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
    20ec:	3c1b033d 	ldccc	3, cr0, [fp], {61}
					PrintString("Barebones lTimeWaitEnd-Millis  ");
					Printu32d(getMillis);
					PrintString("\n");
#endif
				} else {
					FreeServos();
    20f0:	224c221a 	subcs	r2, ip, #-1610612735	; 0xa0000001
    20f4:	200f0321 	andcs	r0, pc, r1, lsr #6
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
					ServoMoveTime = 600;
    20f8:	03212219 	teqeq	r1, #-1879048191	; 0x90000001
    20fc:	221a2e1f 	andscs	r2, sl, #496	; 0x1f0
					StartUpdateServos();
    2100:	03212230 	teqeq	r1, #3	; 0x3
					CommitServoDriver(ServoMoveTime);
    2104:	2316200b 	tstcs	r6, #11	; 0xb
					//MSound(3, 100, 2500, 80, 2250, 60, 2000);
					Buzzed(100, 2500);
    2108:	11035a5d 	tstne	r3, sp, asr sl
    210c:	0d031a3c 	fstseq	s2, [r3, #-240]
    2110:	20110358 	andscs	r0, r1, r8, asr r3
					Buzzed(80, 2250);
    2114:	0f033d18 	svceq	0x00033d18
    2118:	010c0320 	tsteq	ip, r0, lsr #6
					Buzzed(60, 2000);
    211c:	ac0d0323 	stcge	3, cr0, [sp], {35}
    2120:	032e0f03 	teqeq	lr, #12	; 0xc
    2124:	033d010b 	teqeq	sp, #-1073741822	; 0xc0000002

					//lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
					lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
    2128:	2420768b 	strtcs	r7, [r0], #-1675
    212c:	241c241c 	ldrcs	r2, [ip], #-1052
					Printu32d(lTimeWaitEnd);
					PrintString("\n");
#endif
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    2130:	5a415a94 	bpl	1058b88 <__Stack_Size+0x1058788>
					} while (getMillis() < lTimeWaitEnd);
    2134:	025e5a41 	subseq	r5, lr, #266240	; 0x41000
    2138:	01010004 	tsteq	r1, r4
				} else {
					FreeServos();
				}

				// Allow the Servo driver to do stuff durint our idle time
				IdleTime();
    213c:	0000021f 	andeq	r0, r0, pc, lsl r2
				mDelay(20); // give a pause between times we call if nothing is happening
    2140:	00880002 	addeq	r0, r8, r2
			}
			PrevServoMoveTime = ServoMoveTime;
    2144:	01020000 	tsteq	r2, r0
    2148:	000d0efb 	strdeq	r0, [sp], -fp

			//Store previous g_InControlState.fRobotOn State
			if (g_InControlState.fRobotOn)
    214c:	01010101 	tsteq	r1, r1, lsl #2
    2150:	01000000 	tsteq	r0, r0
				g_InControlState.fPrev_RobotOn = 1;
			else
				g_InControlState.fPrev_RobotOn = 0;
    2154:	73010000 	movwvc	r0, #4096	; 0x1000
    2158:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    215c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    2160:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    2164:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    2168:	6d747300 	ldclvs	3, cr7, [r4]
    216c:	31663233 	cmncc	r6, r3, lsr r2
    2170:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    2174:	692f6269 	stmdbvs	pc!, {r0, r3, r5, r6, r9, sp, lr}
    2178:	0000636e 	andeq	r6, r0, lr, ror #6
    217c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2180:	30316632 	eorscc	r6, r1, r2, lsr r6
    2184:	6c665f78 	stclvs	15, cr5, [r6], #-480
    2188:	2e687361 	cdpcs	3, 6, cr7, cr8, cr1, {3}
    218c:	00010063 	andeq	r0, r1, r3, rrx
    2190:	6d747300 	ldclvs	3, cr7, [r4]
    2194:	31663233 	cmncc	r6, r3, lsr r2
    2198:	745f7830 	ldrbvc	r7, [pc], #2096	; 21a0 <__Stack_Size+0x1da0>
    219c:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
    21a0:	00020068 	andeq	r0, r2, r8, rrx
    21a4:	6d747300 	ldclvs	3, cr7, [r4]
    21a8:	31663233 	cmncc	r6, r3, lsr r2
    21ac:	6d5f7830 	ldclvs	8, cr7, [pc, #-192]
    21b0:	682e7061 	stmdavs	lr!, {r0, r5, r6, ip, sp, lr}
    21b4:	00000200 	andeq	r0, r0, r0, lsl #4
    21b8:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    21bc:	30316632 	eorscc	r6, r1, r2, lsr r6
    21c0:	6c665f78 	stclvs	15, cr5, [r6], #-480
    21c4:	2e687361 	cdpcs	3, 6, cr7, cr8, cr1, {3}
    21c8:	00020068 	andeq	r0, r2, r8, rrx
    21cc:	05000000 	streq	r0, [r0]
    21d0:	0065a402 	rsbeq	sl, r5, r2, lsl #8
    21d4:	00d60308 	sbcseq	r0, r6, r8, lsl #6
    21d8:	3d591701 	ldclcc	7, cr1, [r9, #-4]
    21dc:	174a0d03 	strbne	r0, [sl, -r3, lsl #26]
    21e0:	0d033d59 	stceq	13, cr3, [r3, #-356]
    21e4:	3d59174a 	ldclcc	7, cr1, [r9, #-296]
    21e8:	144a0b03 	strbne	r0, [sl], #-2819
    21ec:	0a033d3d 	beq	d16e8 <__Stack_Size+0xd12e8>
    21f0:	03591466 	cmpeq	r9, #1711276032	; 0x66000000
    21f4:	143c03f5 	ldrtne	r0, [ip], #-1013
    21f8:	3c0a033d 	stccc	3, cr0, [sl], {61}
    21fc:	0b032f14 	bleq	cde54 <__Stack_Size+0xcda54>
    2200:	0903154a 	stmdbeq	r3, {r1, r3, r6, r8, sl, ip}
    2204:	3c0a0358 	stccc	3, cr0, [sl], {88}
    2208:	580a0315 	stmdapl	sl, {r0, r2, r4, r8, r9}
    220c:	173c0e03 	ldrne	r0, [ip, -r3, lsl #28]!
    2210:	035a5d23 	cmpeq	sl, #2240	; 0x8c0
    2214:	30183c10 	andscc	r3, r8, r0, lsl ip
    2218:	03580b03 	cmpeq	r8, #3072	; 0xc00
    221c:	0f03660b 	svceq	0x0003660b
    2220:	032f173c 	teqeq	pc, #15728640	; 0xf00000
    2224:	7a154a0b 	bvc	554a58 <__Stack_Size+0x554658>
    2228:	660c036c 	strvs	r0, [ip], -ip, ror #6
    222c:	033c0c03 	teqeq	ip, #768	; 0x300
    2230:	2403205c 	strcs	r2, [r3], #-92
    2234:	205c0320 	subscs	r0, ip, r0, lsr #6
    2238:	03202403 	teqeq	r0, #50331648	; 0x3000000
    223c:	6c5e205c 	mrrcvs	0, 5, r2, lr, cr12
    2240:	22743803 	rsbscs	r3, r4, #196608	; 0x30000
    2244:	907fba03 	rsbsls	fp, pc, r3, lsl #20
    2248:	23036c6c 	movwcs	r6, #15468	; 0x3c6c
    224c:	2e510366 	cdpcs	3, 5, cr0, cr1, cr6, {3}
    2250:	2000c403 	andcs	ip, r0, r3, lsl #8
    2254:	2e650322 	cdpcs	3, 6, cr0, cr5, cr2, {1}
    2258:	ef0343a5 	svc	0x000343a5
    225c:	09034a7d 	stmdbeq	r3, {r0, r2, r3, r4, r5, r6, r9, fp, lr}
    2260:	2e770320 	cdpcs	3, 7, cr0, cr7, cr0, {1}
    2264:	21200903 	teqcs	r0, r3, lsl #18
    2268:	032e7603 	teqeq	lr, #3145728	; 0x300000
    226c:	0323200a 	teqeq	r3, #10	; 0xa
    2270:	0d032073 	stceq	0, cr2, [r3, #-460]
    2274:	2231302e 	eorscs	r3, r1, #46	; 0x2e
    2278:	3e773e1e 	mrccc	14, 3, r3, cr7, cr14, {0}
    227c:	8e036b23 	fmacdhi	d6, d3, d19
    2280:	4c42827f 	sfmmi	f0, 3, [r2], {127}
    2284:	79033531 	stmdbvc	r3, {r0, r4, r5, r8, sl, ip, sp}
    2288:	243e212e 	ldrtcs	r2, [lr], #-302
    228c:	304d3d1c 	subcc	r3, sp, ip, lsl sp
    2290:	224c6931 	subcs	r6, ip, #802816	; 0xc4000
    2294:	314c4e4e 	cmpcc	ip, lr, asr #28
    2298:	036c2387 	cmneq	ip, #469762050	; 0x1c000002
    229c:	20827ef8 	strdcs	r7, [r2], r8
    22a0:	3e200f03 	cdpcc	15, 2, cr0, cr0, cr3, {0}
    22a4:	2e740331 	mrccs	3, 3, r0, cr4, cr1, {1}
    22a8:	212e0c03 	teqcs	lr, r3, lsl #24
    22ac:	2073033d 	rsbscs	r0, r3, sp, lsr r3
    22b0:	30200d03 	eorcc	r0, r0, r3, lsl #26
    22b4:	2322221e 	teqcs	r2, #-536870911	; 0xe0000001
    22b8:	6d03231d 	stcvs	3, cr2, [r3, #-116]
    22bc:	3c15032e 	ldccc	3, cr0, [r5], {46}
    22c0:	231d23a0 	tstcs	sp, #-2147483646	; 0x80000002
    22c4:	032e6703 	teqeq	lr, #786432	; 0xc0000
    22c8:	23a03c1c 	movcs	r3, #7168	; 0x1c00
    22cc:	6003231d 	andvs	r2, r3, sp, lsl r3
    22d0:	2023032e 	eorcs	r0, r3, lr, lsr #6
    22d4:	231d23a0 	tstcs	sp, #-2147483646	; 0x80000002
    22d8:	03872331 	orreq	r2, r7, #-1006632960	; 0xc4000000
    22dc:	20827f90 	umullcs	r7, r2, r0, pc
    22e0:	207a0326 	rsbscs	r0, sl, r6, lsr #6
    22e4:	36313026 	ldrtcc	r3, [r1], -r6, lsr #32
    22e8:	21207803 	teqcs	r0, r3, lsl #16
    22ec:	30234b3f 	eorcc	r4, r3, pc, lsr fp
    22f0:	bb036b23 	bllt	dcf84 <__Stack_Size+0xdcb84>
    22f4:	2720587f 	undefined
    22f8:	27207903 	strcs	r7, [r0, -r3, lsl #18]!
    22fc:	1c243130 	stfnes	f3, [r4], #-192
    2300:	2330224c 	teqcs	r0, #-1073741820	; 0xc0000004
    2304:	7fab036b 	svcvc	0x00ab036b
    2308:	0327204a 	teqeq	r7, #74	; 0x4a
    230c:	30272079 	eorcc	r2, r7, r9, ror r0
    2310:	4c1b2532 	cfldr32mi	mvfx2, [fp], {50}
    2314:	31323031 	teqcc	r2, r1, lsr r0
    2318:	233c0a03 	teqcs	ip, #12288	; 0x3000
    231c:	7f93036c 	svcvc	0x0093036c
    2320:	314c244a 	cmpcc	ip, sl, asr #8
    2324:	2e780336 	mrccs	3, 3, r0, cr8, cr6, {1}
    2328:	1c243f21 	stcne	15, cr3, [r4], #-132
    232c:	31304d3d 	teqcc	r0, sp, lsr sp
    2330:	3f2b2369 	svccc	0x002b2369
    2334:	03231d23 	teqeq	r3, #2240	; 0x8c0
    2338:	6c232e0a 	stcvs	14, cr2, [r3], #-40
    233c:	827fab03 	rsbshi	sl, pc, #3072	; 0xc00
    2340:	4b314c24 	blmi	c553d8 <__Stack_Size+0xc54fd8>
    2344:	3e3f2b23 	fadddcc	d2, d15, d19
    2348:	42036b23 	andmi	r6, r3, #35840	; 0x8c00
    234c:	314c433c 	cmpcc	ip, ip, lsr r3
    2350:	1b252925 	blne	94c7ec <__Stack_Size+0x94c3ec>
    2354:	304d213d 	subcc	r2, sp, sp, lsr r1
    2358:	05026b23 	streq	r6, [r2, #-2851]
    235c:	74010100 	strvc	r0, [r1], #-256
    2360:	02000001 	andeq	r0, r0, #1	; 0x1
    2364:	00008600 	andeq	r8, r0, r0, lsl #12
    2368:	fb010200 	blx	42b72 <__Stack_Size+0x42772>
    236c:	01000d0e 	tsteq	r0, lr, lsl #26
    2370:	00010101 	andeq	r0, r1, r1, lsl #2
    2374:	00010000 	andeq	r0, r1, r0
    2378:	74730100 	ldrbtvc	r0, [r3], #-256
    237c:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    2380:	5f783031 	svcpl	0x00783031
    2384:	2f62696c 	svccs	0x0062696c
    2388:	00637273 	rsbeq	r7, r3, r3, ror r2
    238c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2390:	30316632 	eorscc	r6, r1, r2, lsr r6
    2394:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2398:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
    239c:	73000063 	movwvc	r0, #99	; 0x63
    23a0:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    23a4:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    23a8:	6970675f 	ldmdbvs	r0!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, sp, lr}^
    23ac:	00632e6f 	rsbeq	r2, r3, pc, ror #28
    23b0:	73000001 	movwvc	r0, #1	; 0x1
    23b4:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    23b8:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    23bc:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    23c0:	00682e65 	rsbeq	r2, r8, r5, ror #28
    23c4:	73000002 	movwvc	r0, #2	; 0x2
    23c8:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    23cc:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    23d0:	70616d5f 	rsbvc	r6, r1, pc, asr sp
    23d4:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    23d8:	74730000 	ldrbtvc	r0, [r3]
    23dc:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    23e0:	5f783031 	svcpl	0x00783031
    23e4:	6f697067 	svcvs	0x00697067
    23e8:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    23ec:	00000000 	andeq	r0, r0, r0
    23f0:	6acc0205 	bvs	ff302c0c <SCS_BASE+0x1f2f4c0c>
    23f4:	fc030800 	stc2	8, cr0, [r3], {0}
    23f8:	0a030100 	beq	c2800 <__Stack_Size+0xc2400>
    23fc:	200c0320 	andcs	r0, ip, r0, lsr #6
    2400:	33207603 	teqcc	r0, #3145728	; 0x300000
    2404:	352e7903 	strcc	r7, [lr, #-2307]!
    2408:	2e6a0333 	mcrcs	3, 3, r0, cr10, cr3, {1}
    240c:	22201603 	eorcs	r1, r0, #3145728	; 0x300000
    2410:	32303e32 	eorscc	r3, r0, #800	; 0x320
    2414:	312b3121 	teqcc	fp, r1, lsr #2
    2418:	207a0323 	rsbscs	r0, sl, r3, lsr #6
    241c:	22273a28 	eorcs	r3, r7, #163840	; 0x28000
    2420:	033c6603 	teqeq	ip, #3145728	; 0x300000
    2424:	30253c1f 	eorcc	r3, r5, pc, lsl ip
    2428:	322f5a31 	eorcc	r5, pc, #200704	; 0x31000
    242c:	312b3121 	teqcc	fp, r1, lsr #2
    2430:	207a0323 	rsbscs	r0, sl, r3, lsr #6
    2434:	22253a28 	eorcs	r3, r5, #163840	; 0x28000
    2438:	033c6903 	teqeq	ip, #49152	; 0xc000
    243c:	03223c1b 	teqeq	r2, #6912	; 0x1b00
    2440:	3d143c0b 	ldccc	12, cr3, [r4, #-44]
    2444:	0c032f2f 	stceq	15, cr2, [r3], {47}
    2448:	09031920 	stmdbeq	r3, {r5, r8, fp, ip}
    244c:	200a0358 	andcs	r0, sl, r8, asr r3
    2450:	0c032f16 	stceq	15, cr2, [r3], {22}
    2454:	0903192e 	stmdbeq	r3, {r1, r2, r3, r5, r8, fp, ip}
    2458:	200a0358 	andcs	r0, sl, r8, asr r3
    245c:	0d032f16 	stceq	15, cr2, [r3, #-88]
    2460:	0321172e 	teqeq	r1, #12058624	; 0xb80000
    2464:	2117200d 	tstcs	r7, sp
    2468:	18201003 	stmdane	r0!, {r0, r1, ip}
    246c:	03223222 	teqeq	r2, #536870914	; 0x20000002
    2470:	21162e0c 	tstcs	r6, ip, lsl #28
    2474:	19200d03 	stmdbne	r0!, {r0, r1, r8, sl, fp}
    2478:	22222230 	eorcs	r2, r2, #3	; 0x3
    247c:	0f032122 	svceq	0x00032122
    2480:	2c301920 	ldccs	9, cr1, [r0], #-128
    2484:	22302d31 	eorscs	r2, r0, #3136	; 0xc40
    2488:	3c0b032f 	stccc	3, cr0, [fp], {47}
    248c:	26032f16 	undefined
    2490:	200c034a 	andcs	r0, ip, sl, asr #6
    2494:	2076032c 	rsbscs	r0, r6, ip, lsr #6
    2498:	29222327 	stmdbcs	r2!, {r0, r1, r2, r5, r8, r9, sp}
    249c:	2f1f2333 	svccs	0x001f2333
    24a0:	676b3f4c 	strbvs	r3, [fp, -ip, asr #30]!
    24a4:	2f5b2231 	svccs	0x005b2231
    24a8:	274a0f03 	strbcs	r0, [sl, -r3, lsl #30]
    24ac:	9f1f2f3e 	svcls	0x001f2f3e
    24b0:	7ca70359 	stcvc	3, cr0, [r7], #356
    24b4:	212d214a 	teqcs	sp, sl, asr #2
    24b8:	45034b2f 	strmi	r4, [r3, #-2863]
    24bc:	241c242e 	ldrcs	r2, [ip], #-1070
    24c0:	a108241c 	tstge	r8, ip, lsl r4
    24c4:	324b324b 	subcc	r3, fp, #-1342177276	; 0xb0000004
    24c8:	324b324b 	subcc	r3, fp, #-1342177276	; 0xb0000004
    24cc:	324b324b 	subcc	r3, fp, #-1342177276	; 0xb0000004
    24d0:	06025e59 	undefined
    24d4:	a6010100 	strge	r0, [r1], -r0, lsl #2
    24d8:	02000001 	andeq	r0, r0, #1	; 0x1
    24dc:	00008600 	andeq	r8, r0, r0, lsl #12
    24e0:	fb010200 	blx	42cea <__Stack_Size+0x428ea>
    24e4:	01000d0e 	tsteq	r0, lr, lsl #26
    24e8:	00010101 	andeq	r0, r1, r1, lsl #2
    24ec:	00010000 	andeq	r0, r1, r0
    24f0:	74730100 	ldrbtvc	r0, [r3], #-256
    24f4:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    24f8:	5f783031 	svcpl	0x00783031
    24fc:	2f62696c 	svccs	0x0062696c
    2500:	00637273 	rsbeq	r7, r3, r3, ror r2
    2504:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2508:	30316632 	eorscc	r6, r1, r2, lsr r6
    250c:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2510:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
    2514:	73000063 	movwvc	r0, #99	; 0x63
    2518:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    251c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    2520:	69766e5f 	ldmdbvs	r6!, {r0, r1, r2, r3, r4, r6, r9, sl, fp, sp, lr}^
    2524:	00632e63 	rsbeq	r2, r3, r3, ror #28
    2528:	73000001 	movwvc	r0, #1	; 0x1
    252c:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    2530:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    2534:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    2538:	00682e65 	rsbeq	r2, r8, r5, ror #28
    253c:	73000002 	movwvc	r0, #2	; 0x2
    2540:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    2544:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    2548:	70616d5f 	rsbvc	r6, r1, pc, asr sp
    254c:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    2550:	74730000 	ldrbtvc	r0, [r3]
    2554:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    2558:	5f783031 	svcpl	0x00783031
    255c:	6369766e 	cmnvs	r9, #115343360	; 0x6e00000
    2560:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    2564:	00000000 	andeq	r0, r0, r0
    2568:	6d540205 	lfmvs	f0, 2, [r4, #-20]
    256c:	24030800 	strcs	r0, [r3], #-2048
    2570:	2d3d1501 	cfldr32cs	mvfx1, [sp, #-4]!
    2574:	207a0335 	rsbscs	r0, sl, r5, lsr r3
    2578:	1c322f2f 	ldcne	15, cr2, [r2], #-188
    257c:	2c302c24 	ldccs	12, cr2, [r0], #-144
    2580:	3c0b0324 	stccc	3, cr0, [fp], {36}
    2584:	211e3e15 	tstcs	lr, r5, lsl lr
    2588:	2321212f 	teqcs	r1, #-1073741813	; 0xc000000b
    258c:	212f213e 	teqcs	pc, lr, lsr r1
    2590:	66160321 	ldrvs	r0, [r6], -r1, lsr #6
    2594:	0d036717 	stceq	7, cr6, [r3, #-92]
    2598:	200a034a 	andcs	r0, sl, sl, asr #6
    259c:	031c243f 	tsteq	ip, #1056964608	; 0x3f000000
    25a0:	7603200a 	strvc	r2, [r3], -sl
    25a4:	3f3d5c20 	svccc	0x003d5c20
    25a8:	241f312b 	ldrcs	r3, [pc], #299	; 25b0 <__Stack_Size+0x21b0>
    25ac:	1e6a222b 	cdpne	2, 6, cr2, cr10, cr11, {1}
    25b0:	88312230 	ldmdahi	r1!, {r4, r5, r9, sp}
    25b4:	580b0393 	stmdapl	fp, {r0, r1, r4, r7, r8, r9}
    25b8:	21212f14 	teqcs	r1, r4, lsl pc
    25bc:	00d70321 	sbcseq	r0, r7, r1, lsr #6
    25c0:	03671320 	cmneq	r7, #-2147483648	; 0x80000000
    25c4:	4c19660b 	ldcmi	6, cr6, [r9], {11}
    25c8:	039e0903 	orrseq	r0, lr, #49152	; 0xc000
    25cc:	2f164a0a 	svccs	0x00164a0a
    25d0:	164a0a03 	strbne	r0, [sl], -r3, lsl #20
    25d4:	3c0b0391 	stccc	3, cr0, [fp], {145}
    25d8:	0b034b13 	bleq	d522c <__Stack_Size+0xd4e2c>
    25dc:	034c194a 	movteq	r1, #51530	; 0xc94a
    25e0:	0b039e09 	bleq	e9e0c <__Stack_Size+0xe9a0c>
    25e4:	032f134a 	teqeq	pc, #671088641	; 0x28000001
    25e8:	75174a10 	ldrvc	r4, [r7, #-2576]
    25ec:	133c0a03 	teqne	ip, #12288	; 0x3000
    25f0:	580a033d 	stmdapl	sl, {r0, r2, r3, r4, r5, r8, r9}
    25f4:	11033d13 	tstne	r3, r3, lsl sp
    25f8:	5c221758 	stcpl	7, cr1, [r2], #-352
    25fc:	3c11035a 	ldccc	3, cr0, [r1], {90}
    2600:	5c225a19 	stcpl	10, cr5, [r2], #-100
    2604:	4a18035a 	bmi	603374 <__Stack_Size+0x602f74>
    2608:	78200903 	stmdavc	r0!, {r0, r1, r8, fp}
    260c:	3f31694b 	svccc	0x0031694b
    2610:	282e7903 	stmdacs	lr!, {r0, r1, r8, fp, ip, sp, lr}
    2614:	25207a03 	strcs	r7, [r0, #-2563]!
    2618:	10035975 	andne	r5, r3, r5, ror r9
    261c:	4c23194a 	stcmi	9, cr1, [r3], #-296
    2620:	03820b03 	orreq	r0, r2, #3072	; 0xc00
    2624:	09033c0f 	stmdbeq	r3, {r0, r1, r2, r3, sl, fp, ip, sp}
    2628:	0e038301 	cdpeq	3, 0, cr8, cr3, cr1, {0}
    262c:	0109034a 	tsteq	r9, sl, asr #6
    2630:	3c140391 	ldccc	3, cr0, [r4], {145}
    2634:	5a010a03 	bpl	44e48 <__Stack_Size+0x44a48>
    2638:	03820b03 	orreq	r0, r2, #3072	; 0xc00
    263c:	23193c11 	tstcs	r9, #4352	; 0x1100
    2640:	03303e3e 	teqeq	r0, #992	; 0x3e0
    2644:	03285878 	teqeq	r8, #7864320	; 0x780000
    2648:	4b362078 	blmi	d8a830 <__Stack_Size+0xd8a430>
    264c:	31414022 	cmpcc	r1, r2, lsr #32
    2650:	033c0f03 	teqeq	ip, #12	; 0xc
    2654:	32300109 	eorscc	r0, r0, #1073741826	; 0x40000002
    2658:	0323241c 	teqeq	r3, #469762048	; 0x1c000000
    265c:	2f3c7c8d 	svccs	0x003c7c8d
    2660:	2e6f032f 	cdpcs	3, 6, cr0, cr15, cr15, {1}
    2664:	2f241c24 	svccs	0x00241c24
    2668:	2f3c6d03 	svccs	0x003c6d03
    266c:	2e72032f 	cdpcs	3, 7, cr0, cr2, cr15, {1}
    2670:	72032f2f 	andvc	r2, r3, #188	; 0xbc
    2674:	032f2f2e 	teqeq	pc, #184	; 0xb8
    2678:	2f2f2e72 	svccs	0x002f2e72
    267c:	01000202 	tsteq	r0, r2, lsl #4
    2680:	0000d201 	andeq	sp, r0, r1, lsl #4
    2684:	71000200 	tstvc	r0, r0, lsl #4
    2688:	02000000 	andeq	r0, r0, #0	; 0x0
    268c:	0d0efb01 	vstreq	d15, [lr, #-4]
    2690:	01010100 	tsteq	r1, r0, lsl #2
    2694:	00000001 	andeq	r0, r0, r1
    2698:	01000001 	tsteq	r0, r1
    269c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    26a0:	30316632 	eorscc	r6, r1, r2, lsr r6
    26a4:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    26a8:	72732f62 	rsbsvc	r2, r3, #392	; 0x188
    26ac:	74730063 	ldrbtvc	r0, [r3], #-99
    26b0:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    26b4:	5f783031 	svcpl	0x00783031
    26b8:	2f62696c 	svccs	0x0062696c
    26bc:	00636e69 	rsbeq	r6, r3, r9, ror #28
    26c0:	6d747300 	ldclvs	3, cr7, [r4]
    26c4:	31663233 	cmncc	r6, r3, lsr r2
    26c8:	705f7830 	subsvc	r7, pc, r0, lsr r8
    26cc:	632e7277 	teqvs	lr, #1879048199	; 0x70000007
    26d0:	00000100 	andeq	r0, r0, r0, lsl #2
    26d4:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    26d8:	30316632 	eorscc	r6, r1, r2, lsr r6
    26dc:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    26e0:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
    26e4:	00000200 	andeq	r0, r0, r0, lsl #4
    26e8:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    26ec:	30316632 	eorscc	r6, r1, r2, lsr r6
    26f0:	616d5f78 	smcvs	54776
    26f4:	00682e70 	rsbeq	r2, r8, r0, ror lr
    26f8:	00000002 	andeq	r0, r0, r2
    26fc:	d8020500 	stmdale	r2, {r8, sl}
    2700:	03080070 	movweq	r0, #32880	; 0x8070
    2704:	160100d1 	undefined
    2708:	4a0b032f 	bmi	2c33cc <__Stack_Size+0x2c2fcc>
    270c:	14032f16 	strne	r2, [r3], #-3862
    2710:	3131184a 	teqcc	r1, sl, asr #16
    2714:	0b032123 	bleq	caba8 <__Stack_Size+0xca7a8>
    2718:	032f164a 	teqeq	pc, #77594624	; 0x4a00000
    271c:	184a00d8 	stmdane	sl, {r3, r4, r6, r7}^
    2720:	03660b03 	cmneq	r6, #3072	; 0xc00
    2724:	59164a0d 	ldmdbpl	r6, {r0, r2, r3, r9, fp, lr}
    2728:	143c4303 	ldrtne	r4, [ip], #-771
    272c:	221e221e 	andscs	r2, lr, #-536870911	; 0xe0000001
    2730:	2f934d3f 	svccs	0x00934d3f
    2734:	1a4a4903 	bne	1294b48 <__Stack_Size+0x1294748>
    2738:	28207803 	stmdacs	r0!, {r0, r1, fp, ip, sp, lr}
    273c:	03207803 	teqeq	r0, #196608	; 0x30000
    2740:	2331200b 	teqcs	r1, #11	; 0xb
    2744:	3f1d6923 	svccc	0x001d6923
    2748:	03304123 	teqeq	r0, #-1073741816	; 0xc0000008
    274c:	214a7ef5 	strdcs	r7, [sl, #-229]
    2750:	01024b67 	tsteq	r2, r7, ror #22
    2754:	b4010100 	strlt	r0, [r1], #-256
    2758:	02000001 	andeq	r0, r0, #1	; 0x1
    275c:	00008400 	andeq	r8, r0, r0, lsl #8
    2760:	fb010200 	blx	42f6a <__Stack_Size+0x42b6a>
    2764:	01000d0e 	tsteq	r0, lr, lsl #26
    2768:	00010101 	andeq	r0, r1, r1, lsl #2
    276c:	00010000 	andeq	r0, r1, r0
    2770:	74730100 	ldrbtvc	r0, [r3], #-256
    2774:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    2778:	5f783031 	svcpl	0x00783031
    277c:	2f62696c 	svccs	0x0062696c
    2780:	00637273 	rsbeq	r7, r3, r3, ror r2
    2784:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2788:	30316632 	eorscc	r6, r1, r2, lsr r6
    278c:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2790:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
    2794:	73000063 	movwvc	r0, #99	; 0x63
    2798:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    279c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    27a0:	6363725f 	cmnvs	r3, #-268435451	; 0xf0000005
    27a4:	0100632e 	tsteq	r0, lr, lsr #6
    27a8:	74730000 	ldrbtvc	r0, [r3]
    27ac:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    27b0:	5f783031 	svcpl	0x00783031
    27b4:	65707974 	ldrbvs	r7, [r0, #-2420]!
    27b8:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    27bc:	74730000 	ldrbtvc	r0, [r3]
    27c0:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    27c4:	5f783031 	svcpl	0x00783031
    27c8:	2e70616d 	rpwcssz	f6, f0, #5.0
    27cc:	00020068 	andeq	r0, r2, r8, rrx
    27d0:	6d747300 	ldclvs	3, cr7, [r4]
    27d4:	31663233 	cmncc	r6, r3, lsr r2
    27d8:	725f7830 	subsvc	r7, pc, #3145728	; 0x300000
    27dc:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
    27e0:	00000200 	andeq	r0, r0, r0, lsl #4
    27e4:	02050000 	andeq	r0, r5, #0	; 0x0
    27e8:	080071b8 	stmdaeq	r0, {r3, r4, r5, r7, r8, ip, sp, lr}
    27ec:	0100fc03 	tstpeq	r0, r3, lsl #24
    27f0:	695b5b14 	ldmdbvs	fp, {r2, r4, r8, r9, fp, ip, lr}^
    27f4:	032f4d4d 	teqeq	pc, #4928	; 0x1340
    27f8:	26186611 	undefined
    27fc:	4d2e7a03 	fstmdbsmi	lr!, {s14-s16}
    2800:	50415c4d 	subpl	r5, r1, sp, asr #24
    2804:	213c0c03 	teqcs	ip, r3, lsl #24
    2808:	2006a303 	andcs	sl, r6, r3, lsl #6
    280c:	2079dd03 	rsbscs	sp, r9, r3, lsl #26
    2810:	2006a303 	andcs	sl, r6, r3, lsl #6
    2814:	2079e503 	rsbscs	lr, r9, r3, lsl #10
    2818:	03212d2f 	teqeq	r1, #3008	; 0xbc0
    281c:	0358069a 	cmpeq	r8, #161480704	; 0x9a00000
    2820:	035879f3 	cmpeq	r8, #3981312	; 0x3cc000
    2824:	31184a0c 	tstcc	r8, ip, lsl #20
    2828:	03213131 	teqeq	r1, #1073741836	; 0x4000000c
    282c:	2f163c0d 	svccs	0x00163c0d
    2830:	194a1403 	stmdbne	sl, {r0, r1, sl, ip}^
    2834:	03214d34 	teqeq	r1, #3328	; 0xd00
    2838:	2f163c0c 	svccs	0x00163c0c
    283c:	184a0e03 	stmdane	sl, {r0, r1, r9, sl, fp}^
    2840:	21233131 	teqcs	r3, r1, lsr r1
    2844:	134a0e03 	movtne	r0, #44547	; 0xae03
    2848:	4a15034b 	bmi	54357c <__Stack_Size+0x54317c>
    284c:	23313118 	teqcs	r1, #6	; 0x6
    2850:	4a110321 	bmi	4434dc <__Stack_Size+0x4430dc>
    2854:	23313118 	teqcs	r1, #6	; 0x6
    2858:	4a110321 	bmi	4434e4 <__Stack_Size+0x4430e4>
    285c:	31313118 	teqcc	r1, r8, lsl r1
    2860:	3c130321 	ldccc	3, cr0, [r3], {33}
    2864:	5a5d2317 	bpl	174b4c8 <__Stack_Size+0x174b0c8>
    2868:	163c1003 	ldrtne	r1, [ip], -r3
    286c:	4a10032f 	bmi	403530 <__Stack_Size+0x403130>
    2870:	23313118 	teqcs	r1, #6	; 0x6
    2874:	4a0f0321 	bmi	3c3500 <__Stack_Size+0x3c3100>
    2878:	7a033418 	bvc	cf8e0 <__Stack_Size+0xcf4e0>
    287c:	2a272320 	bcs	9cb504 <__Stack_Size+0x9cb104>
    2880:	343c0903 	ldrtcc	r0, [ip], #-2307
    2884:	164a0c03 	strbne	r0, [sl], -r3, lsl #24
    2888:	4a11032f 	bmi	44354c <__Stack_Size+0x44314c>
    288c:	0d034b17 	vstreq	d4, [r3, #-92]
    2890:	032f164a 	teqeq	pc, #77594624	; 0x4a00000
    2894:	1c164a0b 	ldcne	10, cr4, [r6], {11}
    2898:	0c032224 	sfmeq	f2, 4, [r3], {36}
    289c:	224c2166 	subcs	r2, ip, #-2147483623	; 0x80000019
    28a0:	69273a30 	stmdbvs	r7!, {r4, r5, r9, fp, ip, sp}
    28a4:	03267a78 	teqeq	r6, #491520	; 0x78000
    28a8:	2534207a 	ldrcs	r2, [r4, #-122]!
    28ac:	4177331b 	cmnmi	r7, fp, lsl r3
    28b0:	03364169 	teqeq	r6, #1073741850	; 0x4000001a
    28b4:	413f2078 	teqmi	pc, r8, ror r0
    28b8:	90150367 	andsls	r0, r5, r7, ror #6
    28bc:	5a5c2217 	bpl	170b120 <__Stack_Size+0x170ad20>
    28c0:	173c1403 	ldrne	r1, [ip, -r3, lsl #8]!
    28c4:	035a5c22 	cmpeq	sl, #8704	; 0x2200
    28c8:	22173c15 	andscs	r3, r7, #5376	; 0x1500
    28cc:	13035a5c 	movwne	r5, #14940	; 0x3a5c
    28d0:	5c22173c 	stcpl	7, cr1, [r2], #-240
    28d4:	3c14035a 	ldccc	3, cr0, [r4], {90}
    28d8:	5a5c2217 	bpl	170b13c <__Stack_Size+0x170ad3c>
    28dc:	163c0b03 	ldrtne	r0, [ip], -r3, lsl #22
    28e0:	4a0b032f 	bmi	2c35a4 <__Stack_Size+0x2c31a4>
    28e4:	10032f16 	andne	r2, r3, r6, lsl pc
    28e8:	032f174a 	teqeq	pc, #19398656	; 0x1280000
    28ec:	09034a16 	stmdbeq	r3, {r1, r2, r4, r9, fp, lr}
    28f0:	92302201 	eorsls	r2, r0, #268435456	; 0x10000000
    28f4:	11039430 	tstne	r3, r0, lsr r4
    28f8:	3c0d0382 	stccc	3, cr0, [sp], {130}
    28fc:	11035914 	tstne	r3, r4, lsl r9
    2900:	0b03193c 	bleq	c8df8 <__Stack_Size+0xc89f8>
    2904:	4a110366 	bmi	4436a4 <__Stack_Size+0x4432a4>
    2908:	04022f18 	streq	r2, [r2], #-3864
    290c:	b9010100 	stmdblt	r1, {r8}
    2910:	02000000 	andeq	r0, r0, #0	; 0x0
    2914:	00007500 	andeq	r7, r0, r0, lsl #10
    2918:	fb010200 	blx	43122 <__Stack_Size+0x42d22>
    291c:	01000d0e 	tsteq	r0, lr, lsl #26
    2920:	00010101 	andeq	r0, r1, r1, lsl #2
    2924:	00010000 	andeq	r0, r1, r0
    2928:	74730100 	ldrbtvc	r0, [r3], #-256
    292c:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    2930:	5f783031 	svcpl	0x00783031
    2934:	2f62696c 	svccs	0x0062696c
    2938:	00637273 	rsbeq	r7, r3, r3, ror r2
    293c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2940:	30316632 	eorscc	r6, r1, r2, lsr r6
    2944:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2948:	6e692f62 	cdpvs	15, 6, cr2, cr9, cr2, {3}
    294c:	73000063 	movwvc	r0, #99	; 0x63
    2950:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    2954:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    2958:	7379735f 	cmnvc	r9, #2080374785	; 0x7c000001
    295c:	6b636974 	blvs	18dcf34 <__Stack_Size+0x18dcb34>
    2960:	0100632e 	tsteq	r0, lr, lsr #6
    2964:	74730000 	ldrbtvc	r0, [r3]
    2968:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    296c:	5f783031 	svcpl	0x00783031
    2970:	65707974 	ldrbvs	r7, [r0, #-2420]!
    2974:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    2978:	74730000 	ldrbtvc	r0, [r3]
    297c:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    2980:	5f783031 	svcpl	0x00783031
    2984:	2e70616d 	rpwcssz	f6, f0, #5.0
    2988:	00020068 	andeq	r0, r2, r8, rrx
    298c:	05000000 	streq	r0, [r0]
    2990:	00755c02 	rsbseq	r5, r5, r2, lsl #24
    2994:	012b0308 	teqeq	fp, r8, lsl #6
    2998:	5a4e3016 	bpl	138e9f8 <__Stack_Size+0x138e5f8>
    299c:	163c0b03 	ldrtne	r0, [ip], -r3, lsl #22
    29a0:	4a0e032f 	bmi	383664 <__Stack_Size+0x383264>
    29a4:	3e4c3016 	mcrcc	0, 2, r3, cr12, cr6, {0}
    29a8:	0b033e6a 	bleq	d2358 <__Stack_Size+0xd1f58>
    29ac:	5c22164a 	stcpl	6, cr1, [r2], #-296
    29b0:	3c0a035a 	stccc	3, cr0, [sl], {90}
    29b4:	0e032f13 	mcreq	15, 0, r2, cr3, cr3, {0}
    29b8:	010a034a 	tsteq	sl, sl, asr #6
    29bc:	032e7603 	teqeq	lr, #3145728	; 0x300000
    29c0:	7822200a 	stmdavc	r2!, {r1, r3, sp}
    29c4:	02580c03 	subseq	r0, r8, #768	; 0x300
    29c8:	01010004 	tsteq	r1, r4
    29cc:	000001fa 	strdeq	r0, [r0], -sl
    29d0:	009b0002 	addseq	r0, fp, r2
    29d4:	01020000 	tsteq	r2, r0
    29d8:	000d0efb 	strdeq	r0, [sp], -fp
    29dc:	01010101 	tsteq	r1, r1, lsl #2
    29e0:	01000000 	tsteq	r0, r0
    29e4:	73010000 	movwvc	r0, #4096	; 0x1000
    29e8:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    29ec:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    29f0:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    29f4:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    29f8:	6d747300 	ldclvs	3, cr7, [r4]
    29fc:	31663233 	cmncc	r6, r3, lsr r2
    2a00:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    2a04:	692f6269 	stmdbvs	pc!, {r0, r3, r5, r6, r9, sp, lr}
    2a08:	0000636e 	andeq	r6, r0, lr, ror #6
    2a0c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2a10:	30316632 	eorscc	r6, r1, r2, lsr r6
    2a14:	73755f78 	cmnvc	r5, #480	; 0x1e0
    2a18:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
    2a1c:	00010063 	andeq	r0, r1, r3, rrx
    2a20:	6d747300 	ldclvs	3, cr7, [r4]
    2a24:	31663233 	cmncc	r6, r3, lsr r2
    2a28:	745f7830 	ldrbvc	r7, [pc], #2096	; 2a30 <__Stack_Size+0x2630>
    2a2c:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
    2a30:	00020068 	andeq	r0, r2, r8, rrx
    2a34:	6d747300 	ldclvs	3, cr7, [r4]
    2a38:	31663233 	cmncc	r6, r3, lsr r2
    2a3c:	6d5f7830 	ldclvs	8, cr7, [pc, #-192]
    2a40:	682e7061 	stmdavs	lr!, {r0, r5, r6, ip, sp, lr}
    2a44:	00000200 	andeq	r0, r0, r0, lsl #4
    2a48:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2a4c:	30316632 	eorscc	r6, r1, r2, lsr r6
    2a50:	73755f78 	cmnvc	r5, #480	; 0x1e0
    2a54:	2e747261 	cdpcs	2, 7, cr7, cr4, cr1, {3}
    2a58:	00020068 	andeq	r0, r2, r8, rrx
    2a5c:	6d747300 	ldclvs	3, cr7, [r4]
    2a60:	31663233 	cmncc	r6, r3, lsr r2
    2a64:	725f7830 	subsvc	r7, pc, #3145728	; 0x300000
    2a68:	682e6363 	stmdavs	lr!, {r0, r1, r5, r6, r8, r9, sp, lr}
    2a6c:	00000200 	andeq	r0, r0, r0, lsl #4
    2a70:	02050000 	andeq	r0, r5, #0	; 0x0
    2a74:	08007600 	stmdaeq	r0, {r9, sl, ip, sp, lr}
    2a78:	0101e803 	tsteq	r1, r3, lsl #16
    2a7c:	213d3d14 	teqcs	sp, r4, lsl sp
    2a80:	033d3d21 	teqeq	sp, #2112	; 0x840
    2a84:	18032e0f 	stmdane	r3, {r0, r1, r2, r3, r9, sl, fp, sp}
    2a88:	3c730301 	ldclcc	3, cr0, [r3], #-4
    2a8c:	03200d03 	teqeq	r0, #192	; 0xc0
    2a90:	0b035875 	bleq	d8c6c <__Stack_Size+0xd886c>
    2a94:	2e75032e 	cdpcs	3, 7, cr0, cr5, cr14, {1}
    2a98:	03200b03 	teqeq	r0, #3072	; 0xc00
    2a9c:	0b032075 	bleq	cac78 <__Stack_Size+0xca878>
    2aa0:	0b033d20 	bleq	d1f28 <__Stack_Size+0xd1b28>
    2aa4:	213d1420 	teqcs	sp, r0, lsr #8
    2aa8:	0e032121 	adfeqsp	f2, f3, f1
    2aac:	5d23172e 	stcpl	7, cr1, [r3, #-184]!
    2ab0:	2e1c0368 	cdpcs	3, 1, cr0, cr12, cr8, {3}
    2ab4:	41010d03 	tstmi	r1, r3, lsl #26
    2ab8:	033c6e03 	teqeq	ip, #48	; 0x30
    2abc:	03302012 	teqeq	r0, #18	; 0x12
    2ac0:	14032e6c 	strne	r2, [r3], #-3692
    2ac4:	3e302220 	cdpcc	2, 3, cr2, cr0, cr0, {1}
    2ac8:	40222232 	eormi	r2, r2, r2, lsr r2
    2acc:	3c13034c 	ldccc	3, cr0, [r3], {76}
    2ad0:	5a5e2418 	bpl	178bb38 <__Stack_Size+0x178b738>
    2ad4:	18200d03 	stmdane	r0!, {r0, r1, r8, sl, fp}
    2ad8:	10034b68 	andne	r4, r3, r8, ror #22
    2adc:	4b67172e 	blmi	19c879c <__Stack_Size+0x19c839c>
    2ae0:	172e0e03 	strne	r0, [lr, -r3, lsl #28]!
    2ae4:	03685d23 	cmneq	r8, #2240	; 0x8c0
    2ae8:	67172e11 	undefined
    2aec:	2e0e034b 	cdpcs	3, 0, cr0, cr14, cr11, {2}
    2af0:	685d2317 	ldmdavs	sp, {r0, r1, r2, r4, r8, r9, sp}^
    2af4:	182e0d03 	stmdane	lr!, {r0, r1, r8, sl, fp}
    2af8:	200c033d 	andcs	r0, ip, sp, lsr r3
    2afc:	0c033d17 	stceq	13, cr3, [r3], {23}
    2b00:	03591720 	cmpeq	r9, #8388608	; 0x800000
    2b04:	3e17200d 	wxorcc	wr2, wr7, wr13
    2b08:	2e0e0359 	mcrcs	3, 0, r0, cr14, cr9, {2}
    2b0c:	034b4c17 	movteq	r4, #48151	; 0xbc17
    2b10:	23172e0e 	tstcs	r7, #224	; 0xe0
    2b14:	0e03685d 	mcreq	8, 0, r6, cr3, cr13, {2}
    2b18:	5d23172e 	stcpl	7, cr1, [r3, #-184]!
    2b1c:	2e0e0368 	cdpcs	3, 0, cr0, cr14, cr8, {3}
    2b20:	685d2317 	ldmdavs	sp, {r0, r1, r2, r4, r8, r9, sp}^
    2b24:	172e1003 	strne	r1, [lr, -r3]!
    2b28:	0e034b67 	fnmacdeq	d4, d3, d23
    2b2c:	5d23172e 	stcpl	7, cr1, [r3, #-184]!
    2b30:	2e190368 	cdpcs	3, 1, cr0, cr9, cr8, {3}
    2b34:	5809031a 	stmdapl	r9, {r1, r3, r4, r8, r9}
    2b38:	18202303 	stmdane	r0!, {r0, r1, r8, r9, sp}
    2b3c:	2e1a034b 	cdpcs	3, 1, cr0, cr10, cr11, {2}
    2b40:	41010a03 	tstmi	r1, r3, lsl #20
    2b44:	242c305a 	strtcs	r3, [ip], #-90
    2b48:	3d4f3230 	sfmcc	f3, 2, [pc, #-192]
    2b4c:	9e0a0330 	mcrls	3, 0, r0, cr10, cr0, {1}
    2b50:	032e2303 	teqeq	lr, #201326592	; 0xc000000
    2b54:	0375010b 	cmneq	r5, #-1073741822	; 0xc0000002
    2b58:	032079a6 	teqeq	r0, #2719744	; 0x298000
    2b5c:	09030115 	stmdbeq	r3, {r0, r2, r4, r8}
    2b60:	20790320 	rsbscs	r0, r9, r0, lsr #6
    2b64:	5f033151 	svcpl	0x00033151
    2b68:	202d0320 	eorcs	r0, sp, r0, lsr #6
    2b6c:	03205303 	teqeq	r0, #201326592	; 0xc000000
    2b70:	7603202d 	strvc	r2, [r3], -sp, lsr #32
    2b74:	2e0a0320 	cdpcs	3, 0, cr0, cr10, cr0, {1}
    2b78:	032e7603 	teqeq	lr, #3145728	; 0x300000
    2b7c:	76032e0a 	strvc	r2, [r3], -sl, lsl #28
    2b80:	2e0a0320 	cdpcs	3, 0, cr0, cr10, cr0, {1}
    2b84:	2009033f 	andcs	r0, r9, pc, lsr r3
    2b88:	03207903 	teqeq	r0, #49152	; 0xc000
    2b8c:	39034a4e 	stmdbcc	r3, {r1, r2, r3, r6, r9, fp, lr}
    2b90:	20470320 	subcs	r0, r7, r0, lsr #6
    2b94:	03203903 	teqeq	r0, #49152	; 0xc000
    2b98:	12032047 	andne	r2, r3, #71	; 0x47
    2b9c:	202b0320 	eorcs	r0, fp, r0, lsr #6
    2ba0:	200b033d 	andcs	r0, fp, sp, lsr r3
    2ba4:	22207503 	eorcs	r7, r0, #12582912	; 0xc00000
    2ba8:	32832432 	addcc	r2, r3, #838860800	; 0x32000000
    2bac:	4b93321c 	blmi	fe4cf424 <SCS_BASE+0x1e4c1424>
    2bb0:	667efd03 	ldrbtvs	pc, [lr], -r3, lsl #26
    2bb4:	1c241c24 	stcne	12, cr1, [r4], #-144
    2bb8:	59230824 	stmdbpl	r3!, {r2, r5, fp}
    2bbc:	5940596a 	stmdbpl	r0, {r1, r3, r5, r6, r8, fp, ip, lr}^
    2bc0:	59405940 	stmdbpl	r0, {r6, r8, fp, ip, lr}^
    2bc4:	0006025e 	andeq	r0, r6, lr, asr r2
    2bc8:	00a00101 	adceq	r0, r0, r1, lsl #2
    2bcc:	00020000 	andeq	r0, r2, r0
    2bd0:	00000039 	andeq	r0, r0, r9, lsr r0
    2bd4:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    2bd8:	0101000d 	tsteq	r1, sp
    2bdc:	00000101 	andeq	r0, r0, r1, lsl #2
    2be0:	00000100 	andeq	r0, r0, r0, lsl #2
    2be4:	6d747301 	ldclvs	3, cr7, [r4, #-4]!
    2be8:	31663233 	cmncc	r6, r3, lsr r2
    2bec:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    2bf0:	732f6269 	teqvc	pc, #-1879048186	; 0x90000006
    2bf4:	00006372 	andeq	r6, r0, r2, ror r3
    2bf8:	74726f63 	ldrbtvc	r6, [r2], #-3939
    2bfc:	336d7865 	cmncc	sp, #6619136	; 0x650000
    2c00:	63616d5f 	cmnvs	r1, #6080	; 0x17c0
    2c04:	732e6f72 	teqvc	lr, #456	; 0x1c8
    2c08:	00000100 	andeq	r0, r0, r0, lsl #2
    2c0c:	02050000 	andeq	r0, r5, #0	; 0x0
    2c10:	080079bc 	stmdaeq	r0, {r2, r3, r4, r5, r7, r8, fp, ip, sp, lr}
    2c14:	21013403 	tstcs	r1, r3, lsl #8
    2c18:	21200b03 	teqcs	r0, r3, lsl #22
    2c1c:	21200b03 	teqcs	r0, r3, lsl #22
    2c20:	2f200b03 	svccs	0x00200b03
    2c24:	2f200b03 	svccs	0x00200b03
    2c28:	2f200b03 	svccs	0x00200b03
    2c2c:	21200b03 	teqcs	r0, r3, lsl #22
    2c30:	2f200b03 	svccs	0x00200b03
    2c34:	2f200b03 	svccs	0x00200b03
    2c38:	200a032f 	andcs	r0, sl, pc, lsr #6
    2c3c:	200b032f 	andcs	r0, fp, pc, lsr #6
    2c40:	200b032f 	andcs	r0, fp, pc, lsr #6
    2c44:	200b032f 	andcs	r0, fp, pc, lsr #6
    2c48:	200a032f 	andcs	r0, sl, pc, lsr #6
    2c4c:	200b0321 	andcs	r0, fp, r1, lsr #6
    2c50:	200b0321 	andcs	r0, fp, r1, lsr #6
    2c54:	200b0321 	andcs	r0, fp, r1, lsr #6
    2c58:	200b0321 	andcs	r0, fp, r1, lsr #6
    2c5c:	200b032f 	andcs	r0, fp, pc, lsr #6
    2c60:	200a032f 	andcs	r0, sl, pc, lsr #6
    2c64:	200b0321 	andcs	r0, fp, r1, lsr #6
    2c68:	00010221 	andeq	r0, r1, r1, lsr #4
    2c6c:	005a0101 	subseq	r0, sl, r1, lsl #2
    2c70:	00020000 	andeq	r0, r2, r0
    2c74:	0000003b 	andeq	r0, r0, fp, lsr r0
    2c78:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    2c7c:	0101000d 	tsteq	r1, sp
    2c80:	00000101 	andeq	r0, r0, r1, lsl #2
    2c84:	00000100 	andeq	r0, r0, r0, lsl #2
    2c88:	6d747301 	ldclvs	3, cr7, [r4, #-4]!
    2c8c:	31663233 	cmncc	r6, r3, lsr r2
    2c90:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    2c94:	732f6269 	teqvc	pc, #-1879048186	; 0x90000006
    2c98:	00006372 	andeq	r6, r0, r2, ror r3
    2c9c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    2ca0:	30316632 	eorscc	r6, r1, r2, lsr r6
    2ca4:	65765f78 	ldrbvs	r5, [r6, #-3960]!
    2ca8:	726f7463 	rsbvc	r7, pc, #1660944384	; 0x63000000
    2cac:	0100632e 	tsteq	r0, lr, lsr #6
    2cb0:	00000000 	andeq	r0, r0, r0
    2cb4:	7a2c0205 	bvc	b034d0 <__Stack_Size+0xb030d0>
    2cb8:	91030800 	tstls	r3, r0, lsl #16
    2cbc:	27580101 	ldrbcs	r0, [r8, -r1, lsl #2]
    2cc0:	2260563e 	rsbcs	r5, r0, #65011712	; 0x3e00000
    2cc4:	022f3648 	eoreq	r3, pc, #75497472	; 0x4800000
    2cc8:	0101000e 	tsteq	r1, lr
    2ccc:	00000070 	andeq	r0, r0, r0, ror r0
    2cd0:	00570002 	subseq	r0, r7, r2
    2cd4:	01020000 	tsteq	r2, r0
    2cd8:	000d0efb 	strdeq	r0, [sp], -fp
    2cdc:	01010101 	tsteq	r1, r1, lsl #2
    2ce0:	01000000 	tsteq	r0, r0
    2ce4:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    2ce8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    2cec:	2f2e2e2f 	svccs	0x002e2e2f
    2cf0:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    2cf4:	63672f2e 	cmnvs	r7, #184	; 0xb8
    2cf8:	2e342d63 	cdpcs	13, 3, cr2, cr4, cr3, {3}
    2cfc:	2f302e33 	svccs	0x00302e33
    2d00:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    2d04:	6c2f6269 	sfmvs	f6, 4, [pc], #-420
    2d08:	2f636269 	svccs	0x00636269
    2d0c:	6c647473 	cfstrdvs	mvd7, [r4], #-460
    2d10:	00006269 	andeq	r6, r0, r9, ror #4
    2d14:	78657461 	stmdavc	r5!, {r0, r5, r6, sl, ip, sp, lr}^
    2d18:	632e7469 	teqvs	lr, #1761607680	; 0x69000000
    2d1c:	00000100 	andeq	r0, r0, r0, lsl #2
    2d20:	78657461 	stmdavc	r5!, {r0, r5, r6, sl, ip, sp, lr}^
    2d24:	682e7469 	stmdavs	lr!, {r0, r3, r5, r6, sl, ip, sp, lr}
    2d28:	00000100 	andeq	r0, r0, r0, lsl #2
    2d2c:	02050000 	andeq	r0, r5, #0	; 0x0
    2d30:	00000000 	andeq	r0, r0, r0
    2d34:	4b013f03 	blmi	52948 <__Stack_Size+0x52548>
    2d38:	02672f2d 	rsbeq	r2, r7, #180	; 0xb4
    2d3c:	01010006 	tsteq	r1, r6
    2d40:	000000eb 	andeq	r0, r0, fp, ror #1
    2d44:	00d00002 	sbcseq	r0, r0, r2
    2d48:	01020000 	tsteq	r2, r0
    2d4c:	000d0efb 	strdeq	r0, [sp], -fp
    2d50:	01010101 	tsteq	r1, r1, lsl #2
    2d54:	01000000 	tsteq	r0, r0
    2d58:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    2d5c:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    2d60:	2f2e2e2f 	svccs	0x002e2e2f
    2d64:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    2d68:	63672f2e 	cmnvs	r7, #184	; 0xb8
    2d6c:	2e342d63 	cdpcs	13, 3, cr2, cr4, cr3, {3}
    2d70:	2f302e33 	svccs	0x00302e33
    2d74:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    2d78:	6c2f6269 	sfmvs	f6, 4, [pc], #-420
    2d7c:	2f636269 	svccs	0x00636269
    2d80:	6c647473 	cfstrdvs	mvd7, [r4], #-460
    2d84:	63006269 	movwvs	r6, #617	; 0x269
    2d88:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
    2d8c:	6d72616e 	ldfvse	f6, [r2, #-440]!
    2d90:	75622f73 	strbvc	r2, [r2, #-3955]!
    2d94:	2f646c69 	svccs	0x00646c69
    2d98:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    2d9c:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
    2da0:	656e2f30 	strbvs	r2, [lr, #-3888]!
    2da4:	62696c77 	rsbvs	r6, r9, #30464	; 0x7700
    2da8:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    2dac:	6e692f63 	cdpvs	15, 6, cr2, cr9, cr3, {3}
    2db0:	64756c63 	ldrbtvs	r6, [r5], #-3171
    2db4:	79732f65 	ldmdbvc	r3!, {r0, r2, r5, r6, r8, r9, sl, fp, sp}^
    2db8:	3a630073 	bcc	18c2f8c <__Stack_Size+0x18c2b8c>
    2dbc:	6e69772f 	cdpvs	7, 6, cr7, cr9, cr15, {1}
    2dc0:	736d7261 	cmnvc	sp, #268435462	; 0x10000006
    2dc4:	6975622f 	ldmdbvs	r5!, {r0, r1, r2, r3, r5, r9, sp, lr}^
    2dc8:	672f646c 	strvs	r6, [pc, -ip, ror #8]!
    2dcc:	622d6363 	eorvs	r6, sp, #-1946157055	; 0x8c000001
    2dd0:	646c6975 	strbtvs	r6, [ip], #-2421
    2dd4:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    2dd8:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    2ddc:	6564756c 	strbvs	r7, [r4, #-1388]!
    2de0:	78650000 	stmdavc	r5!, {}^
    2de4:	632e7469 	teqvs	lr, #1761607680	; 0x69000000
    2de8:	00000100 	andeq	r0, r0, r0, lsl #2
    2dec:	6b636f6c 	blvs	18deba4 <__Stack_Size+0x18de7a4>
    2df0:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    2df4:	745f0000 	ldrbvc	r0, [pc], #0	; 2dfc <__Stack_Size+0x29fc>
    2df8:	73657079 	cmnvc	r5, #121	; 0x79
    2dfc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    2e00:	74730000 	ldrbtvc	r0, [r3]
    2e04:	66656464 	strbtvs	r6, [r5], -r4, ror #8
    2e08:	0300682e 	movweq	r6, #2094	; 0x82e
    2e0c:	65720000 	ldrbvs	r0, [r2]!
    2e10:	2e746e65 	cdpcs	14, 7, cr6, cr4, cr5, {3}
    2e14:	00020068 	andeq	r0, r2, r8, rrx
    2e18:	05000000 	streq	r0, [r0]
    2e1c:	007a8002 	rsbseq	r8, sl, r2
    2e20:	013b0308 	teqeq	fp, r8, lsl #6
    2e24:	302f2d13 	eorcc	r2, pc, r3, lsl sp
    2e28:	06024b83 	streq	r4, [r2], -r3, lsl #23
    2e2c:	d7010100 	strle	r0, [r1, -r0, lsl #2]
    2e30:	02000000 	andeq	r0, r0, #0	; 0x0
    2e34:	0000d100 	andeq	sp, r0, r0, lsl #2
    2e38:	fb010200 	blx	43642 <__Stack_Size+0x43242>
    2e3c:	01000d0e 	tsteq	r0, lr, lsl #26
    2e40:	00010101 	andeq	r0, r1, r1, lsl #2
    2e44:	00010000 	andeq	r0, r1, r0
    2e48:	3a630100 	bcc	18c3250 <__Stack_Size+0x18c2e50>
    2e4c:	6e69772f 	cdpvs	7, 6, cr7, cr9, cr15, {1}
    2e50:	736d7261 	cmnvc	sp, #268435462	; 0x10000006
    2e54:	6975622f 	ldmdbvs	r5!, {r0, r1, r2, r3, r5, r9, sp, lr}^
    2e58:	672f646c 	strvs	r6, [pc, -ip, ror #8]!
    2e5c:	342d6363 	strtcc	r6, [sp], #-867
    2e60:	302e332e 	eorcc	r3, lr, lr, lsr #6
    2e64:	77656e2f 	strbvc	r6, [r5, -pc, lsr #28]!
    2e68:	2f62696c 	svccs	0x0062696c
    2e6c:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    2e70:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    2e74:	6564756c 	strbvs	r7, [r4, #-1388]!
    2e78:	7379732f 	cmnvc	r9, #-1140850688	; 0xbc000000
    2e7c:	2f3a6300 	svccs	0x003a6300
    2e80:	616e6977 	smcvs	59031
    2e84:	2f736d72 	svccs	0x00736d72
    2e88:	6c697562 	cfstr64vs	mvdx7, [r9], #-392
    2e8c:	63672f64 	cmnvs	r7, #400	; 0x190
    2e90:	75622d63 	strbvc	r2, [r2, #-3427]!
    2e94:	2f646c69 	svccs	0x00646c69
    2e98:	2f636367 	svccs	0x00636367
    2e9c:	6c636e69 	stclvs	14, cr6, [r3], #-420
    2ea0:	00656475 	rsbeq	r6, r5, r5, ror r4
    2ea4:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    2ea8:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    2eac:	2f2e2e2f 	svccs	0x002e2e2f
    2eb0:	672f2e2e 	strvs	r2, [pc, -lr, lsr #28]!
    2eb4:	342d6363 	strtcc	r6, [sp], #-867
    2eb8:	302e332e 	eorcc	r3, lr, lr, lsr #6
    2ebc:	77656e2f 	strbvc	r6, [r5, -pc, lsr #28]!
    2ec0:	2f62696c 	svccs	0x0062696c
    2ec4:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    2ec8:	6565722f 	strbvs	r7, [r5, #-559]!
    2ecc:	0000746e 	andeq	r7, r0, lr, ror #8
    2ed0:	6b636f6c 	blvs	18dec88 <__Stack_Size+0x18de888>
    2ed4:	0100682e 	tsteq	r0, lr, lsr #16
    2ed8:	745f0000 	ldrbvc	r0, [pc], #0	; 2ee0 <__Stack_Size+0x2ae0>
    2edc:	73657079 	cmnvc	r5, #121	; 0x79
    2ee0:	0100682e 	tsteq	r0, lr, lsr #16
    2ee4:	74730000 	ldrbtvc	r0, [r3]
    2ee8:	66656464 	strbtvs	r6, [r5], -r4, ror #8
    2eec:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    2ef0:	65720000 	ldrbvs	r0, [r2]!
    2ef4:	2e746e65 	cdpcs	14, 7, cr6, cr4, cr5, {3}
    2ef8:	00010068 	andeq	r0, r1, r8, rrx
    2efc:	706d6900 	rsbvc	r6, sp, r0, lsl #18
    2f00:	2e657275 	mcrcs	2, 3, r7, cr5, cr5, {3}
    2f04:	00030063 	andeq	r0, r3, r3, rrx
    2f08:	00a20000 	adceq	r0, r2, r0
    2f0c:	00020000 	andeq	r0, r2, r0
    2f10:	0000007a 	andeq	r0, r0, sl, ror r0
    2f14:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    2f18:	0101000d 	tsteq	r1, sp
    2f1c:	00000101 	andeq	r0, r0, r1, lsl #2
    2f20:	00000100 	andeq	r0, r0, r0, lsl #2
    2f24:	2f2e2e01 	svccs	0x002e2e01
    2f28:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    2f2c:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    2f30:	2f2e2e2f 	svccs	0x002e2e2f
    2f34:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    2f38:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
    2f3c:	656e2f30 	strbvs	r2, [lr, #-3888]!
    2f40:	62696c77 	rsbvs	r6, r9, #30464	; 0x7700
    2f44:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    2f48:	696d2f63 	stmdbvs	sp!, {r0, r1, r5, r6, r8, r9, sl, fp, sp}^
    2f4c:	63006373 	movwvs	r6, #883	; 0x373
    2f50:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
    2f54:	6d72616e 	ldfvse	f6, [r2, #-440]!
    2f58:	75622f73 	strbvc	r2, [r2, #-3955]!
    2f5c:	2f646c69 	svccs	0x00646c69
    2f60:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    2f64:	6c697562 	cfstr64vs	mvdx7, [r9], #-392
    2f68:	63672f64 	cmnvs	r7, #400	; 0x190
    2f6c:	6e692f63 	cdpvs	15, 6, cr2, cr9, cr3, {3}
    2f70:	64756c63 	ldrbtvs	r6, [r5], #-3171
    2f74:	69000065 	stmdbvs	r0, {r0, r2, r5, r6}
    2f78:	2e74696e 	cdpcs	9, 7, cr6, cr4, cr14, {3}
    2f7c:	00010063 	andeq	r0, r1, r3, rrx
    2f80:	64747300 	ldrbtvs	r7, [r4], #-768
    2f84:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    2f88:	00020068 	andeq	r0, r2, r8, rrx
    2f8c:	05000000 	streq	r0, [r0]
    2f90:	00000002 	andeq	r0, r0, r2
    2f94:	01310300 	teqeq	r1, r0, lsl #6
    2f98:	65676732 	strbvs	r6, [r7, #-1842]!
    2f9c:	65032f69 	strvs	r2, [r3, #-3945]
    2fa0:	67673282 	strbvs	r3, [r7, -r2, lsl #5]!
    2fa4:	67306965 	ldrvs	r6, [r0, -r5, ror #18]!
    2fa8:	02686567 	rsbeq	r6, r8, #432013312	; 0x19c00000
    2fac:	0101000c 	tsteq	r1, ip
    2fb0:	000000d1 	ldrdeq	r0, [r0], -r1
    2fb4:	007e0002 	rsbseq	r0, lr, r2
    2fb8:	01020000 	tsteq	r2, r0
    2fbc:	000d0efb 	strdeq	r0, [sp], -fp
    2fc0:	01010101 	tsteq	r1, r1, lsl #2
    2fc4:	01000000 	tsteq	r0, r0
    2fc8:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    2fcc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    2fd0:	2f2e2e2f 	svccs	0x002e2e2f
    2fd4:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    2fd8:	63672f2e 	cmnvs	r7, #184	; 0xb8
    2fdc:	2e342d63 	cdpcs	13, 3, cr2, cr4, cr3, {3}
    2fe0:	2f302e33 	svccs	0x00302e33
    2fe4:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    2fe8:	6c2f6269 	sfmvs	f6, 4, [pc], #-420
    2fec:	2f636269 	svccs	0x00636269
    2ff0:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    2ff4:	6300676e 	movwvs	r6, #1902	; 0x76e
    2ff8:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
    2ffc:	6d72616e 	ldfvse	f6, [r2, #-440]!
    3000:	75622f73 	strbvc	r2, [r2, #-3955]!
    3004:	2f646c69 	svccs	0x00646c69
    3008:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    300c:	6c697562 	cfstr64vs	mvdx7, [r9], #-392
    3010:	63672f64 	cmnvs	r7, #400	; 0x190
    3014:	6e692f63 	cdpvs	15, 6, cr2, cr9, cr3, {3}
    3018:	64756c63 	ldrbtvs	r6, [r5], #-3171
    301c:	6d000065 	stcvs	0, cr0, [r0, #-404]
    3020:	70636d65 	rsbvc	r6, r3, r5, ror #26
    3024:	00632e79 	rsbeq	r2, r3, r9, ror lr
    3028:	73000001 	movwvc	r0, #1	; 0x1
    302c:	65646474 	strbvs	r6, [r4, #-1140]!
    3030:	00682e66 	rsbeq	r2, r8, r6, ror #28
    3034:	00000002 	andeq	r0, r0, r2
    3038:	00020500 	andeq	r0, r2, r0, lsl #10
    303c:	03000000 	movweq	r0, #0	; 0x0
    3040:	16030138 	undefined
    3044:	2e6a032e 	cdpcs	3, 6, cr0, cr10, cr14, {1}
    3048:	034a0f03 	movteq	r0, #44803	; 0xaf03
    304c:	12032e71 	andne	r2, r3, #1808	; 0x710
    3050:	1b03322e 	blne	cf910 <__Stack_Size+0xcf510>
    3054:	4f656782 	svcmi	0x00656782
    3058:	6b666303 	blvs	199bc6c <__Stack_Size+0x199b86c>
    305c:	60034b4b 	andvs	r4, r3, fp, asr #22
    3060:	2e21034a 	cdpcs	3, 2, cr0, cr1, cr10, {2}
    3064:	5f033329 	svcpl	0x00033329
    3068:	4a1c032e 	bmi	703d28 <__Stack_Size+0x703928>
    306c:	032e6403 	teqeq	lr, #50331648	; 0x3000000
    3070:	5a039e26 	bpl	ea910 <__Stack_Size+0xea510>
    3074:	4a26032e 	bmi	983d34 <__Stack_Size+0x983934>
    3078:	5a03644c 	bpl	dc1b0 <__Stack_Size+0xdbdb0>
    307c:	d62e0366 	strtle	r0, [lr], -r6, ror #6
    3080:	01000402 	tsteq	r0, r2, lsl #8
    3084:	0000d801 	andeq	sp, r0, r1, lsl #16
    3088:	7e000200 	cdpvc	2, 0, cr0, cr0, cr0, {0}
    308c:	02000000 	andeq	r0, r0, #0	; 0x0
    3090:	0d0efb01 	vstreq	d15, [lr, #-4]
    3094:	01010100 	tsteq	r1, r0, lsl #2
    3098:	00000001 	andeq	r0, r0, r1
    309c:	01000001 	tsteq	r0, r1
    30a0:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    30a4:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    30a8:	2f2e2e2f 	svccs	0x002e2e2f
    30ac:	672f2e2e 	strvs	r2, [pc, -lr, lsr #28]!
    30b0:	342d6363 	strtcc	r6, [sp], #-867
    30b4:	302e332e 	eorcc	r3, lr, lr, lsr #6
    30b8:	77656e2f 	strbvc	r6, [r5, -pc, lsr #28]!
    30bc:	2f62696c 	svccs	0x0062696c
    30c0:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    30c4:	7274732f 	rsbsvc	r7, r4, #-1140850688	; 0xbc000000
    30c8:	00676e69 	rsbeq	r6, r7, r9, ror #28
    30cc:	772f3a63 	strvc	r3, [pc, -r3, ror #20]!
    30d0:	72616e69 	rsbvc	r6, r1, #1680	; 0x690
    30d4:	622f736d 	eorvs	r7, pc, #-1275068415	; 0xb4000001
    30d8:	646c6975 	strbtvs	r6, [ip], #-2421
    30dc:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    30e0:	6975622d 	ldmdbvs	r5!, {r0, r2, r3, r5, r9, sp, lr}^
    30e4:	672f646c 	strvs	r6, [pc, -ip, ror #8]!
    30e8:	692f6363 	stmdbvs	pc!, {r0, r1, r5, r6, r8, r9, sp, lr}
    30ec:	756c636e 	strbvc	r6, [ip, #-878]!
    30f0:	00006564 	andeq	r6, r0, r4, ror #10
    30f4:	736d656d 	cmnvc	sp, #457179136	; 0x1b400000
    30f8:	632e7465 	teqvs	lr, #1694498816	; 0x65000000
    30fc:	00000100 	andeq	r0, r0, r0, lsl #2
    3100:	64647473 	strbtvs	r7, [r4], #-1139
    3104:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
    3108:	00000200 	andeq	r0, r0, r0, lsl #4
    310c:	02050000 	andeq	r0, r5, #0	; 0x0
    3110:	00000000 	andeq	r0, r0, r0
    3114:	03012e03 	movweq	r2, #7683	; 0x1e03
    3118:	6e030112 	mcrvs	1, 0, r0, cr3, cr2, {0}
    311c:	2e0b032e 	cdpcs	3, 0, cr0, cr11, cr14, {1}
    3120:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    3124:	03312e0f 	teqeq	r1, #240	; 0xf0
    3128:	76036613 	undefined
    312c:	09032f2e 	stmdbeq	r3, {r1, r2, r3, r5, r8, r9, sl, fp, sp}
    3130:	7a036c2e 	bvc	de1f0 <__Stack_Size+0xdddf0>
    3134:	2f2f302e 	svccs	0x002f302e
    3138:	2e56032f 	cdpcs	3, 5, cr0, cr6, cr15, {1}
    313c:	032e2503 	teqeq	lr, #12582912	; 0xc00000
    3140:	2e032e5b 	mcrcs	14, 0, r2, cr3, cr11, {2}
    3144:	2e520382 	cdpcs	3, 5, cr0, cr2, cr2, {4}
    3148:	032e2e03 	teqeq	lr, #48	; 0x30
    314c:	0b032e77 	bleq	ceb30 <__Stack_Size+0xce730>
    3150:	5203482e 	andpl	r4, r3, #3014656	; 0x2e0000
    3154:	9e340366 	cdpls	3, 3, cr0, cr4, cr6, {3}
    3158:	51488431 	cmppl	r8, r1, lsr r4
    315c:	01000602 	tsteq	r0, r2, lsl #12
    3160:	00012301 	andeq	r2, r1, r1, lsl #6
    3164:	e0000200 	and	r0, r0, r0, lsl #4
    3168:	02000000 	andeq	r0, r0, #0	; 0x0
    316c:	0d0efb01 	vstreq	d15, [lr, #-4]
    3170:	01010100 	tsteq	r1, r0, lsl #2
    3174:	00000001 	andeq	r0, r0, r1
    3178:	01000001 	tsteq	r0, r1
    317c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    3180:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    3184:	2f2e2e2f 	svccs	0x002e2e2f
    3188:	672f2e2e 	strvs	r2, [pc, -lr, lsr #28]!
    318c:	342d6363 	strtcc	r6, [sp], #-867
    3190:	302e332e 	eorcc	r3, lr, lr, lsr #6
    3194:	77656e2f 	strbvc	r6, [r5, -pc, lsr #28]!
    3198:	2f62696c 	svccs	0x0062696c
    319c:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    31a0:	6474732f 	ldrbtvs	r7, [r4], #-815
    31a4:	0062696c 	rsbeq	r6, r2, ip, ror #18
    31a8:	772f3a63 	strvc	r3, [pc, -r3, ror #20]!
    31ac:	72616e69 	rsbvc	r6, r1, #1680	; 0x690
    31b0:	622f736d 	eorvs	r7, pc, #-1275068415	; 0xb4000001
    31b4:	646c6975 	strbtvs	r6, [ip], #-2421
    31b8:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    31bc:	332e342d 	teqcc	lr, #754974720	; 0x2d000000
    31c0:	6e2f302e 	cdpvs	0, 2, cr3, cr15, cr14, {1}
    31c4:	696c7765 	stmdbvs	ip!, {r0, r2, r5, r6, r8, r9, sl, ip, sp, lr}^
    31c8:	696c2f62 	stmdbvs	ip!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    31cc:	692f6362 	stmdbvs	pc!, {r1, r5, r6, r8, r9, sp, lr}
    31d0:	756c636e 	strbvc	r6, [ip, #-878]!
    31d4:	732f6564 	teqvc	pc, #419430400	; 0x19000000
    31d8:	63007379 	movwvs	r7, #889	; 0x379
    31dc:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
    31e0:	6d72616e 	ldfvse	f6, [r2, #-440]!
    31e4:	75622f73 	strbvc	r2, [r2, #-3955]!
    31e8:	2f646c69 	svccs	0x00646c69
    31ec:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    31f0:	6c697562 	cfstr64vs	mvdx7, [r9], #-392
    31f4:	63672f64 	cmnvs	r7, #400	; 0x190
    31f8:	6e692f63 	cdpvs	15, 6, cr2, cr9, cr3, {3}
    31fc:	64756c63 	ldrbtvs	r6, [r5], #-3171
    3200:	5f000065 	svcpl	0x00000065
    3204:	6574615f 	ldrbvs	r6, [r4, #-351]!
    3208:	2e746978 	mrccs	9, 3, r6, cr4, cr8, {3}
    320c:	00010063 	andeq	r0, r1, r3, rrx
    3210:	636f6c00 	cmnvs	pc, #0	; 0x0
    3214:	00682e6b 	rsbeq	r2, r8, fp, ror #28
    3218:	5f000002 	svcpl	0x00000002
    321c:	65707974 	ldrbvs	r7, [r0, #-2420]!
    3220:	00682e73 	rsbeq	r2, r8, r3, ror lr
    3224:	73000002 	movwvc	r0, #2	; 0x2
    3228:	65646474 	strbvs	r6, [r4, #-1140]!
    322c:	00682e66 	rsbeq	r2, r8, r6, ror #28
    3230:	72000003 	andvc	r0, r0, #3	; 0x3
    3234:	746e6565 	strbtvc	r6, [lr], #-1381
    3238:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    323c:	74610000 	strbtvc	r0, [r1]
    3240:	74697865 	strbtvc	r7, [r9], #-2149
    3244:	0100682e 	tsteq	r0, lr, lsr #16
    3248:	00000000 	andeq	r0, r0, r0
    324c:	00000205 	andeq	r0, r0, r5, lsl #4
    3250:	16030000 	strne	r0, [r3], -r0
    3254:	010a0301 	tsteq	sl, r1, lsl #6
    3258:	032e7603 	teqeq	lr, #3145728	; 0x300000
    325c:	2f4b2e0a 	svccs	0x004b2e0a
    3260:	032e7403 	teqeq	lr, #50331648	; 0x3000000
    3264:	2f2d2e0d 	svccs	0x002d2e0d
    3268:	032e7303 	teqeq	lr, #201326592	; 0xc000000
    326c:	1703660d 	strne	r6, [r3, -sp, lsl #12]
    3270:	4a1b034a 	bmi	6c3fa0 <__Stack_Size+0x6c3ba0>
    3274:	4a7603a3 	bmi	1d84108 <__Stack_Size+0x1d83d08>
    3278:	2d2f2b4c 	vstmdbcs	pc!, {d2-<overflow reg d39>}
    327c:	302f2b32 	eorcc	r2, pc, r2, lsr fp
    3280:	02312d2c 	eorseq	r2, r1, #2816	; 0xb00
    3284:	01010006 	tsteq	r1, r6
    3288:	0000011b 	andeq	r0, r0, fp, lsl r1
    328c:	00d90002 	sbcseq	r0, r9, r2
    3290:	01020000 	tsteq	r2, r0
    3294:	000d0efb 	strdeq	r0, [sp], -fp
    3298:	01010101 	tsteq	r1, r1, lsl #2
    329c:	01000000 	tsteq	r0, r0
    32a0:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    32a4:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    32a8:	2f2e2e2f 	svccs	0x002e2e2f
    32ac:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    32b0:	63672f2e 	cmnvs	r7, #184	; 0xb8
    32b4:	2e342d63 	cdpcs	13, 3, cr2, cr4, cr3, {3}
    32b8:	2f302e33 	svccs	0x00302e33
    32bc:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    32c0:	6c2f6269 	sfmvs	f6, 4, [pc], #-420
    32c4:	2f636269 	svccs	0x00636269
    32c8:	6c647473 	cfstrdvs	mvd7, [r4], #-460
    32cc:	63006269 	movwvs	r6, #617	; 0x269
    32d0:	69772f3a 	ldmdbvs	r7!, {r1, r3, r4, r5, r8, r9, sl, fp, sp}^
    32d4:	6d72616e 	ldfvse	f6, [r2, #-440]!
    32d8:	75622f73 	strbvc	r2, [r2, #-3955]!
    32dc:	2f646c69 	svccs	0x00646c69
    32e0:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    32e4:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
    32e8:	656e2f30 	strbvs	r2, [lr, #-3888]!
    32ec:	62696c77 	rsbvs	r6, r9, #30464	; 0x7700
    32f0:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    32f4:	6e692f63 	cdpvs	15, 6, cr2, cr9, cr3, {3}
    32f8:	64756c63 	ldrbtvs	r6, [r5], #-3171
    32fc:	79732f65 	ldmdbvc	r3!, {r0, r2, r5, r6, r8, r9, sl, fp, sp}^
    3300:	3a630073 	bcc	18c34d4 <__Stack_Size+0x18c30d4>
    3304:	6e69772f 	cdpvs	7, 6, cr7, cr9, cr15, {1}
    3308:	736d7261 	cmnvc	sp, #268435462	; 0x10000006
    330c:	6975622f 	ldmdbvs	r5!, {r0, r1, r2, r3, r5, r9, sp, lr}^
    3310:	672f646c 	strvs	r6, [pc, -ip, ror #8]!
    3314:	622d6363 	eorvs	r6, sp, #-1946157055	; 0x8c000001
    3318:	646c6975 	strbtvs	r6, [ip], #-2421
    331c:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    3320:	636e692f 	cmnvs	lr, #770048	; 0xbc000
    3324:	6564756c 	strbvs	r7, [r4, #-1388]!
    3328:	5f5f0000 	svcpl	0x005f0000
    332c:	6c6c6163 	stfvse	f6, [ip], #-396
    3330:	6574615f 	ldrbvs	r6, [r4, #-351]!
    3334:	2e746978 	mrccs	9, 3, r6, cr4, cr8, {3}
    3338:	00010063 	andeq	r0, r1, r3, rrx
    333c:	636f6c00 	cmnvs	pc, #0	; 0x0
    3340:	00682e6b 	rsbeq	r2, r8, fp, ror #28
    3344:	5f000002 	svcpl	0x00000002
    3348:	65707974 	ldrbvs	r7, [r0, #-2420]!
    334c:	00682e73 	rsbeq	r2, r8, r3, ror lr
    3350:	73000002 	movwvc	r0, #2	; 0x2
    3354:	65646474 	strbvs	r6, [r4, #-1140]!
    3358:	00682e66 	rsbeq	r2, r8, r6, ror #28
    335c:	72000003 	andvc	r0, r0, #3	; 0x3
    3360:	746e6565 	strbtvc	r6, [lr], #-1381
    3364:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    3368:	00000000 	andeq	r0, r0, r0
    336c:	7ab00205 	bvc	fec03b88 <SCS_BASE+0x1ebf5b88>
    3370:	11030800 	tstne	r3, r0, lsl #16
    3374:	2e0a0301 	cdpcs	3, 0, cr0, cr10, cr1, {0}
    3378:	4a4a7603 	bmi	12a0b8c <__Stack_Size+0x12a078c>
    337c:	034a2c03 	movteq	r2, #44035	; 0xac03
    3380:	69032e77 	stmdbvs	r3, {r0, r1, r2, r4, r5, r6, r9, sl, fp, sp}
    3384:	03c1512e 	biceq	r5, r1, #-2147483637	; 0x8000000b
    3388:	3e039e79 	mcrcc	14, 0, r9, cr3, cr9, {3}
    338c:	664f0366 	strbvs	r0, [pc], -r6, ror #6
    3390:	304b2f2d 	subcc	r2, fp, sp, lsr #30
    3394:	31635031 	cmncc	r3, r1, lsr r0
    3398:	03896730 	orreq	r6, r9, #12582912	; 0xc00000
    339c:	09039e77 	stmdbeq	r3, {r0, r1, r2, r4, r5, r6, r9, sl, fp, ip, pc}
    33a0:	0a02d14a 	beq	b78d0 <__Stack_Size+0xb74d0>
    33a4:	45010100 	strmi	r0, [r1, #-256]
    33a8:	02000000 	andeq	r0, r0, #0	; 0x0
    33ac:	00001f00 	andeq	r1, r0, r0, lsl #30
    33b0:	fb010200 	blx	43bba <__Stack_Size+0x437ba>
    33b4:	01000d0e 	tsteq	r0, lr, lsl #26
    33b8:	00010101 	andeq	r0, r1, r1, lsl #2
    33bc:	00010000 	andeq	r0, r1, r0
    33c0:	63000100 	movwvs	r0, #256	; 0x100
    33c4:	2e6e7472 	mcrcs	4, 3, r7, cr14, cr2, {3}
    33c8:	006d7361 	rsbeq	r7, sp, r1, ror #6
    33cc:	00000000 	andeq	r0, r0, r0
    33d0:	00020500 	andeq	r0, r2, r0, lsl #10
    33d4:	03000000 	movweq	r0, #0	; 0x0
    33d8:	020100ce 	andeq	r0, r1, #206	; 0xce
    33dc:	01010006 	tsteq	r1, r6
    33e0:	00020500 	andeq	r0, r2, r0, lsl #10
    33e4:	03000000 	movweq	r0, #0	; 0x0
    33e8:	020100d2 	andeq	r0, r1, #210	; 0xd2
    33ec:	01010006 	tsteq	r1, r6

Disassembly of section .debug_frame:

00000000 <.debug_frame>:
       0:	0000000c 	andeq	r0, r0, ip
       4:	ffffffff 	undefined instruction 0xffffffff
       8:	7c010001 	stcvc	0, cr0, [r1], {1}
       c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
      10:	0000000c 	andeq	r0, r0, ip
      14:	00000000 	andeq	r0, r0, r0
      18:	08003134 	stmdaeq	r0, {r2, r4, r5, r8, ip, sp}
      1c:	00000002 	andeq	r0, r0, r2
      20:	0000001c 	andeq	r0, r0, ip, lsl r0
      24:	00000000 	andeq	r0, r0, r0
      28:	08003138 	stmdaeq	r0, {r3, r4, r5, r8, ip, sp}
      2c:	00000314 	andeq	r0, r0, r4, lsl r3
      30:	42140e42 	andsmi	r0, r4, #1056	; 0x420
      34:	018e180e 	orreq	r1, lr, lr, lsl #16
      38:	03860287 	orreq	r0, r6, #1879048200	; 0x70000008
      3c:	05840485 	streq	r0, [r4, #1157]
      40:	0000000c 	.word	0x0000000c
      44:	ffffffff 	.word	0xffffffff
      48:	7c010001 	.word	0x7c010001
      4c:	000d0c0e 	.word	0x000d0c0e
      50:	0000000c 	.word	0x0000000c
      54:	00000040 	.word	0x00000040
      58:	0800344c 	.word	0x0800344c
      5c:	00000002 	.word	0x00000002
      60:	0000000c 	.word	0x0000000c
      64:	00000040 	.word	0x00000040
      68:	08003450 	.word	0x08003450
      6c:	00000002 	.word	0x00000002
      70:	0000000c 	.word	0x0000000c
      74:	00000040 	.word	0x00000040
      78:	08003454 	.word	0x08003454
      7c:	00000002 	.word	0x00000002
      80:	0000000c 	.word	0x0000000c
      84:	00000040 	.word	0x00000040
      88:	08003458 	.word	0x08003458
      8c:	00000002 	.word	0x00000002
      90:	0000000c 	.word	0x0000000c
      94:	00000040 	.word	0x00000040
      98:	0800345c 	.word	0x0800345c
      9c:	00000002 	.word	0x00000002
      a0:	0000000c 	.word	0x0000000c
      a4:	00000040 	.word	0x00000040
      a8:	60          	.byte	0x60
      a9:	34          	.byte	0x34
      aa:	0800      	.short	0x0800
      ac:	00000002 	.word	0x00000002
      b0:	0000000c 	.word	0x0000000c
      b4:	00000040 	.word	0x00000040
      b8:	08003464 	.word	0x08003464
      bc:	00000002 	.word	0x00000002
      c0:	0000000c 	.word	0x0000000c
      c4:	00000040 	.word	0x00000040
      c8:	08003468 	.word	0x08003468
      cc:	00000002 	.word	0x00000002
      d0:	0000000c 	.word	0x0000000c
      d4:	00000040 	.word	0x00000040
      d8:	0800346c 	.word	0x0800346c
      dc:	00000002 	.word	0x00000002
      e0:	0000000c 	.word	0x0000000c
      e4:	00000040 	.word	0x00000040
      e8:	08003470 	.word	0x08003470
      ec:	00000002 	.word	0x00000002
      f0:	0000000c 	.word	0x0000000c
      f4:	00000040 	.word	0x00000040
      f8:	08003474 	.word	0x08003474
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
      fc:	00000002 	.word	0x00000002
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
     100:	0000000c 	.word	0x0000000c

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
     104:	00000040 	.word	0x00000040
     108:	08003478 	.word	0x08003478
	nextframe_ = getMillis() + frameLength;
     10c:	00000002 	.word	0x00000002
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     110:	0000000c 	.word	0x0000000c
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
     114:	00000040 	.word	0x00000040
     118:	0800347c 	.word	0x0800347c
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     11c:	00000002 	.word	0x00000002
     120:	0000000c 	.word	0x0000000c
     124:	00000040 	.word	0x00000040
		if (nextpose_[i] > pose_[i]) {
     128:	08003480 	.word	0x08003480
     12c:	00000002 	.word	0x00000002
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
     130:	0000000c 	.word	0x0000000c
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
     134:	00000040 	.word	0x00000040
     138:	08003484 	.word	0x08003484
     13c:	00000002 	.word	0x00000002
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     140:	0000000c 	.word	0x0000000c
     144:	00000040 	.word	0x00000040
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
     148:	08003488 	.word	0x08003488
     14c:	00000002 	.word	0x00000002
}
     150:	0000000c 	.word	0x0000000c
     154:	00000040 	.word	0x00000040
     158:	0800348c 	.word	0x0800348c
     15c:	00000002 	.word	0x00000002
     160:	0000000c 	.word	0x0000000c
     164:	00000040 	.word	0x00000040
     168:	08003490 	.word	0x08003490
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
     16c:	00000002 	.word	0x00000002
     170:	0000000c 	.word	0x0000000c
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
     174:	00000040 	.word	0x00000040
     178:	08003494 	.word	0x08003494
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     17c:	00000002 	.word	0x00000002
     180:	0000000c 	.word	0x0000000c
		nextpose_[i] = 512;
     184:	00000040 	.word	0x00000040
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
     188:	08003498 	.word	0x08003498
		pose_[i] = 512;
     18c:	00000002 	.word	0x00000002
		nextpose_[i] = 512;
     190:	0000000c 	.word	0x0000000c
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
     194:	00000040 	.word	0x00000040
     198:	0800349c 	.word	0x0800349c
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
     19c:	00000002 	.word	0x00000002
     1a0:	0000000c 	.word	0x0000000c
	nextframe_ = getMillis();
     1a4:	00000040 	.word	0x00000040
     1a8:	080034a0 	.word	0x080034a0
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     1ac:	00000002 	.word	0x00000002
     1b0:	0000000c 	.word	0x0000000c
     1b4:	00000040 	.word	0x00000040
     1b8:	080034a4 	.word	0x080034a4
     1bc:	00000002 	.word	0x00000002
     1c0:	0000000c 	.word	0x0000000c
     1c4:	00000040 	.word	0x00000040
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1c8:	080034a8 	.word	0x080034a8
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
     1cc:	00000002 	.word	0x00000002
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d0:	0000000c 	.word	0x0000000c
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1d4:	00000040 	.word	0x00000040
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d8:	080034ac 	.word	0x080034ac
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
     1dc:	00000002 	.word	0x00000002
     1e0:	0000000c 	.word	0x0000000c
		pose_[i] = 512;
		nextpose_[i] = 512;
     1e4:	00000040 	.word	0x00000040
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1e8:	080034b0 	.word	0x080034b0
		nextpose_[i] = 512;
     1ec:	00000002 	.word	0x00000002
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
     1f0:	0000000c 	.word	0x0000000c
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
     1f4:	00000040 	.word	0x00000040
     1f8:	080034b4 	.word	0x080034b4
	interpolating = 0;
     1fc:	00000002 	.word	0x00000002
	nextframe_ = getMillis();
     200:	0000000c 	.word	0x0000000c
     204:	00000040 	.word	0x00000040
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     208:	080034b8 	.word	0x080034b8
     20c:	00000002 	.word	0x00000002
     210:	0000000c 	.word	0x0000000c
     214:	00000040 	.word	0x00000040
     218:	080034bc 	.word	0x080034bc
     21c:	00000002 	.word	0x00000002
     220:	0000000c 	.word	0x0000000c
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
     224:	00000040 	.word	0x00000040
     228:	080034c0 	.word	0x080034c0
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
     22c:	00000002 	.word	0x00000002
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
     230:	0000000c 	.word	0x0000000c
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
     234:	00000040 	.word	0x00000040
     238:	080034c4 	.word	0x080034c4
	dxl_set_txpacket_parameter(1, 2);
     23c:	00000002 	.word	0x00000002
     240:	0000000c 	.word	0x0000000c
     244:	00000040 	.word	0x00000040
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     248:	080034c8 	.word	0x080034c8
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
     24c:	00000002 	.word	0x00000002
     250:	0000000c 	.word	0x0000000c
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     254:	00000040 	.word	0x00000040
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     258:	080034cc 	.word	0x080034cc
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     25c:	00000002 	.word	0x00000002
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     260:	0000000c 	.word	0x0000000c
     264:	00000040 	.word	0x00000040
     268:	080034d0 	.word	0x080034d0
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     26c:	00000002 	.word	0x00000002
     270:	0000000c 	.word	0x0000000c
     274:	00000040 	.word	0x00000040
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     278:	080034d4 	.word	0x080034d4
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     27c:	00000002 	.word	0x00000002
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
     280:	0000000c 	.word	0x0000000c
     284:	00000040 	.word	0x00000040
     288:	080034d8 	.word	0x080034d8
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
     28c:	00000002 	.word	0x00000002
     290:	0000000c 	.word	0x0000000c
     294:	00000040 	.word	0x00000040
	dxl_txrx_packet();
     298:	080034dc 	.word	0x080034dc
	u16 CommStatus = dxl_get_result();
     29c:	00000002 	.word	0x00000002
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
     2a0:	0000000c 	.word	0x0000000c
		PrintErrorCode();
     2a4:	00000040 	.word	0x00000040
	else
		PrintCommStatus(CommStatus);
     2a8:	080034e0 	.word	0x080034e0
#endif
}
     2ac:	00000002 	.word	0x00000002
     2b0:	0000000c 	.word	0x0000000c
     2b4:	00000040 	.word	0x00000040
     2b8:	080034e4 	.word	0x080034e4
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
     2bc:	00000002 	.word	0x00000002
     2c0:	0000000c 	.word	0x0000000c

	if (interpolating == 0)
     2c4:	00000040 	.word	0x00000040
		return 0;
	int i;
	int complete = poseSize;
     2c8:	080034e8 	.word	0x080034e8
	if (!fWait) {
     2cc:	00000002 	.word	0x00000002
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
     2d0:	0000000c 	.word	0x0000000c
     2d4:	00000040 	.word	0x00000040
     2d8:	080034ec 	.word	0x080034ec
			return (getMillis() - nextframe_); // We still have some time to do something...
     2dc:	00000002 	.word	0x00000002
     2e0:	0000000c 	.word	0x0000000c
     2e4:	00000040 	.word	0x00000040
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
     2e8:	080034f0 	.word	0x080034f0
     2ec:	00000002 	.word	0x00000002
     2f0:	0000000c 	.word	0x0000000c
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     2f4:	00000040 	.word	0x00000040
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     2f8:	080034f4 	.word	0x080034f4
     2fc:	00000002 	.word	0x00000002
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     300:	0000000c 	.word	0x0000000c
     304:	00000040 	.word	0x00000040
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     308:	080034f8 	.word	0x080034f8
		int diff = nextpose_[i] - pose_[i];
     30c:	00000002 	.word	0x00000002
     310:	0000000c 	.word	0x0000000c
     314:	00000040 	.word	0x00000040
     318:	080034fc 	.word	0x080034fc
     31c:	00000002 	.word	0x00000002
		if (diff == 0) {
     320:	0000000c 	.word	0x0000000c
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     324:	00000040 	.word	0x00000040
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
     328:	08003500 	.word	0x08003500
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     32c:	00000002 	.word	0x00000002
					pose_[i] = nextpose_[i];
     330:	0000000c 	.word	0x0000000c
					complete--;
     334:	00000040 	.word	0x00000040
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     338:	08003504 	.word	0x08003504
     33c:	00000002 	.word	0x00000002
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     340:	0000000c 	.word	0x0000000c
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     344:	00000040 	.word	0x00000040
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     348:	08003508 	.word	0x08003508
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     34c:	00000002 	.word	0x00000002
     350:	0000000c 	.word	0x0000000c
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
     354:	00000040 	.word	0x00000040
		interpolating = 0;
     358:	0800350c 	.word	0x0800350c
	BioloidControllerEx_writePose();
     35c:	00000002 	.word	0x00000002
     360:	0000000c 	.word	0x0000000c
	return 0;
}
     364:	00000040 	.word	0x00000040
     368:	08003510 	.word	0x08003510
     36c:	00000002 	.word	0x00000002
     370:	0000000c 	.word	0x0000000c
     374:	00000040 	.word	0x00000040
     378:	08003514 	.word	0x08003514
     37c:	00000002 	.word	0x00000002
     380:	0000000c 	.word	0x0000000c
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
     384:	00000040 	.word	0x00000040
     388:	08003518 	.word	0x08003518
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
     38c:	00000002 	.word	0x00000002
     390:	0000000c 	.word	0x0000000c
     394:	00000040 	.word	0x00000040
     398:	0800351c 	.word	0x0800351c
     39c:	00000002 	.word	0x00000002
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
     3a0:	0000000c 	.word	0x0000000c

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
     3a4:	00000040 	.word	0x00000040
     3a8:	08003520 	.word	0x08003520
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
     3ac:	00000002 	.word	0x00000002
     3b0:	0000000c 	.word	0x0000000c
     3b4:	00000040 	.word	0x00000040
     3b8:	08003524 	.word	0x08003524
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
     3bc:	00000002 	.word	0x00000002
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
     3c0:	0000000c 	.word	0x0000000c
     3c4:	00000040 	.word	0x00000040
     3c8:	08003528 	.word	0x08003528
     3cc:	00000002 	.word	0x00000002
     3d0:	0000000c 	.word	0x0000000c
     3d4:	00000040 	.word	0x00000040
     3d8:	0800352c 	.word	0x0800352c
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
     3dc:	00000002 	.word	0x00000002
     3e0:	0000000c 	.word	0x0000000c
     3e4:	00000040 	.word	0x00000040
     3e8:	08003530 	.word	0x08003530
     3ec:	00000002 	.word	0x00000002
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     3f0:	0000000c 	.word	0x0000000c
     3f4:	00000040 	.word	0x00000040
     3f8:	08003534 	.word	0x08003534
     3fc:	00000002 	.word	0x00000002
     400:	0000000c 	.word	0x0000000c
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
     404:	00000040 	.word	0x00000040
     408:	08003538 	.word	0x08003538
     40c:	00000002 	.word	0x00000002
     410:	0000000c 	.word	0x0000000c
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
     414:	00000040 	.word	0x00000040
     418:	0800353c 	.word	0x0800353c
     41c:	00000002 	.word	0x00000002
     420:	0000000c 	.word	0x0000000c
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
     424:	00000040 	.word	0x00000040
     428:	08003540 	.word	0x08003540
     42c:	00000002 	.word	0x00000002
     430:	0000000c 	.word	0x0000000c
     434:	00000040 	.word	0x00000040
     438:	08003544 	.word	0x08003544
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     43c:	00000002 	.word	0x00000002
     440:	0000000c 	.word	0x0000000c
     444:	00000040 	.word	0x00000040
     448:	08003548 	.word	0x08003548
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     44c:	00000002 	.word	0x00000002
     450:	0000000c 	.word	0x0000000c
     454:	00000040 	.word	0x00000040
     458:	0800354c 	.word	0x0800354c
     45c:	00000002 	.word	0x00000002
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     460:	00000014 	.word	0x00000014
     464:	00000040 	.word	0x00000040
     468:	08003550 	.word	0x08003550
     46c:	0000000c 	.word	0x0000000c
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     470:	42040e42 	.word	0x42040e42
     474:	018e080e 	.word	0x018e080e
     478:	00000014 	.word	0x00000014
     47c:	00000040 	.word	0x00000040
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
     480:	0800355c 	.word	0x0800355c
     484:	0000000c 	.word	0x0000000c
     488:	42040e42 	.word	0x42040e42
     48c:	018e080e 	.word	0x018e080e
     490:	00000014 	.word	0x00000014
     494:	00000040 	.word	0x00000040
     498:	08003568 	.word	0x08003568
     49c:	0000000c 	.word	0x0000000c
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     4a0:	42040e42 	.word	0x42040e42
     4a4:	018e080e 	.word	0x018e080e
     4a8:	00000014 	.word	0x00000014
     4ac:	00000040 	.word	0x00000040
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     4b0:	08003574 	.word	0x08003574
     4b4:	0000000c 	.word	0x0000000c
     4b8:	42040e42 	.word	0x42040e42
     4bc:	018e080e 	.word	0x018e080e
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     4c0:	0000000c 	.word	0x0000000c
     4c4:	ffffffff 	.word	0xffffffff
     4c8:	7c010001 	.word	0x7c010001
		GaitPosY[GaitCurrentLegNr] = 0;
     4cc:	000d0c0e 	.word	0x000d0c0e
     4d0:	0000000c 	.word	0x0000000c
	}

	//Move body forward
	else {
		GaitPosX[GaitCurrentLegNr] = GaitPosX[GaitCurrentLegNr]
     4d4:	000004c0 	.word	0x000004c0
     4d8:	00000000 	.word	0x00000000
     4dc:	00000040 	.word	0x00000040
     4e0:	0000000c 	.word	0x0000000c
     4e4:	000004c0 	.word	0x000004c0
     4e8:	00000000 	.word	0x00000000
				- (g_InControlState.TravelLength.x
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitPosY[GaitCurrentLegNr] = 0;
     4ec:	00000002 	.word	0x00000002
     4f0:	0000000c 	.word	0x0000000c
     4f4:	000004c0 	.word	0x000004c0
		GaitPosZ[GaitCurrentLegNr] = GaitPosZ[GaitCurrentLegNr]
     4f8:	00000000 	.word	0x00000000
     4fc:	00000044 	.word	0x00000044
     500:	0000000c 	.word	0x0000000c
     504:	000004c0 	.word	0x000004c0
				- (g_InControlState.TravelLength.z
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitRotY[GaitCurrentLegNr] = GaitRotY[GaitCurrentLegNr]
     508:	00000000 	.word	0x00000000
     50c:	00000002 	.word	0x00000002
     510:	0000000c 	.word	0x0000000c
     514:	000004c0 	.word	0x000004c0
				- (g_InControlState.TravelLength.y
						/ (short) g_InControlState.gaitCur.TLDivFactor);
	}

}
     518:	00000000 	.word	0x00000000
     51c:	00000002 	.word	0x00000002
     520:	0000000c 	.word	0x0000000c
     524:	000004c0 	.word	0x000004c0
     528:	00000000 	.word	0x00000000
     52c:	0000002c 	.word	0x0000002c
     530:	0000000c 	.word	0x0000000c

}

//--------------------------------------------------------------------
//[GAIT Sequence]
void GaitSeq(void) {
     534:	000004c0 	.word	0x000004c0
	//Check if the Gait is in motion - If not if we are going to start a motion try to align our Gaitstep to start with a good foot
	// for the direction we are about to go...

	if (fWalking || (g_InControlState.ForceGaitStepCnt != 0))
     538:	00000000 	.word	0x00000000
     53c:	00000002 	.word	0x00000002
     540:	0000000c 	.word	0x0000000c
		TravelRequest = true;   // Is walking or was walking...
     544:	000004c0 	.word	0x000004c0
     548:	00000000 	.word	0x00000000
	else {
		TravelRequest = (abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
     54c:	00000002 	.word	0x00000002
     550:	00000018 	.word	0x00000018
     554:	000004c0 	.word	0x000004c0
     558:	00000000 	.word	0x00000000
     55c:	00000160 	.word	0x00000160
     560:	8e0c0e4e 	.word	0x8e0c0e4e
     564:	84028501 	.word	0x84028501
     568:	00000003 	.word	0x00000003
     56c:	00000014 	.word	0x00000014
     570:	000004c0 	.word	0x000004c0
     574:	00000000 	.word	0x00000000
     578:	00000034 	.word	0x00000034
     57c:	4c040e42 	.word	0x4c040e42
				|| (abs(g_InControlState.TravelLength.y) > cTravelDeadZone);

		if (TravelRequest) {

		} else {    //Clear values under the cTravelDeadZone
			g_InControlState.TravelLength.x = 0;
     580:	018e080e 	.word	0x018e080e
			g_InControlState.TravelLength.z = 0;
     584:	00000018 	.word	0x00000018
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     588:	000004c0 	.word	0x000004c0
     58c:	00000000 	.word	0x00000000
     590:	000002dc 	.word	0x000002dc
		Gait(LegIndex);
     594:	8e0c0e42 	.word	0x8e0c0e42
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     598:	84028501 	.word	0x84028501
     59c:	00000003 	.word	0x00000003
     5a0:	00000014 	.word	0x00000014
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5a4:	000004c0 	.word	0x000004c0
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5a8:	00000000 	.word	0x00000000
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5ac:	000000ac 	.word	0x000000ac
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5b0:	8e080e42 	.word	0x8e080e42
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5b4:	00028401 	.word	0x00028401
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
		g_InControlState.GaitStep = 1;
     5b8:	00000018 	.word	0x00000018
     5bc:	000004c0 	.word	0x000004c0

	// If we have a force count decrement it now...
	if (g_InControlState.ForceGaitStepCnt)
     5c0:	00000000 	.word	0x00000000
     5c4:	000000ac 	.word	0x000000ac
		g_InControlState.ForceGaitStepCnt--;
     5c8:	8e0c0e44 	.word	0x8e0c0e44
}
     5cc:	84028501 	.word	0x84028501
     5d0:	00000003 	.word	0x00000003
     5d4:	00000018 	.word	0x00000018
     5d8:	000004c0 	.word	0x000004c0
     5dc:	00000000 	.word	0x00000000
}
//--------------------------------------------------------------------
//[BalanceBody]
void BalanceBody(void) {

	TotalTransZ = TotalTransZ / BalanceDivFactor;
     5e0:	00000184 	.word	0x00000184
     5e4:	8e100e44 	.word	0x8e100e44
     5e8:	85028601 	.word	0x85028601
     5ec:	00048403 	.word	0x00048403
     5f0:	00000014 	.word	0x00000014
	TotalTransX = TotalTransX / BalanceDivFactor;
     5f4:	000004c0 	.word	0x000004c0
     5f8:	00000000 	.word	0x00000000
     5fc:	000000cc 	.word	0x000000cc
	TotalTransY = TotalTransY / BalanceDivFactor;
     600:	8e080e44 	.word	0x8e080e44
     604:	00028401 	.word	0x00028401
     608:	0000000c 	.word	0x0000000c
     60c:	000004c0 	.word	0x000004c0

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     610:	00000000 	.word	0x00000000
     614:	00000030 	.word	0x00000030
	TotalTransX = TotalTransX / BalanceDivFactor;
	TotalTransY = TotalTransY / BalanceDivFactor;

#ifndef QUADMODE // ??? on PhantomX Hex at no movment YBal1 = 1800, on Quad = 0...  Need to experiment
	if (TotalYBal1 > 0)        //Rotate balance circle by +/- 180 deg
		TotalYBal1 -= 1800;
     618:	00000018 	.word	0x00000018
     61c:	000004c0 	.word	0x000004c0
	else
		TotalYBal1 += 1800;
     620:	00000000 	.word	0x00000000
#endif

	if (TotalZBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     624:	00000064 	.word	0x00000064
     628:	8e0c0e46 	.word	0x8e0c0e46
     62c:	84028501 	.word	0x84028501
		TotalZBal1 += 3600;
     630:	100e4c03 	.word	0x100e4c03
     634:	0000001c 	.word	0x0000001c

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     638:	000004c0 	.word	0x000004c0
     63c:	00000000 	.word	0x00000000
		TotalXBal1 += 3600;
     640:	000000e0 	.word	0x000000e0
     644:	8e140e42 	.word	0x8e140e42

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     648:	86028701 	.word	0x86028701
     64c:	84048503 	.word	0x84048503
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     650:	180e4605 	.word	0x180e4605
     654:	0000001c 	.word	0x0000001c
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     658:	000004c0 	.word	0x000004c0
	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     65c:	00000000 	.word	0x00000000
     660:	000002d0 	.word	0x000002d0
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     664:	8e140e42 	.word	0x8e140e42
     668:	86028701 	.word	0x86028701

}
     66c:	84048503 	.word	0x84048503
     670:	480e4405 	.word	0x480e4405
     674:	0000001c 	.word	0x0000001c
     678:	000004c0 	.word	0x000004c0
     67c:	00000000 	.word	0x00000000
     680:	00000184 	.word	0x00000184
     684:	8e140e42 	.word	0x8e140e42
     688:	86028701 	.word	0x86028701
//sin4        - Output Sinus of AngleDeg
//cos4          - Output Cosinus of AngleDeg
void GetSinCos(short AngleDeg1) {
	short ABSAngleDeg1;   //Absolute value of the Angle in Degrees, decimals = 1
	//Get the absolute value of AngleDeg
	if (AngleDeg1 < 0)
     68c:	84048503 	.word	0x84048503
     690:	200e4405 	.word	0x200e4405
		ABSAngleDeg1 = AngleDeg1 * -1;
     694:	0000000c 	.word	0x0000000c
     698:	000004c0 	.word	0x000004c0
	else
		ABSAngleDeg1 = AngleDeg1;

	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
     69c:	00000000 	.word	0x00000000
     6a0:	0000001a 	.word	0x0000001a
     6a4:	0000001c 	.word	0x0000001c
     6a8:	000004c0 	.word	0x000004c0
     6ac:	00000000 	.word	0x00000000
     6b0:	000000b0 	.word	0x000000b0
     6b4:	8e140e46 	.word	0x8e140e46
     6b8:	86028701 	.word	0x86028701
     6bc:	84048503 	.word	0x84048503
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
     6c0:	00000005 	.word	0x00000005
     6c4:	0000000c 	.word	0x0000000c
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6c8:	000004c0 	.word	0x000004c0
     6cc:	00000000 	.word	0x00000000
     6d0:	00000046 	.word	0x00000046
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6d4:	00000014 	.word	0x00000014
     6d8:	000004c0 	.word	0x000004c0
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6dc:	00000000 	.word	0x00000000
     6e0:	00000038 	.word	0x00000038
     6e4:	4a040e44 	.word	0x4a040e44
     6e8:	018e080e 	.word	0x018e080e
     6ec:	0000001c 	.word	0x0000001c
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6f0:	000004c0 	.word	0x000004c0
     6f4:	00000000 	.word	0x00000000
     6f8:	0000008c 	.word	0x0000008c
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
     6fc:	8e140e42 	.word	0x8e140e42
     700:	86028701 	.word	0x86028701
     704:	84048503 	.word	0x84048503
     708:	180e5605 	.word	0x180e5605
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     70c:	0000000c 	.word	0x0000000c
     710:	000004c0 	.word	0x000004c0
     714:	00000000 	.word	0x00000000
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     718:	00000002 	.word	0x00000002
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     71c:	0000000c 	.word	0x0000000c
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     720:	000004c0 	.word	0x000004c0
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     724:	00000000 	.word	0x00000000
     728:	00000002 	.word	0x00000002
     72c:	00000014 	.word	0x00000014
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     730:	000004c0 	.word	0x000004c0
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     734:	00000000 	.word	0x00000000
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     738:	0000003c 	.word	0x0000003c
     73c:	44040e42 	.word	0x44040e42
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
     740:	018e080e 	.word	0x018e080e
     744:	00000014 	.word	0x00000014
     748:	000004c0 	.word	0x000004c0
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     74c:	00000000 	.word	0x00000000
     750:	0000009c 	.word	0x0000009c
     754:	44040e42 	.word	0x44040e42
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     758:	018e080e 	.word	0x018e080e
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     75c:	00000014 	.word	0x00000014
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     760:	000004c0 	.word	0x000004c0
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     764:	00000000 	.word	0x00000000
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     768:	0000001c 	.word	0x0000001c
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     76c:	44040e42 	.word	0x44040e42
     770:	018e080e 	.word	0x018e080e
     774:	00000014 	.word	0x00000014
     778:	000004c0 	.word	0x000004c0
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     77c:	00000000 	.word	0x00000000
     780:	00000044 	.word	0x00000044
     784:	44040e42 	.word	0x44040e42
     788:	018e080e 	.word	0x018e080e
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
     78c:	0000001c 	.word	0x0000001c
     790:	000004c0 	.word	0x000004c0
     794:	00000000 	.word	0x00000000
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     798:	00000090 	.word	0x00000090
     79c:	8e140e42 	.word	0x8e140e42
     7a0:	86028701 	.word	0x86028701
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7a4:	84048503 	.word	0x84048503
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7a8:	180e4405 	.word	0x180e4405
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7ac:	00000018 	.word	0x00000018
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b0:	000004c0 	.word	0x000004c0
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7b4:	00000000 	.word	0x00000000
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b8:	00000054 	.word	0x00000054
     7bc:	8e100e42 	.word	0x8e100e42
     7c0:	85028601 	.word	0x85028601
     7c4:	00048403 	.word	0x00048403
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7c8:	00000014 	.word	0x00000014
     7cc:	000004c0 	.word	0x000004c0
     7d0:	00000000 	.word	0x00000000
	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));
     7d4:	00000038 	.word	0x00000038
     7d8:	42040e42 	.word	0x42040e42
     7dc:	018e080e 	.word	0x018e080e
     7e0:	00000018 	.word	0x00000018
     7e4:	000004c0 	.word	0x000004c0
     7e8:	00000000 	.word	0x00000000
     7ec:	00000038 	.word	0x00000038
     7f0:	440c0e42 	.word	0x440c0e42
     7f4:	018e100e 	.word	0x018e100e
     7f8:	03840285 	.word	0x03840285
	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
	}
}
     7fc:	00000014 	.word	0x00000014
     800:	000004c0 	.word	0x000004c0
     804:	00000000 	.word	0x00000000
     808:	00000034 	.word	0x00000034
     80c:	4e040e42 	.word	0x4e040e42
//cos4        - Input Cosinus
//AngleRad4     - Output Angle in AngleRad4
long GetArcCos(short cos4) {
	boolean NegativeValue/*:1*/;    //If the the value is Negative
	//Check for negative value
	if (cos4 < 0) {
     810:	018e080e 	.word	0x018e080e
     814:	00000014 	.word	0x00000014
     818:	000004c0 	.word	0x000004c0
		cos4 = -cos4;
     81c:	00000000 	.word	0x00000000
     820:	00000124 	.word	0x00000124
		NegativeValue = 1;
	} else
		NegativeValue = 0;

	//Limit cos4 to his maximal value
	cos4 = min(cos4, c4DEC);
     824:	8e080e46 	.word	0x8e080e46
     828:	00028401 	.word	0x00028401
     82c:	0000001c 	.word	0x0000001c

	if ((cos4 >= 0) && (cos4 < 9000)) {
     830:	000004c0 	.word	0x000004c0
     834:	00000000 	.word	0x00000000
     838:	000000ec 	.word	0x000000ec
		AngleRad4 = (byte) pgm_read_byte(&GetACos[cos4 / 79]);
     83c:	44140e42 	.word	0x44140e42
     840:	018e200e 	.word	0x018e200e
     844:	03860287 	.word	0x03860287
		AngleRad4 = ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255) ;
     848:	05840485 	.word	0x05840485
     84c:	0000001c 	.word	0x0000001c
	} else if ((cos4 >= 9000) && (cos4 < 9900)) {
     850:	000004c0 	.word	0x000004c0
     854:	00000000 	.word	0x00000000
     858:	0000008c 	.word	0x0000008c
     85c:	8e140e48 	.word	0x8e140e48
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9000) / 8 + 114]);
     860:	86028701 	.word	0x86028701
     864:	84048503 	.word	0x84048503
     868:	200e6e05 	.word	0x200e6e05
     86c:	0000001c 	.word	0x0000001c
     870:	000004c0 	.word	0x000004c0
     874:	00000000 	.word	0x00000000
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     878:	00000084 	.word	0x00000084
	} else if ((cos4 >= 9900) && (cos4 <= 10000)) {
     87c:	42140e42 	.word	0x42140e42
     880:	018e180e 	.word	0x018e180e
     884:	03860287 	.word	0x03860287
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9900) / 2 + 227]);
     888:	05840485 	.word	0x05840485
     88c:	00000014 	.word	0x00000014
     890:	000004c0 	.word	0x000004c0
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     894:	00000000 	.word	0x00000000
     898:	00000054 	.word	0x00000054
     89c:	8e080e42 	.word	0x8e080e42
     8a0:	00028401 	.word	0x00028401
     8a4:	00000014 	.word	0x00000014
     8a8:	000004c0 	.word	0x000004c0
     8ac:	00000000 	.word	0x00000000
	}

	//Add negative sign
	if (NegativeValue)
		AngleRad4 = 31416 - AngleRad4;
     8b0:	0000005c 	.word	0x0000005c
     8b4:	42040e42 	.word	0x42040e42
     8b8:	018e080e 	.word	0x018e080e
     8bc:	0000001c 	.word	0x0000001c
     8c0:	000004c0 	.word	0x000004c0

	return AngleRad4;
}
     8c4:	00000000 	.word	0x00000000
     8c8:	0000059c 	.word	0x0000059c
     8cc:	42140e42 	.word	0x42140e42
     8d0:	018e280e 	.word	0x018e280e
     8d4:	03860287 	.word	0x03860287
     8d8:	05840485 	.word	0x05840485

unsigned long isqrt32(unsigned long n) //
{
     8dc:	0000001c 	.word	0x0000001c
     8e0:	000004c0 	.word	0x000004c0

	root = 0;
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
     8e4:	00000000 	.word	0x00000000
     8e8:	0000051c 	.word	0x0000051c
     8ec:	42140e42 	.word	0x42140e42
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
     8f0:	018e200e 	.word	0x018e200e
			remainder = remainder - root - place;
     8f4:	03860287 	.word	0x03860287
     8f8:	05840485 	.word	0x05840485
			root = root + (place << 1);
     8fc:	0000000c 	.word	0x0000000c

	while (place > remainder)
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
			remainder = remainder - root - place;
     900:	ffffffff 	.word	0xffffffff
			root = root + (place << 1);
		}
		root = root >> 1;
		place = place >> 2;
     904:	7c010001 	.word	0x7c010001
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
		place = place >> 2;
	while (place) {
     908:	000d0c0e 	.word	0x000d0c0e
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
	XYhyp2 = isqrt32(
     90c:	0000000c 	.word	0x0000000c
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     910:	000008fc 	.word	0x000008fc
	XYhyp2 = isqrt32(
     914:	00000000 	.word	0x00000000
     918:	0000000c 	.word	0x0000000c
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     91c:	0000000c 	.word	0x0000000c
	XYhyp2 = isqrt32(
     920:	000008fc 	.word	0x000008fc
     924:	00000000 	.word	0x00000000
     928:	0000000c 	.word	0x0000000c
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);
     92c:	0000000c 	.word	0x0000000c
     930:	000008fc 	.word	0x000008fc
     934:	00000000 	.word	0x00000000
     938:	0000002c 	.word	0x0000002c
     93c:	0000000c 	.word	0x0000000c
     940:	000008fc 	.word	0x000008fc
     944:	00000000 	.word	0x00000000

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
     948:	00000038 	.word	0x00000038
		Atan4 = -AngleRad4;
     94c:	0000000c 	.word	0x0000000c
	else
		Atan4 = AngleRad4;
     950:	000008fc 	.word	0x000008fc
	XYhyp2 = isqrt32(
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
		Atan4 = -AngleRad4;
     954:	00000000 	.word	0x00000000
	else
		Atan4 = AngleRad4;
     958:	00000038 	.word	0x00000038
     95c:	00000014 	.word	0x00000014
	return Atan4;
}
     960:	000008fc 	.word	0x000008fc
     964:	00000000 	.word	0x00000000
     968:	00000030 	.word	0x00000030
     96c:	8e080e44 	.word	0x8e080e44

}

//--------------------------------------------------------------------
//[BalCalcOneLeg]
void BalCalcOneLeg(long PosX, long PosZ, long PosY, byte BalLegNr) {
     970:	00028401 	.word	0x00028401
	long CPR_Y;            //Final Y value for centerpoint of rotation
	long CPR_Z;            //Final Z value for centerpoint of rotation

	long lAtan;
	//Calculating totals from center of the body to the feet
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BalLegNr]) + PosZ;
     974:	0000000c 	.word	0x0000000c
     978:	000008fc 	.word	0x000008fc
	CPR_X = (short) pgm_read_word(&cOffsetX[BalLegNr]) + PosX;
     97c:	00000000 	.word	0x00000000
     980:	00000018 	.word	0x00000018
	CPR_Y = 150 + PosY; // using the value 150 to lower the centerpoint of rotation 'g_InControlState.BodyPos.y +

	TotalTransY += (long) PosY;
     984:	00000018 	.word	0x00000018
     988:	000008fc 	.word	0x000008fc
     98c:	00000000 	.word	0x00000000
	TotalTransZ += (long) CPR_Z;
     990:	00000070 	.word	0x00000070
     994:	8e100e42 	.word	0x8e100e42
     998:	85028601 	.word	0x85028601
	TotalTransX += (long) CPR_X;
     99c:	00048403 	.word	0x00048403
     9a0:	00000018 	.word	0x00000018
     9a4:	000008fc 	.word	0x000008fc
     9a8:	00000000 	.word	0x00000000

	lAtan = GetATan2(CPR_X, CPR_Z);
     9ac:	0000005c 	.word	0x0000005c
	TotalYBal1 += (lAtan * 1800) / 31415;
     9b0:	440c0e42 	.word	0x440c0e42
     9b4:	018e100e 	.word	0x018e100e
     9b8:	03840285 	.word	0x03840285
     9bc:	00000014 	.word	0x00000014
     9c0:	000008fc 	.word	0x000008fc
     9c4:	00000000 	.word	0x00000000
     9c8:	0000005c 	.word	0x0000005c
     9cc:	8e080e42 	.word	0x8e080e42

	lAtan = GetATan2(CPR_X, CPR_Y);
     9d0:	00028401 	.word	0x00028401
     9d4:	0000001c 	.word	0x0000001c
	TotalZBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     9d8:	000008fc 	.word	0x000008fc
     9dc:	00000000 	.word	0x00000000
     9e0:	00000098 	.word	0x00000098
     9e4:	44140e42 	.word	0x44140e42
     9e8:	018e180e 	.word	0x018e180e
     9ec:	03860287 	.word	0x03860287
     9f0:	05840485 	.word	0x05840485
     9f4:	0000001c 	.word	0x0000001c
     9f8:	000008fc 	.word	0x000008fc
     9fc:	00000000 	.word	0x00000000

	lAtan = GetATan2(CPR_Z, CPR_Y);
     a00:	000000c8 	.word	0x000000c8
     a04:	44140e42 	.word	0x44140e42
	TotalXBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     a08:	018e180e 	.word	0x018e180e
     a0c:	03860287 	.word	0x03860287
     a10:	05840485 	.word	0x05840485
     a14:	0000001c 	.word	0x0000001c
     a18:	000008fc 	.word	0x000008fc
     a1c:	00000000 	.word	0x00000000
     a20:	00000038 	.word	0x00000038
     a24:	8e140e42 	.word	0x8e140e42

}
     a28:	86028701 	.word	0x86028701
     a2c:	84048503 	.word	0x84048503
     a30:	180e4405 	.word	0x180e4405
     a34:	0000000c 	.word	0x0000000c
     a38:	ffffffff 	.word	0xffffffff
     a3c:	7c010001 	.word	0x7c010001
     a40:	000d0c0e 	.word	0x000d0c0e
     a44:	0000000c 	.word	0x0000000c
     a48:	00000a34 	.word	0x00000a34
     a4c:	08003580 	.word	0x08003580
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a50:	00000018 	.word	0x00000018
     a54:	0000000c 	.word	0x0000000c
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a58:	00000a34 	.word	0x00000a34
     a5c:	08003598 	.word	0x08003598
     a60:	00000030 	.word	0x00000030
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a64:	0000001c 	.word	0x0000001c
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a68:	00000a34 	.word	0x00000a34
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
     a6c:	080035c8 	.word	0x080035c8
     a70:	0000006c 	.word	0x0000006c
     a74:	44140e42 	.word	0x44140e42

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     a78:	018e200e 	.word	0x018e200e

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a7c:	03860287 	.word	0x03860287
     a80:	05840485 	.word	0x05840485
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a84:	0000001c 	.word	0x0000001c
     a88:	00000a34 	.word	0x00000a34

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a8c:	08003634 	.word	0x08003634
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a90:	00000090 	.word	0x00000090
     a94:	44140e42 	.word	0x44140e42
	SinG4 = sin4;
     a98:	018e200e 	.word	0x018e200e
	CosG4 = cos4;
     a9c:	03860287 	.word	0x03860287
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa0:	05840485 	.word	0x05840485
	CosG4 = cos4;
     aa4:	0000001c 	.word	0x0000001c
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa8:	00000a34 	.word	0x00000a34
	CosG4 = cos4;

	GetSinCos(g_InControlState.BodyRot1.z + TotalZBal1);
     aac:	080036c4 	.word	0x080036c4
	SinB4 = sin4;
     ab0:	00000088 	.word	0x00000088
     ab4:	44140e42 	.word	0x44140e42
	CosB4 = cos4;
     ab8:	018e200e 	.word	0x018e200e

	GetSinCos(g_InControlState.BodyRot1.y + (RotationY * c1DEC) + TotalYBal1);
     abc:	03860287 	.word	0x03860287
     ac0:	05840485 	.word	0x05840485
     ac4:	0000001c 	.word	0x0000001c
     ac8:	00000a34 	.word	0x00000a34
     acc:	0800374c 	.word	0x0800374c

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     ad0:	00000058 	.word	0x00000058
     ad4:	8e140e42 	.word	0x8e140e42
     ad8:	86028701 	.word	0x86028701
     adc:	84048503 	.word	0x84048503
     ae0:	200e4405 	.word	0x200e4405
     ae4:	0000001c 	.word	0x0000001c
     ae8:	00000a34 	.word	0x00000a34
     aec:	080037a4 	.word	0x080037a4
     af0:	00000058 	.word	0x00000058
     af4:	8e140e42 	.word	0x8e140e42
     af8:	86028701 	.word	0x86028701
     afc:	84048503 	.word	0x84048503
     b00:	200e4405 	.word	0x200e4405
     b04:	00000018 	.word	0x00000018
     b08:	00000a34 	.word	0x00000a34
     b0c:	080037fc 	.word	0x080037fc
     b10:	00000064 	.word	0x00000064
     b14:	8e0c0e44 	.word	0x8e0c0e44
     b18:	84028501 	.word	0x84028501
     b1c:	100e5003 	.word	0x100e5003
     b20:	00000014 	.word	0x00000014
     b24:	00000a34 	.word	0x00000a34
     b28:	08003860 	.word	0x08003860
     b2c:	0000001c 	.word	0x0000001c
     b30:	8e080e44 	.word	0x8e080e44
     b34:	00028401 	.word	0x00028401
     b38:	00000014 	.word	0x00000014
     b3c:	00000a34 	.word	0x00000a34
     b40:	0800387c 	.word	0x0800387c
     b44:	0000000c 	.word	0x0000000c
     b48:	42040e42 	.word	0x42040e42
     b4c:	018e080e 	.word	0x018e080e
     b50:	00000018 	.word	0x00000018
     b54:	00000a34 	.word	0x00000a34
     b58:	08003888 	.word	0x08003888
     b5c:	0000001c 	.word	0x0000001c
     b60:	8e0c0e42 	.word	0x8e0c0e42
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b64:	84028501 	.word	0x84028501
     b68:	100e4403 	.word	0x100e4403

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     b6c:	00000014 	.word	0x00000014
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b70:	00000a34 	.word	0x00000a34
     b74:	080038a4 	.word	0x080038a4
     b78:	0000004a 	.word	0x0000004a
     b7c:	44040e42 	.word	0x44040e42
     b80:	018e100e 	.word	0x018e100e
     b84:	00000014 	.word	0x00000014
     b88:	00000a34 	.word	0x00000a34
     b8c:	080038f0 	.word	0x080038f0
     b90:	00000076 	.word	0x00000076
     b94:	44040e42 	.word	0x44040e42
     b98:	018e100e 	.word	0x018e100e
     b9c:	00000014 	.word	0x00000014
     ba0:	00000a34 	.word	0x00000a34
     ba4:	08003968 	.word	0x08003968
     ba8:	00000074 	.word	0x00000074
     bac:	42040e42 	.word	0x42040e42
     bb0:	018e180e 	.word	0x018e180e
     bb4:	00000014 	.word	0x00000014
     bb8:	00000a34 	.word	0x00000a34
     bbc:	080039dc 	.word	0x080039dc
     bc0:	00000070 	.word	0x00000070
     bc4:	44040e42 	.word	0x44040e42
     bc8:	018e180e 	.word	0x018e180e
     bcc:	00000014 	.word	0x00000014
     bd0:	00000a34 	.word	0x00000a34
     bd4:	08003a4c 	.word	0x08003a4c
     bd8:	0000000c 	.word	0x0000000c
     bdc:	42040e42 	.word	0x42040e42
     be0:	018e080e 	.word	0x018e080e
     be4:	00000014 	.word	0x00000014
     be8:	00000a34 	.word	0x00000a34
     bec:	08003a58 	.word	0x08003a58
     bf0:	00000088 	.word	0x00000088
     bf4:	8e080e46 	.word	0x8e080e46
     bf8:	00028401 	.word	0x00028401
     bfc:	00000014 	.word	0x00000014
     c00:	00000a34 	.word	0x00000a34
     c04:	08003ae0 	.word	0x08003ae0
     c08:	00000094 	.word	0x00000094
     c0c:	44040e42 	.word	0x44040e42
     c10:	018e080e 	.word	0x018e080e
     c14:	00000018 	.word	0x00000018
     c18:	00000a34 	.word	0x00000a34
     c1c:	08003b74 	.word	0x08003b74
     c20:	0000005a 	.word	0x0000005a
     c24:	8e100e42 	.word	0x8e100e42
     c28:	85028601 	.word	0x85028601
     c2c:	00048403 	.word	0x00048403
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c30:	00000014 	.word	0x00000014
	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     c34:	00000a34 	.word	0x00000a34
     c38:	08003bd0 	.word	0x08003bd0
     c3c:	0000000c 	.word	0x0000000c
     c40:	42040e42 	.word	0x42040e42
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c44:	018e080e 	.word	0x018e080e
     c48:	00000014 	.word	0x00000014
     c4c:	00000a34 	.word	0x00000a34
     c50:	08003bdc 	.word	0x08003bdc
     c54:	00000030 	.word	0x00000030
     c58:	44040e42 	.word	0x44040e42
     c5c:	018e080e 	.word	0x018e080e
     c60:	00000014 	.word	0x00000014
     c64:	00000a34 	.word	0x00000a34
     c68:	08003c0c 	.word	0x08003c0c
     c6c:	0000000c 	.word	0x0000000c
     c70:	42040e42 	.word	0x42040e42
     c74:	018e080e 	.word	0x018e080e
     c78:	00000014 	.word	0x00000014
     c7c:	00000a34 	.word	0x00000a34
     c80:	08003c18 	.word	0x08003c18
     c84:	0000000c 	.word	0x0000000c
     c88:	42040e42 	.word	0x42040e42
     c8c:	018e080e 	.word	0x018e080e
     c90:	00000014 	.word	0x00000014
     c94:	00000a34 	.word	0x00000a34
     c98:	08003c24 	.word	0x08003c24
     c9c:	00000012 	.word	0x00000012
     ca0:	42040e42 	.word	0x42040e42
     ca4:	018e080e 	.word	0x018e080e
     ca8:	0000000c 	.word	0x0000000c
     cac:	ffffffff 	.word	0xffffffff
     cb0:	7c010001 	.word	0x7c010001
     cb4:	000d0c0e 	.word	0x000d0c0e
     cb8:	0000000c 	.word	0x0000000c
     cbc:	00000ca8 	.word	0x00000ca8
     cc0:	08003c38 	.word	0x08003c38
     cc4:	0000000c 	.word	0x0000000c
     cc8:	0000000c 	.word	0x0000000c
     ccc:	00000ca8 	.word	0x00000ca8
     cd0:	08003c44 	.word	0x08003c44
     cd4:	0000000c 	.word	0x0000000c
     cd8:	0000000c 	.word	0x0000000c
     cdc:	00000ca8 	.word	0x00000ca8
     ce0:	08003c50 	.word	0x08003c50
     ce4:	0000000c 	.word	0x0000000c
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * SinG4 / c4DEC
					+ (long) CPR_Z * c2DEC * CosG4 / c4DEC * SinA4 / c4DEC
							* SinB4 / c4DEC
					+ (long) CPR_Y * c2DEC * CosB4 / c4DEC * CosG4 / c4DEC))
			/ c2DEC;
}
     ce8:	0000000c 	.word	0x0000000c
     cec:	00000ca8 	.word	0x00000ca8
     cf0:	08003c5c 	.word	0x08003c5c
     cf4:	0000000c 	.word	0x0000000c
     cf8:	0000000c 	.word	0x0000000c
     cfc:	00000ca8 	.word	0x00000ca8
     d00:	08003c68 	.word	0x08003c68
     d04:	0000000c 	.word	0x0000000c
     d08:	0000000c 	.word	0x0000000c
     d0c:	00000ca8 	.word	0x00000ca8
     d10:	08003c74 	.word	0x08003c74
     d14:	00000024 	.word	0x00000024
     d18:	0000000c 	.word	0x0000000c
     d1c:	00000ca8 	.word	0x00000ca8
//FemurAngle1           - Output Angle of Femur in degrees
//TibiaAngle1           - Output Angle of Tibia in degrees
//CoxaAngle1            - Output Angle of Coxa in degrees
//--------------------------------------------------------------------
void LegIK(short IKFeetPosX, short IKFeetPosY, short IKFeetPosZ,
		byte LegIKLegNr) {
     d20:	08003c98 	.word	0x08003c98
     d24:	0000001c 	.word	0x0000001c
     d28:	0000000c 	.word	0x0000000c
	long Temp1;
	long Temp2;
	long T3;

	//Calculate IKCoxaAngle and IKFeetPosXZ
	GetATan2(IKFeetPosX, IKFeetPosZ);
     d2c:	00000ca8 	.word	0x00000ca8
	CoxaAngle1[LegIKLegNr] = (((long) Atan4 * 180) / 3141)
     d30:	08003cb4 	.word	0x08003cb4
     d34:	00000020 	.word	0x00000020
     d38:	0000000c 	.word	0x0000000c
     d3c:	00000ca8 	.word	0x00000ca8
     d40:	08003cd4 	.word	0x08003cd4
     d44:	00000008 	.word	0x00000008
     d48:	0000000c 	.word	0x0000000c
     d4c:	00000ca8 	.word	0x00000ca8
     d50:	08003cdc 	.word	0x08003cdc
     d54:	00000004 	.word	0x00000004
	//Length between the Coxa and tars [foot]
	IKFeetPosXZ = XYhyp2 / c2DEC;

	//Using GetAtan2 for solving IKA1 and IKSW
	//IKA14 - Angle between SW line and the ground in radians
	IKA14 = GetATan2(IKFeetPosY - TarsOffsetY,
     d58:	0000000c 	.word	0x0000000c
     d5c:	00000ca8 	.word	0x00000ca8
     d60:	08003ce0 	.word	0x08003ce0
     d64:	00000004 	.word	0x00000004
     d68:	0000000c 	.word	0x0000000c
     d6c:	00000ca8 	.word	0x00000ca8
     d70:	08003ce4 	.word	0x08003ce4

	//IKSW2 - Length between femur axis and tars
	IKSW2 = XYhyp2;

	//IKA2 - Angle of the line S>W with respect to the femur in radians
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     d74:	00000038 	.word	0x00000038
     d78:	00000018 	.word	0x00000018
     d7c:	00000ca8 	.word	0x00000ca8
     d80:	08003d1c 	.word	0x08003d1c
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			+ ((long) IKSW2 * IKSW2));
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);
     d84:	00000184 	.word	0x00000184
     d88:	440c0e42 	.word	0x440c0e42
     d8c:	018e100e 	.word	0x018e100e
     d90:	03840285 	.word	0x03840285
     d94:	00000018 	.word	0x00000018
     d98:	00000ca8 	.word	0x00000ca8
     d9c:	08003ea0 	.word	0x08003ea0
     da0:	000000fc 	.word	0x000000fc
     da4:	460c0e42 	.word	0x460c0e42
     da8:	018e100e 	.word	0x018e100e
     dac:	03840285 	.word	0x03840285
     db0:	00000014 	.word	0x00000014
     db4:	00000ca8 	.word	0x00000ca8

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     db8:	08003f9c 	.word	0x08003f9c
     dbc:	00000060 	.word	0x00000060
     dc0:	8e080e42 	.word	0x8e080e42
     dc4:	00028401 	.word	0x00028401
     dc8:	0000001c 	.word	0x0000001c
     dcc:	00000ca8 	.word	0x00000ca8
     dd0:	08003ffc 	.word	0x08003ffc
     dd4:	000000a8 	.word	0x000000a8
     dd8:	8e140e42 	.word	0x8e140e42
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     ddc:	86028701 	.word	0x86028701
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     de0:	84048503 	.word	0x84048503
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     de4:	180e4605 	.word	0x180e4605
     de8:	00000014 	.word	0x00000014
			+ ((long) (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr])
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);
     dec:	00000ca8 	.word	0x00000ca8
     df0:	080040a4 	.word	0x080040a4
     df4:	00000040 	.word	0x00000040
     df8:	46040e42 	.word	0x46040e42
     dfc:	018e080e 	.word	0x018e080e
     e00:	00000014 	.word	0x00000014
     e04:	00000ca8 	.word	0x00000ca8
     e08:	080040e4 	.word	0x080040e4

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e0c:	00000050 	.word	0x00000050
     e10:	44040e42 	.word	0x44040e42
     e14:	018e080e 	.word	0x018e080e
     e18:	00000014 	.word	0x00000014
     e1c:	00000ca8 	.word	0x00000ca8
     e20:	08004134 	.word	0x08004134
     e24:	0000003c 	.word	0x0000003c
     e28:	46040e42 	.word	0x46040e42
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e2c:	018e080e 	.word	0x018e080e
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e30:	00000014 	.word	0x00000014
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e34:	00000ca8 	.word	0x00000ca8
     e38:	08004170 	.word	0x08004170
     e3c:	00000010 	.word	0x00000010
     e40:	44040e42 	.word	0x44040e42
     e44:	018e080e 	.word	0x018e080e
			< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
					+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]) - 30)
					* c2DEC))
		IKSolution = 1;
     e48:	00000014 	.word	0x00000014
	else {
		if (IKSW2
     e4c:	00000ca8 	.word	0x00000ca8
     e50:	08004180 	.word	0x08004180
				< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
						+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))
						* c2DEC))
			IKSolutionWarning = 1;
     e54:	00000048 	.word	0x00000048
     e58:	44040e42 	.word	0x44040e42
		else
			IKSolutionError = 1;
     e5c:	018e080e 	.word	0x018e080e
	}

}
     e60:	00000014 	.word	0x00000014
     e64:	00000ca8 	.word	0x00000ca8
     e68:	080041c8 	.word	0x080041c8
     e6c:	0000004c 	.word	0x0000004c
     e70:	44040e42 	.word	0x44040e42
     e74:	018e080e 	.word	0x018e080e
     e78:	00000014 	.word	0x00000014
     e7c:	00000ca8 	.word	0x00000ca8
     e80:	08004214 	.word	0x08004214
     e84:	0000000c 	.word	0x0000000c
     e88:	42040e42 	.word	0x42040e42
     e8c:	018e080e 	.word	0x018e080e
     e90:	00000014 	.word	0x00000014
     e94:	00000ca8 	.word	0x00000ca8
     e98:	08004220 	.word	0x08004220
     e9c:	00000028 	.word	0x00000028
     ea0:	42040e42 	.word	0x42040e42
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ea4:	018e080e 	.word	0x018e080e
	if (sVal < s) {
     ea8:	0000000c 	.word	0x0000000c
     eac:	ffffffff 	.word	0xffffffff
		return s;
	}

	s = (short) pgm_read_word(sMax);
     eb0:	7c010001 	.word	0x7c010001
     eb4:	000d0c0e 	.word	0x000d0c0e
     eb8:	0000000c 	.word	0x0000000c

		return s;
	}
	return sVal;

}
     ebc:	00000ea8 	.word	0x00000ea8
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec0:	08004248 	.word	0x08004248
}

//--------------------------------------------------------------------
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
     ec4:	00000014 	.word	0x00000014
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec8:	0000000c 	.word	0x0000000c
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ecc:	00000ea8 	.word	0x00000ea8
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     ed0:	0800425c 	.word	0x0800425c
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ed4:	0000000c 	.word	0x0000000c
	if (sVal < s) {
     ed8:	0000000c 	.word	0x0000000c
     edc:	00000ea8 	.word	0x00000ea8
     ee0:	08004268 	.word	0x08004268
		return s;
	}

	s = (short) pgm_read_word(sMax);
     ee4:	0000000c 	.word	0x0000000c
     ee8:	0000000c 	.word	0x0000000c
     eec:	00000ea8 	.word	0x00000ea8
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
     ef0:	08004274 	.word	0x08004274
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ef4:	0000000c 	.word	0x0000000c
	if (sVal < s) {
     ef8:	0000000c 	.word	0x0000000c
     efc:	00000ea8 	.word	0x00000ea8
     f00:	08004280 	.word	0x08004280
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f04:	0000000c 	.word	0x0000000c
     f08:	0000000c 	.word	0x0000000c
     f0c:	00000ea8 	.word	0x00000ea8
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f10:	0800428c 	.word	0x0800428c
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f14:	0000000c 	.word	0x0000000c
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f18:	0000000c 	.word	0x0000000c
	if (sVal < s) {
     f1c:	00000ea8 	.word	0x00000ea8
     f20:	08004298 	.word	0x08004298
     f24:	00000010 	.word	0x00000010
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f28:	0000000c 	.word	0x0000000c
     f2c:	00000ea8 	.word	0x00000ea8
     f30:	080042a8 	.word	0x080042a8
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
				FemurAngle1[LegIndex], &cFemurMin1[LegIndex],
				&cFemurMax1[LegIndex]);
		TibiaAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f34:	0000000c 	.word	0x0000000c
     f38:	0000000c 	.word	0x0000000c
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     f3c:	00000ea8 	.word	0x00000ea8
     f40:	080042b4 	.word	0x080042b4
				TibiaAngle1[LegIndex], &cTibiaMin1[LegIndex],
				&cTibiaMax1[LegIndex]);

	}
#endif
}
     f44:	0000000c 	.word	0x0000000c
     f48:	0000000c 	.word	0x0000000c
     f4c:	00000ea8 	.word	0x00000ea8
     f50:	080042c0 	.word	0x080042c0
     f54:	0000000c 	.word	0x0000000c
     f58:	0000000c 	.word	0x0000000c
     f5c:	00000ea8 	.word	0x00000ea8
     f60:	080042cc 	.word	0x080042cc
     f64:	0000000c 	.word	0x0000000c
     f68:	0000000c 	.word	0x0000000c
     f6c:	00000ea8 	.word	0x00000ea8
// SmoothControl (From Zenta) -  This function makes the body
//            rotation and translation much smoother
//--------------------------------------------------------------------
short SmoothControl(short CtrlMoveInp, short CtrlMoveOut, byte CtrlDivider) {

	if (CtrlMoveOut < (CtrlMoveInp - 4))
     f70:	080042d8 	.word	0x080042d8
     f74:	00000018 	.word	0x00000018
		return CtrlMoveOut + abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f78:	00000018 	.word	0x00000018
     f7c:	00000ea8 	.word	0x00000ea8
     f80:	080042f0 	.word	0x080042f0
     f84:	00000120 	.word	0x00000120
     f88:	8e100e42 	.word	0x8e100e42
     f8c:	85028601 	.word	0x85028601
     f90:	00048403 	.word	0x00048403
	else if (CtrlMoveOut > (CtrlMoveInp + 4))
     f94:	00000018 	.word	0x00000018
		return CtrlMoveOut - abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f98:	00000ea8 	.word	0x00000ea8
     f9c:	08004410 	.word	0x08004410
     fa0:	000000f8 	.word	0x000000f8
     fa4:	440c0e42 	.word	0x440c0e42
     fa8:	018e100e 	.word	0x018e100e
     fac:	03840285 	.word	0x03840285
     fb0:	00000014 	.word	0x00000014

	return CtrlMoveInp;
}
     fb4:	00000ea8 	.word	0x00000ea8
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
     fb8:	08004508 	.word	0x08004508
     fbc:	00000044 	.word	0x00000044
     fc0:	44040e42 	.word	0x44040e42

//--------------------------------------------------------------------
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
     fc4:	018e100e 	.word	0x018e100e
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
		return g_wLegsXZLength;

	return isqrt32((LegPosX[0] * LegPosX[0]) + (LegPosZ[0] * LegPosZ[0]));
     fc8:	00000014 	.word	0x00000014
     fcc:	00000ea8 	.word	0x00000ea8
     fd0:	0800454c 	.word	0x0800454c
     fd4:	0000000c 	.word	0x0000000c
     fd8:	42040e42 	.word	0x42040e42
     fdc:	018e080e 	.word	0x018e080e
}
     fe0:	00000014 	.word	0x00000014
     fe4:	00000ea8 	.word	0x00000ea8
     fe8:	08004558 	.word	0x08004558
     fec:	00000030 	.word	0x00000030

#ifndef MAX_XZ_LEG_ADJUST
#define MAX_XZ_LEG_ADJUST   (word)(cCoxaLength[0]+cTibiaLength[0] + cFemurLength[0]/4)
#endif

void AdjustLegPositions(word XZLength1) {
     ff0:	42040e42 	.word	0x42040e42
     ff4:	018e080e 	.word	0x018e080e
     ff8:	0000000c 	.word	0x0000000c
     ffc:	ffffffff 	.word	0xffffffff
    1000:	7c010001 	.word	0x7c010001
		XZLength1 = MAX_XZ_LEG_ADJUST;
	if (XZLength1 < MIN_XZ_LEG_ADJUST)
		XZLength1 = MIN_XZ_LEG_ADJUST;

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
    1004:	000d0c0e 	.word	0x000d0c0e
    1008:	0000000c 	.word	0x0000000c
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    100c:	00000ff8 	.word	0x00000ff8

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
		return;

	g_wLegsXZLength = XZLength1;
    1010:	08004588 	.word	0x08004588

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));
    1014:	00000014 	.word	0x00000014
    1018:	0000000c 	.word	0x0000000c

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
    101c:	00000ff8 	.word	0x00000ff8
    1020:	0800459c 	.word	0x0800459c
    1024:	00000020 	.word	0x00000020
    1028:	0000000c 	.word	0x0000000c
    102c:	00000ff8 	.word	0x00000ff8
    1030:	080045bc 	.word	0x080045bc
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    1034:	0000000c 	.word	0x0000000c
    1038:	0000001c 	.word	0x0000001c
    103c:	00000ff8 	.word	0x00000ff8
    1040:	080045c8 	.word	0x080045c8
    1044:	000000b4 	.word	0x000000b4
    1048:	8e140e42 	.word	0x8e140e42
		return;

	g_wLegsXZLength = XZLength1;

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    104c:	86028701 	.word	0x86028701
		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
	}

	// Make sure we cycle through one gait to have the legs all move into their new locations...
	g_InControlState.ForceGaitStepCnt = g_InControlState.gaitCur.StepsInGait;
    1050:	84048503 	.word	0x84048503
    1054:	280e4405 	.word	0x280e4405
}
    1058:	00000014 	.word	0x00000014
    105c:	00000ff8 	.word	0x00000ff8
    1060:	0800467c 	.word	0x0800467c
    1064:	00000034 	.word	0x00000034
    1068:	42040e42 	.word	0x42040e42
    106c:	018e080e 	.word	0x018e080e
    1070:	00000018 	.word	0x00000018
    1074:	00000ff8 	.word	0x00000ff8
    1078:	080046b0 	.word	0x080046b0
		g_InControlState.aCoxaInitAngle1[LegIndex] = (short)pgm_read_word(&cCoxaAngle1[LegIndex]);
#endif
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    107c:	0000003c 	.word	0x0000003c
		else if (g_InControlState.aCoxaInitAngle1[LegIndex] < -700)
		g_InControlState.aCoxaInitAngle1[LegIndex] = -700;
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    1080:	8e100e44 	.word	0x8e100e44
//     to be appropriate for the current y location of the body...
//--------------------------------------------------------------------

u8 g_iLegInitIndex = 0x00; // remember which index we are currently using...

void AdjustLegPositionsToBodyHeight() {
    1084:	85028601 	.word	0x85028601
    1088:	00048403 	.word	0x00048403
#ifdef CNT_HEX_INITS
	// Lets see which of our units we should use...
	// Note: We will also limit our body height here...
	if (g_InControlState.BodyPos.y
    108c:	0000001c 	.word	0x0000001c
			> (short) pgm_read_byte(&g_abHexMaxBodyY[CNT_HEX_INITS-1]))
		g_InControlState.BodyPos.y = (short) pgm_read_byte(
    1090:	00000ff8 	.word	0x00000ff8
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    1094:	080046ec 	.word	0x080046ec
    1098:	00000068 	.word	0x00000068
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    109c:	8e140e42 	.word	0x8e140e42
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    10a0:	86028701 	.word	0x86028701
    10a4:	84048503 	.word	0x84048503
    10a8:	180e4405 	.word	0x180e4405
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    10ac:	0000001c 	.word	0x0000001c
		g_iLegInitIndex = i;  // remember the current index...
		AdjustLegPositions(XZLength1);
    10b0:	00000ff8 	.word	0x00000ff8
	}
#endif // CNT_HEX_INITS
}
    10b4:	08004754 	.word	0x08004754
    10b8:	00000120 	.word	0x00000120
    10bc:	44140e42 	.word	0x44140e42
}
//--------------------------------------------------------------------
//[CHECK VOLTAGE]
//Reads the input voltage and shuts down the bot when the power drops
byte s_bLVBeepCnt;
boolean CheckVoltage() {
    10c0:	018e380e 	.word	0x018e380e
    10c4:	03860287 	.word	0x03860287
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10c8:	05840485 	.word	0x05840485

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10cc:	0000001c 	.word	0x0000001c
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d0:	00000ff8 	.word	0x00000ff8

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10d4:	08004874 	.word	0x08004874
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d8:	000000b0 	.word	0x000000b0

	if (!g_fLowVoltageShutdown) {
		/**PrintString("Voltage : ");
		Printu32d(Voltage);
		PrintString("\n");*/
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {
    10dc:	46140e42 	.word	0x46140e42
    10e0:	018e400e 	.word	0x018e400e
    10e4:	03860287 	.word	0x03860287


			//Turn off
			g_InControlState.BodyPos.x = 0;
    10e8:	05840485 	.word	0x05840485
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;

#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
    10ec:	00000014 	.word	0x00000014
    10f0:	00000ff8 	.word	0x00000ff8
#endif
			g_fLowVoltageShutdown = 1;
    10f4:	08004924 	.word	0x08004924
			s_bLVBeepCnt = 0;    // how many times we beeped...
    10f8:	00000018 	.word	0x00000018
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {


			//Turn off
			g_InControlState.BodyPos.x = 0;
			g_InControlState.BodyPos.y = 0;
    10fc:	44040e42 	.word	0x44040e42
			g_InControlState.BodyPos.z = 0;
			g_InControlState.BodyRot1.x = 0;
    1100:	018e080e 	.word	0x018e080e
			g_InControlState.BodyRot1.y = 0;
			g_InControlState.BodyRot1.z = 0;
    1104:	00000014 	.word	0x00000014
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;
    1108:	00000ff8 	.word	0x00000ff8
#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
#endif
			g_fLowVoltageShutdown = 1;
			s_bLVBeepCnt = 0;    // how many times we beeped...
    110c:	0800493c 	.word	0x0800493c
			g_InControlState.fRobotOn = false;
    1110:	0000003c 	.word	0x0000003c
		}
#ifdef cTurnOnVol
	} else if ((Voltage > cTurnOnVol) && (Voltage < 1999)) {
    1114:	48040e42 	.word	0x48040e42
    1118:	018e080e 	.word	0x018e080e

		g_fLowVoltageShutdown = 0;
    111c:	0000001c 	.word	0x0000001c
    1120:	00000ff8 	.word	0x00000ff8

#endif
	} else {
		if (s_bLVBeepCnt < 5) {
    1124:	08004978 	.word	0x08004978
    1128:	0000039c 	.word	0x0000039c
			s_bLVBeepCnt++;
    112c:	8e140e42 	.word	0x8e140e42

			//MSound( 1, 45, 2000);
			Buzzed(45, 2000);
    1130:	86028701 	.word	0x86028701
    1134:	8503      	.short	0x8503
    1136:	04          	.byte	0x04
    1137:	84          	.byte	0x84
    1138:	200e4405 	.word	0x200e4405
		}
		mDelay(2000);
    113c:	0000000c 	.word	0x0000000c
    1140:	ffffffff 	.word	0xffffffff
    1144:	7c010001 	.word	0x7c010001
	}
#endif

	return g_fLowVoltageShutdown;
}
    1148:	000d0c0e 	.word	0x000d0c0e
    114c:	0000000c 	.word	0x0000000c
    1150:	0000113c 	.word	0x0000113c
    1154:	08004d14 	.word	0x08004d14
    1158:	0000002a 	.word	0x0000002a

//==============================================================================
// BackgroundProcess - Allows us to have some background processing for those
//    servo drivers that need us to do things like polling...
//==============================================================================
void BackgroundProcess(void) {
    115c:	00000018 	.word	0x00000018
    1160:	0000113c 	.word	0x0000113c
	if (g_fAXSpeedControl)
    1164:	08004d40 	.word	0x08004d40
		return;  // nothing to do in this mode...

	if (ServosEnabled) {
		//DebugToggle(A3);
		BioloidControllerEx_interpolateStep(false); // Do our background stuff...
    1168:	00000038 	.word	0x00000038
		Battery_Monitor_Alarm();
    116c:	8e0c0e42 	.word	0x8e0c0e42
	}
}
    1170:	84028501 	.word	0x84028501
    1174:	00000003 	.word	0x00000003
//Function that gets called from the main loop if the robot is not logically
//     on.  Gives us a chance to play some...
//--------------------------------------------------------------------
static u8 g_iIdleServoNum = (u8) - 1;
static u8 g_iIdleLedState = 1;  // what state to we wish to set...
void IdleTime(void) {
    1178:	0000000c 	.word	0x0000000c
    117c:	0000113c 	.word	0x0000113c
	// Each time we call this set servos LED on or off...
	g_iIdleServoNum++;
    1180:	08004d78 	.word	0x08004d78
	if (g_iIdleServoNum >= NUMSERVOS) {
    1184:	00000018 	.word	0x00000018
    1188:	0000000c 	.word	0x0000000c
		g_iIdleServoNum = 0;
    118c:	0000113c 	.word	0x0000113c
		g_iIdleLedState = 1 - g_iIdleLedState;
    1190:	08004d90 	.word	0x08004d90
    1194:	00000010 	.word	0x00000010
	}
	dxl_write_byte(pgm_read_byte(&cPinTable[g_iIdleServoNum]), AXM_LED,
    1198:	0000000c 	.word	0x0000000c
    119c:	0000113c 	.word	0x0000113c
    11a0:	08004da0 	.word	0x08004da0
    11a4:	00000010 	.word	0x00000010
    11a8:	0000000c 	.word	0x0000000c
			g_iIdleLedState);
	//ax12ReadPacket(6);  // get the response...


}
    11ac:	0000113c 	.word	0x0000113c
    11b0:	08004db0 	.word	0x08004db0
    11b4:	0000000c 	.word	0x0000000c
    11b8:	0000000c 	.word	0x0000000c

//--------------------------------------------------------------------
//[SetRegOnAllServos] Function that is called to set the state of one
//  register in all of the servos, like Torque on...
//--------------------------------------------------------------------
void SetRegOnAllServos(u8 bReg, u8 bVal) {
    11bc:	0000113c 	.word	0x0000113c
    11c0:	08004dbc 	.word	0x08004dbc
    11c4:	00000008 	.word	0x00000008
	 ax12write(bVal);

  }
  ax12write(0xff - (checksum % 256));
  setRX(0);*/
	 dxl_set_txpacket_id (BROADCAST_ID);
    11c8:	00000020 	.word	0x00000020
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    11cc:	0000113c 	.word	0x0000113c
	dxl_set_txpacket_parameter(0,bReg);
    11d0:	08004dc4 	.word	0x08004dc4
    11d4:	0000014c 	.word	0x0000014c
	dxl_set_txpacket_parameter(1,2);
    11d8:	42140e42 	.word	0x42140e42
    11dc:	8e01880e 	.word	0x8e01880e
    11e0:	86028701 	.word	0x86028701
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
    11e4:	84048503 	.word	0x84048503
    11e8:	00000005 	.word	0x00000005
    11ec:	00000018 	.word	0x00000018
    11f0:	0000113c 	.word	0x0000113c
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    11f4:	08004f10 	.word	0x08004f10
    11f8:	00000040 	.word	0x00000040
    11fc:	8e100e48 	.word	0x8e100e48
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1200:	85028601 	.word	0x85028601
    1204:	00048403 	.word	0x00048403
    1208:	00000014 	.word	0x00000014
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    120c:	0000113c 	.word	0x0000113c
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1210:	08004f50 	.word	0x08004f50
	 dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0,bReg);
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
    1214:	00000010 	.word	0x00000010
    1218:	46040e42 	.word	0x46040e42
    121c:	018e080e 	.word	0x018e080e
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
	}

	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
    1220:	0000001c 	.word	0x0000001c
    1224:	0000113c 	.word	0x0000113c
    1228:	08004f60 	.word	0x08004f60
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- SetRegOnAllServos ---\n");
#endif
	dxl_txrx_packet();
    122c:	0000003c 	.word	0x0000003c

	u16 CommStatus = dxl_get_result();
    1230:	42140e42 	.word	0x42140e42
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
    1234:	018e300e 	.word	0x018e300e
		PrintErrorCode();
    1238:	03860287 	.word	0x03860287
	else
		PrintCommStatus(CommStatus);
    123c:	05840485 	.word	0x05840485
#endif
}
    1240:	00000018 	.word	0x00000018
    1244:	0000113c 	.word	0x0000113c
    1248:	08004f9c 	.word	0x08004f9c
//--------------------------------------------------------------------
//[MakeSureServosAreOn] Function that is called to handle when you are
//  transistioning from servos all off to being on.  May need to read
//  in the current pose...
//--------------------------------------------------------------------
void MakeSureServosAreOn(void) {
    124c:	00000024 	.word	0x00000024

	if (ServosEnabled) {

		if (!g_fServosFree)
    1250:	8e100e42 	.word	0x8e100e42
			return;    // we are not free

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {
    1254:	85028601 	.word	0x85028601
    1258:	00048403 	.word	0x00048403

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
    125c:	0000001c 	.word	0x0000001c
    1260:	0000113c 	.word	0x0000113c
    1264:	08004fc0 	.word	0x08004fc0
    1268:	00000084 	.word	0x00000084
						AXM_PRESENT_POSITION_L);
				mDelay(25);
    126c:	42140e42 	.word	0x42140e42
    1270:	018e280e 	.word	0x018e280e

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
    1274:	03860287 	.word	0x03860287
    1278:	05840485 	.word	0x05840485
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
						AXM_PRESENT_POSITION_L);
				mDelay(25);
			}
		} else {
			BioloidControllerEx_readPose();
    127c:	0000001c 	.word	0x0000001c
		}

		SetRegOnAllServos(AXM_TORQUE_ENABLE, 1);  // Use sync write to do it.
    1280:	0000113c 	.word	0x0000113c
    1284:	08005044 	.word	0x08005044

		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = false;
    1288:	000000bc 	.word	0x000000bc
	}

}
    128c:	8e140e42 	.word	0x8e140e42
    1290:	86028701 	.word	0x86028701
    1294:	84048503 	.word	0x84048503
    1298:	180e5605 	.word	0x180e5605
    129c:	00000014 	.word	0x00000014

//------------------------------------------------------------------------------------------
//[BeginServoUpdate] Does whatever preperation that is needed to starrt a move of our servos
//------------------------------------------------------------------------------------------
void BeginServoUpdate(void)    // Start the update
		{
    12a0:	0000113c 	.word	0x0000113c

	MakeSureServosAreOn();
    12a4:	08005100 	.word	0x08005100
	if (ServosEnabled) {

		if (g_fAXSpeedControl) {
    12a8:	00000018 	.word	0x00000018
    12ac:	44040e42 	.word	0x44040e42

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awCurAXPos[i] = g_awGoalAXPos[i];
    12b0:	018e080e 	.word	0x018e080e
    12b4:	0000000c 	.word	0x0000000c
    12b8:	ffffffff 	.word	0xffffffff
		if (g_fAXSpeedControl) {

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
    12bc:	7c010001 	.word	0x7c010001
				g_awCurAXPos[i] = g_awGoalAXPos[i];
			}
#endif
		} else
			BioloidControllerEx_interpolateStep(true); // Make sure we call at least once
    12c0:	000d0c0e 	.word	0x000d0c0e
    12c4:	0000000c 	.word	0x0000000c

	}
}
    12c8:	000012b4 	.word	0x000012b4
    12cc:	08005118 	.word	0x08005118
    12d0:	0000000c 	.word	0x0000000c
    12d4:	0000000c 	.word	0x0000000c
}

//--------------------------------------------------------------------
//[FREE SERVOS] Frees all the servos
//--------------------------------------------------------------------
void FreeServos(void) {
    12d8:	000012b4 	.word	0x000012b4
    12dc:	08005124 	.word	0x08005124

	if (!g_fServosFree) {
    12e0:	0000000c 	.word	0x0000000c
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
    12e4:	0000000c 	.word	0x0000000c
    12e8:	000012b4 	.word	0x000012b4
    12ec:	08005130 	.word	0x08005130
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
			Relax(pgm_read_byte(&cPinTable[i]));
    12f0:	00000148 	.word	0x00000148
    12f4:	0000000c 	.word	0x0000000c
    12f8:	000012b4 	.word	0x000012b4

	if (!g_fServosFree) {
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
    12fc:	08005278 	.word	0x08005278
			Relax(pgm_read_byte(&cPinTable[i]));
		}
		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = true;
    1300:	00000054 	.word	0x00000054
	}
}
    1304:	00000014 	.word	0x00000014
    1308:	000012b4 	.word	0x000012b4
    130c:	080052cc 	.word	0x080052cc
extern void SetRegOnAllServos(u8 bReg, u8 bVal);

//--------------------------------------------------------------------
//Init
//--------------------------------------------------------------------
void Servo_Init(void) {
    1310:	00000040 	.word	0x00000040
	// First lets get the actual servo positions for all of our servos...
	//pinMode(0, OUTPUT);
	g_fServosFree = true;
    1314:	44040e42 	.word	0x44040e42

  poseSize = NUMSERVOS;
    1318:	018e080e 	.word	0x018e080e
    131c:	0000000c 	.word	0x0000000c
  BioloidControllerEx_readPose();
    1320:	ffffffff 	.word	0xffffffff
#ifdef cVoltagePin
	for (byte i=0; i < 8; i++)
	GetBatteryVoltage();  // init the voltage pin
#endif

	g_fAXSpeedControl = false;
    1324:	7c010001 	.word	0x7c010001
    1328:	000d0c0e 	.word	0x000d0c0e



	// Added - try to speed things up later if we do a query...
	SetRegOnAllServos(AXM_RETURN_DELAY_TIME, 0); // tell servos to give us back their info as quick as they can...
    132c:	00000014 	.word	0x00000014
    1330:	0000131c 	.word	0x0000131c

}
    1334:	0800530c 	.word	0x0800530c
    1338:	0000002c 	.word	0x0000002c
    133c:	44040e42 	.word	0x44040e42
    1340:	018e080e 	.word	0x018e080e

}

void setupPhoenix() {

	g_fShowDebugPrompt = true;
    1344:	00000014 	.word	0x00000014
void readSensors(){


}

void setupPhoenix() {
    1348:	0000131c 	.word	0x0000131c

	g_fShowDebugPrompt = true;
	g_fDebugOutput = false;
    134c:	08005338 	.word	0x08005338
    1350:	000000f0 	.word	0x000000f0
	//init BioloidEx
	BioloidControllerEx();
    1354:	8e080e42 	.word	0x8e080e42

	// Init our ServoDriver
	Servo_Init();
    1358:	00028401 	.word	0x00028401

	mDelay(10);
    135c:	00000014 	.word	0x00000014

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1360:	0000131c 	.word	0x0000131c
    1364:	08005428 	.word	0x08005428
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    1368:	00000042 	.word	0x00000042
    136c:	44040e42 	.word	0x44040e42
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1370:	018e080e 	.word	0x018e080e

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1374:	00000018 	.word	0x00000018
    1378:	0000131c 	.word	0x0000131c
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    137c:	0800546c 	.word	0x0800546c
    1380:	0000003e 	.word	0x0000003e
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1384:	8e100e42 	.word	0x8e100e42
    1388:	85028601 	.word	0x85028601
    138c:	00048403 	.word	0x00048403
	Servo_Init();

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1390:	0000000c 	.word	0x0000000c
    1394:	ffffffff 	.word	0xffffffff
    1398:	7c010001 	.word	0x7c010001

	ResetLegInitAngles();

	//Single leg control. Make sure no leg is selected
#ifdef OPT_SINGLELEG
	g_InControlState.SelectedLeg = 255; // No Leg selected
    139c:	000d0c0e 	.word	0x000d0c0e
    13a0:	00000014 	.word	0x00000014
	g_InControlState.PrevSelectedLeg = 255;
    13a4:	00001390 	.word	0x00001390
#endif
	//Body Positions
	g_InControlState.BodyPos.x = 0;
    13a8:	080054ac 	.word	0x080054ac
	g_InControlState.BodyPos.y = 0;
	g_InControlState.BodyPos.z = 0;
    13ac:	00000024 	.word	0x00000024

//Body Rotations
	g_InControlState.BodyRot1.x = 0;
	g_InControlState.BodyRot1.y = 0;
    13b0:	44040e42 	.word	0x44040e42
	g_InControlState.BodyRot1.z = 0;
	g_InControlState.BodyRotOffset.x = 0;
    13b4:	018e080e 	.word	0x018e080e
	g_InControlState.BodyRotOffset.y = 0; //Input Y offset value to adjust centerpoint of rotation
	g_InControlState.BodyRotOffset.z = 0;
    13b8:	0000000c 	.word	0x0000000c

	//Gait
	g_InControlState.GaitType = 0;
    13bc:	ffffffff 	.word	0xffffffff
	g_InControlState.BalanceMode = 0;
    13c0:	7c010001 	.word	0x7c010001
	g_InControlState.LegLiftHeight = 50;
	g_InControlState.ForceGaitStepCnt = 0; // added to try to adjust starting positions depending on height...
    13c4:	000d0c0e 	.word	0x000d0c0e
	g_InControlState.GaitStep = 1;
    13c8:	00000014 	.word	0x00000014
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    13cc:	000013b8 	.word	0x000013b8
	g_InControlState.BodyRotOffset.z = 0;

	//Gait
	g_InControlState.GaitType = 0;
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
    13d0:	080054d0 	.word	0x080054d0
    13d4:	0000002c 	.word	0x0000002c
void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    13d8:	44040e42 	.word	0x44040e42
    13dc:	018e080e 	.word	0x018e080e
    13e0:	0000000c 	.word	0x0000000c
//==============================================================================

// If both PS2 and XBee are defined then we will become secondary to the xbee
void CommanderInputController_Init(void) {

	g_BodyYOffset = 0;
    13e4:	ffffffff 	.word	0xffffffff
    13e8:	7c010001 	.word	0x7c010001
    13ec:	000d0c0e 	.word	0x000d0c0e
	g_BodyYShift = 0;
	//begin(XBEE_BAUD);
	GPSeq = 0;  // init to something...
    13f0:	00000018 	.word	0x00000018
    13f4:	000013e0 	.word	0x000013e0

	ControlMode = WALKMODE;
    13f8:	080054fc 	.word	0x080054fc
	HeightSpeedMode = NORM_NORM;
    13fc:	0000003c 	.word	0x0000003c
	//    DoubleHeightOn = false;
	DoubleTravelOn = false;
    1400:	420c0e42 	.word	0x420c0e42
	bJoystickWalkMode = 0;
    1404:	018e100e 	.word	0x018e100e
	GaitSelect();

	CommanderInputController_Init();

	// Servo Driver
	ServoMoveTime = 150;
    1408:	03840285 	.word	0x03840285
	g_InControlState.fRobotOn = 0;
    140c:	00000014 	.word	0x00000014
	g_fLowVoltageShutdown = false;
    1410:	000013e0 	.word	0x000013e0

}
    1414:	08005538 	.word	0x08005538
    1418:	0000000e 	.word	0x0000000e
    141c:	44040e42 	.word	0x44040e42
    1420:	018e080e 	.word	0x018e080e
    1424:	0000000c 	.word	0x0000000c
    1428:	ffffffff 	.word	0xffffffff
    142c:	7c010001 	.word	0x7c010001
    1430:	000d0c0e 	.word	0x000d0c0e
    1434:	0000000c 	.word	0x0000000c
    1438:	00001424 	.word	0x00001424
    143c:	08005548 	.word	0x08005548
    1440:	00000040 	.word	0x00000040
    1444:	00000014 	.word	0x00000014
    1448:	00001424 	.word	0x00001424
    144c:	08005588 	.word	0x08005588
    1450:	00000016 	.word	0x00000016
    1454:	4a040e42 	.word	0x4a040e42
    1458:	018e080e 	.word	0x018e080e
    145c:	0000000c 	.word	0x0000000c
    1460:	00001424 	.word	0x00001424
    1464:	080055a0 	.word	0x080055a0
//[CommitServoDriver Updates the positions of the servos - This outputs
//         as much of the command as we can without committing it.  This
//         allows us to once the previous update was completed to quickly
//        get the next command to start
//--------------------------------------------------------------------
void CommitServoDriver(word wMoveTime) {
    1468:	00000028 	.word	0x00000028
    146c:	0000000c 	.word	0x0000000c
    1470:	00001424 	.word	0x00001424


	CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1474:	080055c8 	.word	0x080055c8

      }
      ax12write(0xff - (checksum % 256));
      setRX(0);
*/
  	    dxl_set_txpacket_id (BROADCAST_ID);
    1478:	00000038 	.word	0x00000038
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    147c:	0000000c 	.word	0x0000000c
    1480:	00001424 	.word	0x00001424
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
    1484:	08005600 	.word	0x08005600
    1488:	00000038 	.word	0x00000038
		dxl_set_txpacket_parameter(1, 2);
    148c:	0000000c 	.word	0x0000000c
    1490:	00001424 	.word	0x00001424
    1494:	08005638 	.word	0x08005638
    1498:	00000018 	.word	0x00000018
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
			wSpeed = CalculateAX12MoveSpeed(g_awCurAXPos[i], g_awGoalAXPos[i], wMoveTime);    // What order should we store these values?
    149c:	0000000c 	.word	0x0000000c
    14a0:	00001424 	.word	0x00001424
    14a4:	08005650 	.word	0x08005650
    14a8:	00000010 	.word	0x00000010
			//dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
			byte id = pgm_read_byte(&cPinTable[i]);
			dxl_set_txpacket_parameter(2 + 3 * i, id);
    14ac:	00000014 	.word	0x00000014
    14b0:	00001424 	.word	0x00001424
    14b4:	08005660 	.word	0x08005660
    14b8:	000000fc 	.word	0x000000fc
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(g_awGoalAXPos[i]));
    14bc:	8e080e44 	.word	0x8e080e44
    14c0:	00028401 	.word	0x00028401
    14c4:	00000014 	.word	0x00000014
    14c8:	00001424 	.word	0x00001424
    14cc:	0800575c 	.word	0x0800575c
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
    14d0:	00000038 	.word	0x00000038
    14d4:	44040e42 	.word	0x44040e42
    14d8:	018e080e 	.word	0x018e080e
    14dc:	00000018 	.word	0x00000018
    14e0:	00001424 	.word	0x00001424
    14e4:	08005794 	.word	0x08005794
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
    14e8:	00000044 	.word	0x00000044
    14ec:	8e0c0e42 	.word	0x8e0c0e42
    14f0:	84028501 	.word	0x84028501
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
    14f4:	100e4403 	.word	0x100e4403
    14f8:	0000000c 	.word	0x0000000c
    14fc:	ffffffff 	.word	0xffffffff
    1500:	7c010001 	.word	0x7c010001
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
		dxl_set_txpacket_parameter(1, 2);
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
    1504:	000d0c0e 	.word	0x000d0c0e
    1508:	00000014 	.word	0x00000014
    150c:	000014f8 	.word	0x000014f8
    1510:	080057d8 	.word	0x080057d8
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
		}

		dxl_set_txpacket_length((4 + 1) * poseSize + 4);
    1514:	00000040 	.word	0x00000040
    1518:	44040e42 	.word	0x44040e42
    151c:	018e080e 	.word	0x018e080e
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- CommitServoDriver ---\n");
#endif
		dxl_txrx_packet();
    1520:	00000014 	.word	0x00000014

			u16 CommStatus = dxl_get_result();
    1524:	000014f8 	.word	0x000014f8
#ifdef USING_PC_UART
			if (CommStatus == DXL_RXSUCCESS)
    1528:	08005818 	.word	0x08005818
				PrintErrorCode();
    152c:	00000024 	.word	0x00000024
			else
				PrintCommStatus(CommStatus);
    1530:	44040e42 	.word	0x44040e42
    1534:	018e080e 	.word	0x018e080e
#endif
#endif
		} else {
			BioloidControllerEx_interpolateSetup(wMoveTime);
    1538:	0000001c 	.word	0x0000001c

	}

	CommanderInputController_AllowControllerInterrupts(true);

}
    153c:	000014f8 	.word	0x000014f8
    1540:	0800583c 	.word	0x0800583c
    1544:	000000e8 	.word	0x000000e8
    1548:	42100e42 	.word	0x42100e42
    154c:	018e280e 	.word	0x018e280e
    1550:	03850286 	.word	0x03850286
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    1554:	00000484 	.word	0x00000484
    1558:	0000001c 	.word	0x0000001c
    155c:	000014f8 	.word	0x000014f8
    1560:	08005924 	.word	0x08005924
    1564:	000001d8 	.word	0x000001d8


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1568:	42140e42 	.word	0x42140e42
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    156c:	018e200e 	.word	0x018e200e
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1570:	03860287 	.word	0x03860287
    1574:	05840485 	.word	0x05840485
    1578:	0000001c 	.word	0x0000001c
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    157c:	000014f8 	.word	0x000014f8
    1580:	08005afc 	.word	0x08005afc
    1584:	0000006e 	.word	0x0000006e


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1588:	46100e42 	.word	0x46100e42
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    158c:	018e180e 	.word	0x018e180e
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1590:	03850286 	.word	0x03850286
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1594:	00000484 	.word	0x00000484
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    1598:	00000014 	.word	0x00000014

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
    159c:	000014f8 	.word	0x000014f8
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    15a0:	08005b6c 	.word	0x08005b6c
			g_awGoalAXPos[FIRSTTIBIAPIN + LegIndex] = wTibiaSDV;
    15a4:	00000094 	.word	0x00000094
    15a8:	42040e42 	.word	0x42040e42
    15ac:	018e080e 	.word	0x018e080e

#endif
		} else {
			BioloidControllerEx_setNextPose(
    15b0:	00000014 	.word	0x00000014
    15b4:	000014f8 	.word	0x000014f8
					pgm_read_byte(&cPinTable[FIRSTCOXAPIN + LegIndex]),
					wCoxaSDV);
			BioloidControllerEx_setNextPose(
    15b8:	08005c00 	.word	0x08005c00
    15bc:	0000002c 	.word	0x0000002c
    15c0:	46040e42 	.word	0x46040e42
					pgm_read_byte(&cPinTable[FIRSTFEMURPIN + LegIndex]),
					wFemurSDV);
			BioloidControllerEx_setNextPose(
    15c4:	018e080e 	.word	0x018e080e
    15c8:	0000000c 	.word	0x0000000c
					wTibiaSDV);

		}
	}
	CommanderInputController_AllowControllerInterrupts(true); // Ok for hserial again...
}
    15cc:	ffffffff 	.word	0xffffffff
    15d0:	7c010001 	.word	0x7c010001
    15d4:	000d0c0e 	.word	0x000d0c0e
    15d8:	0000000c 	.word	0x0000000c
    15dc:	000015c8 	.word	0x000015c8

void StartUpdateServos() {
    15e0:	08005c2c 	.word	0x08005c2c
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update
    15e4:	00000014 	.word	0x00000014
    15e8:	0000000c 	.word	0x0000000c
    15ec:	000015c8 	.word	0x000015c8

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		OutputServoInfoForLeg(LegIndex,
    15f0:	08005c40 	.word	0x08005c40
    15f4:	0000003c 	.word	0x0000003c
    15f8:	0000000c 	.word	0x0000000c
    15fc:	000015c8 	.word	0x000015c8
    1600:	08005c7c 	.word	0x08005c7c
    1604:	00000028 	.word	0x00000028
    1608:	0000000c 	.word	0x0000000c
    160c:	000015c8 	.word	0x000015c8
    1610:	08005ca4 	.word	0x08005ca4
    1614:	00000018 	.word	0x00000018
    1618:	0000000c 	.word	0x0000000c
    161c:	000015c8 	.word	0x000015c8
    1620:	08005cbc 	.word	0x08005cbc
    1624:	00000048 	.word	0x00000048
    1628:	0000001c 	.word	0x0000001c
    162c:	000015c8 	.word	0x000015c8
    1630:	08005d04 	.word	0x08005d04
    1634:	00000054 	.word	0x00000054
    1638:	8e140e42 	.word	0x8e140e42
    163c:	86028701 	.word	0x86028701
    1640:	84048503 	.word	0x84048503
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1644:	200e4805 	.word	0x200e4805
				cTibiaInv[LegIndex] ?
						-TibiaAngle1[LegIndex] : TibiaAngle1[LegIndex]);

	}

}
    1648:	0000000c 	.word	0x0000000c
    164c:	000015c8 	.word	0x000015c8
    1650:	08005d58 	.word	0x08005d58
    1654:	0000002c 	.word	0x0000002c
    1658:	0000001c 	.word	0x0000001c
    165c:	000015c8 	.word	0x000015c8
    1660:	08005d84 	.word	0x08005d84
#else
word g_wLastVoltage = 0xffff;    // save the last voltage we retrieved...
byte g_bLegVoltage = 0;		// what leg did we last check?
unsigned long g_ulTimeLastBatteryVoltage;
#define VOLTAGE_REPEAT_MAX  3
word GetBatteryVoltage(void) {
    1664:	0000005c 	.word	0x0000005c
	if (interpolating && (g_wLastVoltage != 0xffff)
    1668:	8e140e42 	.word	0x8e140e42
    166c:	86028701 	.word	0x86028701
    1670:	84048503 	.word	0x84048503
    1674:	200e4805 	.word	0x200e4805
    1678:	0000000c 	.word	0x0000000c
    167c:	000015c8 	.word	0x000015c8
    1680:	08005de0 	.word	0x08005de0
    1684:	00000014 	.word	0x00000014
			&& ((getMillis() - g_ulTimeLastBatteryVoltage)
					< VOLTAGE_MAX_TIME_BETWEEN_CALLS))
		return g_wLastVoltage;
    1688:	00000014 	.word	0x00000014

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
    168c:	000015c8 	.word	0x000015c8
    1690:	08005df4 	.word	0x08005df4
    1694:	00000078 	.word	0x00000078
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    1698:	44040e42 	.word	0x44040e42
			g_wLastVoltage = wVoltage * 10;
    169c:	018e080e 	.word	0x018e080e

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    16a0:	00000014 	.word	0x00000014
			g_wLastVoltage = wVoltage * 10;
    16a4:	000015c8 	.word	0x000015c8
		}
	} while (--bLoopCnt);

	return 0;

}
    16a8:	08005e6c 	.word	0x08005e6c
    16ac:	00000012 	.word	0x00000012
    16b0:	46040e42 	.word	0x46040e42
    16b4:	018e080e 	.word	0x018e080e
// ReadMsgs
//==============================================================================

/* process messages coming from Commander
 *  format = 0xFF RIGHT_H RIGHT_V LEFT_H LEFT_V BUTTONS EXT CHECKSUM */
int Commander_ReadMsgs() {
    16b8:	00000018 	.word	0x00000018
	 }
	 #endif
	 */
	//while (CheckZBNewArrive() > 0) {
	while (1) {
		if (zgb_rx_check_arduino() == 1) {
    16bc:	000015c8 	.word	0x000015c8
    16c0:	08005e80 	.word	0x08005e80

			leftV = (signed char) (zgb_rx_data_right_V_());
    16c4:	00000054 	.word	0x00000054
    16c8:	8e100e42 	.word	0x8e100e42
			leftH = (signed char) (zgb_rx_data_right_H_());
    16cc:	85028601 	.word	0x85028601
    16d0:	00048403 	.word	0x00048403
			rightV = (signed char) (zgb_rx_data_left_V_());
    16d4:	00000014 	.word	0x00000014
    16d8:	000015c8 	.word	0x000015c8
			rightH = (signed char) (zgb_rx_data_left_H_());
    16dc:	08005ed4 	.word	0x08005ed4
    16e0:	00000014 	.word	0x00000014
			buttons = zgb_rx_data_buttons();
    16e4:	44040e42 	.word	0x44040e42
    16e8:	018e080e 	.word	0x018e080e
			ext = zgb_rx_data_extra();
    16ec:	00000014 	.word	0x00000014
    16f0:	000015c8 	.word	0x000015c8

	}

	return 0;

}
    16f4:	08005ee8 	.word	0x08005ee8
    16f8:	00000024 	.word	0x00000024
    16fc:	44040e42 	.word	0x44040e42
    1700:	018e080e 	.word	0x018e080e
    1704:	00000014 	.word	0x00000014
    1708:	000015c8 	.word	0x000015c8
    170c:	08005f0c 	.word	0x08005f0c
    1710:	00000014 	.word	0x00000014

//==============================================================================
// This is The main code to input function to read inputs from the Commander and then
//process any commands.
//==============================================================================
void CommanderInputController_ControlInput(void) {
    1714:	44040e42 	.word	0x44040e42

	// See if we have a new command available...
	if (Commander_ReadMsgs() > 0) {
    1718:	018e080e 	.word	0x018e080e
    171c:	00000018 	.word	0x00000018
    1720:	000015c8 	.word	0x000015c8
    1724:	08005f20 	.word	0x08005f20
		// If we receive a valid message than turn robot on...
		boolean fAdjustLegPositions = false;
		short sLegInitXZAdjust = 0;
		short sLegInitAngleAdjust = 0;

		if (!g_InControlState.fRobotOn) {
    1728:	00000060 	.word	0x00000060
    172c:	420c0e42 	.word	0x420c0e42
			g_InControlState.fRobotOn = true;
    1730:	018e200e 	.word	0x018e200e
    1734:	03840285 	.word	0x03840285
		}

		// [SWITCH MODES]

		// Cycle through modes...
		if ((buttons & BUT_LT) && !(buttonsPrev & BUT_LT)) {
    1738:	00000018 	.word	0x00000018
    173c:	000015c8 	.word	0x000015c8
    1740:	08005f80 	.word	0x08005f80
    1744:	00000070 	.word	0x00000070
    1748:	420c0e42 	.word	0x420c0e42
    174c:	018e200e 	.word	0x018e200e

			if (++ControlMode >= MODECNT) {
    1750:	03840285 	.word	0x03840285
    1754:	00000018 	.word	0x00000018
    1758:	000015c8 	.word	0x000015c8
    175c:	08005ff0 	.word	0x08005ff0
				ControlMode = WALKMODE;    // cycled back around...
				Buzzed(50, 2000);
    1760:	00000060 	.word	0x00000060
    1764:	420c0e42 	.word	0x420c0e42
    1768:	018e200e 	.word	0x018e200e
				Buzzed(50, 3000);
    176c:	03840285 	.word	0x03840285
    1770:	00000014 	.word	0x00000014

			} else {
				Buzzed(50, 2000);
    1774:	000015c8 	.word	0x000015c8
    1778:	08006050 	.word	0x08006050
    177c:	00000090 	.word	0x00000090
			}
			if (ControlMode != SINGLELEGMODE)
    1780:	8e080e42 	.word	0x8e080e42
    1784:	00028401 	.word	0x00028401
				g_InControlState.SelectedLeg = 255;
    1788:	00000018 	.word	0x00000018
    178c:	000015c8 	.word	0x000015c8
    1790:	080060e0 	.word	0x080060e0

		}

		//[Common functions]
		//Switch Balance mode on/off
		if ((buttons & BUT_L4) && !(buttonsPrev & BUT_L4)) {
    1794:	00000040 	.word	0x00000040
    1798:	8e100e42 	.word	0x8e100e42
    179c:	85028601 	.word	0x85028601
    17a0:	00048403 	.word	0x00048403
    17a4:	00000014 	.word	0x00000014
    17a8:	000015c8 	.word	0x000015c8

			g_InControlState.BalanceMode = !g_InControlState.BalanceMode;
    17ac:	08006120 	.word	0x08006120
    17b0:	000000a0 	.word	0x000000a0
    17b4:	8e080e42 	.word	0x8e080e42
    17b8:	00028401 	.word	0x00028401
    17bc:	00000014 	.word	0x00000014
			if (g_InControlState.BalanceMode) {
    17c0:	000015c8 	.word	0x000015c8
				Buzzed(250, 1500);
    17c4:	080061c0 	.word	0x080061c0
    17c8:	0000000c 	.word	0x0000000c
			} else {
				Buzzed(100, 2000);
    17cc:	42040e42 	.word	0x42040e42
    17d0:	018e080e 	.word	0x018e080e
				Buzzed(50, 4000);
    17d4:	00000014 	.word	0x00000014
    17d8:	000015c8 	.word	0x000015c8
    17dc:	080061cc 	.word	0x080061cc
			}
		}

		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
    17e0:	00000030 	.word	0x00000030
    17e4:	8e080e42 	.word	0x8e080e42
    17e8:	00028401 	.word	0x00028401
    17ec:	00000014 	.word	0x00000014
    17f0:	000015c8 	.word	0x000015c8
    17f4:	080061fc 	.word	0x080061fc
			if (g_BodyYOffset > 0)
    17f8:	00000014 	.word	0x00000014
    17fc:	46040e42 	.word	0x46040e42
				g_BodyYOffset = 0;
    1800:	018e080e 	.word	0x018e080e
    1804:	0000000c 	.word	0x0000000c
			else
				g_BodyYOffset = 35;
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1808:	ffffffff 	.word	0xffffffff
		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
			if (g_BodyYOffset > 0)
				g_BodyYOffset = 0;
			else
				g_BodyYOffset = 35;
    180c:	7c010001 	.word	0x7c010001
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1810:	000d0c0e 	.word	0x000d0c0e
    1814:	0000000c 	.word	0x0000000c

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1818:	00001804 	.word	0x00001804
		int ly = leftV;
		if (buttons & BUT_L6) {
    181c:	08006210 	.word	0x08006210

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1820:	00000048 	.word	0x00000048
    1824:	0000000c 	.word	0x0000000c
		int ly = leftV;
    1828:	00001804 	.word	0x00001804
    182c:	08006258 	.word	0x08006258
		if (buttons & BUT_L6) {
    1830:	00000012 	.word	0x00000012
    1834:	0000000c 	.word	0x0000000c
			// raise or lower the robot on the joystick up /down
			// Maybe should have Min/Max
			int delta = rightV / 25;
    1838:	00001804 	.word	0x00001804
    183c:	0800626c 	.word	0x0800626c
    1840:	00000014 	.word	0x00000014
    1844:	0000000c 	.word	0x0000000c
    1848:	00001804 	.word	0x00001804
    184c:	08006280 	.word	0x08006280
			if (delta) {
    1850:	00000014 	.word	0x00000014
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
    1854:	0000000c 	.word	0x0000000c
    1858:	00001804 	.word	0x00001804
    185c:	08006294 	.word	0x08006294
    1860:	00000016 	.word	0x00000016
    1864:	0000000c 	.word	0x0000000c
    1868:	00001804 	.word	0x00001804
    186c:	080062ac 	.word	0x080062ac
    1870:	0000000a 	.word	0x0000000a
    1874:	0000000c 	.word	0x0000000c
			sLegInitAngleAdjust = ly / 8;
			lx = 0;
			ly = 0;

			// Likewise for Speed control
			delta = rightH / 16;   //
    1878:	00001804 	.word	0x00001804
    187c:	080062b8 	.word	0x080062b8
    1880:	0000000a 	.word	0x0000000a
    1884:	0000000c 	.word	0x0000000c
    1888:	00001804 	.word	0x00001804
			if ((delta < 0) && g_InControlState.SpeedControl) {
    188c:	080062c4 	.word	0x080062c4
    1890:	0000000a 	.word	0x0000000a
    1894:	0000000c 	.word	0x0000000c
				if ((word)(-delta) < g_InControlState.SpeedControl)
    1898:	00001804 	.word	0x00001804
					g_InControlState.SpeedControl += delta;
    189c:	080062d0 	.word	0x080062d0
				else
					g_InControlState.SpeedControl = 0;
    18a0:	0000000a 	.word	0x0000000a
    18a4:	0000000c 	.word	0x0000000c

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
    18a8:	00001804 	.word	0x00001804
    18ac:	080062dc 	.word	0x080062dc
    18b0:	00000014 	.word	0x00000014
				g_InControlState.SpeedControl += delta;
				if (g_InControlState.SpeedControl > 2000)
    18b4:	0000000c 	.word	0x0000000c
					g_InControlState.SpeedControl = 0;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
				g_InControlState.SpeedControl += delta;
    18b8:	00001804 	.word	0x00001804
				if (g_InControlState.SpeedControl > 2000)
					g_InControlState.SpeedControl = 2000;
    18bc:	080062f0 	.word	0x080062f0
    18c0:	0000000a 	.word	0x0000000a

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
    18c4:	0000000c 	.word	0x0000000c
    18c8:	00001804 	.word	0x00001804
    18cc:	080062fc 	.word	0x080062fc
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18d0:	00000010 	.word	0x00000010
    18d4:	0000000c 	.word	0x0000000c
    18d8:	00001804 	.word	0x00001804
    18dc:	0800630c 	.word	0x0800630c
			sLegInitAngleAdjust = ly / 8;
    18e0:	00000014 	.word	0x00000014
    18e4:	00000018 	.word	0x00000018
    18e8:	00001804 	.word	0x00001804
    18ec:	08006320 	.word	0x08006320
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f0:	00000096 	.word	0x00000096
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18f4:	8e0c0e44 	.word	0x8e0c0e44
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f8:	84028501 	.word	0x84028501
		}

		//[Walk functions]
		if (ControlMode == WALKMODE) {
    18fc:	00000003 	.word	0x00000003
    1900:	0000000c 	.word	0x0000000c
    1904:	00001804 	.word	0x00001804

			//Switch gates
			if (((buttons & BUT_R1) && !(buttonsPrev & BUT_R1))
    1908:	080063b8 	.word	0x080063b8
    190c:	00000014 	.word	0x00000014
    1910:	0000000c 	.word	0x0000000c
    1914:	00001804 	.word	0x00001804
    1918:	080063cc 	.word	0x080063cc
    191c:	00000006 	.word	0x00000006
    1920:	0000000c 	.word	0x0000000c
    1924:	00001804 	.word	0x00001804
    1928:	080063d4 	.word	0x080063d4
    192c:	0000000c 	.word	0x0000000c
    1930:	0000000c 	.word	0x0000000c
    1934:	00001804 	.word	0x00001804
    1938:	080063e0 	.word	0x080063e0
    193c:	00000014 	.word	0x00000014
    1940:	0000000c 	.word	0x0000000c
    1944:	00001804 	.word	0x00001804
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1948:	080063f4 	.word	0x080063f4
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    194c:	00000014 	.word	0x00000014
    1950:	0000000c 	.word	0x0000000c
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1954:	00001804 	.word	0x00001804
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    1958:	08006408 	.word	0x08006408
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
					Buzzed(50, 2000);
    195c:	0000000c 	.word	0x0000000c
    1960:	0000000c 	.word	0x0000000c
    1964:	00001804 	.word	0x00001804
				} else {
					Buzzed(50, 2000);
    1968:	08006414 	.word	0x08006414
    196c:	00000014 	.word	0x00000014
    1970:	0000000c 	.word	0x0000000c
					Buzzed(50, 2250);
    1974:	00001804 	.word	0x00001804
    1978:	08006428 	.word	0x08006428
					g_InControlState.GaitType = 0;
    197c:	00000014 	.word	0x00000014
    1980:	0000000c 	.word	0x0000000c
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    1984:	00001804 	.word	0x00001804
    1988:	0800643c 	.word	0x0800643c
    198c:	0000000a 	.word	0x0000000a

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    1990:	00000018 	.word	0x00000018
    1994:	00001804 	.word	0x00001804
    1998:	08006448 	.word	0x08006448
    199c:	00000062 	.word	0x00000062
    19a0:	8e0c0e44 	.word	0x8e0c0e44
				}
				GaitSelect();
			}

			//Double leg lift height
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    19a4:	84028501 	.word	0x84028501
    19a8:	00000003 	.word	0x00000003
    19ac:	0000000c 	.word	0x0000000c
    19b0:	00001804 	.word	0x00001804
    19b4:	080064ac 	.word	0x080064ac
				Buzzed(50, 2000);
    19b8:	00000010 	.word	0x00000010
    19bc:	00000010 	.word	0x00000010
				HeightSpeedMode = (HeightSpeedMode + 1) & 0x3; // wrap around mode
    19c0:	00001804 	.word	0x00001804
    19c4:	080064bc 	.word	0x080064bc
    19c8:	00000008 	.word	0x00000008
    19cc:	00080e42 	.word	0x00080e42
				DoubleTravelOn = HeightSpeedMode & 0x1;
    19d0:	00000010 	.word	0x00000010
    19d4:	00001804 	.word	0x00001804
				if (HeightSpeedMode & 0x2)
    19d8:	080064c4 	.word	0x080064c4
    19dc:	0000000e 	.word	0x0000000e
					g_InControlState.LegLiftHeight = 80;
    19e0:	00080e42 	.word	0x00080e42
    19e4:	0000000c 	.word	0x0000000c
				else
					g_InControlState.LegLiftHeight = 50;
			}

			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {
    19e8:	00001804 	.word	0x00001804
    19ec:	080064d4 	.word	0x080064d4
    19f0:	00000010 	.word	0x00000010
    19f4:	0000000c 	.word	0x0000000c
    19f8:	00001804 	.word	0x00001804

				if ((++bJoystickWalkMode) > 1)
    19fc:	080064e4 	.word	0x080064e4
    1a00:	00000006 	.word	0x00000006
    1a04:	0000000c 	.word	0x0000000c

					bJoystickWalkMode = 0;
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a08:	00001804 	.word	0x00001804
			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {

				if ((++bJoystickWalkMode) > 1)

					bJoystickWalkMode = 0;
    1a0c:	080064ec 	.word	0x080064ec
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a10:	0000000c 	.word	0x0000000c
    1a14:	0000000c 	.word	0x0000000c
    1a18:	00001804 	.word	0x00001804
    1a1c:	080064f8 	.word	0x080064f8
			}

			//Walking
			switch (bJoystickWalkMode) {
    1a20:	0000001c 	.word	0x0000001c
    1a24:	0000000c 	.word	0x0000000c
    1a28:	00001804 	.word	0x00001804
			case 0:
				g_InControlState.TravelLength.x = -lx;
    1a2c:	08006514 	.word	0x08006514
    1a30:	0000000c 	.word	0x0000000c
    1a34:	0000000c 	.word	0x0000000c
				g_InControlState.TravelLength.z = -ly;
    1a38:	00001804 	.word	0x00001804
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
				break;
			case 1:
				g_InControlState.TravelLength.z = (rightV); //Right Stick Up/Down
    1a3c:	08006520 	.word	0x08006520
    1a40:	00000008 	.word	0x00000008
    1a44:	0000000c 	.word	0x0000000c
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
    1a48:	00001804 	.word	0x00001804
    1a4c:	08006528 	.word	0x08006528
    1a50:	0000001a 	.word	0x0000001a
    1a54:	0000000c 	.word	0x0000000c
    1a58:	00001804 	.word	0x00001804
    1a5c:	08006544 	.word	0x08006544
				break;

			}

			if (!DoubleTravelOn) {  //(Double travel length)
    1a60:	00000008 	.word	0x00000008
				g_InControlState.TravelLength.x =
    1a64:	00000014 	.word	0x00000014
    1a68:	00001804 	.word	0x00001804
    1a6c:	0800654c 	.word	0x0800654c
						g_InControlState.TravelLength.x / 2;
				g_InControlState.TravelLength.z =
    1a70:	00000058 	.word	0x00000058
    1a74:	44040e42 	.word	0x44040e42
    1a78:	018e100e 	.word	0x018e100e
			}

		}

		//[Translate functions]
		g_BodyYShift = 0;
    1a7c:	0000000c 	.word	0x0000000c
    1a80:	ffffffff 	.word	0xffffffff
		if (ControlMode == TRANSLATEMODE) {
    1a84:	7c010001 	.word	0x7c010001
    1a88:	000d0c0e 	.word	0x000d0c0e

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
    1a8c:	0000000c 	.word	0x0000000c
    1a90:	00001a7c 	.word	0x00001a7c
    1a94:	080065a4 	.word	0x080065a4
    1a98:	00000018 	.word	0x00000018
    1a9c:	0000000c 	.word	0x0000000c
    1aa0:	00001a7c 	.word	0x00001a7c
    1aa4:	080065bc 	.word	0x080065bc
    1aa8:	00000018 	.word	0x00000018
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1aac:	0000000c 	.word	0x0000000c
    1ab0:	00001a7c 	.word	0x00001a7c
    1ab4:	080065d4 	.word	0x080065d4
    1ab8:	00000018 	.word	0x00000018
    1abc:	0000000c 	.word	0x0000000c
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac0:	00001a7c 	.word	0x00001a7c
		//[Translate functions]
		g_BodyYShift = 0;
		if (ControlMode == TRANSLATEMODE) {

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1ac4:	080065ec 	.word	0x080065ec
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac8:	00000018 	.word	0x00000018
    1acc:	0000000c 	.word	0x0000000c
    1ad0:	00001a7c 	.word	0x00001a7c
    1ad4:	08006604 	.word	0x08006604


			//      g_InControlState.BodyPos.x = (lx)/2;
			//      g_InControlState.BodyPos.z = -(ly)/3;
			//      g_InControlState.BodyRot1.y = (rightH)*2;
			g_BodyYShift = (-(rightV) / 2);
    1ad8:	00000010 	.word	0x00000010
    1adc:	0000000c 	.word	0x0000000c
    1ae0:	00001a7c 	.word	0x00001a7c
    1ae4:	08006614 	.word	0x08006614
    1ae8:	0000000c 	.word	0x0000000c
    1aec:	0000000c 	.word	0x0000000c
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
    1af0:	00001a7c 	.word	0x00001a7c
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1af4:	08006620 	.word	0x08006620
    1af8:	0000000c 	.word	0x0000000c
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1afc:	0000000c 	.word	0x0000000c
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1b00:	00001a7c 	.word	0x00001a7c
			g_BodyYShift = (-(rightV) / 2);
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
    1b04:	0800662c 	.word	0x0800662c
			g_InControlState.BodyRot1.y = (rightH) * 2;
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1b08:	00000010 	.word	0x00000010
    1b0c:	0000000c 	.word	0x0000000c
    1b10:	00001a7c 	.word	0x00001a7c
    1b14:	0800663c 	.word	0x0800663c
    1b18:	00000010 	.word	0x00000010
		}

		//[Single leg functions]
#ifdef OPT_SINGLELEG
		if (ControlMode == SINGLELEGMODE) {
    1b1c:	0000000c 	.word	0x0000000c

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
    1b20:	00001a7c 	.word	0x00001a7c
    1b24:	0800664c 	.word	0x0800664c
    1b28:	0000001c 	.word	0x0000001c
    1b2c:	0000000c 	.word	0x0000000c
    1b30:	00001a7c 	.word	0x00001a7c
				Buzzed(50,2000);
    1b34:	08006668 	.word	0x08006668
    1b38:	00000020 	.word	0x00000020
    1b3c:	0000000c 	.word	0x0000000c
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b40:	00001a7c 	.word	0x00001a7c
    1b44:	08006688 	.word	0x08006688
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
				} else {
					g_InControlState.SelectedLeg = 0;
    1b48:	0000000c 	.word	0x0000000c
		if (ControlMode == SINGLELEGMODE) {

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
				Buzzed(50,2000);
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b4c:	0000000c 	.word	0x0000000c
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
    1b50:	00001a7c 	.word	0x00001a7c
			   g_InControlState.SLLeg.x= (signed char)((int)((int)lx+128)/2); //Left Stick Right/Left
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
    1b54:	08006694 	.word	0x08006694
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b58:	0000002c 	.word	0x0000002c
    1b5c:	00000018 	.word	0x00000018
    1b60:	00001a7c 	.word	0x00001a7c
    1b64:	080066c0 	.word	0x080066c0
    1b68:	00000094 	.word	0x00000094
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b6c:	44080e42 	.word	0x44080e42
    1b70:	018e100e 	.word	0x018e100e
    1b74:	00000284 	.word	0x00000284
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b78:	0000001c 	.word	0x0000001c
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b7c:	00001a7c 	.word	0x00001a7c
    1b80:	08006754 	.word	0x08006754
    1b84:	0000005c 	.word	0x0000005c
				Buzzed(50,2000);
    1b88:	8e140e42 	.word	0x8e140e42
    1b8c:	86028701 	.word	0x86028701
				g_InControlState.fSLHold = !g_InControlState.fSLHold;
    1b90:	84048503 	.word	0x84048503
    1b94:	180e4605 	.word	0x180e4605
    1b98:	00000018 	.word	0x00000018
    1b9c:	00001a7c 	.word	0x00001a7c
			}
		}
#endif

		//Calculate walking time delay
		g_InControlState.InputTimeDelay = 128- max(max(abs(lx), abs(ly)), abs(rightH));
    1ba0:	080067b0 	.word	0x080067b0
    1ba4:	0000009c 	.word	0x0000009c
    1ba8:	8e0c0e42 	.word	0x8e0c0e42
    1bac:	84028501 	.word	0x84028501
    1bb0:	100e4403 	.word	0x100e4403
    1bb4:	00000014 	.word	0x00000014
    1bb8:	00001a7c 	.word	0x00001a7c
    1bbc:	0800684c 	.word	0x0800684c
    1bc0:	000000c0 	.word	0x000000c0
    1bc4:	8e080e42 	.word	0x8e080e42
    1bc8:	00028401 	.word	0x00028401
    1bcc:	00000018 	.word	0x00000018
    1bd0:	00001a7c 	.word	0x00001a7c

		//Calculate g_InControlState.BodyPos.y
		g_InControlState.BodyPos.y = max(g_BodyYOffset + g_BodyYShift, 0);
    1bd4:	0800690c 	.word	0x0800690c
    1bd8:	00000044 	.word	0x00000044
    1bdc:	8e100e42 	.word	0x8e100e42
    1be0:	85028601 	.word	0x85028601
    1be4:	00048403 	.word	0x00048403
    1be8:	00000018 	.word	0x00000018

		if (sLegInitXZAdjust || sLegInitAngleAdjust) {
    1bec:	00001a7c 	.word	0x00001a7c
    1bf0:	08006950 	.word	0x08006950
			// User asked for manual leg adjustment - only do when we have finished any previous adjustment

			if (!g_InControlState.ForceGaitStepCnt) {
    1bf4:	00000038 	.word	0x00000038
				if (sLegInitXZAdjust)
    1bf8:	8e100e42 	.word	0x8e100e42
					g_fDynamicLegXZLength = true;
    1bfc:	85028601 	.word	0x85028601
    1c00:	00048403 	.word	0x00048403

				sLegInitXZAdjust += GetLegsXZLength(); // Add on current length to our adjustment...
    1c04:	00000018 	.word	0x00000018
    1c08:	00001a7c 	.word	0x00001a7c
				// Handle maybe change angles...
				if (sLegInitAngleAdjust)
					RotateLegInitAngles(sLegInitAngleAdjust);

				// Give system time to process previous calls
				AdjustLegPositions(sLegInitXZAdjust);
    1c0c:	08006988 	.word	0x08006988
			}
		}

		if (fAdjustLegPositions && !g_fDynamicLegXZLength)
    1c10:	00000048 	.word	0x00000048
    1c14:	8e100e42 	.word	0x8e100e42
    1c18:	85028601 	.word	0x85028601
			AdjustLegPositionsToBodyHeight(); // Put main workings into main program file
    1c1c:	00048403 	.word	0x00048403
		// Save away the buttons state as to not process the same press twice.
		buttonsPrev = buttons;
    1c20:	00000014 	.word	0x00000014
    1c24:	00001a7c 	.word	0x00001a7c
		extPrev = ext;
    1c28:	080069d0 	.word	0x080069d0
    1c2c:	00000078 	.word	0x00000078
		g_ulLastMsgTime = getMillis();
    1c30:	8e080e42 	.word	0x8e080e42
    1c34:	00028401 	.word	0x00028401
	} else {
		// We did not receive a valid packet.  check for a timeout to see if we should turn robot off...
		if (g_InControlState.fRobotOn) {
    1c38:	00000014 	.word	0x00000014
			if ((getMillis() - g_ulLastMsgTime) > ARBOTIX_TO)
    1c3c:	00001a7c 	.word	0x00001a7c
    1c40:	08006a48 	.word	0x08006a48
    1c44:	0000003c 	.word	0x0000003c
    1c48:	8e080e42 	.word	0x8e080e42
    1c4c:	00028401 	.word	0x00028401
				CommanderTurnRobotOff();
    1c50:	00000018 	.word	0x00000018
		}
	}

}
    1c54:	00001a7c 	.word	0x00001a7c
    1c58:	08006a84 	.word	0x08006a84
    1c5c:	00000048 	.word	0x00000048
    1c60:	8e0c0e42 	.word	0x8e0c0e42
    1c64:	84028501 	.word	0x84028501
    1c68:	100e4403 	.word	0x100e4403
    1c6c:	0000000c 	.word	0x0000000c
    1c70:	ffffffff 	.word	0xffffffff
    1c74:	7c010001 	.word	0x7c010001
    1c78:	000d0c0e 	.word	0x000d0c0e
    1c7c:	0000001c 	.word	0x0000001c
    1c80:	00001c6c 	.word	0x00001c6c
    1c84:	08006acc 	.word	0x08006acc
    1c88:	000000a6 	.word	0x000000a6
    1c8c:	8e140e42 	.word	0x8e140e42
    1c90:	86028701 	.word	0x86028701
    1c94:	84048503 	.word	0x84048503
    1c98:	200e5a05 	.word	0x200e5a05
    1c9c:	0000000c 	.word	0x0000000c
    1ca0:	00001c6c 	.word	0x00001c6c
    1ca4:	08006b74 	.word	0x08006b74
    1ca8:	00000010 	.word	0x00000010
    1cac:	0000000c 	.word	0x0000000c

extern void setupPhoenix(void);
extern void readSensors(void);


int Big_main(void) {
    1cb0:	00001c6c 	.word	0x00001c6c

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
    1cb4:	08006b84 	.word	0x08006b84
	setupPhoenix();
    1cb8:	0000000c 	.word	0x0000000c
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1cbc:	0000000c 	.word	0x0000000c

	while (1){
		while (1) {
			//Start time
			unsigned long lTimeWaitEnd;
			lTimerStart = getMillis();
    1cc0:	00001c6c 	.word	0x00001c6c
    1cc4:	08006b90 	.word	0x08006b90
    1cc8:	00000006 	.word	0x00000006
#ifdef MILLIS
			PrintString("Barebones lTimerStart ");
			Printu32d(lTimerStart);
			PrintString("\n");
#endif
			DoBackgroundProcess();
    1ccc:	0000000c 	.word	0x0000000c
			//Read input
			CheckVoltage();        // check our voltages...
    1cd0:	00001c6c 	.word	0x00001c6c
			if (!g_fLowVoltageShutdown) {
    1cd4:	08006b98 	.word	0x08006b98
    1cd8:	0000000c 	.word	0x0000000c
				CommanderInputController_ControlInput();
    1cdc:	0000000c 	.word	0x0000000c
			}
			WriteOutputs();        // Write Outputs
			//Single leg control
			SingleLegControl();
    1ce0:	00001c6c 	.word	0x00001c6c
			DoBackgroundProcess();
    1ce4:	08006ba4 	.word	0x08006ba4

			//Gait
			GaitSeq();
    1ce8:	00000006 	.word	0x00000006

			DoBackgroundProcess();
    1cec:	0000000c 	.word	0x0000000c

			//Balance calculations
			TotalTransX = 0;     //reset values used for calculation of balance
    1cf0:	00001c6c 	.word	0x00001c6c
    1cf4:	08006bac 	.word	0x08006bac
			TotalTransZ = 0;
    1cf8:	00000004 	.word	0x00000004
			TotalTransY = 0;
    1cfc:	0000000c 	.word	0x0000000c
    1d00:	00001c6c 	.word	0x00001c6c
			TotalXBal1 = 0;
    1d04:	08006bb0 	.word	0x08006bb0
			TotalYBal1 = 0;
    1d08:	00000004 	.word	0x00000004
    1d0c:	0000000c 	.word	0x0000000c
			TotalZBal1 = 0;
    1d10:	00001c6c 	.word	0x00001c6c

			if (g_InControlState.BalanceMode) {
    1d14:	08006bb4 	.word	0x08006bb4
    1d18:	0000000a 	.word	0x0000000a
    1d1c:	0000000c 	.word	0x0000000c

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d20:	00001c6c 	.word	0x00001c6c

					DoBackgroundProcess();
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d24:	08006bc0 	.word	0x08006bc0
    1d28:	00000004 	.word	0x00000004
    1d2c:	0000000c 	.word	0x0000000c

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs

					DoBackgroundProcess();
    1d30:	00001c6c 	.word	0x00001c6c
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d34:	08006bc4 	.word	0x08006bc4
    1d38:	00000010 	.word	0x00000010
    1d3c:	0000000c 	.word	0x0000000c
    1d40:	00001c6c 	.word	0x00001c6c
    1d44:	08006bd4 	.word	0x08006bd4
    1d48:	00000020 	.word	0x00000020
    1d4c:	0000000c 	.word	0x0000000c
    1d50:	00001c6c 	.word	0x00001c6c
    1d54:	08006bf4 	.word	0x08006bf4
    1d58:	0000000c 	.word	0x0000000c
    1d5c:	00000018 	.word	0x00000018
    1d60:	00001c6c 	.word	0x00001c6c
    1d64:	08006c00 	.word	0x08006c00
    1d68:	00000060 	.word	0x00000060
    1d6c:	8e0c0e42 	.word	0x8e0c0e42
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d70:	84028501 	.word	0x84028501
    1d74:	00000003 	.word	0x00000003
    1d78:	00000014 	.word	0x00000014
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1d7c:	00001c6c 	.word	0x00001c6c
    1d80:	08006c60 	.word	0x08006c60
					DoBackgroundProcess();
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d84:	00000034 	.word	0x00000034
    1d88:	8e080e42 	.word	0x8e080e42
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
					DoBackgroundProcess();
    1d8c:	00028401 	.word	0x00028401
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d90:	00000014 	.word	0x00000014
    1d94:	00001c6c 	.word	0x00001c6c
    1d98:	08006c94 	.word	0x08006c94
    1d9c:	00000018 	.word	0x00000018
    1da0:	46040e42 	.word	0x46040e42
    1da4:	018e080e 	.word	0x018e080e
    1da8:	00000014 	.word	0x00000014
    1dac:	00001c6c 	.word	0x00001c6c
    1db0:	08006cac 	.word	0x08006cac
    1db4:	000000a8 	.word	0x000000a8
    1db8:	44040e42 	.word	0x44040e42
    1dbc:	018e100e 	.word	0x018e100e
    1dc0:	0000000c 	.word	0x0000000c
    1dc4:	ffffffff 	.word	0xffffffff
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1dc8:	7c010001 	.word	0x7c010001
    1dcc:	000d0c0e 	.word	0x000d0c0e
    1dd0:	0000000c 	.word	0x0000000c
							LegPosZ[LegIndex] + GaitPosZ[LegIndex],
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}
				BalanceBody();
    1dd4:	00001dc0 	.word	0x00001dc0
			}

			//Reset IKsolution indicators
			IKSolution = 0;
    1dd8:	08006d54 	.word	0x08006d54
    1ddc:	00000034 	.word	0x00000034
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1de0:	0000000c 	.word	0x0000000c
			}

			//Reset IKsolution indicators
			IKSolution = 0;
			IKSolutionWarning = 0;
			IKSolutionError = 0;
    1de4:	00001dc0 	.word	0x00001dc0
    1de8:	08006d88 	.word	0x08006d88

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
				DoBackgroundProcess();
    1dec:	00000030 	.word	0x00000030
				BodyFK(
    1df0:	0000000c 	.word	0x0000000c
    1df4:	00001dc0 	.word	0x00001dc0
    1df8:	08006db8 	.word	0x08006db8
    1dfc:	00000014 	.word	0x00000014
    1e00:	00000018 	.word	0x00000018
    1e04:	00001dc0 	.word	0x00001dc0
    1e08:	08006dcc 	.word	0x08006dcc
    1e0c:	0000007c 	.word	0x0000007c
    1e10:	8e0c0e42 	.word	0x8e0c0e42
    1e14:	84028501 	.word	0x84028501
    1e18:	00000003 	.word	0x00000003
    1e1c:	0000000c 	.word	0x0000000c
    1e20:	00001dc0 	.word	0x00001dc0
    1e24:	08006e48 	.word	0x08006e48
    1e28:	0000000c 	.word	0x0000000c
    1e2c:	0000000c 	.word	0x0000000c
    1e30:	00001dc0 	.word	0x00001dc0
    1e34:	08006e54 	.word	0x08006e54
    1e38:	00000018 	.word	0x00000018
    1e3c:	0000000c 	.word	0x0000000c
    1e40:	00001dc0 	.word	0x00001dc0
    1e44:	08006e6c 	.word	0x08006e6c
    1e48:	00000024 	.word	0x00000024
    1e4c:	0000000c 	.word	0x0000000c
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);

				LegIK(
    1e50:	00001dc0 	.word	0x00001dc0
    1e54:	08006e90 	.word	0x08006e90
    1e58:	0000000c 	.word	0x0000000c
    1e5c:	0000000c 	.word	0x0000000c
    1e60:	00001dc0 	.word	0x00001dc0
    1e64:	08006e9c 	.word	0x08006e9c
    1e68:	00000018 	.word	0x00000018
    1e6c:	0000000c 	.word	0x0000000c
    1e70:	00001dc0 	.word	0x00001dc0
    1e74:	08006eb4 	.word	0x08006eb4
    1e78:	00000010 	.word	0x00000010
    1e7c:	0000000c 	.word	0x0000000c
    1e80:	00001dc0 	.word	0x00001dc0
    1e84:	08006ec4 	.word	0x08006ec4
    1e88:	00000024 	.word	0x00000024
    1e8c:	0000000c 	.word	0x0000000c
    1e90:	00001dc0 	.word	0x00001dc0
    1e94:	08006ee8 	.word	0x08006ee8
    1e98:	0000000c 	.word	0x0000000c
    1e9c:	0000000c 	.word	0x0000000c
    1ea0:	00001dc0 	.word	0x00001dc0
    1ea4:	08006ef4 	.word	0x08006ef4
    1ea8:	00000014 	.word	0x00000014
    1eac:	0000000c 	.word	0x0000000c
    1eb0:	00001dc0 	.word	0x00001dc0
    1eb4:	08006f08 	.word	0x08006f08
    1eb8:	00000010 	.word	0x00000010
    1ebc:	0000000c 	.word	0x0000000c
    1ec0:	00001dc0 	.word	0x00001dc0
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1ec4:	08006f18 	.word	0x08006f18
    1ec8:	00000010 	.word	0x00000010
    1ecc:	0000000c 	.word	0x0000000c
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1ed0:	00001dc0 	.word	0x00001dc0
    1ed4:	08006f28 	.word	0x08006f28
				DoBackgroundProcess();
    1ed8:	0000001c 	.word	0x0000001c
				BodyFK(
    1edc:	0000000c 	.word	0x0000000c
    1ee0:	00001dc0 	.word	0x00001dc0
    1ee4:	08006f44 	.word	0x08006f44
    1ee8:	00000028 	.word	0x00000028
    1eec:	00000014 	.word	0x00000014
    1ef0:	00001dc0 	.word	0x00001dc0
    1ef4:	08006f6c 	.word	0x08006f6c
    1ef8:	00000058 	.word	0x00000058
    1efc:	8e080e42 	.word	0x8e080e42
    1f00:	00028401 	.word	0x00028401
    1f04:	0000000c 	.word	0x0000000c
    1f08:	00001dc0 	.word	0x00001dc0
    1f0c:	08006fc4 	.word	0x08006fc4
    1f10:	00000020 	.word	0x00000020
    1f14:	0000000c 	.word	0x0000000c
    1f18:	00001dc0 	.word	0x00001dc0
    1f1c:	08006fe4 	.word	0x08006fe4
    1f20:	00000018 	.word	0x00000018
    1f24:	0000000c 	.word	0x0000000c
    1f28:	00001dc0 	.word	0x00001dc0
    1f2c:	08006ffc 	.word	0x08006ffc
    1f30:	00000018 	.word	0x00000018
    1f34:	0000000c 	.word	0x0000000c
    1f38:	00001dc0 	.word	0x00001dc0
    1f3c:	08007014 	.word	0x08007014
    1f40:	00000020 	.word	0x00000020
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);
				LegIK(
    1f44:	0000000c 	.word	0x0000000c
    1f48:	00001dc0 	.word	0x00001dc0
    1f4c:	08007034 	.word	0x08007034
    1f50:	00000044 	.word	0x00000044
    1f54:	0000000c 	.word	0x0000000c
    1f58:	00001dc0 	.word	0x00001dc0
    1f5c:	08007078 	.word	0x08007078
    1f60:	00000014 	.word	0x00000014
    1f64:	00000014 	.word	0x00000014
    1f68:	00001dc0 	.word	0x00001dc0
    1f6c:	0800708c 	.word	0x0800708c
    1f70:	0000000c 	.word	0x0000000c
    1f74:	42040e42 	.word	0x42040e42
    1f78:	018e080e 	.word	0x018e080e
    1f7c:	00000014 	.word	0x00000014
    1f80:	00001dc0 	.word	0x00001dc0
    1f84:	08007098 	.word	0x08007098
    1f88:	0000000e 	.word	0x0000000e
    1f8c:	44040e42 	.word	0x44040e42
    1f90:	018e080e 	.word	0x018e080e
    1f94:	00000014 	.word	0x00000014
    1f98:	00001dc0 	.word	0x00001dc0
    1f9c:	080070a8 	.word	0x080070a8
    1fa0:	0000000c 	.word	0x0000000c
    1fa4:	42040e42 	.word	0x42040e42
    1fa8:	018e080e 	.word	0x018e080e
    1fac:	00000014 	.word	0x00000014
    1fb0:	00001dc0 	.word	0x00001dc0
    1fb4:	080070b4 	.word	0x080070b4
    1fb8:	0000000c 	.word	0x0000000c
    1fbc:	42040e42 	.word	0x42040e42
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1fc0:	018e080e 	.word	0x018e080e
    1fc4:	00000014 	.word	0x00000014
    1fc8:	00001dc0 	.word	0x00001dc0
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Check mechanical limits
			CheckAngles();
    1fcc:	080070c0 	.word	0x080070c0

			//Drive Servos
			if (g_InControlState.fRobotOn) {
    1fd0:	0000000c 	.word	0x0000000c
    1fd4:	42040e42 	.word	0x42040e42
    1fd8:	018e080e 	.word	0x018e080e
				if (g_InControlState.fRobotOn && !g_InControlState.fPrev_RobotOn) {
					// MSound(3, 60, 2000, 80, 2250, 100, 2500);
					Buzzed(30, 2000);
    1fdc:	00000014 	.word	0x00000014
    1fe0:	00001dc0 	.word	0x00001dc0
    1fe4:	080070cc 	.word	0x080070cc
					Buzzed(80, 2250);
    1fe8:	0000000c 	.word	0x0000000c
    1fec:	42040e42 	.word	0x42040e42
					Buzzed(100, 2500);
    1ff0:	018e080e 	.word	0x018e080e
    1ff4:	0000000c 	.word	0x0000000c
    1ff8:	ffffffff 	.word	0xffffffff

				}

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
    1ffc:	7c010001 	.word	0x7c010001
    2000:	000d0c0e 	.word	0x000d0c0e
    2004:	0000000c 	.word	0x0000000c
    2008:	00001ff4 	.word	0x00001ff4
    200c:	080070d8 	.word	0x080070d8
    2010:	0000000c 	.word	0x0000000c
    2014:	0000000c 	.word	0x0000000c
    2018:	00001ff4 	.word	0x00001ff4
    201c:	080070e4 	.word	0x080070e4
    2020:	0000000c 	.word	0x0000000c
    2024:	0000000c 	.word	0x0000000c
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2028:	00001ff4 	.word	0x00001ff4
    202c:	080070f0 	.word	0x080070f0
    2030:	00000014 	.word	0x00000014
    2034:	0000000c 	.word	0x0000000c
    2038:	00001ff4 	.word	0x00001ff4
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
    203c:	08007104 	.word	0x08007104

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2040:	0000000c 	.word	0x0000000c
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
						ServoMoveTime = ServoMoveTime + BALANCE_DELAY;
    2044:	0000000c 	.word	0x0000000c
    2048:	00001ff4 	.word	0x00001ff4
				} else
					//Movement speed excl. Walking
					ServoMoveTime = 200 + g_InControlState.SpeedControl;
    204c:	08007110 	.word	0x08007110
    2050:	00000014 	.word	0x00000014
    2054:	0000000c 	.word	0x0000000c

				// note we broke up the servo driver into start/commit that way we can output all of the servo information
				// before we wait and only have the termination information to output after the wait.  That way we hopefully
				// be more accurate with our timings...
				DoBackgroundProcess();
    2058:	00001ff4 	.word	0x00001ff4
				StartUpdateServos();
    205c:	08007124 	.word	0x08007124

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    2060:	00000010 	.word	0x00000010
					if ((GaitPosX[LegIndex] > cGPlimit)
    2064:	00000014 	.word	0x00000014
    2068:	00001ff4 	.word	0x00001ff4
    206c:	08007134 	.word	0x08007134
    2070:	00000034 	.word	0x00000034
    2074:	44040e44 	.word	0x44040e44
    2078:	018e080e 	.word	0x018e080e
    207c:	00000014 	.word	0x00000014
    2080:	00001ff4 	.word	0x00001ff4
    2084:	08007168 	.word	0x08007168
    2088:	00000038 	.word	0x00000038
    208c:	44040e44 	.word	0x44040e44
    2090:	018e080e 	.word	0x018e080e
    2094:	00000014 	.word	0x00000014
    2098:	00001ff4 	.word	0x00001ff4
    209c:	080071a0 	.word	0x080071a0
							|| (GaitPosZ[LegIndex] > cGPlimit)
							|| (GaitPosZ[LegIndex] < -cGPlimit)
							|| (GaitRotY[LegIndex] > cGPlimit)
							|| (GaitRotY[LegIndex] < -cGPlimit)) {

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
    20a0:	00000018 	.word	0x00000018
    20a4:	8e080e42 	.word	0x8e080e42
    20a8:	00028401 	.word	0x00028401

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    20ac:	0000000c 	.word	0x0000000c
    20b0:	ffffffff 	.word	0xffffffff

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
						break;
					}
				}
				if (bExtraCycle > 0) {
    20b4:	7c010001 	.word	0x7c010001
					bExtraCycle--;
    20b8:	000d0c0e 	.word	0x000d0c0e
    20bc:	0000000c 	.word	0x0000000c
					fWalking = !(bExtraCycle == 0);
    20c0:	000020ac 	.word	0x000020ac
    20c4:	080071b8 	.word	0x080071b8

					//Get endtime and calculate wait time
					lTimeWaitEnd = lTimerStart + PrevServoMoveTime;
    20c8:	00000040 	.word	0x00000040
    20cc:	0000000c 	.word	0x0000000c
    20d0:	000020ac 	.word	0x000020ac
					PrintString("\n");
#endif
					//DebugWrite(A1, HIGH);
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    20d4:	080071f8 	.word	0x080071f8
					} while (getMillis() < lTimeWaitEnd);
    20d8:	00000034 	.word	0x00000034
    20dc:	00000010 	.word	0x00000010
					PrintString("\n");
#endif

				}
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
    20e0:	000020ac 	.word	0x000020ac
    20e4:	0800722c 	.word	0x0800722c
    20e8:	00000030 	.word	0x00000030
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
    20ec:	00080e42 	.word	0x00080e42
					PrintString("Barebones lTimeWaitEnd-Millis  ");
					Printu32d(getMillis);
					PrintString("\n");
#endif
				} else {
					FreeServos();
    20f0:	0000000c 	.word	0x0000000c
    20f4:	000020ac 	.word	0x000020ac
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
					ServoMoveTime = 600;
    20f8:	0800725c 	.word	0x0800725c
    20fc:	00000014 	.word	0x00000014
					StartUpdateServos();
    2100:	0000000c 	.word	0x0000000c
					CommitServoDriver(ServoMoveTime);
    2104:	000020ac 	.word	0x000020ac
					//MSound(3, 100, 2500, 80, 2250, 60, 2000);
					Buzzed(100, 2500);
    2108:	08007270 	.word	0x08007270
    210c:	0000000c 	.word	0x0000000c
    2110:	0000000c 	.word	0x0000000c
					Buzzed(80, 2250);
    2114:	000020ac 	.word	0x000020ac
    2118:	0800727c 	.word	0x0800727c
					Buzzed(60, 2000);
    211c:	00000014 	.word	0x00000014
    2120:	0000000c 	.word	0x0000000c
    2124:	000020ac 	.word	0x000020ac

					//lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
					lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
    2128:	08007290 	.word	0x08007290
    212c:	0000000c 	.word	0x0000000c
					Printu32d(lTimeWaitEnd);
					PrintString("\n");
#endif
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    2130:	0000000c 	.word	0x0000000c
					} while (getMillis() < lTimeWaitEnd);
    2134:	000020ac 	.word	0x000020ac
    2138:	0800729c 	.word	0x0800729c
				} else {
					FreeServos();
				}

				// Allow the Servo driver to do stuff durint our idle time
				IdleTime();
    213c:	00000014 	.word	0x00000014
				mDelay(20); // give a pause between times we call if nothing is happening
    2140:	0000000c 	.word	0x0000000c
			}
			PrevServoMoveTime = ServoMoveTime;
    2144:	000020ac 	.word	0x000020ac
    2148:	080072b0 	.word	0x080072b0

			//Store previous g_InControlState.fRobotOn State
			if (g_InControlState.fRobotOn)
    214c:	00000010 	.word	0x00000010
    2150:	0000000c 	.word	0x0000000c
				g_InControlState.fPrev_RobotOn = 1;
			else
				g_InControlState.fPrev_RobotOn = 0;
    2154:	000020ac 	.word	0x000020ac
    2158:	080072c0 	.word	0x080072c0
    215c:	00000014 	.word	0x00000014
    2160:	0000000c 	.word	0x0000000c
    2164:	000020ac 	.word	0x000020ac
    2168:	080072d4 	.word	0x080072d4
    216c:	00000014 	.word	0x00000014
    2170:	0000000c 	.word	0x0000000c
    2174:	000020ac 	.word	0x000020ac
    2178:	080072e8 	.word	0x080072e8
    217c:	00000014 	.word	0x00000014
    2180:	0000000c 	.word	0x0000000c
    2184:	000020ac 	.word	0x000020ac
    2188:	080072fc 	.word	0x080072fc
    218c:	0000001c 	.word	0x0000001c
    2190:	0000000c 	.word	0x0000000c
    2194:	000020ac 	.word	0x000020ac
    2198:	08007318 	.word	0x08007318
    219c:	0000000c 	.word	0x0000000c
    21a0:	0000000c 	.word	0x0000000c
    21a4:	000020ac 	.word	0x000020ac
    21a8:	08007324 	.word	0x08007324
    21ac:	00000014 	.word	0x00000014
    21b0:	0000000c 	.word	0x0000000c
    21b4:	000020ac 	.word	0x000020ac
    21b8:	08007338 	.word	0x08007338
    21bc:	00000020 	.word	0x00000020
    21c0:	0000000c 	.word	0x0000000c
    21c4:	000020ac 	.word	0x000020ac
    21c8:	08007358 	.word	0x08007358
    21cc:	0000000c 	.word	0x0000000c
    21d0:	0000000c 	.word	0x0000000c
    21d4:	000020ac 	.word	0x000020ac
    21d8:	08007364 	.word	0x08007364
    21dc:	00000010 	.word	0x00000010
    21e0:	0000000c 	.word	0x0000000c
    21e4:	000020ac 	.word	0x000020ac
    21e8:	08007374 	.word	0x08007374
    21ec:	0000000c 	.word	0x0000000c
    21f0:	0000000c 	.word	0x0000000c
    21f4:	000020ac 	.word	0x000020ac
    21f8:	08007380 	.word	0x08007380
    21fc:	000000b8 	.word	0x000000b8
    2200:	0000000c 	.word	0x0000000c
    2204:	000020ac 	.word	0x000020ac
    2208:	08007438 	.word	0x08007438
    220c:	0000001c 	.word	0x0000001c
    2210:	0000000c 	.word	0x0000000c
    2214:	000020ac 	.word	0x000020ac
    2218:	08007454 	.word	0x08007454
    221c:	0000001c 	.word	0x0000001c
    2220:	0000000c 	.word	0x0000000c
    2224:	000020ac 	.word	0x000020ac
    2228:	08007470 	.word	0x08007470
    222c:	0000001c 	.word	0x0000001c
    2230:	0000000c 	.word	0x0000000c
    2234:	000020ac 	.word	0x000020ac
    2238:	0800748c 	.word	0x0800748c
    223c:	0000001c 	.word	0x0000001c
    2240:	0000000c 	.word	0x0000000c
    2244:	000020ac 	.word	0x000020ac
    2248:	080074a8 	.word	0x080074a8
    224c:	0000001c 	.word	0x0000001c
    2250:	0000000c 	.word	0x0000000c
    2254:	000020ac 	.word	0x000020ac
    2258:	080074c4 	.word	0x080074c4
    225c:	0000000c 	.word	0x0000000c
    2260:	0000000c 	.word	0x0000000c
    2264:	000020ac 	.word	0x000020ac
    2268:	080074d0 	.word	0x080074d0
    226c:	0000000c 	.word	0x0000000c
    2270:	0000000c 	.word	0x0000000c
    2274:	000020ac 	.word	0x000020ac
    2278:	080074dc 	.word	0x080074dc
    227c:	0000000c 	.word	0x0000000c
    2280:	0000000c 	.word	0x0000000c
    2284:	000020ac 	.word	0x000020ac
    2288:	080074e8 	.word	0x080074e8
    228c:	00000044 	.word	0x00000044
    2290:	0000000c 	.word	0x0000000c
    2294:	000020ac 	.word	0x000020ac
    2298:	0800752c 	.word	0x0800752c
    229c:	00000010 	.word	0x00000010
    22a0:	0000000c 	.word	0x0000000c
    22a4:	000020ac 	.word	0x000020ac
    22a8:	0800753c 	.word	0x0800753c
    22ac:	00000014 	.word	0x00000014
    22b0:	0000000c 	.word	0x0000000c
    22b4:	000020ac 	.word	0x000020ac
    22b8:	08007550 	.word	0x08007550
    22bc:	0000000c 	.word	0x0000000c
    22c0:	0000000c 	.word	0x0000000c
    22c4:	ffffffff 	.word	0xffffffff
    22c8:	7c010001 	.word	0x7c010001
    22cc:	000d0c0e 	.word	0x000d0c0e
    22d0:	0000000c 	.word	0x0000000c
    22d4:	000022c0 	.word	0x000022c0
    22d8:	0800755c 	.word	0x0800755c
    22dc:	0000001c 	.word	0x0000001c
    22e0:	0000000c 	.word	0x0000000c
    22e4:	000022c0 	.word	0x000022c0
    22e8:	08007578 	.word	0x08007578
    22ec:	0000000c 	.word	0x0000000c
    22f0:	0000000c 	.word	0x0000000c
    22f4:	000022c0 	.word	0x000022c0
    22f8:	08007584 	.word	0x08007584
    22fc:	0000002c 	.word	0x0000002c
    2300:	0000000c 	.word	0x0000000c
    2304:	000022c0 	.word	0x000022c0
    2308:	080075b0 	.word	0x080075b0
    230c:	0000001c 	.word	0x0000001c
    2310:	0000000c 	.word	0x0000000c
    2314:	000022c0 	.word	0x000022c0
    2318:	080075cc 	.word	0x080075cc
    231c:	0000000c 	.word	0x0000000c
    2320:	0000000c 	.word	0x0000000c
    2324:	000022c0 	.word	0x000022c0
    2328:	080075d8 	.word	0x080075d8
    232c:	00000028 	.word	0x00000028
    2330:	0000000c 	.word	0x0000000c
    2334:	ffffffff 	.word	0xffffffff
    2338:	7c010001 	.word	0x7c010001
    233c:	000d0c0e 	.word	0x000d0c0e
    2340:	0000000c 	.word	0x0000000c
    2344:	00002330 	.word	0x00002330
    2348:	08007600 	.word	0x08007600
    234c:	0000001e 	.word	0x0000001e
    2350:	0000000c 	.word	0x0000000c
    2354:	00002330 	.word	0x00002330
    2358:	08007620 	.word	0x08007620
    235c:	00000028 	.word	0x00000028
    2360:	0000000c 	.word	0x0000000c
    2364:	00002330 	.word	0x00002330
    2368:	08007648 	.word	0x08007648
    236c:	0000000e 	.word	0x0000000e
    2370:	0000000c 	.word	0x0000000c
    2374:	00002330 	.word	0x00002330
    2378:	08007658 	.word	0x08007658
    237c:	0000001a 	.word	0x0000001a
    2380:	00000010 	.word	0x00000010
    2384:	00002330 	.word	0x00002330
    2388:	08007674 	.word	0x08007674
    238c:	0000003e 	.word	0x0000003e
    2390:	00080e4e 	.word	0x00080e4e
    2394:	0000000c 	.word	0x0000000c
    2398:	00002330 	.word	0x00002330
    239c:	080076b4 	.word	0x080076b4
    23a0:	00000018 	.word	0x00000018
    23a4:	0000000c 	.word	0x0000000c
    23a8:	00002330 	.word	0x00002330
    23ac:	080076cc 	.word	0x080076cc
    23b0:	00000016 	.word	0x00000016
    23b4:	0000000c 	.word	0x0000000c
    23b8:	00002330 	.word	0x00002330
    23bc:	080076e4 	.word	0x080076e4
    23c0:	00000016 	.word	0x00000016
    23c4:	0000000c 	.word	0x0000000c
    23c8:	00002330 	.word	0x00002330
    23cc:	080076fc 	.word	0x080076fc
    23d0:	0000001a 	.word	0x0000001a
    23d4:	0000000c 	.word	0x0000000c
    23d8:	00002330 	.word	0x00002330
    23dc:	08007718 	.word	0x08007718
    23e0:	00000016 	.word	0x00000016
    23e4:	0000000c 	.word	0x0000000c
    23e8:	00002330 	.word	0x00002330
    23ec:	08007730 	.word	0x08007730
    23f0:	0000001a 	.word	0x0000001a
    23f4:	0000000c 	.word	0x0000000c
    23f8:	00002330 	.word	0x00002330
    23fc:	0800774c 	.word	0x0800774c
    2400:	00000008 	.word	0x00000008
    2404:	0000000c 	.word	0x0000000c
    2408:	00002330 	.word	0x00002330
    240c:	08007754 	.word	0x08007754
    2410:	00000008 	.word	0x00000008
    2414:	0000000c 	.word	0x0000000c
    2418:	00002330 	.word	0x00002330
    241c:	0800775c 	.word	0x0800775c
    2420:	0000000c 	.word	0x0000000c
    2424:	0000000c 	.word	0x0000000c
    2428:	00002330 	.word	0x00002330
    242c:	08007768 	.word	0x08007768
    2430:	00000012 	.word	0x00000012
    2434:	0000000c 	.word	0x0000000c
    2438:	00002330 	.word	0x00002330
    243c:	0800777c 	.word	0x0800777c
    2440:	00000012 	.word	0x00000012
    2444:	0000000c 	.word	0x0000000c
    2448:	00002330 	.word	0x00002330
    244c:	08007790 	.word	0x08007790
    2450:	0000001a 	.word	0x0000001a
    2454:	0000000c 	.word	0x0000000c
    2458:	00002330 	.word	0x00002330
    245c:	080077ac 	.word	0x080077ac
    2460:	0000001a 	.word	0x0000001a
    2464:	0000000c 	.word	0x0000000c
    2468:	00002330 	.word	0x00002330
    246c:	080077c8 	.word	0x080077c8
    2470:	0000001a 	.word	0x0000001a
    2474:	0000000c 	.word	0x0000000c
    2478:	00002330 	.word	0x00002330
    247c:	080077e4 	.word	0x080077e4
    2480:	00000016 	.word	0x00000016
    2484:	0000000c 	.word	0x0000000c
    2488:	00002330 	.word	0x00002330
    248c:	080077fc 	.word	0x080077fc
    2490:	0000001a 	.word	0x0000001a
    2494:	0000000c 	.word	0x0000000c
    2498:	00002330 	.word	0x00002330
    249c:	08007818 	.word	0x08007818
    24a0:	0000000c 	.word	0x0000000c
    24a4:	0000000c 	.word	0x0000000c
    24a8:	00002330 	.word	0x00002330
    24ac:	08007824 	.word	0x08007824
    24b0:	0000000a 	.word	0x0000000a
    24b4:	0000000c 	.word	0x0000000c
    24b8:	00002330 	.word	0x00002330
    24bc:	08007830 	.word	0x08007830
    24c0:	0000004a 	.word	0x0000004a
    24c4:	0000000c 	.word	0x0000000c
    24c8:	00002330 	.word	0x00002330
    24cc:	0800787c 	.word	0x0800787c
    24d0:	00000010 	.word	0x00000010
    24d4:	0000001c 	.word	0x0000001c
    24d8:	00002330 	.word	0x00002330
    24dc:	0800788c 	.word	0x0800788c
    24e0:	0000009c 	.word	0x0000009c
    24e4:	8e100e54 	.word	0x8e100e54
    24e8:	85028601 	.word	0x85028601
    24ec:	6c048403 	.word	0x6c048403
    24f0:	0000300e 	.word	0x0000300e
    24f4:	00000014 	.word	0x00000014
    24f8:	00002330 	.word	0x00002330
    24fc:	08007928 	.word	0x08007928
    2500:	00000094 	.word	0x00000094
    2504:	44040e42 	.word	0x44040e42
    2508:	018e100e 	.word	0x018e100e
    250c:	0000000c 	.word	0x0000000c
    2510:	ffffffff 	.word	0xffffffff
    2514:	7c010001 	.word	0x7c010001
    2518:	000d0c0e 	.word	0x000d0c0e
    251c:	00000018 	.word	0x00000018
    2520:	0000250c 	.word	0x0000250c
    2524:	08007a2c 	.word	0x08007a2c
    2528:	00000054 	.word	0x00000054
    252c:	000d0946 	.word	0x000d0946
    2530:	8e080e44 	.word	0x8e080e44
    2534:	00028d01 	.word	0x00028d01
    2538:	0000000c 	.word	0x0000000c
    253c:	ffffffff 	.word	0xffffffff
    2540:	7c010001 	.word	0x7c010001
    2544:	000d0c0e 	.word	0x000d0c0e
    2548:	00000014 	.word	0x00000014
    254c:	00002538 	.word	0x00002538
    2550:	00000000 	.word	0x00000000
    2554:	00000028 	.word	0x00000028
    2558:	4c040e44 	.word	0x4c040e44
    255c:	018e080e 	.word	0x018e080e
    2560:	0000000c 	.word	0x0000000c
    2564:	ffffffff 	.word	0xffffffff
    2568:	7c010001 	.word	0x7c010001
    256c:	000d0c0e 	.word	0x000d0c0e
    2570:	0000000c 	.word	0x0000000c
    2574:	00002560 	.word	0x00002560
    2578:	08007a80 	.word	0x08007a80
    257c:	00000030 	.word	0x00000030
    2580:	0000000c 	.word	0x0000000c
    2584:	ffffffff 	.word	0xffffffff
    2588:	7c010001 	.word	0x7c010001
    258c:	000d0c0e 	.word	0x000d0c0e
    2590:	00000018 	.word	0x00000018
    2594:	00002580 	.word	0x00002580
    2598:	00000000 	.word	0x00000000
    259c:	00000048 	.word	0x00000048
    25a0:	8e100e44 	.word	0x8e100e44
    25a4:	85028601 	.word	0x85028601
    25a8:	00048403 	.word	0x00048403
    25ac:	00000018 	.word	0x00000018
    25b0:	00002580 	.word	0x00002580
    25b4:	00000000 	.word	0x00000000
    25b8:	00000080 	.word	0x00000080
    25bc:	8e100e44 	.word	0x8e100e44
    25c0:	85028601 	.word	0x85028601
    25c4:	00048403 	.word	0x00048403
    25c8:	0000000c 	.word	0x0000000c
    25cc:	ffffffff 	.word	0xffffffff
    25d0:	7c010001 	.word	0x7c010001
    25d4:	000d0c0e 	.word	0x000d0c0e
    25d8:	00000018 	.word	0x00000018
    25dc:	000025c8 	.word	0x000025c8
    25e0:	00000000 	.word	0x00000000
    25e4:	000000fc 	.word	0x000000fc
    25e8:	860c0e44 	.word	0x860c0e44
    25ec:	84028501 	.word	0x84028501
    25f0:	00000003 	.word	0x00000003
    25f4:	0000000c 	.word	0x0000000c
    25f8:	ffffffff 	.word	0xffffffff
    25fc:	7c010001 	.word	0x7c010001
    2600:	000d0c0e 	.word	0x000d0c0e
    2604:	00000014 	.word	0x00000014
    2608:	000025f4 	.word	0x000025f4
    260c:	00000000 	.word	0x00000000
    2610:	000000d0 	.word	0x000000d0
    2614:	85080e48 	.word	0x85080e48
    2618:	00028401 	.word	0x00028401
    261c:	0000000c 	.word	0x0000000c
    2620:	ffffffff 	.word	0xffffffff
    2624:	7c010001 	.word	0x7c010001
    2628:	000d0c0e 	.word	0x000d0c0e
    262c:	0000001c 	.word	0x0000001c
    2630:	0000261c 	.word	0x0000261c
    2634:	00000000 	.word	0x00000000
    2638:	0000009c 	.word	0x0000009c
    263c:	88140e48 	.word	0x88140e48
    2640:	86028701 	.word	0x86028701
    2644:	84048503 	.word	0x84048503
    2648:	00000005 	.word	0x00000005
    264c:	0000000c 	.word	0x0000000c
    2650:	ffffffff 	.word	0xffffffff
    2654:	7c010001 	.word	0x7c010001
    2658:	000d0c0e 	.word	0x000d0c0e
    265c:	00000024 	.word	0x00000024
    2660:	0000264c 	.word	0x0000264c
    2664:	08007ab0 	.word	0x08007ab0
    2668:	0000010c 	.word	0x0000010c
    266c:	8e240e44 	.word	0x8e240e44
    2670:	8a028b01 	.word	0x8a028b01
    2674:	88048903 	.word	0x88048903
    2678:	86068705 	.word	0x86068705
    267c:	84088507 	.word	0x84088507
    2680:	300e4c09 	.word	0x300e4c09

Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	5446454c 	strbpl	r4, [r6], #-1356
       4:	75614200 	strbvc	r4, [r1, #-512]!
       8:	74617264 	strbtvc	r7, [r1], #-612
       c:	495a5f65 	ldmdbmi	sl, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
      10:	58410047 	stmdapl	r1, {r0, r1, r2, r6}^
      14:	52505f4d 	subspl	r5, r0, #308	; 0x134
      18:	4e455345 	cdpmi	3, 4, cr5, cr5, cr5, {2}
      1c:	4f565f54 	svcmi	0x00565f54
      20:	4741544c 	strbmi	r5, [r1, -ip, asr #8]
      24:	58440045 	stmdapl	r4, {r0, r2, r6}^
      28:	58525f4c 	ldmdapl	r2, {r2, r3, r6, r8, r9, sl, fp, ip, lr}^
      2c:	454d4954 	strbmi	r4, [sp, #-2388]
      30:	0054554f 	subseq	r5, r4, pc, asr #10
      34:	5f4d5841 	svcpl	0x004d5841
      38:	5245504f 	subpl	r5, r5, #79	; 0x4f
      3c:	4e495441 	cdpmi	4, 4, cr5, cr9, cr1, {2}
      40:	4f4d5f47 	svcmi	0x004d5f47
      44:	41004544 	tstmi	r0, r4, asr #10
      48:	732f5050 	teqvc	pc, #80	; 0x50
      4c:	6d2f6372 	stcvs	3, cr6, [pc, #-456]!
      50:	2e6e6961 	cdpcs	9, 6, cr6, cr14, cr1, {3}
      54:	61420063 	cmpvs	r2, r3, rrx
      58:	61726475 	cmnvs	r2, r5, ror r4
      5c:	505f6574 	subspl	r6, pc, r4, ror r5
      60:	50005543 	andpl	r5, r0, r3, asr #10
      64:	52474f52 	subpl	r4, r7, #328	; 0x148
      68:	41004d41 	tstmi	r0, r1, asr #26
      6c:	4c5f4d58 	mrrcmi	13, 5, r4, pc, cr8
      70:	41004445 	tstmi	r0, r5, asr #8
      74:	435f4d58 	cmpmi	pc, #5632	; 0x1600
      78:	4f435f57 	svcmi	0x00435f57
      7c:	494c504d 	stmdbmi	ip, {r0, r2, r3, r6, ip, lr}^
      80:	45434e41 	strbmi	r4, [r3, #-3649]
      84:	52414d5f 	subpl	r4, r1, #6080	; 0x17c0
      88:	004e4947 	subeq	r4, lr, r7, asr #18
      8c:	5f4d5841 	svcpl	0x004d5841
      90:	54415453 	strbpl	r5, [r1], #-1107
      94:	525f5355 	subspl	r5, pc, #1409286145	; 0x54000001
      98:	52555445 	subspl	r5, r5, #1157627904	; 0x45000000
      9c:	454c5f4e 	strbmi	r5, [ip, #-3918]
      a0:	004c4556 	subeq	r4, ip, r6, asr r5
      a4:	74616477 	strbtvc	r6, [r1], #-1143
      a8:	75620061 	strbvc	r0, [r2, #-97]!
      ac:	64657a7a 	strbtvs	r7, [r5], #-2682
      b0:	746f6e5f 	strbtvc	r6, [pc], #3679	; b8 <_Minimum_Stack_Size-0x48>
      b4:	00655f65 	rsbeq	r5, r5, r5, ror #30
      b8:	5f4d5841 	svcpl	0x004d5841
      bc:	44554142 	ldrbmi	r4, [r5], #-322
      c0:	5441525f 	strbpl	r5, [r1], #-607
      c4:	58410045 	stmdapl	r1, {r0, r2, r6}^
      c8:	45525f4d 	ldrbmi	r5, [r2, #-3917]
      cc:	4e525554 	mrcmi	5, 2, r5, cr2, cr4, {2}
      d0:	4c45445f 	cfstrdmi	mvd4, [r5], {95}
      d4:	545f5941 	ldrbpl	r5, [pc], #2369	; dc <_Minimum_Stack_Size-0x24>
      d8:	00454d49 	subeq	r4, r5, r9, asr #26
      dc:	45544f4e 	ldrbmi	r4, [r4, #-3918]
      e0:	0073465f 	rsbseq	r4, r3, pc, asr r6
      e4:	524f5045 	subpl	r5, pc, #69	; 0x45
      e8:	00413354 	subeq	r3, r1, r4, asr r3
      ec:	5a706267 	bpl	1c18a90 <__Stack_Size+0x1c18690>
      f0:	75426769 	strbvc	r6, [r2, #-1897]
      f4:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
      f8:	44626700 	strbtmi	r6, [r2], #-1792
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
      fc:	65526c78 	ldrbvs	r6, [r2, #-3192]
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
     100:	41006461 	tstmi	r0, r1, ror #8

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
     104:	485f4d58 	ldmdami	pc, {r3, r4, r6, r8, sl, fp, lr}^
     108:	45484749 	strbmi	r4, [r8, #-1865]
	nextframe_ = getMillis() + frameLength;
     10c:	4c5f5453 	cfldrdmi	mvd5, [pc], {83}
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     110:	54494d49 	strbpl	r4, [r9], #-3401
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
     114:	4c4f565f 	mcrrmi	6, 5, r5, pc, cr15
     118:	45474154 	strbmi	r4, [r7, #-340]
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     11c:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     120:	6f6c2067 	svcvs	0x006c2067
     124:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
		if (nextpose_[i] > pose_[i]) {
     128:	6c00746e 	cfstrsvs	mvf7, [r0], {110}
     12c:	20676e6f 	rsbcs	r6, r7, pc, ror #28
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
     130:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
     134:	736e7520 	cmnvc	lr, #134217728	; 0x8000000
     138:	656e6769 	strbvs	r6, [lr, #-1897]!
     13c:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     140:	58410074 	stmdapl	r1, {r2, r4, r5, r6}^
     144:	52505f4d 	subspl	r5, r0, #308	; 0x134
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
     148:	4e455345 	cdpmi	3, 4, cr5, cr5, cr5, {2}
     14c:	45545f54 	ldrbmi	r5, [r4, #-3924]
}
     150:	5245504d 	subpl	r5, r5, #77	; 0x4d
     154:	52555441 	subspl	r5, r5, #1090519040	; 0x41000000
     158:	58440045 	stmdapl	r4, {r0, r2, r6}^
     15c:	58525f4c 	ldmdapl	r2, {r2, r3, r6, r8, r9, sl, fp, ip, lr}^
     160:	43454843 	movtmi	r4, #22595	; 0x5843
     164:	4d55534b 	ldclmi	3, cr5, [r5, #-300]
     168:	4c584400 	cfldrdmi	mvd4, [r8], {0}
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
     16c:	4441425f 	strbmi	r4, [r1], #-607
     170:	534e495f 	movtpl	r4, #59743	; 0xe95f
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
     174:	4f4e0054 	svcmi	0x004e0054
     178:	475f4554 	undefined
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     17c:	58410062 	stmdapl	r1, {r1, r5, r6}^
     180:	55505f4d 	ldrbpl	r5, [r0, #-3917]
		nextpose_[i] = 512;
     184:	5f48434e 	svcpl	0x0048434e
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
     188:	58410048 	stmdapl	r1, {r3, r6}^
		pose_[i] = 512;
     18c:	55505f4d 	ldrbpl	r5, [r0, #-3917]
		nextpose_[i] = 512;
     190:	5f48434e 	svcpl	0x0048434e
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
     194:	5045004c 	subpl	r0, r5, ip, asr #32
     198:	4174726f 	cmnmi	r4, pc, ror #4
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
     19c:	4e00655f 	cfrshl32mi	mvfx0, mvfx15, r6
     1a0:	5f45544f 	svcpl	0x0045544f
	nextframe_ = getMillis();
     1a4:	45007347 	strmi	r7, [r0, #-839]
     1a8:	54524f50 	ldrbpl	r4, [r2], #-3920
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     1ac:	41004134 	tstmi	r0, r4, lsr r1
     1b0:	435f4d58 	cmpmi	pc, #5632	; 0x1600
     1b4:	415f5743 	cmpmi	pc, r3, asr #14
     1b8:	454c474e 	strbmi	r4, [ip, #-1870]
     1bc:	4d494c5f 	stclmi	12, cr4, [r9, #-380]
     1c0:	485f5449 	ldmdami	pc, {r0, r3, r6, sl, ip, lr}^
     1c4:	6f687300 	svcvs	0x00687300
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1c8:	75207472 	strvc	r7, [r0, #-1138]!
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
     1cc:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d0:	2064656e 	rsbcs	r6, r4, lr, ror #10
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1d4:	00746e69 	rsbseq	r6, r4, r9, ror #28
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d8:	5f4d5841 	svcpl	0x004d5841
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
     1dc:	5f574343 	svcpl	0x00574343
     1e0:	4c474e41 	mcrrmi	14, 4, r4, r7, cr1
		pose_[i] = 512;
		nextpose_[i] = 512;
     1e4:	494c5f45 	stmdbmi	ip, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1e8:	5f54494d 	svcpl	0x0054494d
		nextpose_[i] = 512;
     1ec:	6552004c 	ldrbvs	r0, [r2, #-76]
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
     1f0:	76696563 	strbtvc	r6, [r9], -r3, ror #10
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
     1f4:	6f436465 	svcvs	0x00436465
     1f8:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
	interpolating = 0;
     1fc:	4e470064 	cdpmi	0, 4, cr0, cr7, cr4, {3}
	nextframe_ = getMillis();
     200:	20432055 	subcs	r2, r3, r5, asr r0
     204:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     208:	58410030 	stmdapl	r1, {r4, r5}^
     20c:	43435f4d 	movtmi	r5, #16205	; 0x3f4d
     210:	4f435f57 	svcmi	0x00435f57
     214:	494c504d 	stmdbmi	ip, {r0, r2, r3, r6, ip, lr}^
     218:	45434e41 	strbmi	r4, [r3, #-3649]
     21c:	4f4c535f 	svcmi	0x004c535f
     220:	41004550 	tstmi	r0, r0, asr r5
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
     224:	4c5f4d58 	mrrcmi	13, 5, r4, pc, cr8
     228:	004b434f 	subeq	r4, fp, pc, asr #6
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
     22c:	5f4d5841 	svcpl	0x004d5841
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
     230:	53554150 	cmppl	r5, #20	; 0x14
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
     234:	49545f45 	ldmdbmi	r4, {r0, r2, r6, r8, r9, sl, fp, ip, lr}^
     238:	4400454d 	strmi	r4, [r0], #-1357
	dxl_set_txpacket_parameter(1, 2);
     23c:	4e5f4c58 	mrcmi	12, 2, r4, cr15, cr8, {2}
     240:	5f4c4c55 	svcpl	0x004c4c55
     244:	41544144 	cmpmi	r4, r4, asr #2
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     248:	5c3a4300 	ldcpl	3, cr4, [sl]
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
     24c:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
     250:	6e695c73 	mcrvs	12, 3, r5, cr9, cr3, {3}
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     254:	6c617473 	cfstrdvs	mvd7, [r1], #-460
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     258:	72705c6c 	rsbsvc	r5, r0, #27648	; 0x6c00
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     25c:	6b656a6f 	blvs	195ac20 <__Stack_Size+0x195a820>
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     260:	68545c74 	ldmdavs	r4, {r2, r4, r5, r6, sl, fp, ip, lr}^
     264:	73697365 	cmnvc	r9, #-1811939327	; 0x94000001
     268:	6f69425f 	svcvs	0x0069425f
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     26c:	64696f6c 	strbtvs	r6, [r9], #-3948
     270:	6d75685c 	ldclvs	8, cr6, [r5, #-368]!
     274:	696f6e61 	stmdbvs	pc!, {r0, r5, r6, r9, sl, fp, sp, lr}^
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     278:	5f635f64 	svcpl	0x00635f64
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     27c:	746e6f63 	strbtvc	r6, [lr], #-3939
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
     280:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
     284:	45007265 	strmi	r7, [r0, #-613]
     288:	54524f50 	ldrbpl	r4, [r2], #-3920
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
     28c:	42004135 	andmi	r4, r0, #1073741837	; 0x4000000d
     290:	6f747475 	svcvs	0x00747475
     294:	00655f6e 	rsbeq	r5, r5, lr, ror #30
	dxl_txrx_packet();
     298:	6978655f 	ldmdbvs	r8!, {r0, r1, r2, r3, r4, r6, r8, sl, sp, lr}^
	u16 CommStatus = dxl_get_result();
     29c:	4f4e0074 	svcmi	0x004e0074
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
     2a0:	415f4554 	cmpmi	pc, r4, asr r5
		PrintErrorCode();
     2a4:	544f4e00 	strbpl	r4, [pc], #3584	; 2ac <_Minimum_Stack_Size+0x1ac>
	else
		PrintCommStatus(CommStatus);
     2a8:	00425f45 	subeq	r5, r2, r5, asr #30
#endif
}
     2ac:	45544f4e 	ldrbmi	r4, [r4, #-3918]
     2b0:	5600445f 	undefined
     2b4:	00535542 	subseq	r5, r3, r2, asr #10
     2b8:	45544f4e 	ldrbmi	r4, [r4, #-3918]
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
     2bc:	4e00465f 	mcrmi	6, 0, r4, cr0, cr15, {2}
     2c0:	5f45544f 	svcpl	0x0045544f

	if (interpolating == 0)
     2c4:	4f4e0047 	svcmi	0x004e0047
		return 0;
	int i;
	int complete = poseSize;
     2c8:	415f4554 	cmpmi	pc, r4, asr r5
	if (!fWait) {
     2cc:	62670062 	rsbvs	r0, r7, #98	; 0x62
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
     2d0:	57756350 	undefined
     2d4:	65746972 	ldrbvs	r6, [r4, #-2418]!
     2d8:	4d584100 	ldfmie	f4, [r8]
			return (getMillis() - nextframe_); // We still have some time to do something...
     2dc:	0044495f 	subeq	r4, r4, pc, asr r9
     2e0:	45544f4e 	ldrbmi	r4, [r4, #-3918]
     2e4:	0073415f 	rsbseq	r4, r3, pc, asr r1
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
     2e8:	5f4d5841 	svcpl	0x004d5841
     2ec:	45444f4d 	strbmi	r4, [r4, #-3917]
     2f0:	554e5f4c 	strbpl	r5, [lr, #-3916]
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     2f4:	5245424d 	subpl	r4, r5, #-805306364	; 0xd0000004
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     2f8:	7300485f 	movwvc	r4, #2143	; 0x85f
     2fc:	74726174 	ldrbtvc	r6, [r2], #-372
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     300:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
     304:	66496e6f 	strbvs	r6, [r9], -pc, ror #28
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     308:	656c6449 	strbvs	r6, [ip, #-1097]!
		int diff = nextpose_[i] - pose_[i];
     30c:	4d584100 	ldfmie	f4, [r8]
     310:	444f4d5f 	strbmi	r4, [pc], #3423	; 318 <_Minimum_Stack_Size+0x218>
     314:	4e5f4c45 	cdpmi	12, 5, cr4, cr15, cr5, {2}
     318:	45424d55 	strbmi	r4, [r2, #-3413]
     31c:	004c5f52 	subeq	r5, ip, r2, asr pc
		if (diff == 0) {
     320:	5f4c5844 	svcpl	0x004c5844
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     324:	454c5852 	strbmi	r5, [ip, #-2130]
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
     328:	4854474e 	ldmdami	r4, {r1, r2, r3, r6, r8, r9, sl, lr}^
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     32c:	70626700 	rsbvc	r6, r2, r0, lsl #14
					pose_[i] = nextpose_[i];
     330:	426c7844 	rsbmi	r7, ip, #4456448	; 0x440000
					complete--;
     334:	65666675 	strbvs	r6, [r6, #-1653]!
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     338:	58410072 	stmdapl	r1, {r1, r4, r5, r6}^
     33c:	43435f4d 	movtmi	r5, #16205	; 0x3f4d
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     340:	4f435f57 	svcmi	0x00435f57
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     344:	494c504d 	stmdbmi	ip, {r0, r2, r3, r6, ip, lr}^
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     348:	45434e41 	strbmi	r4, [r3, #-3649]
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     34c:	52414d5f 	subpl	r4, r1, #6080	; 0x17c0
     350:	004e4947 	subeq	r4, lr, r7, asr #18
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
     354:	5f4d5841 	svcpl	0x004d5841
		interpolating = 0;
     358:	5f58414d 	svcpl	0x0058414d
	BioloidControllerEx_writePose();
     35c:	51524f54 	cmppl	r2, r4, asr pc
     360:	485f4555 	ldmdami	pc, {r0, r2, r4, r6, r8, sl, lr}^
	return 0;
}
     364:	4d584100 	ldfmie	f4, [r8]
     368:	58414d5f 	stmdapl	r1, {r0, r1, r2, r3, r4, r6, r8, sl, fp, lr}^
     36c:	524f545f 	subpl	r5, pc, #1593835520	; 0x5f000000
     370:	5f455551 	svcpl	0x00455551
     374:	5841004c 	stmdapl	r1, {r2, r3, r6}^
     378:	50555f4d 	subspl	r5, r5, sp, asr #30
     37c:	4c41435f 	mcrrmi	3, 5, r4, r1, cr15
     380:	41524249 	cmpmi	r2, r9, asr #4
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
     384:	4e4f4954 	mcrmi	9, 2, r4, cr15, cr4, {2}
     388:	4400485f 	strmi	r4, [r0], #-2143
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
     38c:	545f4c58 	ldrbpl	r4, [pc], #3160	; 394 <_Minimum_Stack_Size+0x294>
     390:	49414658 	stmdbmi	r1, {r3, r4, r6, r9, sl, lr}^
     394:	5045004c 	subpl	r0, r5, ip, asr #32
     398:	3654524f 	ldrbcc	r5, [r4], -pc, asr #4
     39c:	58410041 	stmdapl	r1, {r0, r6}^
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
     3a0:	50555f4d 	subspl	r5, r5, sp, asr #30

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
     3a4:	4c41435f 	mcrrmi	3, 5, r4, r1, cr15
     3a8:	41524249 	cmpmi	r2, r9, asr #4
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
     3ac:	4e4f4954 	mcrmi	9, 2, r4, cr15, cr4, {2}
     3b0:	41004c5f 	tstmi	r0, pc, asr ip
     3b4:	4d5f4d58 	ldclmi	13, cr4, [pc, #-352]
     3b8:	4e49564f 	cdpmi	6, 4, cr5, cr9, cr15, {2}
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
     3bc:	58410047 	stmdapl	r1, {r0, r1, r2, r6}^
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
     3c0:	52505f4d 	subspl	r5, r0, #308	; 0x134
     3c4:	4e455345 	cdpmi	3, 4, cr5, cr5, cr5, {2}
     3c8:	4f505f54 	svcmi	0x00505f54
     3cc:	49544953 	ldmdbmi	r4, {r0, r1, r4, r6, r8, fp, lr}^
     3d0:	485f4e4f 	ldmdami	pc, {r0, r1, r2, r3, r6, r9, sl, fp, lr}^
     3d4:	4d584100 	ldfmie	f4, [r8]
     3d8:	4552505f 	ldrbmi	r5, [r2, #-95]
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
     3dc:	544e4553 	strbpl	r4, [lr], #-1363
     3e0:	534f505f 	movtpl	r5, #61535	; 0xf05f
     3e4:	4f495449 	svcmi	0x00495449
     3e8:	004c5f4e 	subeq	r5, ip, lr, asr #30
     3ec:	45574f50 	ldrbmi	r4, [r7, #-3920]
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     3f0:	4f4e0052 	svcmi	0x004e0052
     3f4:	425f4554 	subsmi	r4, pc, #352321536	; 0x15000000
     3f8:	4f4e0062 	svcmi	0x004e0062
     3fc:	435f4554 	cmpmi	pc, #352321536	; 0x15000000
     400:	41545300 	cmpmi	r4, r0, lsl #6
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
     404:	4e005452 	cfmvsrmi	mvf0, r5
     408:	5f45544f 	svcpl	0x0045544f
     40c:	62670045 	rsbvs	r0, r7, #69	; 0x45
     410:	5267695a 	rsbpl	r6, r7, #1474560	; 0x168000
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
     414:	00646165 	rsbeq	r6, r4, r5, ror #2
     418:	5f4d5841 	svcpl	0x004d5841
     41c:	51524f54 	cmppl	r2, r4, asr pc
     420:	4c5f4555 	cfldr64mi	mvdx4, [pc], {85}
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
     424:	54494d49 	strbpl	r4, [r9], #-3401
     428:	6700485f 	smlsdvs	r0, pc, r8, r4
     42c:	75635062 	strbvc	r5, [r3, #-98]!
     430:	64616552 	strbtvs	r6, [r1], #-1362
     434:	4d584100 	ldfmie	f4, [r8]
     438:	524f545f 	subpl	r5, pc, #1593835520	; 0x5f000000
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     43c:	5f455551 	svcpl	0x00455551
     440:	494d494c 	stmdbmi	sp, {r2, r3, r6, r8, fp, lr}^
     444:	004c5f54 	subeq	r5, ip, r4, asr pc
     448:	5f4d5841 	svcpl	0x004d5841
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     44c:	49474552 	stmdbmi	r7, {r1, r4, r6, r8, sl, lr}^
     450:	52455453 	subpl	r5, r5, #1392508928	; 0x53000000
     454:	495f4445 	ldmdbmi	pc, {r0, r2, r6, sl, lr}^
     458:	5254534e 	subspl	r5, r4, #939524097	; 0x38000001
     45c:	49544355 	ldmdbmi	r4, {r0, r2, r4, r6, r8, r9, lr}^
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     460:	41004e4f 	tstmi	r0, pc, asr #28
     464:	545f4d58 	ldrbpl	r4, [pc], #3416	; 46c <__Stack_Size+0x6c>
     468:	5551524f 	ldrbpl	r5, [r1, #-591]
     46c:	4e455f45 	cdpmi	15, 4, cr5, cr5, cr5, {2}
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     470:	454c4241 	strbmi	r4, [ip, #-577]
     474:	4d584100 	ldfmie	f4, [r8]
     478:	574f4c5f 	smlsldpl	r4, pc, pc, ip
     47c:	5f545345 	svcpl	0x00545345
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
     480:	494d494c 	stmdbmi	sp, {r2, r3, r6, r8, fp, lr}^
     484:	4f565f54 	svcmi	0x00565f54
     488:	4741544c 	strbmi	r5, [r1, -ip, asr #8]
     48c:	58440045 	stmdapl	r4, {r0, r2, r6}^
     490:	58525f4c 	ldmdapl	r2, {r2, r3, r6, r8, r9, sl, fp, ip, lr}^
     494:	54494157 	strbpl	r4, [r9], #-343
     498:	00474e49 	subeq	r4, r7, r9, asr #28
     49c:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     4a0:	64656e67 	strbtvs	r6, [r5], #-3687
     4a4:	61686320 	cmnvs	r8, r0, lsr #6
     4a8:	4c500072 	mrrcmi	0, 7, r0, r0, cr2
     4ac:	67005941 	strvs	r5, [r0, -r1, asr #18]
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     4b0:	63507062 	cmpvs	r0, #98	; 0x62
     4b4:	66754275 	undefined
     4b8:	00726566 	rsbseq	r6, r2, r6, ror #10
     4bc:	5f4c5844 	svcpl	0x004c5844
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     4c0:	55535852 	ldrbpl	r5, [r3, #-2130]
     4c4:	53454343 	movtpl	r4, #21315	; 0x5343
     4c8:	68730053 	ldmdavs	r3!, {r0, r1, r4, r6}^
		GaitPosY[GaitCurrentLegNr] = 0;
     4cc:	2074726f 	rsbscs	r7, r4, pc, ror #4
     4d0:	00746e69 	rsbseq	r6, r4, r9, ror #28
	}

	//Move body forward
	else {
		GaitPosX[GaitCurrentLegNr] = GaitPosX[GaitCurrentLegNr]
     4d4:	5f4d5841 	svcpl	0x004d5841
     4d8:	48474948 	stmdami	r7, {r3, r6, r8, fp, lr}^
     4dc:	5f545345 	svcpl	0x00545345
     4e0:	494d494c 	stmdbmi	sp, {r2, r3, r6, r8, fp, lr}^
     4e4:	45545f54 	ldrbmi	r5, [r4, #-3924]
     4e8:	5245504d 	subpl	r5, r5, #77	; 0x4d
				- (g_InControlState.TravelLength.x
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitPosY[GaitCurrentLegNr] = 0;
     4ec:	52555441 	subspl	r5, r5, #1090519040	; 0x41000000
     4f0:	58410045 	stmdapl	r1, {r0, r2, r6}^
     4f4:	4c415f4d 	mcrrmi	15, 4, r5, r1, cr13
		GaitPosZ[GaitCurrentLegNr] = GaitPosZ[GaitCurrentLegNr]
     4f8:	5f4d5241 	svcpl	0x004d5241
     4fc:	0044454c 	subeq	r4, r4, ip, asr #10
     500:	5f4c5844 	svcpl	0x004c5844
     504:	52455854 	subpl	r5, r5, #5505024	; 0x540000
				- (g_InControlState.TravelLength.z
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitRotY[GaitCurrentLegNr] = GaitRotY[GaitCurrentLegNr]
     508:	00524f52 	subseq	r4, r2, r2, asr pc
     50c:	43706d74 	cmnmi	r0, #7424	; 0x1d00
     510:	006d6d6f 	rsbeq	r6, sp, pc, ror #26
     514:	65636552 	strbvs	r6, [r3, #-1362]!
				- (g_InControlState.TravelLength.y
						/ (short) g_InControlState.gaitCur.TLDivFactor);
	}

}
     518:	64657669 	strbtvs	r7, [r5], #-1641
     51c:	61746144 	cmnvs	r4, r4, asr #2
     520:	544f4e00 	strbpl	r4, [pc], #3584	; 528 <__Stack_Size+0x128>
     524:	73435f45 	movtvc	r5, #16197	; 0x3f45
     528:	44454c00 	strbmi	r4, [r5], #-3072
     52c:	4100655f 	tstmi	r0, pc, asr r5
     530:	445f4d58 	ldrbmi	r4, [pc], #3416	; 538 <__Stack_Size+0x138>

}

//--------------------------------------------------------------------
//[GAIT Sequence]
void GaitSeq(void) {
     534:	5f4e574f 	svcpl	0x004e574f
	//Check if the Gait is in motion - If not if we are going to start a motion try to align our Gaitstep to start with a good foot
	// for the direction we are about to go...

	if (fWalking || (g_InControlState.ForceGaitStepCnt != 0))
     538:	494c4143 	stmdbmi	ip, {r0, r1, r6, r8, lr}^
     53c:	54415242 	strbpl	r5, [r1], #-578
     540:	5f4e4f49 	svcpl	0x004e4f49
		TravelRequest = true;   // Is walking or was walking...
     544:	58410048 	stmdapl	r1, {r3, r6}^
     548:	4f445f4d 	svcmi	0x00445f4d
	else {
		TravelRequest = (abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
     54c:	435f4e57 	cmpmi	pc, #1392	; 0x570
     550:	42494c41 	submi	r4, r9, #16640	; 0x4100
     554:	49544152 	ldmdbmi	r4, {r1, r4, r6, r8, lr}^
     558:	4c5f4e4f 	mrrcmi	14, 4, r4, pc, cr15
     55c:	47495200 	strbmi	r5, [r9, -r0, lsl #4]
     560:	70005448 	andvc	r5, r0, r8, asr #8
     564:	61746164 	cmnvs	r4, r4, ror #2
     568:	42655200 	rsbmi	r5, r5, #0	; 0x0
     56c:	54746f6f 	ldrbtpl	r6, [r4], #-3951
     570:	6f6f426f 	svcvs	0x006f426f
     574:	616f4c74 	smcvs	62660
     578:	00726564 	rsbseq	r6, r2, r4, ror #10
     57c:	5f4d5841 	svcpl	0x004d5841
				|| (abs(g_InControlState.TravelLength.y) > cTravelDeadZone);

		if (TravelRequest) {

		} else {    //Clear values under the cTravelDeadZone
			g_InControlState.TravelLength.x = 0;
     580:	53455250 	movtpl	r5, #21072	; 0x5250
			g_InControlState.TravelLength.z = 0;
     584:	5f544e45 	svcpl	0x00544e45
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     588:	45455053 	strbmi	r5, [r5, #-83]
     58c:	00485f44 	subeq	r5, r8, r4, asr #30
     590:	5f4d5841 	svcpl	0x004d5841
		Gait(LegIndex);
     594:	53455250 	movtpl	r5, #21072	; 0x5250
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     598:	5f544e45 	svcpl	0x00544e45
     59c:	45455053 	strbmi	r5, [r5, #-83]
     5a0:	004c5f44 	subeq	r5, ip, r4, asr #30
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5a4:	45544f4e 	ldrbmi	r4, [r4, #-3918]
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5a8:	0062445f 	rsbeq	r4, r2, pc, asr r4
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5ac:	5f4d5841 	svcpl	0x004d5841
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5b0:	415f5743 	cmpmi	pc, r3, asr #14
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5b4:	454c474e 	strbmi	r4, [ip, #-1870]
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
		g_InControlState.GaitStep = 1;
     5b8:	4d494c5f 	stclmi	12, cr4, [r9, #-380]
     5bc:	485f5449 	ldmdami	pc, {r0, r3, r6, sl, ip, lr}^

	// If we have a force count decrement it now...
	if (g_InControlState.ForceGaitStepCnt)
     5c0:	4c584400 	cfldrdmi	mvd4, [r8], {0}
     5c4:	4441425f 	strbmi	r4, [r1], #-607
		g_InControlState.ForceGaitStepCnt--;
     5c8:	0044495f 	subeq	r4, r4, pc, asr r9
}
     5cc:	5f4d5841 	svcpl	0x004d5841
     5d0:	415f5743 	cmpmi	pc, r3, asr #14
     5d4:	454c474e 	strbmi	r4, [ip, #-1870]
     5d8:	4d494c5f 	stclmi	12, cr4, [r9, #-380]
     5dc:	4c5f5449 	cfldrdmi	mvd5, [pc], {73}
}
//--------------------------------------------------------------------
//[BalanceBody]
void BalanceBody(void) {

	TotalTransZ = TotalTransZ / BalanceDivFactor;
     5e0:	544f4e00 	strbpl	r4, [pc], #3584	; 5e8 <__Stack_Size+0x1e8>
     5e4:	73445f45 	movtvc	r5, #20293	; 0x4f45
     5e8:	4f504500 	svcmi	0x00504500
     5ec:	41315452 	teqmi	r1, r2, asr r4
     5f0:	4d584100 	ldfmie	f4, [r8]
	TotalTransX = TotalTransX / BalanceDivFactor;
     5f4:	5249465f 	subpl	r4, r9, #99614720	; 0x5f00000
     5f8:	5241574d 	subpl	r5, r1, #20185088	; 0x1340000
     5fc:	45565f45 	ldrbmi	r5, [r6, #-3909]
	TotalTransY = TotalTransY / BalanceDivFactor;
     600:	4f495352 	svcmi	0x00495352
     604:	5841004e 	stmdapl	r1, {r1, r2, r3, r6}^
     608:	4f4d5f4d 	svcmi	0x004d5f4d
     60c:	474e4956 	smlsldmi	r4, lr, r6, r9

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     610:	4550535f 	ldrbmi	r5, [r0, #-863]
     614:	485f4445 	ldmdami	pc, {r0, r2, r6, sl, lr}^
	TotalTransX = TotalTransX / BalanceDivFactor;
	TotalTransY = TotalTransY / BalanceDivFactor;

#ifndef QUADMODE // ??? on PhantomX Hex at no movment YBal1 = 1800, on Quad = 0...  Need to experiment
	if (TotalYBal1 > 0)        //Rotate balance circle by +/- 180 deg
		TotalYBal1 -= 1800;
     618:	44626700 	strbtmi	r6, [r2], #-1792
     61c:	72576c78 	subsvc	r6, r7, #30720	; 0x7800
	else
		TotalYBal1 += 1800;
     620:	00657469 	rsbeq	r7, r5, r9, ror #8
#endif

	if (TotalZBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     624:	5f4d5841 	svcpl	0x004d5841
     628:	49564f4d 	ldmdbmi	r6, {r0, r2, r3, r6, r8, r9, sl, fp, lr}^
     62c:	535f474e 	cmppl	pc, #20447232	; 0x1380000
		TotalZBal1 += 3600;
     630:	44454550 	strbmi	r4, [r5], #-1360
     634:	41004c5f 	tstmi	r0, pc, asr ip

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     638:	415f4d58 	cmpmi	pc, r8, asr sp
     63c:	4d52414c 	ldfmie	f4, [r2, #-304]
		TotalXBal1 += 3600;
     640:	5548535f 	strbpl	r5, [r8, #-863]
     644:	574f4454 	smlsldpl	r4, pc, r4, r4

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     648:	6267004e 	rsbvs	r0, r7, #78	; 0x4e
     64c:	5767695a 	undefined
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     650:	65746972 	ldrbvs	r6, [r4, #-2418]!
     654:	4d584100 	ldfmie	f4, [r8]
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     658:	414f475f 	cmpmi	pc, pc, asr r7
	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     65c:	4f505f4c 	svcmi	0x00505f4c
     660:	49544953 	ldmdbmi	r4, {r0, r1, r4, r6, r8, fp, lr}^
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     664:	485f4e4f 	ldmdami	pc, {r0, r1, r2, r3, r6, r9, sl, fp, lr}^
     668:	4d584100 	ldfmie	f4, [r8]

}
     66c:	5359535f 	cmppl	r9, #2080374785	; 0x7c000001
     670:	5f4d4554 	svcpl	0x004d4554
     674:	41544144 	cmpmi	r4, r4, asr #2
     678:	58410032 	stmdapl	r1, {r1, r4, r5}^
     67c:	4f475f4d 	svcmi	0x00475f4d
     680:	505f4c41 	subspl	r4, pc, r1, asr #24
     684:	5449534f 	strbpl	r5, [r9], #-847
     688:	5f4e4f49 	svcpl	0x004e4f49
//sin4        - Output Sinus of AngleDeg
//cos4          - Output Cosinus of AngleDeg
void GetSinCos(short AngleDeg1) {
	short ABSAngleDeg1;   //Absolute value of the Angle in Degrees, decimals = 1
	//Get the absolute value of AngleDeg
	if (AngleDeg1 < 0)
     68c:	6570004c 	ldrbvs	r0, [r0, #-76]!
     690:	726f7272 	rsbvc	r7, pc, #536870919	; 0x20000007
		ABSAngleDeg1 = AngleDeg1 * -1;
     694:	4d584100 	ldfmie	f4, [r8]
     698:	5f57435f 	svcpl	0x0057435f
	else
		ABSAngleDeg1 = AngleDeg1;

	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
     69c:	504d4f43 	subpl	r4, sp, r3, asr #30
     6a0:	4e41494c 	cdpmi	9, 4, cr4, cr1, cr12, {2}
     6a4:	535f4543 	cmppl	pc, #281018368	; 0x10c00000
     6a8:	45504f4c 	ldrbmi	r4, [r0, #-3916]
     6ac:	544f4e00 	strbpl	r4, [pc], #3584	; 6b4 <__Stack_Size+0x2b4>
     6b0:	62455f45 	subvs	r5, r5, #276	; 0x114
     6b4:	4c584400 	cfldrdmi	mvd4, [r8], {0}
     6b8:	5358545f 	cmppl	r8, #1593835520	; 0x5f000000
     6bc:	45434355 	strbmi	r4, [r3, #-853]
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
     6c0:	44005353 	strmi	r5, [r0], #-851
     6c4:	525f4c58 	subspl	r4, pc, #22528	; 0x5800
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6c8:	49414658 	stmdbmi	r1, {r3, r4, r6, r9, sl, lr}^
     6cc:	6142004c 	cmpvs	r2, ip, asr #32
     6d0:	61726475 	cmnvs	r2, r5, ror r4
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6d4:	445f6574 	ldrbmi	r6, [pc], #1396	; 6dc <__Stack_Size+0x2dc>
     6d8:	45004c58 	strmi	r4, [r0, #-3160]
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6dc:	54524f50 	ldrbpl	r4, [r2], #-3920
     6e0:	41004132 	tstmi	r0, r2, lsr r1
     6e4:	505f4d58 	subspl	r4, pc, r8, asr sp
     6e8:	45534552 	ldrbmi	r4, [r3, #-1362]
     6ec:	4c5f544e 	cfldrdmi	mvd5, [pc], {78}
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6f0:	5f44414f 	svcpl	0x0044414f
     6f4:	58440048 	stmdapl	r4, {r3, r6}^
     6f8:	554e5f4c 	strbpl	r5, [lr, #-3916]
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
     6fc:	535f4c4c 	cmppl	pc, #19456	; 0x4c00
     700:	00455a49 	subeq	r5, r5, r9, asr #20
     704:	5f4d5841 	svcpl	0x004d5841
     708:	53455250 	movtpl	r5, #21072	; 0x5250
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     70c:	5f544e45 	svcpl	0x00544e45
     710:	44414f4c 	strbmi	r4, [r1], #-3916
     714:	49004c5f 	stmdbmi	r0, {r0, r1, r2, r3, r4, r6, sl, fp, lr}
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     718:	5f314332 	svcpl	0x00314332
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     71c:	495f5245 	ldmdbmi	pc, {r0, r2, r6, r9, ip, lr}^
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     720:	61485152 	cmpvs	r8, r2, asr r1
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     724:	656c646e 	strbvs	r6, [ip, #-1134]!
     728:	4d440072 	stclmi	0, cr0, [r4, #-456]
     72c:	435f3141 	cmpmi	pc, #1073741840	; 0x40000010
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     730:	6e6e6168 	powvsez	f6, f6, #0.0
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     734:	5f346c65 	svcpl	0x00346c65
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     738:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     73c:	6c646e61 	stclvs	14, cr6, [r4], #-388
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
     740:	54007265 	strpl	r7, [r0], #-613
     744:	5f314d49 	svcpl	0x00314d49
     748:	5f4b5242 	svcpl	0x004b5242
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     74c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     750:	6c646e61 	stclvs	14, cr6, [r4], #-388
     754:	54007265 	strpl	r7, [r0], #-613
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     758:	5f314d49 	svcpl	0x00314d49
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     75c:	5f475254 	svcpl	0x00475254
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     760:	5f4d4f43 	svcpl	0x004d4f43
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     764:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     768:	6c646e61 	stclvs	14, cr6, [r4], #-388
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     76c:	54007265 	strpl	r7, [r0], #-613
     770:	45504d41 	ldrbmi	r4, [r0, #-3393]
     774:	52495f52 	subpl	r5, r9, #328	; 0x148
     778:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     77c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     780:	61735500 	cmnvs	r3, r0, lsl #10
     784:	61466567 	cmpvs	r6, r7, ror #10
     788:	45746c75 	ldrbmi	r6, [r4, #-3189]!
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
     78c:	70656378 	rsbvc	r6, r5, r8, ror r3
     790:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     794:	414d4400 	cmpmi	sp, r0, lsl #8
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     798:	68435f31 	stmdavs	r3, {r0, r4, r5, r8, r9, sl, fp, ip, lr}^
     79c:	656e6e61 	strbvs	r6, [lr, #-3681]!
     7a0:	495f356c 	ldmdbmi	pc, {r2, r3, r5, r6, r8, sl, ip, sp}^
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7a4:	61485152 	cmpvs	r8, r2, asr r1
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7a8:	656c646e 	strbvs	r6, [ip, #-1134]!
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7ac:	49540072 	ldmdbmi	r4, {r1, r4, r5, r6}^
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b0:	495f324d 	ldmdbmi	pc, {r0, r2, r3, r6, r9, ip, sp}^
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7b4:	61485152 	cmpvs	r8, r2, asr r1
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b8:	656c646e 	strbvs	r6, [ip, #-1134]!
     7bc:	54520072 	ldrbpl	r0, [r2], #-114
     7c0:	52495f43 	subpl	r5, r9, #268	; 0x10c
     7c4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7c8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     7cc:	4d495400 	cfstrdmi	mvd5, [r9]
     7d0:	52495f33 	subpl	r5, r9, #204	; 0xcc
	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));
     7d4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     7d8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     7dc:	4d534600 	ldclmi	6, cr4, [r3]
     7e0:	52495f43 	subpl	r5, r9, #268	; 0x10c
     7e4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     7e8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     7ec:	4d495400 	cfstrdmi	mvd5, [r9]
     7f0:	52495f34 	subpl	r5, r9, #208	; 0xd0
     7f4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     7f8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
	}
}
     7fc:	42535500 	subsmi	r5, r3, #0	; 0x0
     800:	656b6157 	strbvs	r6, [fp, #-343]!
     804:	495f7055 	ldmdbmi	pc, {r0, r2, r4, r6, ip, sp, lr}^
     808:	61485152 	cmpvs	r8, r2, asr r1
     80c:	656c646e 	strbvs	r6, [ip, #-1134]!
//cos4        - Input Cosinus
//AngleRad4     - Output Angle in AngleRad4
long GetArcCos(short cos4) {
	boolean NegativeValue/*:1*/;    //If the the value is Negative
	//Check for negative value
	if (cos4 < 0) {
     810:	49540072 	ldmdbmi	r4, {r1, r4, r5, r6}^
     814:	495f354d 	ldmdbmi	pc, {r0, r2, r3, r6, r8, sl, ip, sp}^
     818:	61485152 	cmpvs	r8, r2, asr r1
		cos4 = -cos4;
     81c:	656c646e 	strbvs	r6, [ip, #-1134]!
     820:	50530072 	subspl	r0, r3, r2, ror r0
		NegativeValue = 1;
	} else
		NegativeValue = 0;

	//Limit cos4 to his maximal value
	cos4 = min(cos4, c4DEC);
     824:	495f3149 	ldmdbmi	pc, {r0, r3, r6, r8, ip, sp}^
     828:	61485152 	cmpvs	r8, r2, asr r1
     82c:	656c646e 	strbvs	r6, [ip, #-1134]!

	if ((cos4 >= 0) && (cos4 < 9000)) {
     830:	75420072 	strbvc	r0, [r2, #-114]
     834:	75614673 	strbvc	r4, [r1, #-1651]!
     838:	7845746c 	stmdavc	r5, {r2, r3, r5, r6, sl, ip, sp, lr}^
		AngleRad4 = (byte) pgm_read_byte(&GetACos[cos4 / 79]);
     83c:	74706563 	ldrbtvc	r6, [r0], #-1379
     840:	006e6f69 	rsbeq	r6, lr, r9, ror #30
     844:	32495053 	subcc	r5, r9, #83	; 0x53
		AngleRad4 = ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255) ;
     848:	5152495f 	cmppl	r2, pc, asr r9
     84c:	646e6148 	strbtvs	r6, [lr], #-328
	} else if ((cos4 >= 9000) && (cos4 < 9900)) {
     850:	0072656c 	rsbseq	r6, r2, ip, ror #10
     854:	5f425355 	svcpl	0x00425355
     858:	435f5048 	cmpmi	pc, #72	; 0x48
     85c:	545f4e41 	ldrbpl	r4, [pc], #3649	; 864 <__Stack_Size+0x464>
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9000) / 8 + 114]);
     860:	52495f58 	subpl	r5, r9, #352	; 0x160
     864:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     868:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     86c:	49505300 	ldmdbmi	r0, {r8, r9, ip, lr}^
     870:	52495f33 	subpl	r5, r9, #204	; 0xcc
     874:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     878:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
	} else if ((cos4 >= 9900) && (cos4 <= 10000)) {
     87c:	4d495400 	cfstrdmi	mvd5, [r9]
     880:	43435f31 	movtmi	r5, #16177	; 0x3f31
     884:	5152495f 	cmppl	r2, pc, asr r9
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9900) / 2 + 227]);
     888:	646e6148 	strbtvs	r6, [lr], #-328
     88c:	0072656c 	rsbseq	r6, r2, ip, ror #10
     890:	33434441 	movtcc	r4, #13377	; 0x3441
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     894:	5152495f 	cmppl	r2, pc, asr r9
     898:	646e6148 	strbtvs	r6, [lr], #-328
     89c:	0072656c 	rsbseq	r6, r2, ip, ror #10
     8a0:	31434441 	cmpcc	r3, r1, asr #8
     8a4:	495f325f 	ldmdbmi	pc, {r0, r1, r2, r3, r4, r6, r9, ip, sp}^
     8a8:	61485152 	cmpvs	r8, r2, asr r1
     8ac:	656c646e 	strbvs	r6, [ip, #-1134]!
	}

	//Add negative sign
	if (NegativeValue)
		AngleRad4 = 31416 - AngleRad4;
     8b0:	41550072 	cmpmi	r5, r2, ror r0
     8b4:	5f355452 	svcpl	0x00355452
     8b8:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     8bc:	6c646e61 	stclvs	14, cr6, [r4], #-388
     8c0:	44007265 	strmi	r7, [r0], #-613

	return AngleRad4;
}
     8c4:	5f32414d 	svcpl	0x0032414d
     8c8:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     8cc:	316c656e 	cmncc	ip, lr, ror #10
     8d0:	5152495f 	cmppl	r2, pc, asr r9
     8d4:	646e6148 	strbtvs	r6, [lr], #-328
     8d8:	0072656c 	rsbseq	r6, r2, ip, ror #10

unsigned long isqrt32(unsigned long n) //
{
     8dc:	32433249 	subcc	r3, r3, #-1879048188	; 0x90000004
     8e0:	5f56455f 	svcpl	0x0056455f

	root = 0;
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
     8e4:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     8e8:	6c646e61 	stclvs	14, cr6, [r4], #-388
     8ec:	44007265 	strmi	r7, [r0], #-613
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
     8f0:	5f32414d 	svcpl	0x0032414d
			remainder = remainder - root - place;
     8f4:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     8f8:	326c656e 	rsbcc	r6, ip, #461373440	; 0x1b800000
			root = root + (place << 1);
     8fc:	5152495f 	cmppl	r2, pc, asr r9

	while (place > remainder)
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
			remainder = remainder - root - place;
     900:	646e6148 	strbtvs	r6, [lr], #-328
			root = root + (place << 1);
		}
		root = root >> 1;
		place = place >> 2;
     904:	0072656c 	rsbseq	r6, r2, ip, ror #10
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
		place = place >> 2;
	while (place) {
     908:	49545845 	ldmdbmi	r4, {r0, r2, r6, fp, ip, lr}^
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
	XYhyp2 = isqrt32(
     90c:	52495f31 	subpl	r5, r9, #196	; 0xc4
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     910:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
	XYhyp2 = isqrt32(
     914:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     918:	414d4400 	cmpmi	sp, r0, lsl #8
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     91c:	68435f32 	stmdavs	r3, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
	XYhyp2 = isqrt32(
     920:	656e6e61 	strbvs	r6, [lr, #-3681]!
     924:	495f336c 	ldmdbmi	pc, {r2, r3, r5, r6, r8, r9, ip, sp}^
     928:	61485152 	cmpvs	r8, r2, asr r1
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);
     92c:	656c646e 	strbvs	r6, [ip, #-1134]!
     930:	56500072 	undefined
     934:	52495f44 	subpl	r5, r9, #272	; 0x110
     938:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     93c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     940:	49445300 	stmdbmi	r4, {r8, r9, ip, lr}^
     944:	52495f4f 	subpl	r5, r9, #316	; 0x13c

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
     948:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
		Atan4 = -AngleRad4;
     94c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
	else
		Atan4 = AngleRad4;
     950:	42535500 	subsmi	r5, r3, #0	; 0x0
	XYhyp2 = isqrt32(
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
		Atan4 = -AngleRad4;
     954:	5f504c5f 	svcpl	0x00504c5f
	else
		Atan4 = AngleRad4;
     958:	5f4e4143 	svcpl	0x004e4143
     95c:	5f305852 	svcpl	0x00305852
	return Atan4;
}
     960:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     964:	6c646e61 	stclvs	14, cr6, [r4], #-388
     968:	53007265 	movwpl	r7, #613	; 0x265
     96c:	61484356 	cmpvs	r8, r6, asr r3

}

//--------------------------------------------------------------------
//[BalCalcOneLeg]
void BalCalcOneLeg(long PosX, long PosZ, long PosY, byte BalLegNr) {
     970:	656c646e 	strbvs	r6, [ip, #-1134]!
	long CPR_Y;            //Final Y value for centerpoint of rotation
	long CPR_Z;            //Final Z value for centerpoint of rotation

	long lAtan;
	//Calculating totals from center of the body to the feet
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BalLegNr]) + PosZ;
     974:	58450072 	stmdapl	r5, {r1, r4, r5, r6}^
     978:	5f334954 	svcpl	0x00334954
	CPR_X = (short) pgm_read_word(&cOffsetX[BalLegNr]) + PosX;
     97c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     980:	6c646e61 	stclvs	14, cr6, [r4], #-388
	CPR_Y = 150 + PosY; // using the value 150 to lower the centerpoint of rotation 'g_InControlState.BodyPos.y +

	TotalTransY += (long) PosY;
     984:	45007265 	strmi	r7, [r0, #-613]
     988:	39495458 	stmdbcc	r9, {r3, r4, r6, sl, ip, lr}^
     98c:	495f355f 	ldmdbmi	pc, {r0, r1, r2, r3, r4, r6, r8, sl, ip, sp}^
	TotalTransZ += (long) CPR_Z;
     990:	61485152 	cmpvs	r8, r2, asr r1
     994:	656c646e 	strbvs	r6, [ip, #-1134]!
     998:	49540072 	ldmdbmi	r4, {r1, r4, r5, r6}^
	TotalTransX += (long) CPR_X;
     99c:	545f384d 	ldrbpl	r3, [pc], #2125	; 9a4 <__Stack_Size+0x5a4>
     9a0:	435f4752 	cmpmi	pc, #21495808	; 0x1480000
     9a4:	495f4d4f 	ldmdbmi	pc, {r0, r1, r2, r3, r6, r8, sl, fp, lr}^
     9a8:	61485152 	cmpvs	r8, r2, asr r1

	lAtan = GetATan2(CPR_X, CPR_Z);
     9ac:	656c646e 	strbvs	r6, [ip, #-1134]!
	TotalYBal1 += (lAtan * 1800) / 31415;
     9b0:	41430072 	cmpmi	r3, r2, ror r0
     9b4:	58525f4e 	ldmdapl	r2, {r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
     9b8:	52495f31 	subpl	r5, r9, #196	; 0xc4
     9bc:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     9c0:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     9c4:	54584500 	ldrbpl	r4, [r8], #-1280
     9c8:	495f3449 	ldmdbmi	pc, {r0, r3, r6, sl, ip, sp}^
     9cc:	61485152 	cmpvs	r8, r2, asr r1

	lAtan = GetATan2(CPR_X, CPR_Y);
     9d0:	656c646e 	strbvs	r6, [ip, #-1134]!
     9d4:	58450072 	stmdapl	r5, {r1, r4, r5, r6}^
	TotalZBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     9d8:	5f304954 	svcpl	0x00304954
     9dc:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     9e0:	6c646e61 	stclvs	14, cr6, [r4], #-388
     9e4:	54007265 	strpl	r7, [r0], #-613
     9e8:	5f314d49 	svcpl	0x00314d49
     9ec:	495f5055 	ldmdbmi	pc, {r0, r2, r4, r6, ip, lr}^
     9f0:	61485152 	cmpvs	r8, r2, asr r1
     9f4:	656c646e 	strbvs	r6, [ip, #-1134]!
     9f8:	61480072 	cmpvs	r8, r2, ror r0
     9fc:	61466472 	cmpvs	r6, r2, ror r4

	lAtan = GetATan2(CPR_Z, CPR_Y);
     a00:	45746c75 	ldrbmi	r6, [r4, #-3189]!
     a04:	70656378 	rsbvc	r6, r5, r8, ror r3
	TotalXBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     a08:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     a0c:	43435200 	movtmi	r5, #12800	; 0x3200
     a10:	5152495f 	cmppl	r2, pc, asr r9
     a14:	646e6148 	strbtvs	r6, [lr], #-328
     a18:	0072656c 	rsbseq	r6, r2, ip, ror #10
     a1c:	31414d44 	cmpcc	r1, r4, asr #26
     a20:	6168435f 	cmnvs	r8, pc, asr r3
     a24:	6c656e6e 	stclvs	14, cr6, [r5], #-440

}
     a28:	52495f36 	subpl	r5, r9, #216	; 0xd8
     a2c:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     a30:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     a34:	62654400 	rsbvs	r4, r5, #0	; 0x0
     a38:	6f4d6775 	svcvs	0x004d6775
     a3c:	6f74696e 	svcvs	0x0074696e
     a40:	49540072 	ldmdbmi	r4, {r1, r4, r5, r6}^
     a44:	435f384d 	cmpmi	pc, #5046272	; 0x4d0000
     a48:	52495f43 	subpl	r5, r9, #268	; 0x10c
     a4c:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a50:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     a54:	50504100 	subspl	r4, r0, r0, lsl #2
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a58:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
     a5c:	6d74732f 	ldclvs	3, cr7, [r4, #-188]!
     a60:	31663233 	cmncc	r6, r3, lsr r2
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a64:	695f7830 	ldmdbvs	pc, {r4, r5, fp, ip, sp, lr}^
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a68:	00632e74 	rsbeq	r2, r3, r4, ror lr
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
     a6c:	47445757 	smlsldmi	r5, r4, r7, r7
     a70:	5152495f 	cmppl	r2, pc, asr r9
     a74:	646e6148 	strbtvs	r6, [lr], #-328

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     a78:	0072656c 	rsbseq	r6, r2, ip, ror #10

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a7c:	31414d44 	cmpcc	r1, r4, asr #26
     a80:	6168435f 	cmnvs	r8, pc, asr r3
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a84:	6c656e6e 	stclvs	14, cr6, [r5], #-440
     a88:	52495f37 	subpl	r5, r9, #220	; 0xdc

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a8c:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a90:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     a94:	43324900 	teqmi	r2, #0	; 0x0
	SinG4 = sin4;
     a98:	56455f31 	undefined
	CosG4 = cos4;
     a9c:	5152495f 	cmppl	r2, pc, asr r9
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa0:	646e6148 	strbtvs	r6, [lr], #-328
	CosG4 = cos4;
     aa4:	0072656c 	rsbseq	r6, r2, ip, ror #10
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa8:	384d4954 	stmdacc	sp, {r2, r4, r6, r8, fp, lr}^
	CosG4 = cos4;

	GetSinCos(g_InControlState.BodyRot1.z + TotalZBal1);
     aac:	4b52425f 	blmi	1491430 <__Stack_Size+0x1491030>
	SinB4 = sin4;
     ab0:	5152495f 	cmppl	r2, pc, asr r9
     ab4:	646e6148 	strbtvs	r6, [lr], #-328
	CosB4 = cos4;
     ab8:	0072656c 	rsbseq	r6, r2, ip, ror #10

	GetSinCos(g_InControlState.BodyRot1.y + (RotationY * c1DEC) + TotalYBal1);
     abc:	53414c46 	movtpl	r4, #7238	; 0x1c46
     ac0:	52495f48 	subpl	r5, r9, #288	; 0x120
     ac4:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     ac8:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     acc:	52415500 	subpl	r5, r1, #0	; 0x0

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     ad0:	495f3454 	ldmdbmi	pc, {r2, r4, r6, sl, ip, sp}^
     ad4:	61485152 	cmpvs	r8, r2, asr r1
     ad8:	656c646e 	strbvs	r6, [ip, #-1134]!
     adc:	49540072 	ldmdbmi	r4, {r1, r4, r5, r6}^
     ae0:	495f364d 	ldmdbmi	pc, {r0, r2, r3, r6, r9, sl, ip, sp}^
     ae4:	61485152 	cmpvs	r8, r2, asr r1
     ae8:	656c646e 	strbvs	r6, [ip, #-1134]!
     aec:	54520072 	ldrbpl	r0, [r2], #-114
     af0:	616c4143 	cmnvs	ip, r3, asr #2
     af4:	495f6d72 	ldmdbmi	pc, {r1, r4, r5, r6, r8, sl, fp, sp, lr}^
     af8:	61485152 	cmpvs	r8, r2, asr r1
     afc:	656c646e 	strbvs	r6, [ip, #-1134]!
     b00:	49540072 	ldmdbmi	r4, {r1, r4, r5, r6}^
     b04:	495f374d 	ldmdbmi	pc, {r0, r2, r3, r6, r8, r9, sl, ip, sp}^
     b08:	61485152 	cmpvs	r8, r2, asr r1
     b0c:	656c646e 	strbvs	r6, [ip, #-1134]!
     b10:	32490072 	subcc	r0, r9, #114	; 0x72
     b14:	455f3243 	ldrbmi	r3, [pc, #-579]	; 8d9 <__Stack_Size+0x4d9>
     b18:	52495f52 	subpl	r5, r9, #328	; 0x148
     b1c:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     b20:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     b24:	41535500 	cmpmi	r3, r0, lsl #10
     b28:	5f315452 	svcpl	0x00315452
     b2c:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     b30:	6c646e61 	stclvs	14, cr6, [r4], #-388
     b34:	44007265 	strmi	r7, [r0], #-613
     b38:	5f32414d 	svcpl	0x0032414d
     b3c:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     b40:	346c656e 	strbtcc	r6, [ip], #-1390
     b44:	495f355f 	ldmdbmi	pc, {r0, r1, r2, r3, r4, r6, r8, sl, ip, sp}^
     b48:	61485152 	cmpvs	r8, r2, asr r1
     b4c:	656c646e 	strbvs	r6, [ip, #-1134]!
     b50:	65500072 	ldrbvs	r0, [r0, #-114]
     b54:	5653646e 	ldrbpl	r6, [r3], -lr, ror #8
     b58:	49540043 	ldmdbmi	r4, {r0, r1, r6}^
     b5c:	555f384d 	ldrbpl	r3, [pc, #-2125]	; 317 <_Minimum_Stack_Size+0x217>
     b60:	52495f50 	subpl	r5, r9, #320	; 0x140
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b64:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     b68:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     b6c:	41535500 	cmpmi	r3, r0, lsl #10
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b70:	5f325452 	svcpl	0x00325452
     b74:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     b78:	6c646e61 	stclvs	14, cr6, [r4], #-388
     b7c:	55007265 	strpl	r7, [r0, #-613]
     b80:	54524153 	ldrbpl	r4, [r2], #-339
     b84:	52495f33 	subpl	r5, r9, #204	; 0xcc
     b88:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     b8c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     b90:	73795300 	cmnvc	r9, #0	; 0x0
     b94:	6b636954 	blvs	18db0ec <__Stack_Size+0x18dacec>
     b98:	646e6148 	strbtvs	r6, [lr], #-328
     b9c:	0072656c 	rsbseq	r6, r2, ip, ror #10
     ba0:	49545845 	ldmdbmi	r4, {r0, r2, r6, fp, ip, lr}^
     ba4:	315f3531 	cmpcc	pc, r1, lsr r5
     ba8:	52495f30 	subpl	r5, r9, #192	; 0xc0
     bac:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     bb0:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
     bb4:	414d4400 	cmpmi	sp, r0, lsl #8
     bb8:	68435f31 	stmdavs	r3, {r0, r4, r5, r8, r9, sl, fp, ip, lr}^
     bbc:	656e6e61 	strbvs	r6, [lr, #-3681]!
     bc0:	495f316c 	ldmdbmi	pc, {r2, r3, r5, r6, r8, ip, sp}^
     bc4:	61485152 	cmpvs	r8, r2, asr r1
     bc8:	656c646e 	strbvs	r6, [ip, #-1134]!
     bcc:	58450072 	stmdapl	r5, {r1, r4, r5, r6}^
     bd0:	5f324954 	svcpl	0x00324954
     bd4:	48515249 	ldmdami	r1, {r0, r3, r6, r9, ip, lr}^
     bd8:	6c646e61 	stclvs	14, cr6, [r4], #-388
     bdc:	44007265 	strmi	r7, [r0], #-613
     be0:	5f31414d 	svcpl	0x0031414d
     be4:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     be8:	326c656e 	rsbcc	r6, ip, #461373440	; 0x1b800000
     bec:	5152495f 	cmppl	r2, pc, asr r9
     bf0:	646e6148 	strbtvs	r6, [lr], #-328
     bf4:	0072656c 	rsbseq	r6, r2, ip, ror #10
     bf8:	45494d4e 	strbmi	r4, [r9, #-3406]
     bfc:	70656378 	rsbvc	r6, r5, r8, ror r3
     c00:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     c04:	4e414300 	cdpmi	3, 4, cr4, cr1, cr0, {0}
     c08:	4543535f 	strbmi	r5, [r3, #-863]
     c0c:	5152495f 	cmppl	r2, pc, asr r9
     c10:	646e6148 	strbtvs	r6, [lr], #-328
     c14:	0072656c 	rsbseq	r6, r2, ip, ror #10
     c18:	31414d44 	cmpcc	r1, r4, asr #26
     c1c:	6168435f 	cmnvs	r8, pc, asr r3
     c20:	6c656e6e 	stclvs	14, cr6, [r5], #-440
     c24:	52495f33 	subpl	r5, r9, #204	; 0xcc
     c28:	6e614851 	mcrvs	8, 3, r4, cr1, cr1, {2}
     c2c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c30:	6d654d00 	stclvs	13, cr4, [r5]
	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     c34:	616e614d 	cmnvs	lr, sp, asr #2
     c38:	78456567 	stmdavc	r5, {r0, r1, r2, r5, r6, r8, sl, sp, lr}^
     c3c:	74706563 	ldrbtvc	r6, [r0], #-1379
     c40:	006e6f69 	rsbeq	r6, lr, r9, ror #30
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c44:	64756162 	ldrbtvs	r6, [r5], #-354
     c48:	67654c00 	strbvs	r4, [r5, -r0, lsl #24]!
     c4c:	43004b49 	movwmi	r4, #2889	; 0xb49
     c50:	6b636568 	blvs	18da1f8 <__Stack_Size+0x18d9df8>
     c54:	746c6f56 	strbtvc	r6, [ip], #-3926
     c58:	00656761 	rsbeq	r6, r5, r1, ror #14
     c5c:	47735f67 	ldrbmi	r5, [r3, -r7, ror #30]!
     c60:	434d5350 	movtmi	r5, #54096	; 0xd350
     c64:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
     c68:	656c6c6f 	strbvs	r6, [ip, #-3183]!
     c6c:	52660072 	rsbpl	r0, r6, #114	; 0x72
     c70:	746f626f 	strbtvc	r6, [pc], #623	; c78 <__Stack_Size+0x878>
     c74:	69737055 	ldmdbvs	r3!, {r0, r2, r4, r6, ip, sp, lr}^
     c78:	6f446564 	svcvs	0x00446564
     c7c:	72506e77 	subsvc	r6, r0, #1904	; 0x770
     c80:	49007665 	stmdbmi	r0, {r0, r2, r5, r6, r9, sl, ip, sp, lr}
     c84:	5f54534e 	svcpl	0x0054534e
     c88:	44414552 	strbmi	r4, [r1], #-1362
     c8c:	4952475f 	ldmdbmi	r2, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
     c90:	65470044 	strbvs	r0, [r7, #-68]
     c94:	61544174 	cmpvs	r4, r4, ror r1
     c98:	4300326e 	movwmi	r3, #622	; 0x26e
     c9c:	4d6c7274 	sfmmi	f7, 2, [ip, #-464]!
     ca0:	4f65766f 	svcmi	0x0065766f
     ca4:	6c007475 	cfstrsvs	mvf7, [r0], {117}
     ca8:	656d6954 	strbvs	r6, [sp, #-2388]!
     cac:	646e4572 	strbtvs	r4, [lr], #-1394
     cb0:	6e695300 	cdpvs	3, 6, cr5, cr9, cr0, {0}
     cb4:	4c003441 	cfstrsmi	mvf3, [r0], {65}
     cb8:	6f506765 	svcvs	0x00506765
     cbc:	4c005873 	stcmi	8, cr5, [r0], {115}
     cc0:	6f506765 	svcvs	0x00506765
     cc4:	4c005973 	stcmi	9, cr5, [r0], {115}
     cc8:	6f506765 	svcvs	0x00506765
     ccc:	43005a73 	movwmi	r5, #2675	; 0xa73
     cd0:	616d6d6f 	cmnvs	sp, pc, ror #26
     cd4:	7265646e 	rsbvc	r6, r5, #1845493760	; 0x6e000000
     cd8:	6165525f 	cmnvs	r5, pc, asr r2
     cdc:	67734d64 	ldrbvs	r4, [r3, -r4, ror #26]!
     ce0:	6f720073 	svcvs	0x00720073
     ce4:	6300746f 	movwvs	r7, #1135	; 0x46f
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * SinG4 / c4DEC
					+ (long) CPR_Z * c2DEC * CosG4 / c4DEC * SinA4 / c4DEC
							* SinB4 / c4DEC
					+ (long) CPR_Y * c2DEC * CosB4 / c4DEC * CosG4 / c4DEC))
			/ c2DEC;
}
     ce8:	61786f43 	cmnvs	r8, r3, asr #30
     cec:	6c676e41 	stclvs	14, cr6, [r7], #-260
     cf0:	73003165 	movwvc	r3, #357	; 0x165
     cf4:	006c6156 	rsbeq	r6, ip, r6, asr r1
     cf8:	45444f4d 	strbmi	r4, [r4, #-3917]
     cfc:	00544e43 	subseq	r4, r4, r3, asr #28
     d00:	446c6c41 	strbtmi	r6, [ip], #-3137
     d04:	006e776f 	rsbeq	r7, lr, pc, ror #14
     d08:	6c755f67 	ldclvs	15, cr5, [r5], #-412
     d0c:	7473614c 	ldrbtvc	r6, [r3], #-332
     d10:	5467734d 	strbtpl	r7, [r7], #-845
     d14:	00656d69 	rsbeq	r6, r5, r9, ror #26
     d18:	68676972 	stmdavs	r7!, {r1, r4, r5, r6, r8, fp, sp, lr}^
     d1c:	67004874 	smlsdxvs	r0, r4, r8, r4
//FemurAngle1           - Output Angle of Femur in degrees
//TibiaAngle1           - Output Angle of Tibia in degrees
//CoxaAngle1            - Output Angle of Coxa in degrees
//--------------------------------------------------------------------
void LegIK(short IKFeetPosX, short IKFeetPosY, short IKFeetPosZ,
		byte LegIKLegNr) {
     d20:	6449695f 	strbvs	r6, [r9], #-2399
     d24:	654c656c 	strbvs	r6, [ip, #-1388]
     d28:	61745364 	cmnvs	r4, r4, ror #6
	long Temp1;
	long Temp2;
	long T3;

	//Calculate IKCoxaAngle and IKFeetPosXZ
	GetATan2(IKFeetPosX, IKFeetPosZ);
     d2c:	49006574 	stmdbmi	r0, {r2, r4, r5, r6, r8, sl, sp, lr}
	CoxaAngle1[LegIKLegNr] = (((long) Atan4 * 180) / 3141)
     d30:	7475706e 	ldrbtvc	r7, [r5], #-110
     d34:	656d6954 	strbvs	r6, [sp, #-2388]!
     d38:	616c6544 	cmnvs	ip, r4, asr #10
     d3c:	69720079 	ldmdbvs	r2!, {r0, r3, r4, r5, r6}^
     d40:	56746867 	ldrbtpl	r6, [r4], -r7, ror #16
     d44:	53504700 	cmppl	r0, #0	; 0x0
     d48:	67007165 	strvs	r7, [r0, -r5, ror #2]
     d4c:	6f52665f 	svcvs	0x0052665f
     d50:	55746f62 	ldrbpl	r6, [r4, #-3938]!
     d54:	64697370 	strbtvs	r7, [r9], #-880
	//Length between the Coxa and tars [foot]
	IKFeetPosXZ = XYhyp2 / c2DEC;

	//Using GetAtan2 for solving IKA1 and IKSW
	//IKA14 - Angle between SW line and the ground in radians
	IKA14 = GetATan2(IKFeetPosY - TarsOffsetY,
     d58:	776f4465 	strbvc	r4, [pc, -r5, ror #8]!
     d5c:	6f42006e 	svcvs	0x0042006e
     d60:	4b497964 	blmi	125f2f8 <__Stack_Size+0x125eef8>
     d64:	0067654c 	rsbeq	r6, r7, ip, asr #10
     d68:	426e6953 	rsbmi	r6, lr, #1359872	; 0x14c000
     d6c:	48500034 	ldmdami	r0, {r2, r4, r5}^
     d70:	494e454f 	stmdbmi	lr, {r0, r1, r2, r3, r6, r8, sl, lr}^

	//IKSW2 - Length between femur axis and tars
	IKSW2 = XYhyp2;

	//IKA2 - Angle of the line S>W with respect to the femur in radians
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     d74:	49414758 	stmdbmi	r1, {r3, r4, r6, r8, r9, sl, lr}^
     d78:	4b490054 	blmi	1240ed0 <__Stack_Size+0x1240ad0>
     d7c:	756c6f53 	strbvc	r6, [ip, #-3923]!
     d80:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			+ ((long) IKSW2 * IKSW2));
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);
     d84:	6e726157 	mrcvs	1, 3, r6, cr2, cr7, {2}
     d88:	00676e69 	rsbeq	r6, r7, r9, ror #28
     d8c:	54534e49 	ldrbpl	r4, [r3], #-3657
     d90:	5741525f 	smlsldpl	r5, r1, pc, r2
     d94:	4d41535f 	stclmi	3, cr5, [r1, #-380]
     d98:	00454c50 	subeq	r4, r5, r0, asr ip
     d9c:	74696147 	strbtvc	r6, [r9], #-327
     da0:	65707954 	ldrbvs	r7, [r0, #-2388]!
     da4:	67654c00 	strbvs	r4, [r5, -r0, lsl #24]!
     da8:	65646e49 	strbvs	r6, [r4, #-3657]!
     dac:	43630078 	cmnmi	r3, #120	; 0x78
     db0:	4d61786f 	stclmi	8, cr7, [r1, #-444]!
     db4:	00316e69 	eorseq	r6, r1, r9, ror #28

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     db8:	6f534b49 	svcvs	0x00534b49
     dbc:	6974756c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sl, ip, sp, lr}^
     dc0:	4c006e6f 	stcmi	14, cr6, [r0], {111}
     dc4:	74536765 	ldrbvc	r6, [r3], #-1893
     dc8:	49007065 	stmdbmi	r0, {r0, r2, r5, r6, ip, sp, lr}
     dcc:	5f54534e 	svcpl	0x0054534e
     dd0:	504d4153 	subpl	r4, sp, r3, asr r1
     dd4:	465f454c 	ldrbmi	r4, [pc], -ip, asr #10
     dd8:	00545341 	subseq	r5, r4, r1, asr #6
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     ddc:	41544f52 	cmpmi	r4, r2, asr pc
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     de0:	4f4d4554 	svcmi	0x004d4554
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     de4:	67004544 	strvs	r4, [r0, -r4, asr #10]
     de8:	6553665f 	ldrbvs	r6, [r3, #-1631]
			+ ((long) (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr])
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);
     dec:	736f7672 	cmnvc	pc, #119537664	; 0x7200000
     df0:	65657246 	strbvs	r7, [r5, #-582]!
     df4:	65684300 	strbvs	r4, [r8, #-768]!
     df8:	6e416b63 	fnmacdvs	d22, d1, d19
     dfc:	73656c67 	cmnvc	r5, #26368	; 0x6700
     e00:	61725400 	cmnvs	r2, r0, lsl #8
     e04:	526c6576 	rsbpl	r6, ip, #494927872	; 0x1d800000
     e08:	65757165 	ldrbvs	r7, [r5, #-357]!

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e0c:	62007473 	andvs	r7, r0, #1929379840	; 0x73000000
     e10:	72747845 	rsbsvc	r7, r4, #4521984	; 0x450000
     e14:	63794361 	cmnvs	r9, #-2080374783	; 0x84000001
     e18:	4200656c 	andmi	r6, r0, #452984832	; 0x1b000000
     e1c:	4679646f 	ldrbtmi	r6, [r9], -pc, ror #8
     e20:	6176004b 	cmnvs	r6, fp, asr #32
     e24:	5400736c 	strpl	r7, [r0], #-876
     e28:	7669444c 	strbtvc	r4, [r9], -ip, asr #8
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e2c:	74636146 	strbtvc	r6, [r3], #-326
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e30:	4300726f 	movwmi	r7, #623	; 0x26f
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e34:	616d6d6f 	cmnvs	sp, pc, ror #26
     e38:	7265646e 	rsbvc	r6, r5, #1845493760	; 0x6e000000
     e3c:	6d6f435f 	stclvs	3, cr4, [pc, #-380]!
     e40:	646e616d 	strbtvs	r6, [lr], #-365
     e44:	42007265 	andmi	r7, r0, #1342177286	; 0x50000006
			< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
					+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]) - 30)
					* c2DEC))
		IKSolution = 1;
     e48:	6e616c61 	cdpvs	12, 6, cr6, cr1, cr1, {3}
	else {
		if (IKSW2
     e4c:	6f4d6563 	svcvs	0x004d6563
     e50:	67006564 	strvs	r6, [r0, -r4, ror #10]
				< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
						+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))
						* c2DEC))
			IKSolutionWarning = 1;
     e54:	546c755f 	strbtpl	r7, [ip], #-1375
     e58:	4c656d69 	stclmi	13, cr6, [r5], #-420
		else
			IKSolutionError = 1;
     e5c:	42747361 	rsbsmi	r7, r4, #-2080374783	; 0x84000001
	}

}
     e60:	65747461 	ldrbvs	r7, [r4, #-1121]!
     e64:	6f567972 	svcvs	0x00567972
     e68:	6761746c 	strbvs	r7, [r1, -ip, ror #8]!
     e6c:	61470065 	cmpvs	r7, r5, rrx
     e70:	6f507469 	svcvs	0x00507469
     e74:	47005973 	smlsdxmi	r0, r3, r9, r5
     e78:	50746961 	rsbspl	r6, r4, r1, ror #18
     e7c:	005a736f 	subseq	r7, sl, pc, ror #6
     e80:	54534e49 	ldrbpl	r4, [r3], #-3657
     e84:	5443415f 	strbpl	r4, [r3], #-351
     e88:	004e4f49 	subeq	r4, lr, r9, asr #30
     e8c:	4d524f4e 	ldclmi	15, cr4, [r2, #-312]
     e90:	4e4f4c5f 	mcrmi	12, 2, r4, cr15, cr15, {2}
     e94:	65470047 	strbvs	r0, [r7, #-71]
     e98:	6e695374 	mcrvs	3, 3, r5, cr9, cr4, {3}
     e9c:	6d6f4300 	stclvs	3, cr4, [pc]
     ea0:	646e616d 	strbtvs	r6, [lr], #-365
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ea4:	6e497265 	cdpvs	2, 4, cr7, cr9, cr5, {3}
	if (sVal < s) {
     ea8:	43747570 	cmnmi	r4, #469762048	; 0x1c000000
     eac:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
		return s;
	}

	s = (short) pgm_read_word(sMax);
     eb0:	656c6c6f 	strbvs	r6, [ip, #-3183]!
     eb4:	6e495f72 	mcrvs	15, 2, r5, cr9, cr2, {3}
     eb8:	62007469 	andvs	r7, r0, #1761607680	; 0x69000000

		return s;
	}
	return sVal;

}
     ebc:	006c6156 	rsbeq	r6, ip, r6, asr r1
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec0:	636c6143 	cmnvs	ip, #-1073741808	; 0xc0000010
}

//--------------------------------------------------------------------
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
     ec4:	74616c75 	strbtvc	r6, [r1], #-3189
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec8:	31584165 	cmpcc	r8, r5, ror #2
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ecc:	766f4d32 	undefined
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     ed0:	65705365 	ldrbvs	r5, [r0, #-869]!
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ed4:	67006465 	strvs	r6, [r0, -r5, ror #8]
	if (sVal < s) {
     ed8:	646f425f 	strbtvs	r4, [pc], #607	; ee0 <__Stack_Size+0xae0>
     edc:	664f5979 	undefined
     ee0:	74657366 	strbtvc	r7, [r5], #-870
		return s;
	}

	s = (short) pgm_read_word(sMax);
     ee4:	534e4900 	movtpl	r4, #59648	; 0xe900
     ee8:	49445f54 	stmdbmi	r4, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
     eec:	41544947 	cmpmi	r4, r7, asr #18
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
     ef0:	45525f4c 	ldrbmi	r5, [r2, #-3916]
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ef4:	00544553 	subseq	r4, r4, r3, asr r5
	if (sVal < s) {
     ef8:	54534e49 	ldrbpl	r4, [r3], #-3657
     efc:	4745525f 	smlsldmi	r5, r5, pc, r2
     f00:	4952575f 	ldmdbmi	r2, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, lr}^
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f04:	62004554 	andvs	r4, r0, #352321536	; 0x15000000
     f08:	706f6f4c 	rsbvc	r6, pc, ip, asr #30
     f0c:	00746e43 	rsbseq	r6, r4, r3, asr #28
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f10:	74696147 	strbtvc	r6, [r9], #-327
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f14:	59746f52 	ldmdbpl	r4!, {r1, r4, r6, r8, r9, sl, fp, sp, lr}^
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f18:	646f4200 	strbtvs	r4, [pc], #512	; f20 <__Stack_Size+0xb20>
	if (sVal < s) {
     f1c:	746f5279 	strbtvc	r5, [pc], #633	; f24 <__Stack_Size+0xb24>
     f20:	7366664f 	cmnvc	r6, #82837504	; 0x4f00000
     f24:	52007465 	andpl	r7, r0, #1694498816	; 0x65000000
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f28:	7461746f 	strbtvc	r7, [r1], #-1135
     f2c:	596e6f69 	stmdbpl	lr!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
     f30:	6f6f6200 	svcvs	0x006f6200
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
				FemurAngle1[LegIndex], &cFemurMin1[LegIndex],
				&cFemurMax1[LegIndex]);
		TibiaAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f34:	6e61656c 	cdpvs	5, 6, cr6, cr1, cr12, {3}
     f38:	69725700 	ldmdbvs	r2!, {r8, r9, sl, ip, lr}^
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     f3c:	754f6574 	strbvc	r6, [pc, #-1396]	; 9d0 <__Stack_Size+0x5d0>
     f40:	74757074 	ldrbtvc	r7, [r5], #-116
				TibiaAngle1[LegIndex], &cTibiaMin1[LegIndex],
				&cTibiaMax1[LegIndex]);

	}
#endif
}
     f44:	435f0073 	cmpmi	pc, #115	; 0x73
     f48:	64726f6f 	ldrbtvs	r6, [r2], #-3951
     f4c:	54004433 	strpl	r4, [r0], #-1075
     f50:	6c61746f 	cfstrdvs	mvd7, [r1], #-444
     f54:	6c61425a 	sfmvs	f4, 2, [r1], #-360
     f58:	6f430031 	svcvs	0x00430031
     f5c:	6e616d6d 	cdpvs	13, 6, cr6, cr1, cr13, {3}
     f60:	49726564 	ldmdbmi	r2!, {r2, r5, r6, r8, sl, sp, lr}^
     f64:	7475706e 	ldrbtvc	r7, [r5], #-110
     f68:	746e6f43 	strbtvc	r6, [lr], #-3907
     f6c:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
// SmoothControl (From Zenta) -  This function makes the body
//            rotation and translation much smoother
//--------------------------------------------------------------------
short SmoothControl(short CtrlMoveInp, short CtrlMoveOut, byte CtrlDivider) {

	if (CtrlMoveOut < (CtrlMoveInp - 4))
     f70:	415f7265 	cmpmi	pc, r5, ror #4
     f74:	776f6c6c 	strbvc	r6, [pc, -ip, ror #24]!
		return CtrlMoveOut + abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f78:	746e6f43 	strbtvc	r6, [lr], #-3907
     f7c:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
     f80:	6e497265 	cdpvs	2, 4, cr7, cr9, cr5, {3}
     f84:	72726574 	rsbsvc	r6, r2, #486539264	; 0x1d000000
     f88:	73747075 	cmnvc	r4, #117	; 0x75
     f8c:	69614700 	stmdbvs	r1!, {r8, r9, sl, lr}^
     f90:	65745374 	ldrbvs	r5, [r4, #-884]!
	else if (CtrlMoveOut > (CtrlMoveInp + 4))
     f94:	6f620070 	svcvs	0x00620070
		return CtrlMoveOut - abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f98:	63006c6f 	movwvs	r6, #3183	; 0xc6f
     f9c:	0034736f 	eorseq	r7, r4, pc, ror #6
     fa0:	54534e49 	ldrbpl	r4, [r3], #-3657
     fa4:	4e49505f 	mcrmi	0, 2, r5, cr9, cr15, {2}
     fa8:	65540047 	ldrbvs	r0, [r4, #-71]
     fac:	0031706d 	eorseq	r7, r1, sp, rrx
     fb0:	706d6554 	rsbvc	r6, sp, r4, asr r5

	return CtrlMoveInp;
}
     fb4:	65480032 	strbvs	r0, [r8, #-50]
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
     fb8:	74686769 	strbtvc	r6, [r8], #-1897
     fbc:	65657053 	strbvs	r7, [r5, #-83]!
     fc0:	646f4d64 	strbtvs	r4, [pc], #3428	; fc8 <__Stack_Size+0xbc8>

//--------------------------------------------------------------------
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
     fc4:	724e0065 	subvc	r0, lr, #101	; 0x65
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
		return g_wLegsXZLength;

	return isqrt32((LegPosX[0] * LegPosX[0]) + (LegPosZ[0] * LegPosZ[0]));
     fc8:	7466694c 	strbtvc	r6, [r6], #-2380
     fcc:	6f506465 	svcvs	0x00506465
     fd0:	656c0073 	strbvs	r0, [ip, #-115]!
     fd4:	00487466 	subeq	r7, r8, r6, ror #8
     fd8:	41534241 	cmpmi	r3, r1, asr #4
     fdc:	656c676e 	strbvs	r6, [ip, #-1902]!
}
     fe0:	31676544 	cmncc	r7, r4, asr #10
     fe4:	61725400 	cmnvs	r2, r0, lsl #8
     fe8:	4c6c6576 	cfstr64mi	mvdx6, [ip], #-472
     fec:	74676e65 	strbtvc	r6, [r7], #-3685

#ifndef MAX_XZ_LEG_ADJUST
#define MAX_XZ_LEG_ADJUST   (word)(cCoxaLength[0]+cTibiaLength[0] + cFemurLength[0]/4)
#endif

void AdjustLegPositions(word XZLength1) {
     ff0:	656c0068 	strbvs	r0, [ip, #-104]!
     ff4:	00567466 	subseq	r7, r6, r6, ror #8
     ff8:	746e6f43 	strbtvc	r6, [lr], #-3907
     ffc:	4d6c6f72 	stclmi	15, cr6, [ip, #-456]!
    1000:	0065646f 	rsbeq	r6, r5, pc, ror #8
		XZLength1 = MAX_XZ_LEG_ADJUST;
	if (XZLength1 < MIN_XZ_LEG_ADJUST)
		XZLength1 = MIN_XZ_LEG_ADJUST;

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
    1004:	436c6142 	cmnmi	ip, #-2147483632	; 0x80000010
    1008:	4f636c61 	svcmi	0x00636c61
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    100c:	654c656e 	strbvs	r6, [ip, #-1390]

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
		return;

	g_wLegsXZLength = XZLength1;
    1010:	69730067 	ldmdbvs	r3!, {r0, r1, r2, r5, r6}^

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));
    1014:	5300346e 	movwpl	r3, #1134	; 0x46e
    1018:	34476e69 	strbcc	r6, [r7], #-3689

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
    101c:	65466300 	strbvs	r6, [r6, #-768]
    1020:	4d72756d 	cfldr64mi	mvdx7, [r2, #-436]!
    1024:	00317861 	eorseq	r7, r1, r1, ror #16
    1028:	6e617441 	cdpvs	4, 6, cr7, cr1, cr1, {2}
    102c:	416c0034 	cmnmi	ip, r4, lsr r0
    1030:	006e6174 	rsbeq	r6, lr, r4, ror r1
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    1034:	5f525043 	svcpl	0x00525043
    1038:	50430059 	subpl	r0, r3, r9, asr r0
    103c:	005a5f52 	subseq	r5, sl, r2, asr pc
    1040:	74747562 	ldrbtvc	r7, [r4], #-1378
    1044:	50736e6f 	rsbspl	r6, r3, pc, ror #28
    1048:	00766572 	rsbseq	r6, r6, r2, ror r5
		return;

	g_wLegsXZLength = XZLength1;

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    104c:	44665f67 	strbtmi	r5, [r6], #-3943
		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
	}

	// Make sure we cycle through one gait to have the legs all move into their new locations...
	g_InControlState.ForceGaitStepCnt = g_InControlState.gaitCur.StepsInGait;
    1050:	67756265 	ldrbvs	r6, [r5, -r5, ror #4]!
    1054:	7074754f 	rsbsvc	r7, r4, pc, asr #10
}
    1058:	66007475 	undefined
    105c:	6b6c6157 	blvs	1b195c0 <__Stack_Size+0x1b191c0>
    1060:	00676e69 	rsbeq	r6, r7, r9, ror #28
    1064:	72754377 	rsbsvc	r4, r5, #-603979775	; 0xdc000001
    1068:	00736f50 	rsbseq	r6, r3, r0, asr pc
    106c:	6c676e41 	stclvs	14, cr6, [r7], #-260
    1070:	64615265 	strbtvs	r5, [r1], #-613
    1074:	74410034 	strbvc	r0, [r1], #-52
    1078:	00586e61 	subseq	r6, r8, r1, ror #28
		g_InControlState.aCoxaInitAngle1[LegIndex] = (short)pgm_read_word(&cCoxaAngle1[LegIndex]);
#endif
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    107c:	6e617441 	cdpvs	4, 6, cr7, cr1, cr1, {2}
		else if (g_InControlState.aCoxaInitAngle1[LegIndex] < -700)
		g_InControlState.aCoxaInitAngle1[LegIndex] = -700;
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    1080:	43630059 	cmnmi	r3, #89	; 0x59
//     to be appropriate for the current y location of the body...
//--------------------------------------------------------------------

u8 g_iLegInitIndex = 0x00; // remember which index we are currently using...

void AdjustLegPositionsToBodyHeight() {
    1084:	4961786f 	stmdbmi	r1!, {r0, r1, r2, r3, r5, r6, fp, ip, sp, lr}^
    1088:	6300766e 	movwvs	r7, #1646	; 0x66e
#ifdef CNT_HEX_INITS
	// Lets see which of our units we should use...
	// Note: We will also limit our body height here...
	if (g_InControlState.BodyPos.y
    108c:	74696e49 	strbtvc	r6, [r9], #-3657
			> (short) pgm_read_byte(&g_abHexMaxBodyY[CNT_HEX_INITS-1]))
		g_InControlState.BodyPos.y = (short) pgm_read_byte(
    1090:	58736f50 	ldmdapl	r3!, {r4, r6, r8, r9, sl, fp, sp, lr}^
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    1094:	6e496300 	cdpvs	3, 4, cr6, cr9, cr0, {0}
    1098:	6f507469 	svcvs	0x00507469
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    109c:	63005973 	movwvs	r5, #2419	; 0x973
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    10a0:	74696e49 	strbtvc	r6, [r9], #-3657
    10a4:	5a736f50 	bpl	1cdcdec <__Stack_Size+0x1cdc9ec>
    10a8:	524f4e00 	subpl	r4, pc, #0	; 0x0
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    10ac:	4f4e5f4d 	svcmi	0x004e5f4d
		g_iLegInitIndex = i;  // remember the current index...
		AdjustLegPositions(XZLength1);
    10b0:	67004d52 	smlsdvs	r0, r2, sp, r4
	}
#endif // CNT_HEX_INITS
}
    10b4:	4377615f 	cmnmi	r7, #-1073741801	; 0xc0000017
    10b8:	58417275 	stmdapl	r1, {r0, r2, r4, r5, r6, r9, ip, sp, lr}^
    10bc:	00736f50 	rsbseq	r6, r3, r0, asr pc
}
//--------------------------------------------------------------------
//[CHECK VOLTAGE]
//Reads the input voltage and shuts down the bot when the power drops
byte s_bLVBeepCnt;
boolean CheckVoltage() {
    10c0:	6e6f7246 	cdpvs	2, 6, cr7, cr15, cr6, {2}
    10c4:	776f4474 	undefined
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10c8:	736f506e 	cmnvc	pc, #110	; 0x6e

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10cc:	67654200 	strbvs	r4, [r5, -r0, lsl #4]!
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d0:	65536e69 	ldrbvs	r6, [r3, #-3689]

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10d4:	556f7672 	strbpl	r7, [pc, #-1650]!	; a6a <__Stack_Size+0x66a>
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d8:	74616470 	strbtvc	r6, [r1], #-1136

	if (!g_fLowVoltageShutdown) {
		/**PrintString("Voltage : ");
		Printu32d(Voltage);
		PrintString("\n");*/
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {
    10dc:	61670065 	cmnvs	r7, r5, rrx
    10e0:	75437469 	strbvc	r7, [r3, #-1129]
    10e4:	43730072 	cmnmi	r3, #114	; 0x72


			//Turn off
			g_InControlState.BodyPos.x = 0;
    10e8:	4161786f 	cmnmi	r1, pc, ror #16
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;

#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
    10ec:	656c676e 	strbvs	r6, [ip, #-1902]!
    10f0:	4e490031 	mcrmi	0, 2, r0, cr9, cr1, {1}
#endif
			g_fLowVoltageShutdown = 1;
    10f4:	525f5453 	subspl	r5, pc, #1392508928	; 0x53000000
			s_bLVBeepCnt = 0;    // how many times we beeped...
    10f8:	54455345 	strbpl	r5, [r5], #-837
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {


			//Turn off
			g_InControlState.BodyPos.x = 0;
			g_InControlState.BodyPos.y = 0;
    10fc:	74654700 	strbtvc	r4, [r5], #-1792
			g_InControlState.BodyPos.z = 0;
			g_InControlState.BodyRot1.x = 0;
    1100:	74746142 	ldrbtvc	r6, [r4], #-322
			g_InControlState.BodyRot1.y = 0;
			g_InControlState.BodyRot1.z = 0;
    1104:	56797265 	ldrbtpl	r7, [r9], -r5, ror #4
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;
    1108:	61746c6f 	cmnvs	r4, pc, ror #24
#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
#endif
			g_fLowVoltageShutdown = 1;
			s_bLVBeepCnt = 0;    // how many times we beeped...
    110c:	5f006567 	svcpl	0x00006567
			g_InControlState.fRobotOn = false;
    1110:	656f6850 	strbvs	r6, [pc, #-2128]!	; 8c8 <__Stack_Size+0x4c8>
		}
#ifdef cTurnOnVol
	} else if ((Voltage > cTurnOnVol) && (Voltage < 1999)) {
    1114:	4778696e 	ldrbmi	r6, [r8, -lr, ror #18]!
    1118:	00746961 	rsbseq	r6, r4, r1, ror #18

		g_fLowVoltageShutdown = 0;
    111c:	54534e49 	ldrbpl	r4, [r3], #-3657
    1120:	5041435f 	subpl	r4, r1, pc, asr r3

#endif
	} else {
		if (s_bLVBeepCnt < 5) {
    1124:	4952475f 	ldmdbmi	r2, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
    1128:	4e490044 	cdpmi	0, 4, cr0, cr9, cr4, {2}
			s_bLVBeepCnt++;
    112c:	535f5453 	cmppl	pc, #1392508928	; 0x53000000

			//MSound( 1, 45, 2000);
			Buzzed(45, 2000);
    1130:	5f434e59 	svcpl	0x00434e59
    1134:	5f474552 	svcpl	0x00474552
    1138:	54495257 	strbpl	r5, [r9], #-599
		}
		mDelay(2000);
    113c:	5f670045 	svcpl	0x00670045
    1140:	6c644969 	stclvs	9, cr4, [r4], #-420
    1144:	72655365 	rsbvc	r5, r5, #-1811939327	; 0x94000001
	}
#endif

	return g_fLowVoltageShutdown;
}
    1148:	754e6f76 	strbvc	r6, [lr, #-3958]
    114c:	5377006d 	cmnpl	r7, #109	; 0x6d
    1150:	64656570 	strbtvs	r6, [r5], #-1392
    1154:	665f6700 	ldrbvs	r6, [pc], -r0, lsl #14
    1158:	62616e45 	rsbvs	r6, r1, #1104	; 0x450

//==============================================================================
// BackgroundProcess - Allows us to have some background processing for those
//    servo drivers that need us to do things like polling...
//==============================================================================
void BackgroundProcess(void) {
    115c:	6553656c 	ldrbvs	r6, [r3, #-1388]
    1160:	736f7672 	cmnvc	pc, #119537664	; 0x7200000
	if (g_fAXSpeedControl)
    1164:	746f5400 	strbtvc	r5, [pc], #1024	; 116c <__Stack_Size+0xd6c>
		return;  // nothing to do in this mode...

	if (ServosEnabled) {
		//DebugToggle(A3);
		BioloidControllerEx_interpolateStep(false); // Do our background stuff...
    1168:	42596c61 	subsmi	r6, r9, #24832	; 0x6100
		Battery_Monitor_Alarm();
    116c:	00316c61 	eorseq	r6, r1, r1, ror #24
	}
}
    1170:	654c5a58 	strbvs	r5, [ip, #-2648]
    1174:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
//Function that gets called from the main loop if the robot is not logically
//     on.  Gives us a chance to play some...
//--------------------------------------------------------------------
static u8 g_iIdleServoNum = (u8) - 1;
static u8 g_iIdleLedState = 1;  // what state to we wish to set...
void IdleTime(void) {
    1178:	65520031 	ldrbvs	r0, [r2, #-49]
    117c:	4c746573 	cfldr64mi	mvdx6, [r4], #-460
	// Each time we call this set servos LED on or off...
	g_iIdleServoNum++;
    1180:	6e496765 	cdpvs	7, 4, cr6, cr9, cr5, {3}
	if (g_iIdleServoNum >= NUMSERVOS) {
    1184:	6e417469 	cdpvs	4, 4, cr7, cr1, cr9, {3}
    1188:	73656c67 	cmnvc	r5, #26368	; 0x6700
		g_iIdleServoNum = 0;
    118c:	534e4900 	movtpl	r4, #59648	; 0xe900
		g_iIdleLedState = 1 - g_iIdleLedState;
    1190:	44525f54 	ldrbmi	r5, [r2], #-3924
    1194:	4c49465f 	mcrrmi	6, 5, r4, r9, cr15
	}
	dxl_write_byte(pgm_read_byte(&cPinTable[g_iIdleServoNum]), AXM_LED,
    1198:	00524854 	subseq	r4, r2, r4, asr r8
    119c:	6f534b49 	svcvs	0x00534b49
    11a0:	6974756c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sl, ip, sp, lr}^
    11a4:	72456e6f 	subvc	r6, r5, #1776	; 0x6f0
    11a8:	00726f72 	rsbseq	r6, r2, r2, ror pc
			g_iIdleLedState);
	//ax12ReadPacket(6);  // get the response...


}
    11ac:	66664f63 	strbtvs	r4, [r6], -r3, ror #30
    11b0:	58746573 	ldmdapl	r4!, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
    11b4:	664f6300 	strbvs	r6, [pc], -r0, lsl #6
    11b8:	74657366 	strbtvc	r7, [r5], #-870

//--------------------------------------------------------------------
//[SetRegOnAllServos] Function that is called to set the state of one
//  register in all of the servos, like Torque on...
//--------------------------------------------------------------------
void SetRegOnAllServos(u8 bReg, u8 bVal) {
    11bc:	4948005a 	stmdbmi	r8, {r1, r3, r4, r6}^
    11c0:	4c5f4847 	mrrcmi	8, 4, r4, pc, cr7
    11c4:	00474e4f 	subeq	r4, r7, pc, asr #28
	 ax12write(bVal);

  }
  ax12write(0xff - (checksum % 256));
  setRX(0);*/
	 dxl_set_txpacket_id (BROADCAST_ID);
    11c8:	6167654e 	cmnvs	r7, lr, asr #10
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    11cc:	65766974 	ldrbvs	r6, [r6, #-2420]!
	dxl_set_txpacket_parameter(0,bReg);
    11d0:	756c6156 	strbvc	r6, [ip, #-342]!
    11d4:	4e490065 	cdpmi	0, 4, cr0, cr9, cr5, {3}
	dxl_set_txpacket_parameter(1,2);
    11d8:	525f5453 	subspl	r5, pc, #1392508928	; 0x53000000
    11dc:	5f444145 	svcpl	0x00444145
    11e0:	41544144 	cmpmi	r4, r4, asr #2
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
    11e4:	74654700 	strbtvc	r4, [r5], #-1792
    11e8:	736f4341 	cmnvc	pc, #67108865	; 0x4000001
    11ec:	534e4900 	movtpl	r4, #59648	; 0xe900
    11f0:	59535f54 	ldmdbpl	r3, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    11f4:	525f434e 	subspl	r4, pc, #939524097	; 0x38000001
    11f8:	00444145 	subeq	r4, r4, r5, asr #2
    11fc:	4c665f67 	stclmi	15, cr5, [r6], #-412
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1200:	6f56776f 	svcvs	0x0056776f
    1204:	6761746c 	strbvs	r7, [r1, -ip, ror #8]!
    1208:	75685365 	strbvc	r5, [r8, #-869]!
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    120c:	776f6474 	undefined
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1210:	5262006e 	rsbpl	r0, r2, #110	; 0x6e
	 dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0,bReg);
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
    1214:	43006765 	movwmi	r6, #1893	; 0x765
    1218:	4c5f544e 	cfldrdmi	mvd5, [pc], {78}
    121c:	00534745 	subseq	r4, r3, r5, asr #14
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
	}

	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
    1220:	74696147 	strbtvc	r6, [r9], #-327
    1224:	72727543 	rsbsvc	r7, r2, #281018368	; 0x10c00000
    1228:	4c746e65 	ldclmi	14, cr6, [r4], #-404
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- SetRegOnAllServos ---\n");
#endif
	dxl_txrx_packet();
    122c:	724e6765 	subvc	r6, lr, #26476544	; 0x1940000

	u16 CommStatus = dxl_get_result();
    1230:	746f5200 	strbtvc	r5, [pc], #512	; 1238 <__Stack_Size+0xe38>
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
    1234:	4c657461 	cfstrdmi	mvd7, [r5], #-388
		PrintErrorCode();
    1238:	6e496765 	cdpvs	7, 4, cr6, cr9, cr5, {3}
	else
		PrintCommStatus(CommStatus);
    123c:	6e417469 	cdpvs	4, 4, cr7, cr1, cr9, {3}
#endif
}
    1240:	73656c67 	cmnvc	r5, #26368	; 0x6700
    1244:	65725000 	ldrbvs	r5, [r2]!
    1248:	72655376 	rsbvc	r5, r5, #-671088639	; 0xd8000001
//--------------------------------------------------------------------
//[MakeSureServosAreOn] Function that is called to handle when you are
//  transistioning from servos all off to being on.  May need to read
//  in the current pose...
//--------------------------------------------------------------------
void MakeSureServosAreOn(void) {
    124c:	6f4d6f76 	svcvs	0x004d6f76

	if (ServosEnabled) {

		if (!g_fServosFree)
    1250:	69546576 	ldmdbvs	r4, {r1, r2, r4, r5, r6, r8, sl, sp, lr}^
			return;    // we are not free

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {
    1254:	4200656d 	andmi	r6, r0, #457179136	; 0x1b400000
    1258:	5079646f 	rsbspl	r6, r9, pc, ror #8

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
    125c:	4200736f 	andmi	r7, r0, #-1140850687	; 0xbc000001
    1260:	676b6361 	strbvs	r6, [fp, -r1, ror #6]!
    1264:	6e756f72 	mrcvs	15, 3, r6, cr5, cr2, {3}
    1268:	6f725064 	svcvs	0x00725064
						AXM_PRESENT_POSITION_L);
				mDelay(25);
    126c:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
    1270:	6f4a6200 	svcvs	0x004a6200

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
    1274:	69747379 	ldmdbvs	r4!, {r0, r3, r4, r5, r6, r8, r9, ip, sp, lr}^
    1278:	61576b63 	cmpvs	r7, r3, ror #22
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
						AXM_PRESENT_POSITION_L);
				mDelay(25);
			}
		} else {
			BioloidControllerEx_readPose();
    127c:	6f4d6b6c 	svcvs	0x004d6b6c
		}

		SetRegOnAllServos(AXM_TORQUE_ENABLE, 1);  // Use sync write to do it.
    1280:	48006564 	stmdami	r0, {r2, r5, r6, r8, sl, sp, lr}
    1284:	4c666c61 	stclmi	12, cr6, [r6], #-388

		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = false;
    1288:	48746669 	ldmdami	r4!, {r0, r3, r5, r6, r9, sl, sp, lr}^
	}

}
    128c:	68676965 	stmdavs	r7!, {r0, r2, r5, r6, r8, fp, sp, lr}^
    1290:	4d730074 	ldclmi	0, cr0, [r3, #-464]!
    1294:	49006e69 	stmdbmi	r0, {r0, r3, r5, r6, r9, sl, fp, sp, lr}
    1298:	5f54534e 	svcpl	0x0054534e
    129c:	525f5257 	subspl	r5, pc, #1879048197	; 0x70000005

//------------------------------------------------------------------------------------------
//[BeginServoUpdate] Does whatever preperation that is needed to starrt a move of our servos
//------------------------------------------------------------------------------------------
void BeginServoUpdate(void)    // Start the update
		{
    12a0:	48544745 	ldmdami	r4, {r0, r2, r6, r8, r9, sl, lr}^

	MakeSureServosAreOn();
    12a4:	65530052 	ldrbvs	r0, [r3, #-82]
	if (ServosEnabled) {

		if (g_fAXSpeedControl) {
    12a8:	67655274 	undefined
    12ac:	6c416e4f 	mcrrvs	14, 4, r6, r1, cr15

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awCurAXPos[i] = g_awGoalAXPos[i];
    12b0:	7265536c 	rsbvc	r5, r5, #-1342177279	; 0xb0000001
    12b4:	00736f76 	rsbseq	r6, r3, r6, ror pc
    12b8:	74696147 	strbtvc	r6, [r9], #-327
		if (g_fAXSpeedControl) {

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
    12bc:	58736f50 	ldmdapl	r3!, {r4, r6, r8, r9, sl, fp, sp, lr}^
				g_awCurAXPos[i] = g_awGoalAXPos[i];
			}
#endif
		} else
			BioloidControllerEx_interpolateStep(true); // Make sure we call at least once
    12c0:	646f4200 	strbtvs	r4, [pc], #512	; 12c8 <__Stack_Size+0xec8>
    12c4:	746f5279 	strbtvc	r5, [pc], #633	; 12cc <__Stack_Size+0xecc>

	}
}
    12c8:	50430031 	subpl	r0, r3, r1, lsr r0
    12cc:	00585f52 	subseq	r5, r8, r2, asr pc
    12d0:	62695463 	rsbvs	r5, r9, #1660944384	; 0x63000000
    12d4:	694d6169 	stmdbvs	sp, {r0, r3, r5, r6, r8, sp, lr}^
}

//--------------------------------------------------------------------
//[FREE SERVOS] Frees all the servos
//--------------------------------------------------------------------
void FreeServos(void) {
    12d8:	6700316e 	strvs	r3, [r0, -lr, ror #2]
    12dc:	654c625f 	strbvs	r6, [ip, #-607]

	if (!g_fServosFree) {
    12e0:	6c6f5667 	stclvs	6, cr5, [pc], #-412
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
    12e4:	65676174 	strbvs	r6, [r7, #-372]!
    12e8:	65466300 	strbvs	r6, [r6, #-768]
    12ec:	4c72756d 	cfldr64mi	mvdx7, [r2], #-436
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
			Relax(pgm_read_byte(&cPinTable[i]));
    12f0:	74676e65 	strbtvc	r6, [r7], #-3685
    12f4:	6f440068 	svcvs	0x00440068
    12f8:	656c6275 	strbvs	r6, [ip, #-629]!

	if (!g_fServosFree) {
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
    12fc:	76617254 	undefined
			Relax(pgm_read_byte(&cPinTable[i]));
		}
		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = true;
    1300:	6e4f6c65 	cdpvs	12, 4, cr6, cr15, cr5, {3}
	}
}
    1304:	434e4900 	movtmi	r4, #59648	; 0xe900
    1308:	52544e4f 	subspl	r4, r4, #1264	; 0x4f0
    130c:	54534c4f 	ldrbpl	r4, [r3], #-3151
extern void SetRegOnAllServos(u8 bReg, u8 bVal);

//--------------------------------------------------------------------
//Init
//--------------------------------------------------------------------
void Servo_Init(void) {
    1310:	00455441 	subeq	r5, r5, r1, asr #8
	// First lets get the actual servo positions for all of our servos...
	//pinMode(0, OUTPUT);
	g_fServosFree = true;
    1314:	6d654663 	stclvs	6, cr4, [r5, #-396]!

  poseSize = NUMSERVOS;
    1318:	694d7275 	stmdbvs	sp, {r0, r2, r4, r5, r6, r9, ip, sp, lr}^
    131c:	7300316e 	movwvc	r3, #366	; 0x16e
  BioloidControllerEx_readPose();
    1320:	0078614d 	rsbseq	r6, r8, sp, asr #2
#ifdef cVoltagePin
	for (byte i=0; i < 8; i++)
	GetBatteryVoltage();  // init the voltage pin
#endif

	g_fAXSpeedControl = false;
    1324:	476d6f4e 	strbmi	r6, [sp, -lr, asr #30]!
    1328:	53746961 	cmnpl	r4, #1589248	; 0x184000



	// Added - try to speed things up later if we do a query...
	SetRegOnAllServos(AXM_RETURN_DELAY_TIME, 0); // tell servos to give us back their info as quick as they can...
    132c:	64656570 	strbtvs	r6, [r5], #-1392
    1330:	67654c00 	strbvs	r4, [r5, -r0, lsl #24]!

}
    1334:	654c4b49 	strbvs	r4, [ip, #-2889]
    1338:	00724e67 	rsbseq	r4, r2, r7, ror #28
    133c:	48474948 	stmdami	r7, {r3, r6, r8, fp, lr}^
    1340:	524f4e5f 	subpl	r4, pc, #1520	; 0x5f0

}

void setupPhoenix() {

	g_fShowDebugPrompt = true;
    1344:	7453004d 	ldrbvc	r0, [r3], #-77
void readSensors(){


}

void setupPhoenix() {
    1348:	49737065 	ldmdbmi	r3!, {r0, r2, r5, r6, ip, sp, lr}^

	g_fShowDebugPrompt = true;
	g_fDebugOutput = false;
    134c:	6961476e 	stmdbvs	r1!, {r1, r2, r3, r5, r6, r8, r9, sl, lr}^
    1350:	5f670074 	svcpl	0x00670074
	//init BioloidEx
	BioloidControllerEx();
    1354:	67654c77 	undefined

	// Init our ServoDriver
	Servo_Init();
    1358:	4c5a5873 	mrrcmi	8, 7, r5, sl, cr3

	mDelay(10);
    135c:	74676e65 	strbtvc	r6, [r7], #-3685

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1360:	69530068 	ldmdbvs	r3, {r3, r5, r6}^
    1364:	656c676e 	strbvs	r6, [ip, #-1902]!
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    1368:	4367654c 	cmnmi	r7, #318767104	; 0x13000000
    136c:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1370:	47006c6f 	strmi	r6, [r0, -pc, ror #24]

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1374:	69537465 	ldmdbvs	r3, {r0, r2, r5, r6, sl, ip, sp, lr}^
    1378:	736f436e 	cmnvc	pc, #-1207959551	; 0xb8000001
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    137c:	67694200 	strbvs	r4, [r9, -r0, lsl #4]!
    1380:	69616d5f 	stmdbvs	r1!, {r0, r1, r2, r3, r4, r6, r8, sl, fp, sp, lr}^
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1384:	7443006e 	strbvc	r0, [r3], #-110
    1388:	6f4d6c72 	svcvs	0x004d6c72
    138c:	6e496576 	mcrvs	5, 2, r6, cr9, cr6, {3}
	Servo_Init();

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1390:	4c730070 	ldclmi	0, cr0, [r3], #-448
    1394:	6e496765 	cdpvs	7, 4, cr6, cr9, cr5, {3}
    1398:	6e417469 	cdpvs	4, 4, cr7, cr1, cr9, {3}

	ResetLegInitAngles();

	//Single leg control. Make sure no leg is selected
#ifdef OPT_SINGLELEG
	g_InControlState.SelectedLeg = 255; // No Leg selected
    139c:	41656c67 	cmnmi	r5, r7, ror #24
    13a0:	73756a64 	cmnvc	r5, #409600	; 0x64000
	g_InControlState.PrevSelectedLeg = 255;
    13a4:	74530074 	ldrbvc	r0, [r3], #-116
#endif
	//Body Positions
	g_InControlState.BodyPos.x = 0;
    13a8:	55747261 	ldrbpl	r7, [r4, #-609]!
	g_InControlState.BodyPos.y = 0;
	g_InControlState.BodyPos.z = 0;
    13ac:	74616470 	strbtvc	r6, [r1], #-1136

//Body Rotations
	g_InControlState.BodyRot1.x = 0;
	g_InControlState.BodyRot1.y = 0;
    13b0:	72655365 	rsbvc	r5, r5, #-1811939327	; 0x94000001
	g_InControlState.BodyRot1.z = 0;
	g_InControlState.BodyRotOffset.x = 0;
    13b4:	00736f76 	rsbseq	r6, r3, r6, ror pc
	g_InControlState.BodyRotOffset.y = 0; //Input Y offset value to adjust centerpoint of rotation
	g_InControlState.BodyRotOffset.z = 0;
    13b8:	41736f43 	cmnmi	r3, r3, asr #30

	//Gait
	g_InControlState.GaitType = 0;
    13bc:	61420034 	cmpvs	r2, r4, lsr r0
	g_InControlState.BalanceMode = 0;
    13c0:	636e616c 	cmnvs	lr, #27	; 0x1b
	g_InControlState.LegLiftHeight = 50;
	g_InControlState.ForceGaitStepCnt = 0; // added to try to adjust starting positions depending on height...
    13c4:	646f4265 	strbtvs	r4, [pc], #613	; 13cc <__Stack_Size+0xfcc>
	g_InControlState.GaitStep = 1;
    13c8:	65470079 	strbvs	r0, [r7, #-121]
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    13cc:	63724174 	cmnvs	r2, #29	; 0x1d
	g_InControlState.BodyRotOffset.z = 0;

	//Gait
	g_InControlState.GaitType = 0;
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
    13d0:	00736f43 	rsbseq	r6, r3, r3, asr #30
    13d4:	41665f67 	cmnmi	r6, r7, ror #30
void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    13d8:	65705358 	ldrbvs	r5, [r0, #-856]!
    13dc:	6f436465 	svcvs	0x00436465
    13e0:	6f72746e 	svcvs	0x0072746e
//==============================================================================

// If both PS2 and XBee are defined then we will become secondary to the xbee
void CommanderInputController_Init(void) {

	g_BodyYOffset = 0;
    13e4:	6572006c 	ldrbvs	r0, [r2, #-108]!
    13e8:	65536461 	ldrbvs	r6, [r3, #-1121]
    13ec:	726f736e 	rsbvc	r7, pc, #-1207959551	; 0xb8000001
	g_BodyYShift = 0;
	//begin(XBEE_BAUD);
	GPSeq = 0;  // init to something...
    13f0:	43770073 	cmnmi	r7, #115	; 0x73
    13f4:	5361786f 	cmnpl	r1, #7274496	; 0x6f0000

	ControlMode = WALKMODE;
    13f8:	70005644 	andvc	r5, r0, r4, asr #12
	HeightSpeedMode = NORM_NORM;
    13fc:	6563616c 	strbvs	r6, [r3, #-364]!
	//    DoubleHeightOn = false;
	DoubleTravelOn = false;
    1400:	695f6700 	ldmdbvs	pc, {r8, r9, sl, sp, lr}^
	bJoystickWalkMode = 0;
    1404:	4967654c 	stmdbmi	r7!, {r2, r3, r6, r8, sl, sp, lr}^
	GaitSelect();

	CommanderInputController_Init();

	// Servo Driver
	ServoMoveTime = 150;
    1408:	4974696e 	ldmdbmi	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
	g_InControlState.fRobotOn = 0;
    140c:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
	g_fLowVoltageShutdown = false;
    1410:	65466300 	strbvs	r6, [r6, #-768]

}
    1414:	4972756d 	ldmdbmi	r2!, {r0, r2, r3, r5, r6, r8, sl, ip, sp, lr}^
    1418:	4300766e 	movwmi	r7, #1646	; 0x66e
    141c:	616d6d6f 	cmnvs	sp, pc, ror #26
    1420:	7265646e 	rsbvc	r6, r5, #1845493760	; 0x6e000000
    1424:	6765625f 	undefined
    1428:	54006e69 	strpl	r6, [r0], #-3689
    142c:	6c61746f 	cfstrdvs	mvd7, [r1], #-444
    1430:	6c614258 	sfmvs	f4, 2, [r1], #-352
    1434:	6f430031 	svcvs	0x00430031
    1438:	00344273 	eorseq	r4, r4, r3, ror r2
    143c:	534c4146 	movtpl	r4, #49478	; 0xc146
    1440:	43630045 	cmnmi	r3, #69	; 0x45
    1444:	4c61786f 	stclmi	8, cr7, [r1], #-444
    1448:	74676e65 	strbtvc	r6, [r7], #-3685
    144c:	50660068 	rsbpl	r0, r6, r8, rrx
    1450:	5f766572 	svcpl	0x00766572
    1454:	6f626f52 	svcvs	0x00626f52
    1458:	006e4f74 	rsbeq	r4, lr, r4, ror pc
    145c:	6c727443 	cfldrdvs	mvd7, [r2], #-268
    1460:	69766944 	ldmdbvs	r6!, {r2, r6, r8, fp, sp, lr}^
    1464:	00726564 	rsbseq	r6, r2, r4, ror #10
//[CommitServoDriver Updates the positions of the servos - This outputs
//         as much of the command as we can without committing it.  This
//         allows us to once the previous update was completed to quickly
//        get the next command to start
//--------------------------------------------------------------------
void CommitServoDriver(word wMoveTime) {
    1468:	6f425f67 	svcvs	0x00425f67
    146c:	53597964 	cmppl	r9, #1638400	; 0x190000
    1470:	74666968 	strbtvc	r6, [r6], #-2408


	CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1474:	534e4900 	movtpl	r4, #59648	; 0xe900

      }
      ax12write(0xff - (checksum % 256));
      setRX(0);
*/
  	    dxl_set_txpacket_id (BROADCAST_ID);
    1478:	52575f54 	subspl	r5, r7, #336	; 0x150
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    147c:	5f455449 	svcpl	0x00455449
    1480:	41544144 	cmpmi	r4, r4, asr #2
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
    1484:	65686300 	strbvs	r6, [r8, #-768]!
    1488:	75736b63 	ldrbvc	r6, [r3, #-2915]!
		dxl_set_txpacket_parameter(1, 2);
    148c:	4677006d 	ldrbtmi	r0, [r7], -sp, rrx
    1490:	72756d65 	rsbsvc	r6, r5, #6464	; 0x1940
    1494:	00564453 	subseq	r4, r6, r3, asr r4
    1498:	65657246 	strbvs	r7, [r5, #-582]!
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
			wSpeed = CalculateAX12MoveSpeed(g_awCurAXPos[i], g_awGoalAXPos[i], wMoveTime);    // What order should we store these values?
    149c:	76726553 	undefined
    14a0:	6700736f 	strvs	r7, [r0, -pc, ror #6]
    14a4:	614c775f 	cmpvs	ip, pc, asr r7
    14a8:	6f567473 	svcvs	0x00567473
			//dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
			byte id = pgm_read_byte(&cPinTable[i]);
			dxl_set_txpacket_parameter(2 + 3 * i, id);
    14ac:	6761746c 	strbvs	r7, [r1, -ip, ror #8]!
    14b0:	4e490065 	cdpmi	0, 4, cr0, cr9, cr5, {3}
    14b4:	4c5f5453 	cfldrdmi	mvd5, [pc], {83}
    14b8:	4d5f5455 	cfldrdmi	mvd5, [pc, #-340]
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(g_awGoalAXPos[i]));
    14bc:	47414e41 	strbmi	r4, [r1, -r1, asr #28]
    14c0:	54770045 	ldrbtpl	r0, [r7], #-69
    14c4:	00656d69 	rsbeq	r6, r5, r9, ror #26
    14c8:	2f505041 	svccs	0x00505041
    14cc:	2f637273 	svccs	0x00637273
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
    14d0:	5f676942 	svcpl	0x00676942
    14d4:	6e69616d 	powvsez	f6, f1, #5.0
    14d8:	6c00632e 	stcvs	3, cr6, [r0], {46}
    14dc:	656d6954 	strbvs	r6, [sp, #-2388]!
    14e0:	61745372 	cmnvs	r4, r2, ror r3
    14e4:	49007472 	stmdbmi	r0, {r1, r4, r5, r6, sl, ip, sp, lr}
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
    14e8:	54656c64 	strbtpl	r6, [r5], #-3172
    14ec:	00656d69 	rsbeq	r6, r5, r9, ror #26
    14f0:	62695473 	rsbvs	r5, r9, #1929379840	; 0x73000000
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
    14f4:	6e416169 	dvfvssz	f6, f1, #1.0
    14f8:	31656c67 	cmncc	r5, r7, ror #24
    14fc:	464b4900 	strbmi	r4, [fp], -r0, lsl #18
    1500:	50746565 	rsbspl	r6, r4, r5, ror #10
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
		dxl_set_txpacket_parameter(1, 2);
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
    1504:	0058736f 	subseq	r7, r8, pc, ror #6
    1508:	65464b49 	strbvs	r4, [r6, #-2889]
    150c:	6f507465 	svcvs	0x00507465
    1510:	49005973 	stmdbmi	r0, {r0, r1, r4, r5, r6, r8, fp, ip, lr}
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
		}

		dxl_set_txpacket_length((4 + 1) * poseSize + 4);
    1514:	6565464b 	strbvs	r4, [r5, #-1611]!
    1518:	736f5074 	cmnvc	pc, #116	; 0x74
    151c:	7865005a 	stmdavc	r5!, {r1, r3, r4, r6}^
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- CommitServoDriver ---\n");
#endif
		dxl_txrx_packet();
    1520:	65725074 	ldrbvs	r5, [r2, #-116]!

			u16 CommStatus = dxl_get_result();
    1524:	65640076 	strbvs	r0, [r4, #-118]!
#ifdef USING_PC_UART
			if (CommStatus == DXL_RXSUCCESS)
    1528:	0061746c 	rsbeq	r7, r1, ip, ror #8
				PrintErrorCode();
    152c:	4c746547 	cfldr64mi	mvdx6, [r4], #-284
			else
				PrintCommStatus(CommStatus);
    1530:	58736765 	ldmdapl	r3!, {r0, r2, r5, r6, r8, r9, sl, sp, lr}^
    1534:	6e654c5a 	mcrvs	12, 3, r4, cr5, cr10, {2}
#endif
#endif
		} else {
			BioloidControllerEx_interpolateSetup(wMoveTime);
    1538:	00687467 	rsbeq	r7, r8, r7, ror #8

	}

	CommanderInputController_AllowControllerInterrupts(true);

}
    153c:	524f4f43 	subpl	r4, pc, #268	; 0x10c
    1540:	00443344 	subeq	r3, r4, r4, asr #6
    1544:	74636166 	strbtvc	r6, [r3], #-358
    1548:	4900726f 	stmdbmi	r0, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}
    154c:	5f54534e 	svcpl	0x0054534e
    1550:	465f5257 	undefined
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    1554:	48544c49 	ldmdami	r4, {r0, r3, r6, sl, fp, lr}^
    1558:	52660052 	rsbpl	r0, r6, #82	; 0x52
    155c:	746f626f 	strbtvc	r6, [pc], #623	; 1564 <__Stack_Size+0x1164>
    1560:	4c006e4f 	stcmi	14, cr6, [r0], {79}
    1564:	44746669 	ldrbtmi	r6, [r4], #-1641


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1568:	61467669 	cmpvs	r6, r9, ror #12
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    156c:	726f7463 	rsbvc	r7, pc, #1660944384	; 0x63000000
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1570:	6b614d00 	blvs	1854978 <__Stack_Size+0x1854578>
    1574:	72755365 	rsbsvc	r5, r5, #-1811939327	; 0x94000001
    1578:	72655365 	rsbvc	r5, r5, #-1811939327	; 0x94000001
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    157c:	41736f76 	cmnmi	r3, r6, ror pc
    1580:	6e4f6572 	mcrvs	5, 2, r6, cr15, cr2, {3}
    1584:	68595800 	ldmdavs	r9, {fp, ip, lr}^


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1588:	00327079 	eorseq	r7, r2, r9, ror r0
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    158c:	61746f54 	cmnvs	r4, r4, asr pc
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1590:	6172546c 	cmnvs	r2, ip, ror #8
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1594:	0058736e 	subseq	r7, r8, lr, ror #6
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    1598:	61746f54 	cmnvs	r4, r4, asr pc

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
    159c:	6172546c 	cmnvs	r2, ip, ror #8
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    15a0:	0059736e 	subseq	r7, r9, lr, ror #6
			g_awGoalAXPos[FIRSTTIBIAPIN + LegIndex] = wTibiaSDV;
    15a4:	61746f54 	cmnvs	r4, r4, asr pc
    15a8:	6172546c 	cmnvs	r2, ip, ror #8
    15ac:	005a736e 	subseq	r7, sl, lr, ror #6

#endif
		} else {
			BioloidControllerEx_setNextPose(
    15b0:	57534b49 	ldrbpl	r4, [r3, -r9, asr #22]
    15b4:	5f670032 	svcpl	0x00670032
					pgm_read_byte(&cPinTable[FIRSTCOXAPIN + LegIndex]),
					wCoxaSDV);
			BioloidControllerEx_setNextPose(
    15b8:	65486261 	strbvs	r6, [r8, #-609]
    15bc:	746e4978 	strbtvc	r4, [lr], #-2424
    15c0:	41005a58 	tstmi	r0, r8, asr sl
					pgm_read_byte(&cPinTable[FIRSTFEMURPIN + LegIndex]),
					wFemurSDV);
			BioloidControllerEx_setNextPose(
    15c4:	73756a64 	cmnvc	r5, #409600	; 0x64000
    15c8:	67654c74 	undefined
					wTibiaSDV);

		}
	}
	CommanderInputController_AllowControllerInterrupts(true); // Ok for hserial again...
}
    15cc:	69736f50 	ldmdbvs	r3!, {r4, r6, r8, r9, sl, fp, sp, lr}^
    15d0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    15d4:	426f5473 	rsbmi	r5, pc, #1929379840	; 0x73000000
    15d8:	4879646f 	ldmdami	r9!, {r0, r1, r2, r3, r5, r6, sl, sp, lr}^
    15dc:	68676965 	stmdavs	r7!, {r0, r2, r5, r6, r8, fp, sp, lr}^

void StartUpdateServos() {
    15e0:	5f670074 	svcpl	0x00670074
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update
    15e4:	6f436e49 	svcvs	0x00436e49
    15e8:	6f72746e 	svcvs	0x0072746e
    15ec:	6174536c 	cmnvs	r4, ip, ror #6

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		OutputServoInfoForLeg(LegIndex,
    15f0:	43006574 	movwmi	r6, #1396	; 0x574
    15f4:	696d6d6f 	stmdbvs	sp!, {r0, r1, r2, r3, r5, r6, r8, sl, fp, sp, lr}^
    15f8:	72655374 	rsbvc	r5, r5, #-805306367	; 0xd0000001
    15fc:	72446f76 	subvc	r6, r4, #472	; 0x1d8
    1600:	72657669 	rsbvc	r7, r5, #110100480	; 0x6900000
    1604:	6f477700 	svcvs	0x00477700
    1608:	6f506c61 	svcvs	0x00506c61
    160c:	754f0073 	strbvc	r0, [pc, #-115]	; 15a1 <__Stack_Size+0x11a1>
    1610:	74757074 	ldrbtvc	r7, [r5], #-116
    1614:	76726553 	undefined
    1618:	666e496f 	strbtvs	r4, [lr], -pc, ror #18
    161c:	726f466f 	rsbvc	r4, pc, #116391936	; 0x6f00000
    1620:	0067654c 	rsbeq	r6, r7, ip, asr #10
    1624:	54534e49 	ldrbpl	r4, [r3], #-3657
    1628:	5041435f 	subpl	r4, r1, pc, asr r3
    162c:	4745525f 	smlsldmi	r5, r5, pc, r2
    1630:	004e4f49 	subeq	r4, lr, r9, asr #30
    1634:	76726553 	undefined
    1638:	6e495f6f 	cdpvs	15, 4, cr5, cr9, cr15, {3}
    163c:	77007469 	strvc	r7, [r0, -r9, ror #8]
    1640:	746c6f56 	strbtvc	r6, [ip], #-3926
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1644:	00656761 	rsbeq	r6, r5, r1, ror #14
				cTibiaInv[LegIndex] ?
						-TibiaAngle1[LegIndex] : TibiaAngle1[LegIndex]);

	}

}
    1648:	6c6c4166 	stfvse	f4, [ip], #-408
    164c:	7300776f 	movwvc	r7, #1903	; 0x76f
    1650:	70757465 	rsbsvc	r7, r5, r5, ror #8
    1654:	656f6850 	strbvs	r6, [pc, #-2128]!	; e0c <__Stack_Size+0xa0c>
    1658:	0078696e 	rsbseq	r6, r8, lr, ror #18
    165c:	4c67654c 	cfstr64mi	mvdx6, [r7], #-304
    1660:	48746669 	ldmdami	r4!, {r0, r3, r5, r6, r9, sl, sp, lr}^
#else
word g_wLastVoltage = 0xffff;    // save the last voltage we retrieved...
byte g_bLegVoltage = 0;		// what leg did we last check?
unsigned long g_ulTimeLastBatteryVoltage;
#define VOLTAGE_REPEAT_MAX  3
word GetBatteryVoltage(void) {
    1664:	68676965 	stmdavs	r7!, {r0, r2, r5, r6, r8, fp, sp, lr}^
	if (interpolating && (g_wLastVoltage != 0xffff)
    1668:	61470074 	cmpvs	r7, r4, ror r0
    166c:	65537469 	ldrbvs	r7, [r3, #-1129]
    1670:	4c530071 	mrrcmi	0, 7, r0, r3, cr1
    1674:	0067654c 	rsbeq	r6, r7, ip, asr #10
    1678:	54534e49 	ldrbpl	r4, [r3], #-3657
    167c:	4e59535f 	mrcmi	3, 2, r5, cr9, cr15, {2}
    1680:	52575f43 	subspl	r5, r7, #268	; 0x10c
    1684:	00455449 	subeq	r5, r5, r9, asr #8
			&& ((getMillis() - g_ulTimeLastBatteryVoltage)
					< VOLTAGE_MAX_TIME_BETWEEN_CALLS))
		return g_wLastVoltage;
    1688:	6d6d6f43 	stclvs	15, cr6, [sp, #-268]!

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
    168c:	65646e61 	strbvs	r6, [r4, #-3681]!
    1690:	706e4972 	rsbvc	r4, lr, r2, ror r9
    1694:	6f437475 	svcvs	0x00437475
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    1698:	6f72746e 	svcvs	0x0072746e
			g_wLastVoltage = wVoltage * 10;
    169c:	72656c6c 	rsbvc	r6, r5, #27648	; 0x6c00

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    16a0:	6e6f435f 	mcrvs	3, 3, r4, cr15, cr15, {2}
			g_wLastVoltage = wVoltage * 10;
    16a4:	6c6f7274 	sfmvs	f7, 2, [pc], #-464
		}
	} while (--bLoopCnt);

	return 0;

}
    16a8:	75706e49 	ldrbvc	r6, [r0, #-3657]!
    16ac:	6f430074 	svcvs	0x00430074
    16b0:	00344773 	eorseq	r4, r4, r3, ror r7
    16b4:	63726f46 	cmnvs	r2, #280	; 0x118
// ReadMsgs
//==============================================================================

/* process messages coming from Commander
 *  format = 0xFF RIGHT_H RIGHT_V LEFT_H LEFT_V BUTTONS EXT CHECKSUM */
int Commander_ReadMsgs() {
    16b8:	69614765 	stmdbvs	r1!, {r0, r2, r5, r6, r8, r9, sl, lr}^
	 }
	 #endif
	 */
	//while (CheckZBNewArrive() > 0) {
	while (1) {
		if (zgb_rx_check_arduino() == 1) {
    16bc:	65745374 	ldrbvs	r5, [r4, #-884]!
    16c0:	746e4370 	strbtvc	r4, [lr], #-880

			leftV = (signed char) (zgb_rx_data_right_V_());
    16c4:	64416600 	strbvs	r6, [r1], #-1536
    16c8:	7473756a 	ldrbtvc	r7, [r3], #-1386
			leftH = (signed char) (zgb_rx_data_right_H_());
    16cc:	5067654c 	rsbpl	r6, r7, ip, asr #10
    16d0:	7469736f 	strbtvc	r7, [r9], #-879
			rightV = (signed char) (zgb_rx_data_left_V_());
    16d4:	736e6f69 	cmnvc	lr, #420	; 0x1a4
    16d8:	6f6d5300 	svcvs	0x006d5300
			rightH = (signed char) (zgb_rx_data_left_H_());
    16dc:	4368746f 	cmnmi	r8, #1862270976	; 0x6f000000
    16e0:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
			buttons = zgb_rx_data_buttons();
    16e4:	57006c6f 	strpl	r6, [r0, -pc, ror #24]
    16e8:	4d4b4c41 	stclmi	12, cr4, [fp, #-260]
			ext = zgb_rx_data_extra();
    16ec:	0045444f 	subeq	r4, r5, pc, asr #8
    16f0:	54534e49 	ldrbpl	r4, [r3], #-3657

	}

	return 0;

}
    16f4:	4c55425f 	lfmmi	f4, 2, [r5], {95}
    16f8:	45525f4b 	ldrbmi	r5, [r2, #-3915]
    16fc:	6c004441 	cfstrsvs	mvf4, [r0], {65}
    1700:	656d6954 	strbvs	r6, [sp, #-2388]!
    1704:	74696157 	strbtvc	r6, [r9], #-343
    1708:	00646e45 	rsbeq	r6, r4, r5, asr #28
    170c:	74696147 	strbtvc	r6, [r9], #-327
    1710:	656c6553 	strbvs	r6, [ip, #-1363]!

//==============================================================================
// This is The main code to input function to read inputs from the Commander and then
//process any commands.
//==============================================================================
void CommanderInputController_ControlInput(void) {
    1714:	42007463 	andmi	r7, r0, #1660944384	; 0x63000000

	// See if we have a new command available...
	if (Commander_ReadMsgs() > 0) {
    1718:	654c6c61 	strbvs	r6, [ip, #-3169]
    171c:	00724e67 	rsbseq	r4, r2, r7, ror #28
    1720:	786f4363 	stmdavc	pc!, {r0, r1, r5, r6, r8, r9, lr}^
    1724:	78614d61 	stmdavc	r1!, {r0, r5, r6, r8, sl, fp, lr}^
		// If we receive a valid message than turn robot on...
		boolean fAdjustLegPositions = false;
		short sLegInitXZAdjust = 0;
		short sLegInitAngleAdjust = 0;

		if (!g_InControlState.fRobotOn) {
    1728:	4e490031 	mcrmi	0, 2, r0, cr9, cr1, {1}
    172c:	535f5453 	cmppl	pc, #1392508928	; 0x53000000
			g_InControlState.fRobotOn = true;
    1730:	45545359 	ldrbmi	r5, [r4, #-857]
    1734:	45525f4d 	ldrbmi	r5, [r2, #-3917]
		}

		// [SWITCH MODES]

		// Cycle through modes...
		if ((buttons & BUT_LT) && !(buttonsPrev & BUT_LT)) {
    1738:	47004441 	strmi	r4, [r0, -r1, asr #8]
    173c:	4c746961 	ldclmi	9, cr6, [r4], #-388
    1740:	724e6765 	subvc	r6, lr, #26476544	; 0x1940000
    1744:	55525400 	ldrbpl	r5, [r2, #-1024]
    1748:	4e490045 	cdpmi	0, 4, cr0, cr9, cr5, {2}
    174c:	525f5453 	subspl	r5, pc, #1392508928	; 0x53000000

			if (++ControlMode >= MODECNT) {
    1750:	45525f44 	ldrbmi	r5, [r2, #-3908]
    1754:	52485447 	subpl	r5, r8, #1191182336	; 0x47000000
    1758:	746e6900 	strbtvc	r6, [lr], #-2304
    175c:	6f707265 	svcvs	0x00707265
				ControlMode = WALKMODE;    // cycled back around...
				Buzzed(50, 2000);
    1760:	6974616c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sp, lr}^
    1764:	6900676e 	stmdbvs	r0, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
    1768:	746c6544 	strbtvc	r6, [ip], #-1348
				Buzzed(50, 3000);
    176c:	676e4161 	strbvs	r4, [lr, -r1, ror #2]!
    1770:	6700656c 	strvs	r6, [r0, -ip, ror #10]

			} else {
				Buzzed(50, 2000);
    1774:	6853665f 	ldmdavs	r3, {r0, r1, r2, r3, r4, r6, r9, sl, sp, lr}^
    1778:	6544776f 	strbvs	r7, [r4, #-1903]
    177c:	50677562 	rsbpl	r7, r7, r2, ror #10
			}
			if (ControlMode != SINGLELEGMODE)
    1780:	706d6f72 	rsbvc	r6, sp, r2, ror pc
    1784:	4e490074 	mcrmi	0, 2, r0, cr9, cr4, {3}
				g_InControlState.SelectedLeg = 255;
    1788:	535f5453 	cmppl	pc, #1392508928	; 0x53000000
    178c:	45545359 	ldrbmi	r5, [r4, #-857]
    1790:	52575f4d 	subspl	r5, r7, #308	; 0x134

		}

		//[Common functions]
		//Switch Balance mode on/off
		if ((buttons & BUT_L4) && !(buttonsPrev & BUT_L4)) {
    1794:	00455449 	subeq	r5, r5, r9, asr #8
    1798:	6d6d6f43 	stclvs	15, cr6, [sp, #-268]!
    179c:	65646e61 	strbvs	r6, [r4, #-3681]!
    17a0:	72755472 	rsbsvc	r5, r5, #1912602624	; 0x72000000
    17a4:	626f526e 	rsbvs	r5, pc, #-536870906	; 0xe0000006
    17a8:	664f746f 	strbvs	r7, [pc], -pc, ror #8

			g_InControlState.BalanceMode = !g_InControlState.BalanceMode;
    17ac:	53660066 	cmnpl	r6, #102	; 0x66
    17b0:	6c6f484c 	stclvs	8, cr4, [pc], #-304
    17b4:	4b490064 	blmi	124194c <__Stack_Size+0x124154c>
    17b8:	00343141 	eorseq	r3, r4, r1, asr #2
    17bc:	72717369 	rsbsvc	r7, r1, #-1543503871	; 0xa4000001
			if (g_InControlState.BalanceMode) {
    17c0:	00323374 	eorseq	r3, r2, r4, ror r3
				Buzzed(250, 1500);
    17c4:	65736f70 	ldrbvs	r6, [r3, #-3952]!
    17c8:	657a6953 	ldrbvs	r6, [sl, #-2387]!
			} else {
				Buzzed(100, 2000);
    17cc:	65684300 	strbvs	r4, [r8, #-768]!
    17d0:	65536b63 	ldrbvs	r6, [r3, #-2915]
				Buzzed(50, 4000);
    17d4:	416f7672 	smcmi	63330
    17d8:	656c676e 	strbvs	r6, [ip, #-1902]!
    17dc:	6e756f42 	cdpvs	15, 7, cr6, cr5, cr2, {2}
			}
		}

		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
    17e0:	49007364 	stmdbmi	r0, {r2, r5, r6, r8, r9, ip, sp, lr}
    17e4:	6565464b 	strbvs	r4, [r5, #-1611]!
    17e8:	736f5074 	cmnvc	pc, #116	; 0x74
    17ec:	77005a58 	smlsdvc	r0, r8, sl, r5
    17f0:	65766f4d 	ldrbvs	r6, [r6, #-3917]!
    17f4:	656d6954 	strbvs	r6, [sp, #-2388]!
			if (g_BodyYOffset > 0)
    17f8:	65725000 	ldrbvs	r5, [r2]!
    17fc:	6c655376 	stclvs	3, cr5, [r5], #-472
				g_BodyYOffset = 0;
    1800:	65746365 	ldrbvs	r6, [r4, #-869]!
    1804:	67654c64 	strbvs	r4, [r5, -r4, ror #24]!
			else
				g_BodyYOffset = 35;
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1808:	69546300 	ldmdbvs	r4, {r8, r9, sp, lr}^
		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
			if (g_BodyYOffset > 0)
				g_BodyYOffset = 0;
			else
				g_BodyYOffset = 35;
    180c:	49616962 	stmdbmi	r1!, {r1, r5, r6, r8, fp, sp, lr}^
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1810:	7700766e 	strvc	r7, [r0, -lr, ror #12]
    1814:	76617254 	undefined

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1818:	49006c65 	stmdbmi	r0, {r0, r2, r5, r6, sl, fp, sp, lr}
		int ly = leftV;
		if (buttons & BUT_L6) {
    181c:	3432414b 	ldrtcc	r4, [r2], #-331

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1820:	4d554e00 	ldclmi	14, cr4, [r5]
    1824:	4941475f 	stmdbmi	r1, {r0, r1, r2, r3, r4, r6, r8, r9, sl, lr}^
		int ly = leftV;
    1828:	63005354 	movwvs	r5, #852	; 0x354
    182c:	546e6950 	strbtpl	r6, [lr], #-2384
		if (buttons & BUT_L6) {
    1830:	656c6261 	strbvs	r6, [ip, #-609]!
    1834:	41525400 	cmpmi	r2, r0, lsl #8
			// raise or lower the robot on the joystick up /down
			// Maybe should have Min/Max
			int delta = rightV / 25;
    1838:	414c534e 	cmpmi	ip, lr, asr #6
    183c:	4f4d4554 	svcmi	0x004d4554
    1840:	63004544 	movwvs	r4, #1348	; 0x544
    1844:	69626954 	stmdbvs	r2!, {r2, r4, r6, r8, fp, sp, lr}^
    1848:	78614d61 	stmdavc	r1!, {r0, r5, r6, r8, sl, fp, lr}^
    184c:	54770031 	ldrbtpl	r0, [r7], #-49
			if (delta) {
    1850:	61696269 	cmnvs	r9, r9, ror #4
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
    1854:	00564453 	subseq	r4, r6, r3, asr r4
    1858:	44665f67 	strbtmi	r5, [r6], #-3943
    185c:	6d616e79 	stclvs	14, cr6, [r1, #-484]!
    1860:	654c6369 	strbvs	r6, [ip, #-873]
    1864:	4c5a5867 	mrrcmi	8, 6, r5, sl, cr7
    1868:	74676e65 	strbtvc	r6, [r7], #-3685
    186c:	54630068 	strbtpl	r0, [r3], #-104
    1870:	61696269 	cmnvs	r9, r9, ror #4
    1874:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
			sLegInitAngleAdjust = ly / 8;
			lx = 0;
			ly = 0;

			// Likewise for Speed control
			delta = rightH / 16;   //
    1878:	67006874 	smlsdxvs	r0, r4, r8, r6
    187c:	4862615f 	stmdami	r2!, {r0, r1, r2, r3, r4, r6, r8, sp, lr}^
    1880:	614d7865 	cmpvs	sp, r5, ror #16
    1884:	646f4278 	strbtvs	r4, [pc], #632	; 188c <__Stack_Size+0x148c>
    1888:	43005979 	movwmi	r5, #2425	; 0x979
			if ((delta < 0) && g_InControlState.SpeedControl) {
    188c:	656c6379 	strbvs	r6, [ip, #-889]!
    1890:	656d6954 	strbvs	r6, [sp, #-2388]!
    1894:	4e495300 	cdpmi	3, 4, cr5, cr9, cr0, {0}
				if ((word)(-delta) < g_InControlState.SpeedControl)
    1898:	4c454c47 	mcrrmi	12, 4, r4, r5, cr7
					g_InControlState.SpeedControl += delta;
    189c:	4f4d4745 	svcmi	0x004d4745
				else
					g_InControlState.SpeedControl = 0;
    18a0:	73004544 	movwvc	r4, #1348	; 0x544
    18a4:	4967654c 	stmdbmi	r7!, {r2, r3, r6, r8, sl, sp, lr}^

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
    18a8:	5874696e 	ldmdapl	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    18ac:	6a64415a 	bvs	1911e1c <__Stack_Size+0x1911a1c>
    18b0:	00747375 	rsbseq	r7, r4, r5, ror r3
				g_InControlState.SpeedControl += delta;
				if (g_InControlState.SpeedControl > 2000)
    18b4:	4c625f73 	stclmi	15, cr5, [r2], #-460
					g_InControlState.SpeedControl = 0;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
				g_InControlState.SpeedControl += delta;
    18b8:	65654256 	strbvs	r4, [r5, #-598]!
				if (g_InControlState.SpeedControl > 2000)
					g_InControlState.SpeedControl = 2000;
    18bc:	746e4370 	strbtvc	r4, [lr], #-880
    18c0:	615f6700 	cmpvs	pc, r0, lsl #14

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
    18c4:	616f4777 	smcvs	62583
    18c8:	5058416c 	subspl	r4, r8, ip, ror #2
    18cc:	7300736f 	movwvc	r7, #879	; 0x36f
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18d0:	756d6546 	strbvc	r6, [sp, #-1350]!
    18d4:	676e4172 	undefined
    18d8:	0031656c 	eorseq	r6, r1, ip, ror #10
    18dc:	616d6572 	smcvs	54866
			sLegInitAngleAdjust = ly / 8;
    18e0:	65646e69 	strbvs	r6, [r4, #-3689]!
    18e4:	6f420072 	svcvs	0x00420072
    18e8:	4b467964 	blmi	119fe80 <__Stack_Size+0x119fa80>
    18ec:	58736f50 	ldmdapl	r3!, {r4, r6, r8, r9, sl, fp, sp, lr}^
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f0:	646f4200 	strbtvs	r4, [pc], #512	; 18f8 <__Stack_Size+0x14f8>
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18f4:	504b4679 	subpl	r4, fp, r9, ror r6
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f8:	0059736f 	subseq	r7, r9, pc, ror #6
		}

		//[Walk functions]
		if (ControlMode == WALKMODE) {
    18fc:	79646f42 	stmdbvc	r4!, {r1, r6, r8, r9, sl, fp, sp, lr}^
    1900:	6f504b46 	svcvs	0x00504b46
    1904:	42005a73 	andmi	r5, r0, #471040	; 0x73000

			//Switch gates
			if (((buttons & BUT_R1) && !(buttonsPrev & BUT_R1))
    1908:	6f6c6f69 	svcvs	0x006c6f69
    190c:	6f436469 	svcvs	0x00436469
    1910:	6f72746e 	svcvs	0x0072746e
    1914:	72656c6c 	rsbvc	r6, r5, #27648	; 0x6c00
    1918:	735f7845 	cmpvc	pc, #4521984	; 0x450000
    191c:	654e7465 	strbvs	r7, [lr, #-1125]
    1920:	6f507478 	svcvs	0x00507478
    1924:	79426573 	stmdbvc	r2, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
    1928:	65646e49 	strbvs	r6, [r4, #-3657]!
    192c:	72660078 	rsbvc	r0, r6, #120	; 0x78
    1930:	4c656d61 	stclmi	13, cr6, [r5], #-388
    1934:	74676e65 	strbtvc	r6, [r7], #-3685
    1938:	72740068 	rsbsvc	r0, r4, #104	; 0x68
    193c:	69736e61 	ldmdbvs	r3!, {r0, r5, r6, r9, sl, fp, sp, lr}^
    1940:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    1944:	69640073 	stmdbvs	r4!, {r0, r1, r4, r5, r6}^
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1948:	66006666 	strvs	r6, [r0], -r6, ror #12
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    194c:	74696157 	strbtvc	r6, [r9], #-343
    1950:	6f694200 	svcvs	0x00694200
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1954:	64696f6c 	strbtvs	r6, [r9], #-3948
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    1958:	746e6f43 	strbtvc	r6, [lr], #-3907
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
					Buzzed(50, 2000);
    195c:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
    1960:	78457265 	stmdavc	r5, {r0, r2, r5, r6, r9, ip, sp, lr}^
    1964:	7465735f 	strbtvc	r7, [r5], #-863
				} else {
					Buzzed(50, 2000);
    1968:	42006449 	andmi	r6, r0, #1224736768	; 0x49000000
    196c:	6f6c6f69 	svcvs	0x006c6f69
    1970:	6f436469 	svcvs	0x00436469
					Buzzed(50, 2250);
    1974:	6f72746e 	svcvs	0x0072746e
    1978:	72656c6c 	rsbvc	r6, r5, #27648	; 0x6c00
					g_InControlState.GaitType = 0;
    197c:	675f7845 	ldrbvs	r7, [pc, -r5, asr #16]
    1980:	75437465 	strbvc	r7, [r3, #-1125]
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    1984:	736f5072 	cmnvc	pc, #114	; 0x72
    1988:	69420065 	stmdbvs	r2, {r0, r2, r5, r6}^
    198c:	696f6c6f 	stmdbvs	pc!, {r0, r1, r2, r3, r5, r6, sl, fp, sp, lr}^

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    1990:	65535f64 	ldrbvs	r5, [r3, #-3940]
    1994:	00707574 	rsbseq	r7, r0, r4, ror r5
    1998:	706d6574 	rsbvc	r6, sp, r4, ror r5
    199c:	6f694200 	svcvs	0x00694200
    19a0:	64696f6c 	strbtvs	r6, [r9], #-3948
				}
				GaitSelect();
			}

			//Double leg lift height
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    19a4:	746e6f43 	strbtvc	r6, [lr], #-3907
    19a8:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
    19ac:	78457265 	stmdavc	r5, {r0, r2, r5, r6, r9, ip, sp, lr}^
    19b0:	7465675f 	strbtvc	r6, [r5], #-1887
    19b4:	7478654e 	ldrbtvc	r6, [r8], #-1358
				Buzzed(50, 2000);
    19b8:	65736f50 	ldrbvs	r6, [r3, #-3920]!
    19bc:	61727400 	cmnvs	r2, r0, lsl #8
				HeightSpeedMode = (HeightSpeedMode + 1) & 0x3; // wrap around mode
    19c0:	7469736e 	strbtvc	r7, [r9], #-878
    19c4:	5f6e6f69 	svcpl	0x006e6f69
    19c8:	70730074 	rsbsvc	r0, r3, r4, ror r0
    19cc:	5f646565 	svcpl	0x00646565
				DoubleTravelOn = HeightSpeedMode & 0x1;
    19d0:	6f694200 	svcvs	0x00694200
    19d4:	64696f6c 	strbtvs	r6, [r9], #-3948
				if (HeightSpeedMode & 0x2)
    19d8:	746e6f43 	strbtvc	r6, [lr], #-3907
    19dc:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
					g_InControlState.LegLiftHeight = 80;
    19e0:	78457265 	stmdavc	r5, {r0, r2, r5, r6, r9, ip, sp, lr}^
    19e4:	6972775f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
				else
					g_InControlState.LegLiftHeight = 50;
			}

			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {
    19e8:	6f506574 	svcvs	0x00506574
    19ec:	41006573 	tstmi	r0, r3, ror r5
    19f0:	732f5050 	teqvc	pc, #80	; 0x50
    19f4:	422f6372 	eormi	r6, pc, #-939524095	; 0xc8000001
    19f8:	6f6c6f69 	svcvs	0x006c6f69

				if ((++bJoystickWalkMode) > 1)
    19fc:	78456469 	stmdavc	r5, {r0, r3, r5, r6, sl, sp, lr}^
    1a00:	4200632e 	andmi	r6, r0, #-1207959552	; 0xb8000000
    1a04:	6f6c6f69 	svcvs	0x006c6f69

					bJoystickWalkMode = 0;
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a08:	6f436469 	svcvs	0x00436469
			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {

				if ((++bJoystickWalkMode) > 1)

					bJoystickWalkMode = 0;
    1a0c:	6f72746e 	svcvs	0x0072746e
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a10:	72656c6c 	rsbvc	r6, r5, #27648	; 0x6c00
    1a14:	6c5f7845 	mrrcvs	8, 4, r7, pc, cr5
    1a18:	5064616f 	rsbpl	r6, r4, pc, ror #2
    1a1c:	0065736f 	rsbeq	r7, r5, pc, ror #6
			}

			//Walking
			switch (bJoystickWalkMode) {
    1a20:	6c6f6942 	stclvs	9, cr6, [pc], #-264
    1a24:	4364696f 	cmnmi	r4, #1818624	; 0x1bc000
    1a28:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
			case 0:
				g_InControlState.TravelLength.x = -lx;
    1a2c:	656c6c6f 	strbvs	r6, [ip, #-3183]!
    1a30:	5f784572 	svcpl	0x00784572
    1a34:	4e746573 	mrcmi	5, 3, r6, cr4, cr3, {3}
				g_InControlState.TravelLength.z = -ly;
    1a38:	50747865 	rsbspl	r7, r4, r5, ror #16
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
				break;
			case 1:
				g_InControlState.TravelLength.z = (rightV); //Right Stick Up/Down
    1a3c:	0065736f 	rsbeq	r7, r5, pc, ror #6
    1a40:	75716573 	ldrbvc	r6, [r1, #-1395]!
    1a44:	65636e65 	strbvs	r6, [r3, #-3685]!
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
    1a48:	6f694200 	svcvs	0x00694200
    1a4c:	64696f6c 	strbtvs	r6, [r9], #-3948
    1a50:	746e6f43 	strbtvc	r6, [lr], #-3907
    1a54:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
    1a58:	78457265 	stmdavc	r5, {r0, r2, r5, r6, r9, ip, sp, lr}^
    1a5c:	6165725f 	cmnvs	r5, pc, asr r2
				break;

			}

			if (!DoubleTravelOn) {  //(Double travel length)
    1a60:	736f5064 	cmnvc	pc, #100	; 0x64
				g_InControlState.TravelLength.x =
    1a64:	656e0065 	strbvs	r0, [lr, #-101]!
    1a68:	6f707478 	svcvs	0x00707478
    1a6c:	005f6573 	subseq	r6, pc, r3, ror r5
						g_InControlState.TravelLength.x / 2;
				g_InControlState.TravelLength.z =
    1a70:	6c6f6942 	stclvs	9, cr6, [pc], #-264
    1a74:	4364696f 	cmnmi	r4, #1818624	; 0x1bc000
    1a78:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
			}

		}

		//[Translate functions]
		g_BodyYShift = 0;
    1a7c:	656c6c6f 	strbvs	r6, [ip, #-3183]!
    1a80:	5f784572 	svcpl	0x00784572
		if (ControlMode == TRANSLATEMODE) {
    1a84:	49746567 	ldmdbmi	r4!, {r0, r1, r2, r5, r6, r8, sl, sp, lr}^
    1a88:	6e690064 	cdpvs	0, 6, cr0, cr9, cr4, {3}

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
    1a8c:	00786564 	rsbseq	r6, r8, r4, ror #10
    1a90:	6c6f6942 	stclvs	9, cr6, [pc], #-264
    1a94:	4364696f 	cmnmi	r4, #1818624	; 0x1bc000
    1a98:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    1a9c:	656c6c6f 	strbvs	r6, [ip, #-3183]!
    1aa0:	5f784572 	svcpl	0x00784572
    1aa4:	65746e69 	ldrbvs	r6, [r4, #-3689]!
    1aa8:	6c6f7072 	stclvs	0, cr7, [pc], #-456
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1aac:	53657461 	cmnpl	r5, #1627389952	; 0x61000000
    1ab0:	70757465 	rsbsvc	r7, r5, r5, ror #8
    1ab4:	6e757200 	cdpvs	2, 7, cr7, cr5, cr0, {0}
    1ab8:	676e696e 	strbvs	r6, [lr, -lr, ror #18]!
    1abc:	00716553 	rsbseq	r6, r1, r3, asr r5
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac0:	7478656e 	ldrbtvc	r6, [r8], #-1390
		//[Translate functions]
		g_BodyYShift = 0;
		if (ControlMode == TRANSLATEMODE) {

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1ac4:	6d617266 	sfmvs	f7, 2, [r1, #-408]!
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac8:	73005f65 	movwvc	r5, #3941	; 0xf65
    1acc:	6f767265 	svcvs	0x00767265
    1ad0:	746e635f 	strbtvc	r6, [lr], #-863
    1ad4:	6f694200 	svcvs	0x00694200


			//      g_InControlState.BodyPos.x = (lx)/2;
			//      g_InControlState.BodyPos.z = -(ly)/3;
			//      g_InControlState.BodyRot1.y = (rightH)*2;
			g_BodyYShift = (-(rightV) / 2);
    1ad8:	64696f6c 	strbtvs	r6, [r9], #-3948
    1adc:	746e6f43 	strbtvc	r6, [lr], #-3907
    1ae0:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
    1ae4:	78457265 	stmdavc	r5, {r0, r2, r5, r6, r9, ip, sp, lr}^
    1ae8:	6f694200 	svcvs	0x00694200
    1aec:	64696f6c 	strbtvs	r6, [r9], #-3948
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
    1af0:	746e6f43 	strbtvc	r6, [lr], #-3907
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1af4:	6c6c6f72 	stclvs	15, cr6, [ip], #-456
    1af8:	78457265 	stmdavc	r5, {r0, r2, r5, r6, r9, ip, sp, lr}^
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1afc:	746e695f 	strbtvc	r6, [lr], #-2399
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1b00:	6f707265 	svcvs	0x00707265
			g_BodyYShift = (-(rightV) / 2);
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
    1b04:	6574616c 	ldrbvs	r6, [r4, #-364]!
			g_InControlState.BodyRot1.y = (rightH) * 2;
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1b08:	70657453 	rsbvc	r7, r5, r3, asr r4
    1b0c:	6d6f6300 	stclvs	3, cr6, [pc]
    1b10:	74656c70 	strbtvc	r6, [r5], #-3184
    1b14:	72660065 	rsbvc	r0, r6, #101	; 0x65
    1b18:	73656d61 	cmnvc	r5, #6208	; 0x1840
		}

		//[Single leg functions]
#ifdef OPT_SINGLELEG
		if (ControlMode == SINGLELEGMODE) {
    1b1c:	69725000 	ldmdbvs	r2!, {ip, lr}^

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
    1b20:	3175746e 	cmncc	r5, lr, ror #8
    1b24:	77006836 	smladxvc	r0, r6, r8, r6
    1b28:	61746144 	cmnvs	r4, r4, asr #2
    1b2c:	44785400 	ldrbtmi	r5, [r8], #-1024
    1b30:	6365445f 	cmnvs	r5, #1593835520	; 0x5f000000
				Buzzed(50,2000);
    1b34:	3233535f 	eorscc	r5, r3, #2080374785	; 0x7c000001
    1b38:	74654700 	strbtvc	r4, [r5], #-1792
    1b3c:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b40:	7000676e 	andvc	r6, r0, lr, ror #14
    1b44:	695f7563 	ldmdbvs	pc, {r0, r1, r5, r6, r8, sl, ip, sp, lr}^
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
				} else {
					g_InControlState.SelectedLeg = 0;
    1b48:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
		if (ControlMode == SINGLELEGMODE) {

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
				Buzzed(50,2000);
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b4c:	7a696c61 	bvc	1a5ccd8 <__Stack_Size+0x1a5c8d8>
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
    1b50:	52450065 	subpl	r0, r5, #101	; 0x65
			   g_InControlState.SLLeg.x= (signed char)((int)((int)lx+128)/2); //Left Stick Right/Left
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
    1b54:	54494252 	strbpl	r4, [r9], #-594
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b58:	4548435f 	strbmi	r4, [r8, #-863]
    1b5c:	55534b43 	ldrbpl	r4, [r3, #-2883]
    1b60:	5245004d 	subpl	r0, r5, #77	; 0x4d
    1b64:	54494252 	strbpl	r4, [r9], #-594
    1b68:	45564f5f 	ldrbmi	r4, [r6, #-3935]
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b6c:	41454852 	cmpmi	r5, r2, asr r8
    1b70:	74730054 	ldrbtvc	r0, [r3], #-84
    1b74:	65675f64 	strbvs	r5, [r7, #-3940]!
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b78:	62007374 	andvs	r7, r0, #-805306367	; 0xd0000001
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b7c:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    1b80:	63700074 	cmnvs	r0, #116	; 0x74
    1b84:	65745f75 	ldrbvs	r5, [r4, #-3957]!
				Buzzed(50,2000);
    1b88:	6e696d72 	mcrvs	13, 3, r6, cr9, cr2, {3}
    1b8c:	00657461 	rsbeq	r7, r5, r1, ror #8
				g_InControlState.fSLHold = !g_InControlState.fSLHold;
    1b90:	5f447854 	svcpl	0x00447854
    1b94:	5f636544 	svcpl	0x00636544
    1b98:	00323355 	eorseq	r3, r2, r5, asr r3
    1b9c:	69725062 	ldmdbvs	r2!, {r1, r5, r6, ip, lr}^
			}
		}
#endif

		//Calculate walking time delay
		g_InControlState.InputTimeDelay = 128- max(max(abs(lx), abs(ly)), abs(rightH));
    1ba0:	6465746e 	strbtvs	r7, [r5], #-1134
    1ba4:	69725000 	ldmdbvs	r2!, {ip, lr}^
    1ba8:	7245746e 	subvc	r7, r5, #1845493760	; 0x6e000000
    1bac:	43726f72 	cmnmi	r2, #456	; 0x1c8
    1bb0:	0065646f 	rsbeq	r6, r5, pc, ror #8
    1bb4:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    1bb8:	00726168 	rsbseq	r6, r2, r8, ror #2
    1bbc:	6d754e6c 	ldclvs	14, cr4, [r5, #-432]!
    1bc0:	44785400 	ldrbtmi	r5, [r8], #-1024
    1bc4:	6365445f 	cmnvs	r5, #1593835520	; 0x5f000000
    1bc8:	3631555f 	undefined
    1bcc:	52524500 	subspl	r4, r2, #0	; 0x0
    1bd0:	5f544942 	svcpl	0x00544942

		//Calculate g_InControlState.BodyPos.y
		g_InControlState.BodyPos.y = max(g_BodyYOffset + g_BodyYShift, 0);
    1bd4:	4c474e41 	mcrrmi	14, 4, r4, r7, cr1
    1bd8:	52450045 	subpl	r0, r5, #69	; 0x45
    1bdc:	54494252 	strbpl	r4, [r9], #-594
    1be0:	534e495f 	movtpl	r4, #59743	; 0xe95f
    1be4:	43555254 	cmpmi	r5, #1073741829	; 0x40000005
    1be8:	4e4f4954 	mcrmi	9, 2, r4, cr15, cr4, {2}

		if (sLegInitXZAdjust || sLegInitAngleAdjust) {
    1bec:	6d546c00 	ldclvs	12, cr6, [r4]
    1bf0:	74730070 	ldrbtvc	r0, [r3], #-112
			// User asked for manual leg adjustment - only do when we have finished any previous adjustment

			if (!g_InControlState.ForceGaitStepCnt) {
    1bf4:	75705f64 	ldrbvc	r5, [r0, #-3940]!
				if (sLegInitXZAdjust)
    1bf8:	61686374 	smcvs	34356
					g_fDynamicLegXZLength = true;
    1bfc:	72500072 	subsvc	r0, r0, #114	; 0x72
    1c00:	53746e69 	cmnpl	r4, #1680	; 0x690

				sLegInitXZAdjust += GetLegsXZLength(); // Add on current length to our adjustment...
    1c04:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    1c08:	72500067 	subsvc	r0, r0, #103	; 0x67
				// Handle maybe change angles...
				if (sLegInitAngleAdjust)
					RotateLegInitAngles(sLegInitAngleAdjust);

				// Give system time to process previous calls
				AdjustLegPositions(sLegInitXZAdjust);
    1c0c:	73746e69 	cmnvc	r4, #1680	; 0x690
			}
		}

		if (fAdjustLegPositions && !g_fDynamicLegXZLength)
    1c10:	00643233 	rsbeq	r3, r4, r3, lsr r2
    1c14:	6e6f4c6c 	cdpvs	12, 6, cr4, cr15, cr12, {3}
    1c18:	78540067 	ldmdavc	r4, {r0, r1, r2, r5, r6}^
			AdjustLegPositionsToBodyHeight(); // Put main workings into main program file
    1c1c:	65445f44 	strbvs	r5, [r4, #-3908]
		// Save away the buttons state as to not process the same press twice.
		buttonsPrev = buttons;
    1c20:	31535f63 	cmpcc	r3, r3, ror #30
    1c24:	61620036 	cmnvs	r2, r6, lsr r0
		extPrev = ext;
    1c28:	61726475 	cmnvs	r2, r5, ror r4
    1c2c:	45006574 	strmi	r6, [r0, #-1396]
		g_ulLastMsgTime = getMillis();
    1c30:	49425252 	stmdbmi	r2, {r1, r4, r6, r9, ip, lr}^
    1c34:	4f565f54 	svcmi	0x00565f54
	} else {
		// We did not receive a valid packet.  check for a timeout to see if we should turn robot off...
		if (g_InControlState.fRobotOn) {
    1c38:	4741544c 	strbmi	r5, [r1, -ip, asr #8]
			if ((getMillis() - g_ulLastMsgTime) > ARBOTIX_TO)
    1c3c:	68430045 	stmdavs	r3, {r0, r2, r6}^
    1c40:	506b6365 	rsbpl	r6, fp, r5, ror #6
    1c44:	77654e43 	strbvc	r4, [r5, -r3, asr #28]!
    1c48:	69727241 	ldmdbvs	r2!, {r0, r6, r9, ip, sp, lr}^
    1c4c:	50006576 	andpl	r6, r0, r6, ror r5
				CommanderTurnRobotOff();
    1c50:	746e6972 	strbtvc	r6, [lr], #-2418
		}
	}

}
    1c54:	72616843 	rsbvc	r6, r1, #4390912	; 0x430000
    1c58:	69447700 	stmdbvs	r4, {r8, r9, sl, ip, sp, lr}^
    1c5c:	00746967 	rsbseq	r6, r4, r7, ror #18
    1c60:	6d754e77 	ldclvs	14, cr4, [r5, #-476]!
    1c64:	69725000 	ldmdbvs	r2!, {ip, lr}^
    1c68:	6f43746e 	svcvs	0x0043746e
    1c6c:	74536d6d 	ldrbvc	r6, [r3], #-3437
    1c70:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    1c74:	754e6c00 	strbvc	r6, [lr, #-3072]
    1c78:	7300536d 	movwvc	r5, #877	; 0x36d
    1c7c:	705f6474 	subsvc	r6, pc, r4, ror r4
    1c80:	00737475 	rsbseq	r7, r3, r5, ror r4
    1c84:	5f447854 	svcpl	0x00447854
    1c88:	5f636544 	svcpl	0x00636544
    1c8c:	62003853 	andvs	r3, r0, #5439488	; 0x530000
    1c90:	706d6554 	rsbvc	r6, sp, r4, asr r5
    1c94:	754e6200 	strbvc	r6, [lr, #-512]
    1c98:	7473006d 	ldrbtvc	r0, [r3], #-109
    1c9c:	65675f64 	strbvs	r5, [r7, #-3940]!
    1ca0:	61686374 	smcvs	34356
    1ca4:	446c0072 	strbtmi	r0, [ip], #-114
    1ca8:	74696769 	strbtvc	r6, [r9], #-1897
    1cac:	69725000 	ldmdbvs	r2!, {ip, lr}^

extern void setupPhoenix(void);
extern void readSensors(void);


int Big_main(void) {
    1cb0:	3375746e 	cmncc	r5, #1845493760	; 0x6e000000

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
    1cb4:	50006432 	andpl	r6, r0, r2, lsr r4
	setupPhoenix();
    1cb8:	746e6972 	strbtvc	r6, [lr], #-2418
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1cbc:	00683875 	rsbeq	r3, r8, r5, ror r8

	while (1){
		while (1) {
			//Start time
			unsigned long lTimeWaitEnd;
			lTimerStart = getMillis();
    1cc0:	2f505041 	svccs	0x00505041
    1cc4:	2f637273 	svccs	0x00637273
    1cc8:	69726573 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
#ifdef MILLIS
			PrintString("Barebones lTimerStart ");
			Printu32d(lTimerStart);
			PrintString("\n");
#endif
			DoBackgroundProcess();
    1ccc:	632e6c61 	teqvs	lr, #24832	; 0x6100
			//Read input
			CheckVoltage();        // check our voltages...
    1cd0:	44785400 	ldrbtmi	r5, [r8], #-1024
			if (!g_fLowVoltageShutdown) {
    1cd4:	6365445f 	cmnvs	r5, #1593835520	; 0x5f000000
    1cd8:	0038555f 	eorseq	r5, r8, pc, asr r5
				CommanderInputController_ControlInput();
    1cdc:	42447852 	submi	r7, r4, #5373952	; 0x520000
			}
			WriteOutputs();        // Write Outputs
			//Single leg control
			SingleLegControl();
    1ce0:	5f657479 	svcpl	0x00657479
			DoBackgroundProcess();
    1ce4:	62004350 	andvs	r4, r0, #1073741825	; 0x40000001

			//Gait
			GaitSeq();
    1ce8:	756e694d 	strbvc	r6, [lr, #-2381]!

			DoBackgroundProcess();
    1cec:	54770073 	ldrbtpl	r0, [r7], #-115

			//Balance calculations
			TotalTransX = 0;     //reset values used for calculation of balance
    1cf0:	4500706d 	strmi	r7, [r0, #-109]
    1cf4:	49425252 	stmdbmi	r2, {r1, r4, r6, r9, ip, lr}^
			TotalTransZ = 0;
    1cf8:	41525f54 	cmpmi	r2, r4, asr pc
			TotalTransY = 0;
    1cfc:	0045474e 	subeq	r4, r5, lr, asr #14
    1d00:	706d5462 	rsbvc	r5, sp, r2, ror #8
			TotalXBal1 = 0;
    1d04:	79426200 	stmdbvc	r2, {r9, sp, lr}^
			TotalYBal1 = 0;
    1d08:	45006574 	strmi	r6, [r0, #-1396]
    1d0c:	49425252 	stmdbmi	r2, {r1, r4, r6, r9, ip, lr}^
			TotalZBal1 = 0;
    1d10:	564f5f54 	undefined

			if (g_InControlState.BalanceMode) {
    1d14:	4f4c5245 	svcmi	0x004c5245
    1d18:	64004441 	strvs	r4, [r0], #-1089
    1d1c:	735f6c78 	cmpvc	pc, #30720	; 0x7800

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d20:	745f7465 	ldrbvc	r7, [pc], #1125	; 1d28 <__Stack_Size+0x1928>

					DoBackgroundProcess();
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d24:	63617078 	cmnvs	r1, #120	; 0x78
    1d28:	5f74656b 	svcpl	0x0074656b
    1d2c:	61726170 	cmnvs	r2, r0, ror r1

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs

					DoBackgroundProcess();
    1d30:	6574656d 	ldrbvs	r6, [r4, #-1389]!
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d34:	58440072 	stmdapl	r4, {r1, r4, r5, r6}^
    1d38:	4b505f4c 	blmi	1419a70 <__Stack_Size+0x1419670>
    1d3c:	454c5f54 	strbmi	r5, [ip, #-3924]
    1d40:	7864004e 	stmdavc	r4!, {r1, r2, r3, r6}^
    1d44:	65725f6c 	ldrbvs	r5, [r2, #-3948]!
    1d48:	775f6461 	ldrbvc	r6, [pc, -r1, ror #8]
    1d4c:	0064726f 	rsbeq	r7, r4, pc, ror #4
    1d50:	6e496267 	cdpvs	2, 4, cr6, cr9, cr7, {3}
    1d54:	75727473 	ldrbvc	r7, [r2, #-1139]!
    1d58:	6f697463 	svcvs	0x00697463
    1d5c:	6361506e 	cmnvs	r1, #110	; 0x6e
    1d60:	0074656b 	rsbseq	r6, r4, fp, ror #10
    1d64:	5f6c7864 	svcpl	0x006c7864
    1d68:	705f7874 	subsvc	r7, pc, r4, ror r8
    1d6c:	656b6361 	strbvs	r6, [fp, #-865]!
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d70:	554e0074 	strbpl	r0, [lr, #-116]
    1d74:	43415f4d 	movtmi	r5, #8013	; 0x1f4d
    1d78:	54415554 	strbpl	r5, [r1], #-1364
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1d7c:	6400524f 	strvs	r5, [r0], #-591
    1d80:	745f6c78 	ldrbvc	r6, [pc], #3192	; 1d88 <__Stack_Size+0x1988>
					DoBackgroundProcess();
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d84:	696d7265 	stmdbvs	sp!, {r0, r2, r5, r6, r9, ip, sp, lr}^
    1d88:	6574616e 	ldrbvs	r6, [r4, #-366]!
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
					DoBackgroundProcess();
    1d8c:	6c786400 	cfldrdvs	mvd6, [r8]
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d90:	7465675f 	strbtvc	r6, [r5], #-1887
    1d94:	7078725f 	rsbsvc	r7, r8, pc, asr r2
    1d98:	656b6361 	strbvs	r6, [fp, #-865]!
    1d9c:	656c5f74 	strbvs	r5, [ip, #-3956]!
    1da0:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    1da4:	4c584400 	cfldrdmi	mvd4, [r8], {0}
    1da8:	544b505f 	strbpl	r5, [fp], #-95
    1dac:	534e495f 	movtpl	r4, #59743	; 0xe95f
    1db0:	78640054 	stmdavc	r4!, {r2, r4, r6}^
    1db4:	65675f6c 	strbvs	r5, [r7, #-3948]!
    1db8:	65725f74 	ldrbvs	r5, [r2, #-3956]!
    1dbc:	746c7573 	strbtvc	r7, [ip], #-1395
    1dc0:	6c786400 	cfldrdvs	mvd6, [r8]
    1dc4:	7465735f 	strbtvc	r7, [r5], #-863
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1dc8:	7078745f 	rsbsvc	r7, r8, pc, asr r4
    1dcc:	656b6361 	strbvs	r6, [fp, #-865]!
    1dd0:	64695f74 	strbtvs	r5, [r9], #-3956
							LegPosZ[LegIndex] + GaitPosZ[LegIndex],
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}
				BalanceBody();
    1dd4:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
			}

			//Reset IKsolution indicators
			IKSolution = 0;
    1dd8:	00363174 	eorseq	r3, r6, r4, ror r1
    1ddc:	746e6975 	strbtvc	r6, [lr], #-2421
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1de0:	00745f38 	rsbseq	r5, r4, r8, lsr pc
			}

			//Reset IKsolution indicators
			IKSolution = 0;
			IKSolutionWarning = 0;
			IKSolutionError = 0;
    1de4:	746e6975 	strbtvc	r6, [lr], #-2421
    1de8:	58440038 	stmdapl	r4, {r3, r4, r5}^

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
				DoBackgroundProcess();
    1dec:	4b505f4c 	blmi	1419b24 <__Stack_Size+0x1419724>
				BodyFK(
    1df0:	41505f54 	cmpmi	r0, r4, asr pc
    1df4:	64004152 	strvs	r4, [r0], #-338
    1df8:	675f6c78 	undefined
    1dfc:	725f7465 	subsvc	r7, pc, #1694498816	; 0x65000000
    1e00:	63617078 	cmnvs	r1, #120	; 0x78
    1e04:	5f74656b 	svcpl	0x0074656b
    1e08:	6f727265 	svcvs	0x00727265
    1e0c:	72650072 	rsbvc	r0, r5, #114	; 0x72
    1e10:	74696272 	strbtvc	r6, [r9], #-626
    1e14:	52626700 	rsbpl	r6, r2, #0	; 0x0
    1e18:	74654778 	strbtvc	r4, [r5], #-1912
    1e1c:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
    1e20:	44006874 	strmi	r6, [r0], #-2164
    1e24:	505f4c58 	subspl	r4, pc, r8, asr ip
    1e28:	495f544b 	ldmdbmi	pc, {r0, r1, r3, r6, sl, ip, lr}^
    1e2c:	62670044 	rsbvs	r0, r7, #68	; 0x44
    1e30:	6d6d6f43 	stclvs	15, cr6, [sp, #-268]!
    1e34:	74617453 	strbtvc	r7, [r1], #-1107
    1e38:	64007375 	strvs	r7, [r0], #-885
    1e3c:	705f6c78 	subsvc	r6, pc, r8, ror ip
    1e40:	00676e69 	rsbeq	r6, r7, r9, ror #28
    1e44:	5f6c7864 	svcpl	0x006c7864
    1e48:	5f746573 	svcpl	0x00746573
    1e4c:	61707874 	cmnvs	r0, r4, ror r8
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);

				LegIK(
    1e50:	74656b63 	strbtvc	r6, [r5], #-2915
    1e54:	736e695f 	cmnvc	lr, #1556480	; 0x17c000
    1e58:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    1e5c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    1e60:	52626700 	rsbpl	r6, r2, #0	; 0x0
    1e64:	63615078 	cmnvs	r1, #120	; 0x78
    1e68:	4c74656b 	cfldr64mi	mvdx6, [r4], #-428
    1e6c:	74676e65 	strbtvc	r6, [r7], #-3685
    1e70:	78640068 	stmdavc	r4!, {r3, r5, r6}^
    1e74:	65735f6c 	ldrbvs	r5, [r3, #-3948]!
    1e78:	78745f74 	ldmdavc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1e7c:	6b636170 	blvs	18da444 <__Stack_Size+0x18da044>
    1e80:	6c5f7465 	cfldrdvs	mvd7, [pc], {101}
    1e84:	74676e65 	strbtvc	r6, [r7], #-3685
    1e88:	65520068 	ldrbvs	r0, [r2, #-104]
    1e8c:	78546c61 	ldmdavc	r4, {r0, r5, r6, sl, fp, sp, lr}^
    1e90:	426d754e 	rsbmi	r7, sp, #327155712	; 0x13800000
    1e94:	00657479 	rsbeq	r7, r5, r9, ror r4
    1e98:	6165526e 	cmnvs	r5, lr, ror #4
    1e9c:	78640064 	stmdavc	r4!, {r2, r5, r6}^
    1ea0:	65675f6c 	strbvs	r5, [r7, #-3948]!
    1ea4:	78725f74 	ldmdavc	r2!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1ea8:	6b636170 	blvs	18da470 <__Stack_Size+0x18da070>
    1eac:	705f7465 	subsvc	r7, pc, r5, ror #8
    1eb0:	6d617261 	sfmvs	f7, 2, [r1, #-388]!
    1eb4:	72657465 	rsbvc	r7, r5, #1694498816	; 0x65000000
    1eb8:	6c786400 	cfldrdvs	mvd6, [r8]
    1ebc:	6b616d5f 	blvs	185d440 <__Stack_Size+0x185d040>
    1ec0:	726f7765 	rsbvc	r7, pc, #26476544	; 0x1940000
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1ec4:	78640064 	stmdavc	r4!, {r2, r5, r6}^
    1ec8:	65675f6c 	strbvs	r5, [r7, #-3948]!
    1ecc:	69685f74 	stmdbvs	r8!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1ed0:	79626867 	stmdbvc	r2!, {r0, r1, r2, r5, r6, fp, sp, lr}^
    1ed4:	75006574 	strvc	r6, [r0, #-1396]
				DoBackgroundProcess();
    1ed8:	31746e69 	cmncc	r4, r9, ror #28
				BodyFK(
    1edc:	00745f36 	rsbseq	r5, r4, r6, lsr pc
    1ee0:	5f6c7864 	svcpl	0x006c7864
    1ee4:	705f7872 	subsvc	r7, pc, r2, ror r8
    1ee8:	656b6361 	strbvs	r6, [fp, #-865]!
    1eec:	78640074 	stmdavc	r4!, {r2, r4, r5, r6}^
    1ef0:	65675f6c 	strbvs	r5, [r7, #-3948]!
    1ef4:	6f6c5f74 	svcvs	0x006c5f74
    1ef8:	74796277 	ldrbtvc	r6, [r9], #-631
    1efc:	58440065 	stmdapl	r4, {r0, r2, r5, r6}^
    1f00:	4b505f4c 	blmi	1419c38 <__Stack_Size+0x1419838>
    1f04:	52455f54 	subpl	r5, r5, #336	; 0x150
    1f08:	78640052 	stmdavc	r4!, {r1, r4, r6}^
    1f0c:	65735f6c 	ldrbvs	r5, [r3, #-3948]!
    1f10:	6f675f74 	svcvs	0x00675f74
    1f14:	735f6c61 	cmpvc	pc, #24832	; 0x6100
    1f18:	64656570 	strbtvs	r6, [r5], #-1392
    1f1c:	6c786400 	cfldrdvs	mvd6, [r8]
    1f20:	7278745f 	rsbsvc	r7, r8, #1593835520	; 0x5f000000
    1f24:	61705f78 	cmnvs	r0, r8, ror pc
    1f28:	74656b63 	strbtvc	r6, [r5], #-2915
    1f2c:	50504100 	subspl	r4, r0, r0, lsl #2
    1f30:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    1f34:	6e79642f 	cdpvs	4, 7, cr6, cr9, cr15, {1}
    1f38:	78696d61 	stmdavc	r9!, {r0, r5, r6, r8, sl, fp, sp, lr}^
    1f3c:	632e6c65 	teqvs	lr, #25856	; 0x6500
    1f40:	53626700 	cmnpl	r2, #0	; 0x0
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);
				LegIK(
    1f44:	75746174 	ldrbvc	r6, [r4, #-372]!
    1f48:	63615073 	cmnvs	r1, #115	; 0x73
    1f4c:	0074656b 	rsbseq	r6, r4, fp, ror #10
    1f50:	5f6c7864 	svcpl	0x006c7864
    1f54:	74696e69 	strbtvc	r6, [r9], #-3689
    1f58:	696c6169 	stmdbvs	ip!, {r0, r3, r5, r6, r8, sp, lr}^
    1f5c:	6400657a 	strvs	r6, [r0], #-1402
    1f60:	635f6c78 	cmpvs	pc, #30720	; 0x7800
    1f64:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    1f68:	6174735f 	cmnvs	r4, pc, asr r3
    1f6c:	746b7074 	strbtvc	r7, [fp], #-116
    1f70:	6c786400 	cfldrdvs	mvd6, [r8]
    1f74:	6972775f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    1f78:	625f6574 	subsvs	r6, pc, #486539264	; 0x1d000000
    1f7c:	00657479 	rsbeq	r7, r5, r9, ror r4
    1f80:	5f6c7864 	svcpl	0x006c7864
    1f84:	74706163 	ldrbtvc	r6, [r0], #-355
    1f88:	00657275 	rsbeq	r7, r5, r5, ror r2
    1f8c:	5f6c7864 	svcpl	0x006c7864
    1f90:	74697277 	strbtvc	r7, [r9], #-631
    1f94:	6f775f65 	svcvs	0x00775f65
    1f98:	67006472 	smlsdxvs	r0, r2, r4, r6
    1f9c:	73754269 	cmnvc	r5, #-1879048186	; 0x90000006
    1fa0:	6e697355 	mcrvs	3, 3, r7, cr9, cr5, {2}
    1fa4:	78640067 	stmdavc	r4!, {r0, r1, r2, r5, r6}^
    1fa8:	65725f6c 	ldrbvs	r5, [r2, #-3948]!
    1fac:	625f6461 	subsvs	r6, pc, #1627389952	; 0x61000000
    1fb0:	00657479 	rsbeq	r7, r5, r9, ror r4
    1fb4:	5f62677a 	svcpl	0x0062677a
    1fb8:	635f7872 	cmpvs	pc, #7471104	; 0x720000
    1fbc:	6b636568 	blvs	18db564 <__Stack_Size+0x18db164>
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1fc0:	50504100 	subspl	r4, r0, r0, lsl #2
    1fc4:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    1fc8:	67697a2f 	strbvs	r7, [r9, -pc, lsr #20]!
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Check mechanical limits
			CheckAngles();
    1fcc:	2e656562 	cdpcs	5, 6, cr6, cr5, cr2, {3}

			//Drive Servos
			if (g_InControlState.fRobotOn) {
    1fd0:	677a0063 	ldrbvs	r0, [sl, -r3, rrx]!
    1fd4:	6e695f62 	cdpvs	15, 6, cr5, cr9, cr2, {3}
    1fd8:	61697469 	cmnvs	r9, r9, ror #8
				if (g_InControlState.fRobotOn && !g_InControlState.fPrev_RobotOn) {
					// MSound(3, 60, 2000, 80, 2250, 100, 2500);
					Buzzed(30, 2000);
    1fdc:	657a696c 	ldrbvs	r6, [sl, #-2412]!
    1fe0:	62677a00 	rsbvs	r7, r7, #0	; 0x0
    1fe4:	5f78725f 	svcpl	0x0078725f
					Buzzed(80, 2250);
    1fe8:	61746164 	cmnvs	r4, r4, ror #2
    1fec:	6769725f 	undefined
					Buzzed(100, 2500);
    1ff0:	485f7468 	ldmdami	pc, {r3, r5, r6, sl, ip, sp, lr}^
    1ff4:	52626700 	rsbpl	r6, r2, #0	; 0x0
    1ff8:	61507663 	cmpvs	r0, r3, ror #12

				}

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
    1ffc:	74656b63 	strbtvc	r6, [r5], #-2915
    2000:	76635200 	strbtvc	r5, [r3], -r0, lsl #4
    2004:	006d754e 	rsbeq	r7, sp, lr, asr #10
    2008:	5f62677a 	svcpl	0x0062677a
    200c:	645f7872 	ldrbvs	r7, [pc], #2162	; 2014 <__Stack_Size+0x1c14>
    2010:	5f617461 	svcpl	0x00617461
    2014:	68676972 	stmdavs	r7!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    2018:	00565f74 	subseq	r5, r6, r4, ror pc
    201c:	50646e53 	rsbpl	r6, r4, r3, asr lr
    2020:	656b6361 	strbvs	r6, [fp, #-865]!
    2024:	677a0074 	undefined
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2028:	78725f62 	ldmdavc	r2!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    202c:	7461645f 	strbtvc	r6, [r1], #-1119
    2030:	78655f61 	stmdavc	r5!, {r0, r5, r6, r8, r9, sl, fp, ip, lr}^
    2034:	00617274 	rsbeq	r7, r1, r4, ror r2
    2038:	5f62677a 	svcpl	0x0062677a
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
    203c:	645f7872 	ldrbvs	r7, [pc], #2162	; 2044 <__Stack_Size+0x1c44>

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2040:	5f617461 	svcpl	0x00617461
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
						ServoMoveTime = ServoMoveTime + BALANCE_DELAY;
    2044:	7466656c 	strbtvc	r6, [r6], #-1388
    2048:	005f485f 	subseq	r4, pc, pc, asr r8
				} else
					//Movement speed excl. Walking
					ServoMoveTime = 200 + g_InControlState.SpeedControl;
    204c:	63527767 	cmpvs	r2, #27000832	; 0x19c0000
    2050:	74614476 	strbtvc	r4, [r1], #-1142
    2054:	75620061 	strbvc	r0, [r2, #-97]!

				// note we broke up the servo driver into start/commit that way we can output all of the servo information
				// before we wait and only have the termination information to output after the wait.  That way we hopefully
				// be more accurate with our timings...
				DoBackgroundProcess();
    2058:	6e6f7474 	mcrvs	4, 3, r7, cr15, cr4, {3}
				StartUpdateServos();
    205c:	7a005f73 	bvc	19e30 <__Stack_Size+0x19a30>

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    2060:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
					if ((GaitPosX[LegIndex] > cGPlimit)
    2064:	61645f78 	smcvs	17912
    2068:	7a006174 	bvc	1a640 <__Stack_Size+0x1a240>
    206c:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
    2070:	61645f78 	smcvs	17912
    2074:	725f6174 	subsvc	r6, pc, #29	; 0x1d
    2078:	74686769 	strbtvc	r6, [r8], #-1897
    207c:	005f485f 	subseq	r4, pc, pc, asr r8
    2080:	5f62677a 	svcpl	0x0062677a
    2084:	635f7872 	cmpvs	pc, #7471104	; 0x720000
    2088:	6b636568 	blvs	18db630 <__Stack_Size+0x18db230>
    208c:	6472615f 	ldrbtvs	r6, [r2], #-351
    2090:	6f6e6975 	svcvs	0x006e6975
    2094:	52626700 	rsbpl	r6, r2, #0	; 0x0
    2098:	61507663 	cmpvs	r0, r3, ror #12
    209c:	74656b63 	strbtvc	r6, [r5], #-2915
							|| (GaitPosZ[LegIndex] > cGPlimit)
							|| (GaitPosZ[LegIndex] < -cGPlimit)
							|| (GaitRotY[LegIndex] > cGPlimit)
							|| (GaitRotY[LegIndex] < -cGPlimit)) {

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
    20a0:	006d754e 	rsbeq	r7, sp, lr, asr #10
    20a4:	5f62677a 	svcpl	0x0062677a
    20a8:	645f7874 	ldrbvs	r7, [pc], #2164	; 20b0 <__Stack_Size+0x1cb0>

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    20ac:	00617461 	rsbeq	r7, r1, r1, ror #8
    20b0:	5f62677a 	svcpl	0x0062677a

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
						break;
					}
				}
				if (bExtraCycle > 0) {
    20b4:	6d726574 	cfldr64vs	mvdx6, [r2, #-464]!
					bExtraCycle--;
    20b8:	74616e69 	strbtvc	r6, [r1], #-3689
    20bc:	677a0065 	ldrbvs	r0, [sl, -r5, rrx]!
					fWalking = !(bExtraCycle == 0);
    20c0:	78725f62 	ldmdavc	r2!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    20c4:	7461645f 	strbtvc	r6, [r1], #-1119

					//Get endtime and calculate wait time
					lTimeWaitEnd = lTimerStart + PrevServoMoveTime;
    20c8:	656c5f61 	strbvs	r5, [ip, #-3937]!
    20cc:	565f7466 	ldrbpl	r7, [pc], -r6, ror #8
    20d0:	6843005f 	stmdavs	r3, {r0, r1, r2, r3, r4, r6}^
					PrintString("\n");
#endif
					//DebugWrite(A1, HIGH);
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    20d4:	5a6b6365 	bpl	1adae70 <__Stack_Size+0x1adaa70>
					} while (getMillis() < lTimeWaitEnd);
    20d8:	77654e42 	strbvc	r4, [r5, -r2, asr #28]!
    20dc:	69727241 	ldmdbvs	r2!, {r0, r6, r9, ip, sp, lr}^
					PrintString("\n");
#endif

				}
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
    20e0:	7a006576 	bvc	1b6c0 <__Stack_Size+0x1b2c0>
    20e4:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
    20e8:	61645f78 	smcvs	17912
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
    20ec:	6c5f6174 	ldfvse	f6, [pc], {116}
					PrintString("Barebones lTimeWaitEnd-Millis  ");
					Printu32d(getMillis);
					PrintString("\n");
#endif
				} else {
					FreeServos();
    20f0:	5f746665 	svcpl	0x00746665
    20f4:	677a0048 	ldrbvs	r0, [sl, -r8, asr #32]!
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
					ServoMoveTime = 600;
    20f8:	78725f62 	ldmdavc	r2!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    20fc:	7461645f 	strbtvc	r6, [r1], #-1119
					StartUpdateServos();
    2100:	75625f61 	strbvc	r5, [r2, #-3937]!
					CommitServoDriver(ServoMoveTime);
    2104:	6e6f7474 	mcrvs	4, 3, r7, cr15, cr4, {3}
					//MSound(3, 100, 2500, 80, 2250, 60, 2000);
					Buzzed(100, 2500);
    2108:	677a0073 	undefined
    210c:	78725f62 	ldmdavc	r2!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    2110:	7461645f 	strbtvc	r6, [r1], #-1119
					Buzzed(80, 2250);
    2114:	69725f61 	ldmdbvs	r2!, {r0, r5, r6, r8, r9, sl, fp, ip, lr}^
    2118:	5f746867 	svcpl	0x00746867
					Buzzed(60, 2000);
    211c:	7a005f56 	bvc	19e7c <__Stack_Size+0x19a7c>
    2120:	725f6267 	subsvc	r6, pc, #1879048198	; 0x70000006
    2124:	61645f78 	smcvs	17912

					//lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
					lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
    2128:	6c5f6174 	ldfvse	f6, [pc], {116}
    212c:	5f746665 	svcpl	0x00746665
					Printu32d(lTimeWaitEnd);
					PrintString("\n");
#endif
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    2130:	62670056 	rsbvs	r0, r7, #86	; 0x56
					} while (getMillis() < lTimeWaitEnd);
    2134:	46766352 	undefined
    2138:	0067616c 	rsbeq	r6, r7, ip, ror #2
				} else {
					FreeServos();
				}

				// Allow the Servo driver to do stuff durint our idle time
				IdleTime();
    213c:	63526267 	cmpvs	r2, #1879048198	; 0x70000006
				mDelay(20); // give a pause between times we call if nothing is happening
    2140:	63615076 	cmnvs	r1, #118	; 0x76
			}
			PrevServoMoveTime = ServoMoveTime;
    2144:	4174656b 	cmnmi	r4, fp, ror #10
    2148:	69756472 	ldmdbvs	r5!, {r1, r4, r5, r6, sl, sp, lr}^

			//Store previous g_InControlState.fRobotOn State
			if (g_InControlState.fRobotOn)
    214c:	41006f6e 	tstmi	r0, lr, ror #30
    2150:	5f323158 	svcpl	0x00323158
				g_InControlState.fPrev_RobotOn = 1;
			else
				g_InControlState.fPrev_RobotOn = 0;
    2154:	00534449 	subseq	r4, r3, r9, asr #8
    2158:	64646170 	strbtvs	r6, [r4], #-368
    215c:	00676e69 	rsbeq	r6, r7, r9, ror #28
    2160:	6c616f67 	stclvs	15, cr6, [r1], #-412
    2164:	65736f50 	ldrbvs	r6, [r3, #-3920]!
    2168:	70655200 	rsbvc	r5, r5, r0, lsl #4
    216c:	54746165 	ldrbtpl	r6, [r4], #-357
    2170:	00656d69 	rsbeq	r6, r5, r9, ror #26
    2174:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!
    2178:	74617453 	strbtvc	r7, [r1], #-1107
    217c:	53007375 	movwpl	r7, #885	; 0x375
    2180:	4f565245 	svcmi	0x00565245
    2184:	58414d5f 	stmdapl	r1, {r0, r1, r2, r3, r4, r6, r8, sl, fp, lr}^
    2188:	4c41565f 	mcrrmi	6, 5, r5, r1, cr15
    218c:	00534555 	subseq	r4, r3, r5, asr r5
    2190:	69746f6d 	ldmdbvs	r4!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    2194:	61506e6f 	cmpvs	r0, pc, ror #28
    2198:	64496567 	strbvs	r6, [r9], #-1383
    219c:	65686300 	strbvs	r6, [r8, #-768]!
    21a0:	6f4d6b63 	svcvs	0x004d6b63
    21a4:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    21a8:	70657453 	rsbvc	r7, r5, r3, asr r4
    21ac:	696e6946 	stmdbvs	lr!, {r1, r2, r6, r8, fp, sp, lr}^
    21b0:	64656873 	strbtvs	r6, [r5], #-2163
    21b4:	656e4900 	strbvs	r4, [lr, #-2304]!
    21b8:	61697472 	smcvs	38722
    21bc:	726f466c 	rsbvc	r4, pc, #113246208	; 0x6c00000
    21c0:	50006563 	andpl	r6, r0, r3, ror #10
    21c4:	65737561 	ldrbvs	r7, [r3, #-1377]!
    21c8:	656d6954 	strbvs	r6, [sp, #-2388]!
    21cc:	65727000 	ldrbvs	r7, [r2]!
    21d0:	6574735f 	ldrbvs	r7, [r4, #-863]!
    21d4:	69745f70 	ldmdbvs	r4!, {r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    21d8:	6c00656d 	cfstr32vs	mvfx6, [r0], {109}
    21dc:	5f747361 	svcpl	0x00747361
    21e0:	6c6f6962 	stclvs	9, cr6, [pc], #-392
    21e4:	5f64696f 	svcpl	0x0064696f
    21e8:	6d6d6f63 	stclvs	15, cr6, [sp, #-396]!
    21ec:	00646e61 	rsbeq	r6, r4, r1, ror #28
    21f0:	61316b75 	teqvs	r1, r5, ror fp
    21f4:	31584100 	cmpcc	r8, r0, lsl #2
    21f8:	4e455f32 	mcrmi	15, 2, r5, cr5, cr2, {1}
    21fc:	454c4241 	strbmi	r4, [ip, #-577]
    2200:	6f6d0044 	svcvs	0x006d0044
    2204:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2208:	696f705f 	stmdbvs	pc!, {r0, r1, r2, r3, r4, r6, ip, sp, lr}^
    220c:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    2210:	65747300 	ldrbvs	r7, [r4, #-768]!
    2214:	74735f70 	ldrbtvc	r5, [r3], #-3952
    2218:	5f747261 	svcpl	0x00747261
    221c:	656d6974 	strbvs	r6, [sp, #-2420]!
    2220:	72756300 	rsbsvc	r6, r5, #0	; 0x0
    2224:	746e6572 	strbtvc	r6, [lr], #-1394
    2228:	746f6d5f 	strbtvc	r6, [pc], #3423	; 2230 <__Stack_Size+0x1e30>
    222c:	5f6e6f69 	svcpl	0x006e6f69
    2230:	65676170 	strbvs	r6, [r7, #-368]!
    2234:	66656c00 	strbtvs	r6, [r5], -r0, lsl #24
    2238:	69725f74 	ldmdbvs	r2!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    223c:	5f746867 	svcpl	0x00746867
    2240:	70657473 	rsbvc	r7, r5, r3, ror r4
    2244:	74657300 	strbtvc	r7, [r5], #-768
    2248:	4d77654e 	cfldr64mi	mvdx6, [r7, #-312]!
    224c:	6f69746f 	svcvs	0x0069746f
    2250:	6d6f436e 	stclvs	3, cr4, [pc, #-440]!
    2254:	646e616d 	strbtvs	r6, [lr], #-365
    2258:	696f6a00 	stmdbvs	pc!, {r9, fp, sp, lr}^
    225c:	705f746e 	subsvc	r7, pc, lr, ror #8
    2260:	5300736f 	movwpl	r7, #879	; 0x36f
    2264:	74726174 	ldrbtvc	r6, [r2], #-372
    2268:	65676150 	strbvs	r6, [r7, #-336]!
    226c:	70657200 	rsbvc	r7, r5, r0, lsl #4
    2270:	74697465 	strbtvc	r7, [r9], #-1125
    2274:	736e6f69 	cmnvc	lr, #420	; 0x1a4
    2278:	65786500 	ldrbvs	r6, [r8, #-1280]!
    227c:	65747563 	ldrbvs	r7, [r4, #-1379]!
    2280:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    2284:	78456e6f 	stmdavc	r5, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2288:	61507469 	cmpvs	r0, r9, ror #8
    228c:	74006567 	strvc	r6, [r0], #-1383
    2290:	6c61746f 	cfstrdvs	mvd7, [r1], #-444
    2294:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!
    2298:	78650065 	stmdavc	r5!, {r0, r2, r5, r6}^
    229c:	665f7469 	ldrbvs	r7, [pc], -r9, ror #8
    22a0:	0067616c 	rsbeq	r6, r7, ip, ror #2
    22a4:	6f727265 	svcvs	0x00727265
    22a8:	74735f72 	ldrbtvc	r5, [r3], #-3954
    22ac:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    22b0:	6d6f6300 	stclvs	3, cr6, [pc]
    22b4:	74735f6d 	ldrbtvc	r5, [r3], #-3949
    22b8:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    22bc:	75617000 	strbvc	r7, [r1]!
    22c0:	6e006573 	cfrshl64vs	mvdx0, mvdx3, r6
    22c4:	00656d61 	rsbeq	r6, r5, r1, ror #26
    22c8:	6c727463 	cfldrdvs	mvd7, [r2], #-396
    22cc:	656e695f 	strbvs	r6, [lr, #-2399]!
    22d0:	61697472 	smcvs	38722
    22d4:	6f665f6c 	svcvs	0x00665f6c
    22d8:	00656372 	rsbeq	r6, r5, r2, ror r3
    22dc:	32315841 	eorscc	r5, r1, #4259840	; 0x410000
    22e0:	76726553 	undefined
    22e4:	6d00736f 	stcvs	3, cr7, [r0, #-444]
    22e8:	6f69746f 	svcvs	0x0069746f
    22ec:	74735f6e 	ldrbtvc	r5, [r3], #-3950
    22f0:	00657461 	rsbeq	r7, r5, r1, ror #8
    22f4:	6e696f6a 	cdpvs	15, 6, cr6, cr9, cr10, {3}
    22f8:	6f735f74 	svcvs	0x00735f74
    22fc:	656e7466 	strbvs	r7, [lr, #-1126]!
    2300:	6e007373 	mcrvs	3, 0, r7, cr0, cr3, {3}
    2304:	6574735f 	ldrbvs	r7, [r4, #-863]!
    2308:	4e007370 	mcrmi	3, 0, r7, cr0, cr0, {3}
    230c:	50747865 	rsbspl	r7, r4, r5, ror #16
    2310:	00656761 	rsbeq	r6, r5, r1, ror #14
    2314:	7473616c 	ldrbtvc	r6, [r3], #-364
    2318:	696f6a5f 	stmdbvs	pc!, {r0, r1, r2, r3, r4, r6, r9, fp, sp, lr}^
    231c:	665f746e 	ldrbvs	r7, [pc], -lr, ror #8
    2320:	0078656c 	rsbseq	r6, r8, ip, ror #10
    2324:	65657073 	strbvs	r7, [r5, #-115]!
    2328:	61725f64 	cmnvs	r2, r4, ror #30
    232c:	6d006574 	cfstr32vs	mvfx6, [r0, #-464]
    2330:	6e69766f 	cdpvs	6, 6, cr7, cr9, cr15, {3}
    2334:	6c665f67 	stclvs	15, cr5, [r6], #-412
    2338:	6e006761 	cdpvs	7, 0, cr6, cr0, cr1, {3}
    233c:	5f747865 	svcpl	0x00747865
    2340:	65676170 	strbvs	r6, [r7, #-368]!
    2344:	746f6d00 	strbtvc	r6, [pc], #3328	; 234c <__Stack_Size+0x1f4c>
    2348:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    234c:	65657053 	strbvs	r7, [r5, #-83]!
    2350:	74615264 	strbtvc	r5, [r1], #-612
    2354:	00303165 	eorseq	r3, r0, r5, ror #2
    2358:	636f6c62 	cmnvs	pc, #25088	; 0x6200
    235c:	69745f6b 	ldmdbvs	r4!, {r0, r1, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    2360:	6300656d 	movwvs	r6, #1389	; 0x56d
    2364:	65727275 	ldrbvs	r7, [r2, #-629]!
    2368:	735f746e 	cmpvc	pc, #1845493760	; 0x6e000000
    236c:	00706574 	rsbseq	r6, r0, r4, ror r5
    2370:	706d6f63 	rsbvc	r6, sp, r3, ror #30
    2374:	6e61696c 	cdpvs	9, 6, cr6, cr1, cr12, {3}
    2378:	6c536563 	cfldr64vs	mvdx6, [r3], {99}
    237c:	0065706f 	rsbeq	r7, r5, pc, rrx
    2380:	4d746573 	cfldr64mi	mvdx6, [r4, #-460]!
    2384:	6f69746f 	svcvs	0x0069746f
    2388:	6761506e 	strbvs	r5, [r1, -lr, rrx]!
    238c:	696f4a65 	stmdbvs	pc!, {r0, r2, r5, r6, r9, fp, lr}^
    2390:	6c46746e 	cfstrdvs	mvd7, [r6], {110}
    2394:	62697865 	rsbvs	r7, r9, #6619136	; 0x650000
    2398:	74696c69 	strbtvc	r6, [r9], #-3177
    239c:	74530079 	ldrbvc	r0, [r3], #-121
    23a0:	00737065 	rsbseq	r7, r3, r5, rrx
    23a4:	63657865 	cmnvs	r5, #6619136	; 0x650000
    23a8:	4d657475 	cfstrdmi	mvd7, [r5, #-468]!
    23ac:	6f69746f 	svcvs	0x0069746f
    23b0:	7165536e 	cmnvc	r5, lr, ror #6
    23b4:	636e6575 	cmnvs	lr, #490733568	; 0x1d400000
    23b8:	656e0065 	strbvs	r0, [lr, #-101]!
    23bc:	6d5f7478 	cfldrdvs	mvd7, [pc, #-480]
    23c0:	6f69746f 	svcvs	0x0069746f
    23c4:	61705f6e 	cmnvs	r0, lr, ror #30
    23c8:	43006567 	movwmi	r6, #1383	; 0x567
    23cc:	65727275 	ldrbvs	r7, [r2, #-629]!
    23d0:	6f4d746e 	svcvs	0x004d746e
    23d4:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    23d8:	65786500 	ldrbvs	r6, [r8, #-1280]!
    23dc:	65747563 	ldrbvs	r7, [r4, #-1379]!
    23e0:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    23e4:	74536e6f 	ldrbvc	r6, [r3], #-3695
    23e8:	4a007065 	bmi	1e584 <__Stack_Size+0x1e184>
    23ec:	746e696f 	strbtvc	r6, [lr], #-2415
    23f0:	78656c46 	stmdavc	r5!, {r1, r2, r6, sl, fp, sp, lr}^
    23f4:	74656700 	strbtvc	r6, [r5], #-1792
    23f8:	72727543 	rsbsvc	r7, r2, #281018368	; 0x10c00000
    23fc:	4d746e65 	ldclmi	14, cr6, [r4, #-404]!
    2400:	6f69746f 	svcvs	0x0069746f
    2404:	6174536e 	cmnvs	r4, lr, ror #6
    2408:	69547472 	ldmdbvs	r4, {r1, r4, r5, r6, sl, ip, sp, lr}^
    240c:	7400656d 	strvc	r6, [r0], #-1389
    2410:	31706d65 	cmncc	r0, r5, ror #26
    2414:	77656e00 	strbvc	r6, [r5, -r0, lsl #28]!
    2418:	6d6f635f 	stclvs	3, cr6, [pc, #-380]!
    241c:	646e616d 	strbtvs	r6, [lr], #-365
    2420:	746f6d00 	strbtvc	r6, [pc], #3328	; 2428 <__Stack_Size+0x2028>
    2424:	5f6e6f69 	svcpl	0x006e6f69
    2428:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    242c:	5f726574 	svcpl	0x00726574
    2430:	65676170 	strbvs	r6, [r7, #-368]!
    2434:	6f6d0073 	svcvs	0x006d0073
    2438:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    243c:	65676150 	strbvs	r6, [r7, #-336]!
    2440:	74696e49 	strbtvc	r6, [r9], #-3657
    2444:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
    2448:	7543746e 	strbvc	r7, [r3, #-1134]
    244c:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
    2450:	746f4d74 	strbtvc	r4, [pc], #3444	; 2458 <__Stack_Size+0x2058>
    2454:	506e6f69 	rsbpl	r6, lr, r9, ror #30
    2458:	00656761 	rsbeq	r6, r5, r1, ror #14
    245c:	69746f6d 	ldmdbvs	r4!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    2460:	735f6e6f 	cmpvc	pc, #1776	; 0x6f0
    2464:	00706574 	rsbseq	r6, r0, r4, ror r5
    2468:	73756170 	cmnvc	r5, #28	; 0x1c
    246c:	74735f65 	ldrbtvc	r5, [r3], #-3941
    2470:	5f747261 	svcpl	0x00747261
    2474:	656d6974 	strbvs	r6, [sp, #-2420]!
    2478:	65786500 	ldrbvs	r6, [r8, #-1280]!
    247c:	65747563 	ldrbvs	r7, [r4, #-1379]!
    2480:	69746f4d 	ldmdbvs	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    2484:	75006e6f 	strvc	r6, [r0, #-3695]
    2488:	6361706e 	cmnvs	r1, #110	; 0x6e
    248c:	746f4d6b 	strbtvc	r4, [pc], #3435	; 2494 <__Stack_Size+0x2094>
    2490:	326e6f69 	rsbcc	r6, lr, #420	; 0x1a4
    2494:	65686300 	strbvs	r6, [r8, #-768]!
    2498:	6f4d6b63 	svcvs	0x004d6b63
    249c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    24a0:	696e6946 	stmdbvs	lr!, {r1, r2, r6, r8, fp, sp, lr}^
    24a4:	64656873 	strbtvs	r6, [r5], #-2163
    24a8:	65747300 	ldrbvs	r7, [r4, #-768]!
    24ac:	69745f70 	ldmdbvs	r4!, {r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    24b0:	0073656d 	rsbseq	r6, r3, sp, ror #10
    24b4:	72727563 	rsbsvc	r7, r2, #415236096	; 0x18c00000
    24b8:	5f746e65 	svcpl	0x00746e65
    24bc:	69746f6d 	ldmdbvs	r4!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    24c0:	735f6e6f 	cmpvc	pc, #1776	; 0x6f0
    24c4:	74726174 	ldrbtvc	r6, [r2], #-372
    24c8:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!
    24cc:	65720065 	ldrbvs	r0, [r2, #-101]!
    24d0:	74616570 	strbtvc	r6, [r1], #-1392
    24d4:	756f635f 	strbvc	r6, [pc, #-863]!	; 217d <__Stack_Size+0x1d7d>
    24d8:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    24dc:	65745300 	ldrbvs	r5, [r4, #-768]!
    24e0:	6c615670 	stclvs	6, cr5, [r1], #-448
    24e4:	00736575 	rsbseq	r6, r3, r5, ror r5
    24e8:	70657473 	rsbvc	r7, r5, r3, ror r4
    24ec:	6e69665f 	mcrvs	6, 3, r6, cr9, cr15, {2}
    24f0:	5f687369 	svcpl	0x00687369
    24f4:	656d6974 	strbvs	r6, [sp, #-2420]!
    24f8:	50504100 	subspl	r4, r0, r0, lsl #2
    24fc:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    2500:	746f6d2f 	strbtvc	r6, [pc], #3375	; 2508 <__Stack_Size+0x2108>
    2504:	2e6e6f69 	cdpcs	15, 6, cr6, cr14, cr9, {3}
    2508:	45530063 	ldrbmi	r0, [r3, #-99]
    250c:	5f4f5652 	svcpl	0x004f5652
    2510:	5f4e494d 	svcpl	0x004e494d
    2514:	554c4156 	strbpl	r4, [ip, #-342]
    2518:	65005345 	strvs	r5, [r0, #-837]
    251c:	5f746978 	svcpl	0x00746978
    2520:	65676170 	strbvs	r6, [r7, #-368]!
    2524:	616c6600 	cmnvs	ip, r0, lsl #12
    2528:	65725f67 	ldrbvs	r5, [r2, #-3943]!
    252c:	76696563 	strbtvc	r6, [r9], -r3, ror #10
    2530:	65725f65 	ldrbvs	r5, [r2, #-3941]!
    2534:	00796461 	rsbseq	r6, r9, r1, ror #8
    2538:	5f636461 	svcpl	0x00636461
    253c:	736e6573 	cmnvc	lr, #482344960	; 0x1cc00000
    2540:	655f726f 	ldrbvs	r7, [pc, #-623]	; 22d9 <__Stack_Size+0x1ed9>
    2544:	6c62616e 	stfvse	f6, [r2], #-440
    2548:	75620065 	strbvc	r0, [r2, #-101]!
    254c:	72657a7a 	rsbvc	r7, r5, #499712	; 0x7a000
    2550:	696e6946 	stmdbvs	lr!, {r1, r2, r6, r8, fp, sp, lr}^
    2554:	64656873 	strbtvs	r6, [r5], #-2163
    2558:	64697000 	strbtvs	r7, [r9]
    255c:	7465735f 	strbtvc	r7, [r5], #-863
    2560:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    2564:	64610074 	strbtvs	r0, [r1], #-116
    2568:	63615f63 	cmnvs	r1, #396	; 0x18c
    256c:	796c6563 	stmdbvc	ip!, {r0, r1, r5, r6, r8, sl, sp, lr}^
    2570:	6e65635f 	mcrvs	3, 3, r6, cr5, cr15, {2}
    2574:	00726574 	rsbseq	r6, r2, r4, ror r5
    2578:	5f636461 	svcpl	0x00636461
    257c:	736e6573 	cmnvc	lr, #482344960	; 0x1cc00000
    2580:	765f726f 	ldrbvc	r7, [pc], -pc, ror #4
    2584:	61006c61 	tstvs	r0, r1, ror #24
    2588:	625f6364 	subsvs	r6, pc, #-1879048191	; 0x90000001
    258c:	65747461 	ldrbvs	r7, [r4, #-1121]!
    2590:	765f7972 	undefined
    2594:	61006c61 	tstvs	r0, r1, ror #24
    2598:	675f6364 	ldrbvs	r6, [pc, -r4, ror #6]
    259c:	786f7279 	stmdavc	pc!, {r0, r3, r4, r5, r6, r9, ip, sp, lr}^
    25a0:	6e65635f 	mcrvs	3, 3, r6, cr5, cr15, {2}
    25a4:	00726574 	rsbseq	r6, r2, r4, ror r5
    25a8:	5f636461 	svcpl	0x00636461
    25ac:	72746c75 	rsbsvc	r6, r4, #29952	; 0x7500
    25b0:	6e6f7361 	cdpvs	3, 6, cr7, cr15, cr1, {3}
    25b4:	645f6369 	ldrbvs	r6, [pc], #873	; 25bc <__Stack_Size+0x21bc>
    25b8:	61747369 	cmnvs	r4, r9, ror #6
    25bc:	0065636e 	rsbeq	r6, r5, lr, ror #6
    25c0:	5f646970 	svcpl	0x00646970
    25c4:	7074756f 	rsbsvc	r7, r4, pc, ror #10
    25c8:	41007475 	tstmi	r0, r5, ror r4
    25cc:	732f5050 	teqvc	pc, #80	; 0x50
    25d0:	672f6372 	undefined
    25d4:	61626f6c 	cmnvs	r2, ip, ror #30
    25d8:	7461446c 	strbtvc	r4, [r1], #-1132
    25dc:	00632e61 	rsbeq	r2, r3, r1, ror #28
    25e0:	5f636461 	svcpl	0x00636461
    25e4:	65636361 	strbvs	r6, [r3, #-865]!
    25e8:	6100786c 	tstvs	r0, ip, ror #16
    25ec:	615f6364 	cmpvs	pc, r4, ror #6
    25f0:	6c656363 	stclvs	3, cr6, [r5], #-396
    25f4:	64610079 	strbtvs	r0, [r1], #-121
    25f8:	6d645f63 	stclvs	15, cr5, [r4, #-396]!
    25fc:	69645f73 	stmdbvs	r4!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    2600:	6e617473 	mcrvs	4, 3, r7, cr1, cr3, {3}
    2604:	61006563 	tstvs	r0, r3, ror #10
    2608:	675f6364 	ldrbvs	r6, [pc, -r4, ror #6]
    260c:	796f7279 	stmdbvc	pc!, {r0, r3, r4, r5, r6, r9, ip, sp, lr}^
    2610:	6e65635f 	mcrvs	3, 3, r6, cr5, cr15, {2}
    2614:	00726574 	rsbseq	r6, r2, r4, ror r5
    2618:	69746f6d 	ldmdbvs	r4!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    261c:	735f6e6f 	cmpvc	pc, #1776	; 0x6f0
    2620:	5f706574 	svcpl	0x00706574
    2624:	76726573 	undefined
    2628:	6d5f736f 	ldclvs	3, cr7, [pc, #-444]
    262c:	6e69766f 	cdpvs	6, 6, cr7, cr9, cr15, {3}
    2630:	6f6d0067 	svcvs	0x006d0067
    2634:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2638:	7265735f 	rsbvc	r7, r5, #2080374785	; 0x7c000001
    263c:	5f736f76 	svcpl	0x00736f76
    2640:	69766f6d 	ldmdbvs	r6!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    2644:	7000676e 	andvc	r6, r0, lr, ror #14
    2648:	755f6469 	ldrbvc	r6, [pc, #-1129]	; 21e7 <__Stack_Size+0x1de7>
    264c:	6163736e 	cmnvs	r3, lr, ror #6
    2650:	5f64656c 	svcpl	0x0064656c
    2654:	7074756f 	rsbsvc	r7, r4, pc, ror #10
    2658:	6d007475 	cfstrsvs	mvf7, [r0, #-468]
    265c:	726f6a61 	rsbvc	r6, pc, #397312	; 0x61000
    2660:	616c615f 	cmnvs	ip, pc, asr r1
    2664:	70006d72 	andvc	r6, r0, r2, ror sp
    2668:	695f6469 	ldmdbvs	pc, {r0, r3, r5, r6, sl, sp, lr}^
    266c:	7475706e 	ldrbtvc	r7, [r5], #-110
    2670:	7a756200 	bvc	1d5ae78 <__Stack_Size+0x1d5aa78>
    2674:	5372657a 	cmnpl	r2, #511705088	; 0x1e800000
    2678:	65757165 	ldrbvs	r7, [r5, #-357]!
    267c:	0065636e 	rsbeq	r6, r5, lr, ror #6
    2680:	72727563 	rsbsvc	r7, r2, #415236096	; 0x18c00000
    2684:	5f746e65 	svcpl	0x00746e65
    2688:	65736f70 	ldrbvs	r6, [r3, #-3952]!
    268c:	63646100 	cmnvs	r4, #0	; 0x0
    2690:	6363615f 	cmnvs	r3, #-1073741801	; 0xc0000017
    2694:	5f786c65 	svcpl	0x00786c65
    2698:	746e6563 	strbtvc	r6, [lr], #-1379
    269c:	6e007265 	cdpvs	2, 0, cr7, cr0, cr5, {3}
    26a0:	635f6d75 	cmpvs	pc, #7488	; 0x1d40
    26a4:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    26a8:	67006465 	strvs	r6, [r0, -r5, ror #8]
    26ac:	5f6c616f 	svcpl	0x006c616f
    26b0:	65657073 	strbvs	r7, [r5, #-115]!
    26b4:	635f7364 	cmpvs	pc, #-1879048191	; 0x90000001
    26b8:	676e6168 	strbvs	r6, [lr, -r8, ror #2]!
    26bc:	67006465 	strvs	r6, [r0, -r5, ror #8]
    26c0:	5f6c616f 	svcpl	0x006c616f
    26c4:	65736f70 	ldrbvs	r6, [r3, #-3952]!
    26c8:	6168635f 	cmnvs	r8, pc, asr r3
    26cc:	6465676e 	strbtvs	r6, [r5], #-1902
    26d0:	616f6700 	cmnvs	pc, r0, lsl #14
    26d4:	6f705f6c 	svcvs	0x00705f6c
    26d8:	69746973 	ldmdbvs	r4!, {r0, r1, r4, r5, r6, r8, fp, sp, lr}^
    26dc:	72006e6f 	andvc	r6, r0, #1776	; 0x6f0
    26e0:	74657365 	strbtvc	r7, [r5], #-869
    26e4:	6e696f4a 	cdpvs	15, 6, cr6, cr9, cr10, {2}
    26e8:	66664f74 	uqsub16vs	r4, r6, r4
    26ec:	73746573 	cmnvc	r4, #482344960	; 0x1cc00000
    26f0:	766f6d00 	strbtvc	r6, [pc], -r0, lsl #26
    26f4:	476f5465 	strbmi	r5, [pc, -r5, ror #8]!
    26f8:	506c616f 	rsbpl	r6, ip, pc, ror #2
    26fc:	0065736f 	rsbeq	r7, r5, pc, ror #6
    2700:	636c6163 	cmnvs	ip, #-1073741800	; 0xc0000018
    2704:	74616c75 	strbtvc	r6, [r1], #-3189
    2708:	70735f65 	rsbsvc	r5, r3, r5, ror #30
    270c:	00646565 	rsbeq	r6, r4, r5, ror #10
    2710:	5f746567 	svcpl	0x00746567
    2714:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    2718:	65007465 	strvs	r7, [r0, #-1125]
    271c:	745f7473 	ldrbvc	r7, [pc], #1139	; 2724 <__Stack_Size+0x2324>
    2720:	00656d69 	rsbeq	r6, r5, r9, ror #26
    2724:	43746567 	cmnmi	r4, #432013312	; 0x19c00000
    2728:	65727275 	ldrbvs	r7, [r2, #-629]!
    272c:	6f47746e 	svcvs	0x0047746e
    2730:	6f506c61 	svcvs	0x00506c61
    2734:	67006573 	smlsdxvs	r0, r3, r5, r6
    2738:	5f6c616f 	svcpl	0x006c616f
    273c:	00706d74 	rsbseq	r6, r0, r4, ror sp
    2740:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    2744:	5f737465 	svcpl	0x00737465
    2748:	65657073 	strbvs	r7, [r5, #-115]!
    274c:	50007364 	andpl	r7, r0, r4, ror #6
    2750:	5f45534f 	svcpl	0x0045534f
    2754:	45444f4d 	strbmi	r4, [r4, #-3917]
    2758:	66666f00 	strbtvs	r6, [r6], -r0, lsl #30
    275c:	5f746573 	svcpl	0x00746573
    2760:	696d6974 	stmdbvs	sp!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    2764:	0073676e 	rsbseq	r6, r3, lr, ror #14
    2768:	6f727265 	svcvs	0x00727265
    276c:	61745372 	cmnvs	r4, r2, ror r3
    2770:	00737574 	rsbseq	r7, r3, r4, ror r5
    2774:	73726966 	cmnvc	r2, #1671168	; 0x198000
    2778:	6f6c5f74 	svcvs	0x006c5f74
    277c:	7700706f 	strvc	r7, [r0, -pc, rrx]
    2780:	46746961 	ldrbtmi	r6, [r4], -r1, ror #18
    2784:	6f50726f 	svcvs	0x0050726f
    2788:	69466573 	stmdbvs	r6, {r0, r1, r4, r5, r6, r8, sl, sp, lr}^
    278c:	6873696e 	ldmdavs	r3!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    2790:	534f5000 	movtpl	r5, #61440	; 0xf000
    2794:	4f4d5f45 	svcmi	0x004d5f45
    2798:	535f4544 	cmppl	pc, #285212672	; 0x11000000
    279c:	00434e59 	subeq	r4, r3, r9, asr lr
    27a0:	6c616f67 	stclvs	15, cr6, [r1], #-412
    27a4:	736f705f 	cmnvc	pc, #95	; 0x5f
    27a8:	64615f65 	strbtvs	r5, [r1], #-3941
    27ac:	7473756a 	ldrbtvc	r7, [r3], #-1386
    27b0:	67006465 	strvs	r6, [r0, -r5, ror #8]
    27b4:	6f5f7465 	svcvs	0x005f7465
    27b8:	65736666 	ldrbvs	r6, [r3, #-1638]!
    27bc:	64615f74 	strbtvs	r5, [r1], #-3956
    27c0:	7473756a 	ldrbtvc	r7, [r3], #-1386
    27c4:	746e656d 	strbtvc	r6, [lr], #-1389
    27c8:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!
    27cc:	50410065 	subpl	r0, r1, r5, rrx
    27d0:	72732f50 	rsbsvc	r2, r3, #320	; 0x140
    27d4:	6f702f63 	svcvs	0x00702f63
    27d8:	632e6573 	teqvs	lr, #482344960	; 0x1cc00000
    27dc:	61657200 	cmnvs	r5, r0, lsl #4
    27e0:	72754364 	rsbsvc	r4, r5, #-1879048191	; 0x90000001
    27e4:	746e6572 	strbtvc	r6, [lr], #-1394
    27e8:	65736f50 	ldrbvs	r6, [r3, #-3920]!
    27ec:	616f6700 	cmnvs	pc, r0, lsl #14
    27f0:	6f705f6c 	svcvs	0x00705f6c
    27f4:	73006573 	movwvc	r6, #1395	; 0x573
    27f8:	6f4a7465 	svcvs	0x004a7465
    27fc:	4f746e69 	svcmi	0x00746e69
    2800:	65736666 	ldrbvs	r6, [r3, #-1638]!
    2804:	49794274 	ldmdbmi	r9!, {r2, r4, r5, r6, r9, lr}^
    2808:	69750064 	ldmdbvs	r5!, {r2, r5, r6}^
    280c:	3233746e 	eorscc	r7, r3, #1845493760	; 0x6e000000
    2810:	6f00745f 	svcvs	0x0000745f
    2814:	65736666 	ldrbvs	r6, [r3, #-1638]!
    2818:	64615f74 	strbtvs	r5, [r1], #-3956
    281c:	7473756a 	ldrbtvc	r7, [r3], #-1386
    2820:	746e656d 	strbtvc	r6, [lr], #-1389
    2824:	7361685f 	cmnvc	r1, #6225920	; 0x5f0000
    2828:	73756a5f 	cmnvc	r5, #389120	; 0x5f000
    282c:	6f635f74 	svcvs	0x00635f74
    2830:	656c706d 	strbvs	r7, [ip, #-109]!
    2834:	00646574 	rsbeq	r6, r4, r4, ror r5
    2838:	6c616f67 	stclvs	15, cr6, [r1], #-412
    283c:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!
    2840:	74730065 	ldrbtvc	r0, [r3], #-101
    2844:	5f6c6c69 	svcpl	0x006c6c69
    2848:	69766f6d 	ldmdbvs	r6!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    284c:	6700676e 	strvs	r6, [r0, -lr, ror #14]
    2850:	5f6c616f 	svcpl	0x006c616f
    2854:	65736f70 	ldrbvs	r6, [r3, #-3952]!
    2858:	6168735f 	cmnvs	r8, pc, asr r3
    285c:	00776f64 	rsbseq	r6, r7, r4, ror #30
    2860:	636c6163 	cmnvs	ip, #-1073741800	; 0xc0000018
    2864:	74616c75 	strbtvc	r6, [r1], #-3189
    2868:	736f5065 	cmnvc	pc, #101	; 0x65
    286c:	72655365 	rsbvc	r5, r5, #-1811939327	; 0x94000001
    2870:	70536f76 	subsvc	r6, r3, r6, ror pc
    2874:	73646565 	cmnvc	r4, #423624704	; 0x19400000
    2878:	534f5000 	movtpl	r5, #61440	; 0xf000
    287c:	4f4d5f45 	svcmi	0x004d5f45
    2880:	445f4544 	ldrbmi	r4, [pc], #1348	; 2888 <__Stack_Size+0x2488>
    2884:	43455249 	movtmi	r5, #21065	; 0x5249
    2888:	6c6f0054 	stclvs	0, cr0, [pc], #-336
    288c:	666f5f64 	strbtvs	r5, [pc], -r4, ror #30
    2890:	74657366 	strbtvc	r7, [r5], #-870
    2894:	66666f00 	strbtvs	r6, [r6], -r0, lsl #30
    2898:	73746573 	cmnvc	r4, #482344960	; 0x1cc00000
    289c:	6168735f 	cmnvs	r8, pc, asr r3
    28a0:	00776f64 	rsbseq	r6, r7, r4, ror #30
    28a4:	72727563 	rsbsvc	r7, r2, #415236096	; 0x18c00000
    28a8:	5f746e65 	svcpl	0x00746e65
    28ac:	69736f70 	ldmdbvs	r3!, {r4, r5, r6, r8, r9, sl, fp, sp, lr}^
    28b0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    28b4:	6e697500 	cdpvs	5, 6, cr7, cr9, cr0, {0}
    28b8:	00323374 	eorseq	r3, r2, r4, ror r3
    28bc:	6c707061 	ldclvs	0, cr7, [r0], #-388
    28c0:	656e5f79 	strbvs	r5, [lr, #-3961]!
    28c4:	6f705f77 	svcvs	0x00705f77
    28c8:	615f6573 	cmpvs	pc, r3, ror r5
    28cc:	6f5f646e 	svcvs	0x005f646e
    28d0:	65736666 	ldrbvs	r6, [r3, #-1638]!
    28d4:	73007374 	movwvc	r7, #884	; 0x374
    28d8:	6f4a7465 	svcvs	0x004a7465
    28dc:	4f746e69 	svcmi	0x00746e69
    28e0:	65736666 	ldrbvs	r6, [r3, #-1638]!
    28e4:	65705374 	ldrbvs	r5, [r0, #-884]!
    28e8:	79426465 	stmdbvc	r2, {r0, r2, r5, r6, sl, sp, lr}^
    28ec:	49006449 	stmdbmi	r0, {r0, r3, r6, sl, sp, lr}
    28f0:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    28f4:	6c506c61 	mrrcvs	12, 6, r6, r0, cr1
    28f8:	69547961 	ldmdbvs	r4, {r0, r5, r6, r8, fp, ip, sp, lr}^
    28fc:	4900656d 	stmdbmi	r0, {r0, r2, r3, r5, r6, r8, sl, sp, lr}
    2900:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    2904:	61566c61 	cmpvs	r6, r1, ror #24
    2908:	7365756c 	cmnvc	r5, #452984832	; 0x1b000000
    290c:	6d657400 	cfstrdvs	mvd7, [r5]
    2910:	6f675f70 	svcvs	0x00675f70
    2914:	74006c61 	strvc	r6, [r0], #-3169
    2918:	65766172 	ldrbvs	r6, [r6, #-370]!
    291c:	7061006c 	rsbvc	r0, r1, ip, rrx
    2920:	4f796c70 	svcmi	0x00796c70
    2924:	65736666 	ldrbvs	r6, [r3, #-1638]!
    2928:	6f427374 	svcvs	0x00427374
    292c:	73646e75 	cmnvc	r4, #1872	; 0x750
    2930:	73646900 	cmnvc	r4, #0	; 0x0
    2934:	6168635f 	cmnvs	r8, pc, asr r3
    2938:	6465676e 	strbtvs	r6, [r5], #-1902
    293c:	74657300 	strbtvc	r7, [r5], #-768
    2940:	736f705f 	cmnvc	pc, #95	; 0x5f
    2944:	6f6d5f65 	svcvs	0x006d5f65
    2948:	6d006564 	cfstr32vs	mvfx6, [r0, #-400]
    294c:	5465766f 	strbtpl	r7, [r5], #-1647
    2950:	6665446f 	strbtvs	r4, [r5], -pc, ror #8
    2954:	746c7561 	strbtvc	r7, [ip], #-1377
    2958:	65736f50 	ldrbvs	r6, [r3, #-3920]!
    295c:	69617700 	stmdbvs	r1!, {r8, r9, sl, ip, sp, lr}^
    2960:	6c665f74 	stclvs	15, cr5, [r6], #-464
    2964:	77006761 	strvc	r6, [r0, -r1, ror #14]
    2968:	5f6b6c61 	svcpl	0x006b6c61
    296c:	696f7661 	stmdbvs	pc!, {r0, r5, r6, r9, sl, ip, sp, lr}^
    2970:	73624f64 	cmnvc	r2, #400	; 0x190
    2974:	6c636174 	stfvse	f6, [r3], #-464
    2978:	61770065 	cmnvs	r7, r5, rrx
    297c:	675f6b6c 	ldrbvs	r6, [pc, -ip, ror #22]
    2980:	61577465 	cmpvs	r7, r5, ror #8
    2984:	74536b6c 	ldrbvc	r6, [r3], #-2924
    2988:	00657461 	rsbeq	r7, r5, r1, ror #8
    298c:	7473626f 	ldrbtvc	r6, [r3], #-623
    2990:	656c6361 	strbvs	r6, [ip, #-865]!
    2994:	616c665f 	cmnvs	ip, pc, asr r6
    2998:	61770067 	cmnvs	r7, r7, rrx
    299c:	635f6b6c 	cmpvs	pc, #110592	; 0x1b000
    29a0:	616d6d6f 	cmnvs	sp, pc, ror #26
    29a4:	7700646e 	strvc	r6, [r0, -lr, ror #8]
    29a8:	5f6b6c61 	svcpl	0x006b6c61
    29ac:	74696e69 	strbtvc	r6, [r9], #-3689
    29b0:	50504100 	subspl	r4, r0, r0, lsl #2
    29b4:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    29b8:	6c61772f 	stclvs	7, cr7, [r1], #-188
    29bc:	00632e6b 	rsbeq	r2, r3, fp, ror #28
    29c0:	6b6c6177 	blvs	1b1afa4 <__Stack_Size+0x1b1aba4>
    29c4:	6968735f 	stmdbvs	r8!, {r0, r1, r2, r3, r4, r6, r8, r9, ip, sp, lr}^
    29c8:	77007466 	strvc	r7, [r0, -r6, ror #8]
    29cc:	5f6b6c61 	svcpl	0x006b6c61
    29d0:	57746573 	undefined
    29d4:	536b6c61 	cmnpl	fp, #24832	; 0x6100
    29d8:	65746174 	ldrbvs	r6, [r4, #-372]!
    29dc:	6c617700 	stclvs	7, cr7, [r1]
    29e0:	74735f6b 	ldrbtvc	r5, [r3], #-3947
    29e4:	00657461 	rsbeq	r7, r5, r1, ror #8
    29e8:	4f495047 	svcmi	0x00495047
    29ec:	7079545f 	rsbsvc	r5, r9, pc, asr r4
    29f0:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    29f4:	61655200 	cmnvs	r5, r0, lsl #4
    29f8:	00524964 	subseq	r4, r2, r4, ror #18
    29fc:	3252444a 	subscc	r4, r2, #1241513984	; 0x4a000000
    2a00:	52444a00 	subpl	r4, r4, #0	; 0x0
    2a04:	444a0033 	strbmi	r0, [sl], #-51
    2a08:	42003452 	andmi	r3, r0, #1375731712	; 0x52000000
    2a0c:	65747461 	ldrbvs	r7, [r4, #-1121]!
    2a10:	4d5f7972 	ldclmi	9, cr7, [pc, #-456]
    2a14:	74696e6f 	strbtvc	r6, [r9], #-3695
    2a18:	415f726f 	cmpmi	pc, pc, ror #4
    2a1c:	6d72616c 	ldfvse	f6, [r2, #-432]!
    2a20:	4f504500 	svcmi	0x00504500
    2a24:	35325452 	ldrcc	r5, [r2, #-1106]!
    2a28:	4f504500 	svcmi	0x00504500
    2a2c:	31325452 	teqcc	r2, r2, asr r4
    2a30:	74655300 	strbtvc	r5, [r5], #-768
    2a34:	726f5045 	rsbvc	r5, pc, #69	; 0x45
    2a38:	534a0074 	movtpl	r0, #41076	; 0xa074
    2a3c:	45005251 	strmi	r5, [r0, #-593]
    2a40:	74726f50 	ldrbtvc	r6, [r2], #-3920
    2a44:	00655f44 	rsbeq	r5, r5, r4, asr #30
    2a48:	746c6f76 	strbtvc	r6, [ip], #-3958
    2a4c:	4f504500 	svcmi	0x00504500
    2a50:	31365452 	teqcc	r6, r2, asr r4
    2a54:	354d4300 	strbcc	r4, [sp, #-768]
    2a58:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
    2a5c:	72732f57 	rsbsvc	r2, r3, #348	; 0x15c
    2a60:	64612f63 	strbtvs	r2, [r1], #-3939
    2a64:	00632e63 	rsbeq	r2, r3, r3, ror #28
    2a68:	524f5045 	subpl	r5, pc, #69	; 0x45
    2a6c:	00353654 	eorseq	r3, r5, r4, asr r6
    2a70:	41534944 	cmpmi	r3, r4, asr #18
    2a74:	00454c42 	subeq	r4, r5, r2, asr #24
    2a78:	3152444a 	cmpcc	r2, sl, asr #8
    2a7c:	52534200 	subspl	r4, r3, #0	; 0x0
    2a80:	50450052 	subpl	r0, r5, r2, asr r0
    2a84:	3354524f 	cmpcc	r4, #-268435452	; 0xf0000004
    2a88:	4f4a0031 	svcmi	0x004a0031
    2a8c:	00315246 	eorseq	r5, r1, r6, asr #4
    2a90:	52464f4a 	subpl	r4, r6, #296	; 0x128
    2a94:	50450032 	subpl	r0, r5, r2, lsr r0
    2a98:	3354524f 	cmpcc	r4, #-268435452	; 0xf0000004
    2a9c:	61450035 	cmpvs	r5, r5, lsr r0
    2aa0:	50457973 	subpl	r7, r5, r3, ror r9
    2aa4:	0074726f 	rsbseq	r7, r4, pc, ror #4
    2aa8:	726f5045 	rsbvc	r5, pc, #69	; 0x45
    2aac:	745f4474 	ldrbvc	r4, [pc], #1140	; 2ab4 <__Stack_Size+0x26b4>
    2ab0:	464f4a00 	strbmi	r4, [pc], -r0, lsl #20
    2ab4:	45003352 	strmi	r3, [r0, #-850]
    2ab8:	54524f50 	ldrbpl	r4, [r2], #-3920
    2abc:	4a003531 	bmi	ff88 <__Stack_Size+0xfb88>
    2ac0:	3452464f 	ldrbcc	r4, [r2], #-1615
    2ac4:	61655200 	cmnvs	r5, r0, lsl #4
    2ac8:	616e4164 	cmnvs	lr, r4, ror #2
    2acc:	00676f6c 	rsbeq	r6, r7, ip, ror #30
    2ad0:	524f5045 	subpl	r5, pc, #69	; 0x45
    2ad4:	00313454 	eorseq	r3, r1, r4, asr r4
    2ad8:	524f5045 	subpl	r5, pc, #69	; 0x45
    2adc:	00353454 	eorseq	r3, r5, r4, asr r4
    2ae0:	74726f70 	ldrbtvc	r6, [r2], #-3952
    2ae4:	6f504500 	svcvs	0x00504500
    2ae8:	5f417472 	svcpl	0x00417472
    2aec:	51530074 	cmppl	r3, r4, ror r0
    2af0:	53003152 	movwpl	r3, #338	; 0x152
    2af4:	00325251 	eorseq	r5, r2, r1, asr r2
    2af8:	33525153 	cmpcc	r2, #-1073741804	; 0xc0000014
    2afc:	4f504500 	svcmi	0x00504500
    2b00:	31315452 	teqcc	r1, r2, asr r4
    2b04:	73614500 	cmnvc	r1, #0	; 0x0
    2b08:	726f5079 	rsbvc	r5, pc, #121	; 0x79
    2b0c:	00735f74 	rsbseq	r5, r3, r4, ror pc
    2b10:	79736145 	ldmdbvc	r3!, {r0, r2, r6, r8, sp, lr}^
    2b14:	74726f50 	ldrbtvc	r6, [r2], #-3920
    2b18:	5300745f 	movwpl	r7, #1119	; 0x45f
    2b1c:	3152504d 	cmpcc	r2, sp, asr #32
    2b20:	504d5300 	subpl	r5, sp, r0, lsl #6
    2b24:	4c003252 	sfmmi	f3, 4, [r0], {82}
    2b28:	00524b43 	subseq	r4, r2, r3, asr #22
    2b2c:	524f5045 	subpl	r5, pc, #69	; 0x45
    2b30:	00313554 	eorseq	r3, r1, r4, asr r5
    2b34:	524f5045 	subpl	r5, pc, #69	; 0x45
    2b38:	00353554 	eorseq	r3, r5, r4, asr r5
    2b3c:	74747542 	ldrbtvc	r7, [r4], #-1346
    2b40:	745f6e6f 	ldrbvc	r6, [pc], #3695	; 2b48 <__Stack_Size+0x2748>
    2b44:	73614500 	cmnvc	r1, #0	; 0x0
    2b48:	74754279 	ldrbtvc	r4, [r5], #-633
    2b4c:	006e6f74 	rsbeq	r6, lr, r4, ror pc
    2b50:	64616552 	strbtvs	r6, [r1], #-1362
    2b54:	74747542 	ldrbtvc	r7, [r4], #-1346
    2b58:	43006e6f 	movwmi	r6, #3695	; 0xe6f
    2b5c:	3033354d 	eorscc	r3, r3, sp, asr #10
    2b60:	2f57485f 	svccs	0x0057485f
    2b64:	2f637273 	svccs	0x00637273
    2b68:	74747562 	ldrbtvc	r7, [r4], #-1378
    2b6c:	632e6e6f 	teqvs	lr, #1776	; 0x6f0
    2b70:	74756200 	ldrbtvc	r6, [r5], #-512
    2b74:	006e6f74 	rsbeq	r6, lr, r4, ror pc
    2b78:	33354d43 	teqcc	r5, #4288	; 0x10c0
    2b7c:	57485f30 	smlaldxpl	r5, r8, r0, pc
    2b80:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    2b84:	64656c2f 	strbtvs	r6, [r5], #-3119
    2b88:	4c00632e 	stcmi	3, cr6, [r0], {46}
    2b8c:	745f4445 	ldrbvc	r4, [pc], #1093	; 2b94 <__Stack_Size+0x2794>
    2b90:	74655300 	strbtvc	r5, [r5], #-768
    2b94:	0044454c 	subeq	r4, r4, ip, asr #10
    2b98:	79736145 	ldmdbvc	r3!, {r0, r2, r6, r8, sp, lr}^
    2b9c:	0044454c 	subeq	r4, r4, ip, asr #10
    2ba0:	65746f6e 	ldrbvs	r6, [r4, #-3950]!
    2ba4:	6e6f7400 	cdpvs	4, 6, cr7, cr15, cr0, {0}
    2ba8:	75620065 	strbvc	r0, [r2, #-101]!
    2bac:	64657a7a 	strbtvs	r7, [r5], #-2682
    2bb0:	746f6e5f 	strbtvc	r6, [pc], #3679	; 2bb8 <__Stack_Size+0x27b8>
    2bb4:	00745f65 	rsbseq	r5, r4, r5, ror #30
    2bb8:	6e656c6d 	cdpvs	12, 6, cr6, cr5, cr13, {3}
    2bbc:	00687467 	rsbeq	r7, r8, r7, ror #8
    2bc0:	6174636f 	cmnvs	r4, pc, ror #6
    2bc4:	50006576 	andpl	r6, r0, r6, ror r5
    2bc8:	4e79616c 	rpwmiez	f6, f1, #4.0
    2bcc:	0065746f 	rsbeq	r7, r5, pc, ror #8
    2bd0:	75426c67 	strbvc	r6, [r2, #-3175]
    2bd4:	72657a7a 	rsbvc	r7, r5, #499712	; 0x7a000
    2bd8:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    2bdc:	00726574 	rsbseq	r6, r2, r4, ror r5
    2be0:	7a7a7542 	bvc	1ea00f0 <__Stack_Size+0x1e9fcf0>
    2be4:	43006465 	movwmi	r6, #1125	; 0x465
    2be8:	3033354d 	eorscc	r3, r3, sp, asr #10
    2bec:	2f57485f 	svccs	0x0057485f
    2bf0:	2f637273 	svccs	0x00637273
    2bf4:	2e63696d 	cdpcs	9, 6, cr6, cr3, cr13, {3}
    2bf8:	546e0063 	strbtpl	r0, [lr], #-99
    2bfc:	00656d69 	rsbeq	r6, r5, r9, ror #26
    2c00:	6c65446d 	cfstrdvs	mvd4, [r5], #-436
    2c04:	6d007961 	stcvs	9, cr7, [r0, #-388]
    2c08:	6f726369 	svcvs	0x00726369
    2c0c:	53490073 	movtpl	r0, #36979	; 0x9073
    2c10:	65445f52 	strbvs	r5, [r4, #-3922]
    2c14:	5f79616c 	svcpl	0x0079616c
    2c18:	65736142 	ldrbvs	r6, [r3, #-322]!
    2c1c:	354d4300 	strbcc	r4, [sp, #-768]
    2c20:	485f3033 	ldmdami	pc, {r0, r1, r4, r5, ip, sp}^
    2c24:	72732f57 	rsbsvc	r2, r3, #348	; 0x15c
    2c28:	79732f63 	ldmdbvc	r3!, {r0, r1, r5, r6, r8, r9, sl, fp, sp}^
    2c2c:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    2c30:	6e75665f 	mrcvs	6, 3, r6, cr5, cr15, {2}
    2c34:	00632e63 	rsbeq	r2, r3, r3, ror #28
    2c38:	4d746567 	cfldr64mi	mvdx6, [r4, #-412]!
    2c3c:	696c6c69 	stmdbvs	ip!, {r0, r3, r5, r6, sl, fp, sp, lr}^
    2c40:	6c670073 	stclvs	0, cr0, [r7], #-460
    2c44:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    2c48:	776f6474 	undefined
    2c4c:	756f436e 	strbvc	r4, [pc, #-878]!	; 28e6 <__Stack_Size+0x24e6>
    2c50:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    2c54:	446c6700 	strbtmi	r6, [ip], #-1792
    2c58:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
    2c5c:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    2c60:	00726574 	rsbseq	r6, r2, r4, ror r5
    2c64:	63506c67 	cmpvs	r0, #26368	; 0x6700
    2c68:	6d695475 	cfstrdvs	mvd5, [r9, #-468]!
    2c6c:	74756f65 	ldrbtvc	r6, [r5], #-3941
    2c70:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    2c74:	00726574 	rsbseq	r6, r2, r4, ror r5
    2c78:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
    2c7c:	756f4374 	strbvc	r4, [pc, #-884]!	; 2910 <__Stack_Size+0x2510>
    2c80:	6f64746e 	svcvs	0x0064746e
    2c84:	75006e77 	strvc	r6, [r0, #-3703]
    2c88:	616c6544 	cmnvs	ip, r4, asr #10
    2c8c:	736d0079 	cmnvc	sp, #121	; 0x79
    2c90:	6c6c694d 	stclvs	9, cr6, [ip], #-308
    2c94:	5f007369 	svcpl	0x00007369
    2c98:	5253495f 	subspl	r4, r3, #1556480	; 0x17c000
    2c9c:	5359535f 	cmppl	r9, #2080374785	; 0x7c000001
    2ca0:	4b434954 	blmi	10d51f8 <__Stack_Size+0x10d4df8>
    2ca4:	61747300 	cmnvs	r4, r0, lsl #6
    2ca8:	745f7472 	ldrbvc	r7, [pc], #1138	; 2cb0 <__Stack_Size+0x28b0>
    2cac:	6f656d69 	svcvs	0x00656d69
    2cb0:	645f7475 	ldrbvs	r7, [pc], #1141	; 2cb8 <__Stack_Size+0x28b8>
    2cb4:	6d006c78 	stcvs	12, cr6, [r0, #-480]
    2cb8:	73795373 	cmnvc	r9, #-872415231	; 0xcc000001
    2cbc:	6b636974 	blvs	18dd294 <__Stack_Size+0x18dce94>
    2cc0:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    2cc4:	00726574 	rsbseq	r6, r2, r4, ror r5
    2cc8:	78446c67 	stmdavc	r4, {r0, r1, r2, r5, r6, sl, fp, sp, lr}^
    2ccc:	6d69546c 	cfstrdvs	mvd5, [r9, #-432]!
    2cd0:	74756f65 	ldrbtvc	r6, [r5], #-3941
    2cd4:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    2cd8:	00726574 	rsbseq	r6, r2, r4, ror r5
    2cdc:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    2ce0:	6f635f74 	svcvs	0x00635f74
    2ce4:	64746e75 	ldrbtvs	r6, [r4], #-3701
    2ce8:	5f6e776f 	svcpl	0x006e776f
    2cec:	7a7a7562 	bvc	1ea027c <__Stack_Size+0x1e9fe7c>
    2cf0:	73007265 	movwvc	r7, #613	; 0x265
    2cf4:	74726174 	ldrbtvc	r6, [r2], #-372
    2cf8:	6d69745f 	cfstrdvs	mvd7, [r9, #-380]!
    2cfc:	74756f65 	ldrbtvc	r6, [r5], #-3941
    2d00:	7563705f 	strbvc	r7, [r3, #-95]!
    2d04:	43626700 	cmnmi	r2, #0	; 0x0
    2d08:	746e756f 	strbtvc	r7, [lr], #-1391
    2d0c:	6f437265 	svcvs	0x00437265
    2d10:	00746e75 	rsbseq	r6, r4, r5, ror lr
    2d14:	4f495047 	svcmi	0x00495047
    2d18:	6e69505f 	mcrvs	0, 3, r5, cr9, cr15, {2}
    2d1c:	43444100 	movtmi	r4, #16640	; 0x4100
    2d20:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    2d24:	72745374 	rsbsvc	r5, r4, #-805306367	; 0xd0000001
    2d28:	75746375 	ldrbvc	r6, [r4, #-885]!
    2d2c:	4e006572 	cfrshl64mi	mvdx0, mvdx2, r6
    2d30:	5f434956 	svcpl	0x00434956
    2d34:	43515249 	cmpmi	r1, #-1879048188	; 0x90000004
    2d38:	6e6e6168 	powvsez	f6, f6, #0.0
    2d3c:	6d436c65 	stclvs	12, cr6, [r3, #-404]
    2d40:	44410064 	strbmi	r0, [r1], #-100
    2d44:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    2d48:	79547469 	ldmdbvc	r4, {r0, r3, r5, r6, sl, ip, sp, lr}^
    2d4c:	65446570 	strbvs	r6, [r4, #-1392]
    2d50:	50470066 	subpl	r0, r7, r6, rrx
    2d54:	6f4d4f49 	svcvs	0x004d4f49
    2d58:	545f6564 	ldrbpl	r6, [pc], #1380	; 2d60 <__Stack_Size+0x2960>
    2d5c:	44657079 	strbtmi	r7, [r5], #-121
    2d60:	43006665 	movwmi	r6, #1637	; 0x665
    2d64:	3033354d 	eorscc	r3, r3, sp, asr #10
    2d68:	2f57485f 	svccs	0x0057485f
    2d6c:	2f637273 	svccs	0x00637273
    2d70:	74737973 	ldrbtvc	r7, [r3], #-2419
    2d74:	695f6d65 	ldmdbvs	pc, {r0, r2, r5, r6, r8, sl, fp, sp, lr}^
    2d78:	2e74696e 	cdpcs	9, 7, cr6, cr4, cr14, {3}
    2d7c:	44410063 	strbmi	r0, [r1], #-99
    2d80:	63535f43 	cmpvs	r3, #268	; 0x10c
    2d84:	6f436e61 	svcvs	0x00436e61
    2d88:	6f4d766e 	svcvs	0x004d766e
    2d8c:	47006564 	strmi	r6, [r0, -r4, ror #10]
    2d90:	5f4f4950 	svcpl	0x004f4950
    2d94:	65657053 	strbvs	r7, [r5, #-83]!
    2d98:	79530064 	ldmdbvc	r3, {r2, r5, r6}^
    2d9c:	696e4973 	stmdbvs	lr!, {r0, r1, r4, r5, r6, r8, fp, lr}^
    2da0:	564e0074 	undefined
    2da4:	495f4349 	ldmdbmi	pc, {r0, r3, r6, r8, r9, lr}^
    2da8:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
    2dac:	656e6e61 	strbvs	r6, [lr, #-3681]!
    2db0:	6275536c 	rsbsvs	r5, r5, #-1342177279	; 0xb0000001
    2db4:	6f697250 	svcvs	0x00697250
    2db8:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    2dbc:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    2dc0:	6f4d5f4f 	svcvs	0x004d5f4f
    2dc4:	4f5f6564 	svcmi	0x005f6564
    2dc8:	4f5f7475 	svcmi	0x005f7475
    2dcc:	50470044 	subpl	r0, r7, r4, asr #32
    2dd0:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]
    2dd4:	5f65646f 	svcpl	0x0065646f
    2dd8:	505f4641 	subspl	r4, pc, r1, asr #12
    2ddc:	53480050 	movtpl	r0, #32848	; 0x8050
    2de0:	61745345 	cmnvs	r4, r5, asr #6
    2de4:	70557472 	subsvc	r7, r5, r2, ror r4
    2de8:	74617453 	strbtvc	r7, [r1], #-1107
    2dec:	4e007375 	mcrmi	3, 0, r7, cr0, cr5, {3}
    2df0:	5f434956 	svcpl	0x00434956
    2df4:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2df8:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
    2dfc:	6f697461 	svcvs	0x00697461
    2e00:	4352006e 	cmpmi	r2, #110	; 0x6e
    2e04:	6f435f43 	svcvs	0x00435f43
    2e08:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2e0c:	74617275 	strbtvc	r7, [r1], #-629
    2e10:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2e14:	6f727245 	svcvs	0x00727245
    2e18:	61745372 	cmnvs	r4, r2, ror r3
    2e1c:	00737574 	rsbseq	r7, r3, r4, ror r5
    2e20:	4f495047 	svcmi	0x00495047
    2e24:	6570535f 	ldrbvs	r5, [r0, #-863]!
    2e28:	315f6465 	cmpcc	pc, r5, ror #8
    2e2c:	7a484d30 	bvc	12162f4 <__Stack_Size+0x1215ef4>
    2e30:	43444100 	movtmi	r4, #16640	; 0x4100
    2e34:	646f4d5f 	strbtvs	r4, [pc], #3423	; 2e3c <__Stack_Size+0x2a3c>
    2e38:	50470065 	subpl	r0, r7, r5, rrx
    2e3c:	535f4f49 	cmppl	pc, #292	; 0x124
    2e40:	64656570 	strbtvs	r6, [r5], #-1392
    2e44:	484d325f 	stmdami	sp, {r0, r1, r2, r3, r4, r6, r9, ip, sp}^
    2e48:	5047007a 	subpl	r0, r7, sl, ror r0
    2e4c:	435f4f49 	cmpmi	pc, #292	; 0x124
    2e50:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2e54:	61727567 	cmnvs	r2, r7, ror #10
    2e58:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2e5c:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    2e60:	6e495f4f 	cdpvs	15, 4, cr5, cr9, cr15, {2}
    2e64:	79547469 	ldmdbvc	r4, {r0, r3, r5, r6, sl, ip, sp, lr}^
    2e68:	65446570 	strbvs	r6, [r4, #-1392]
    2e6c:	44410066 	strbmi	r0, [r1], #-102
    2e70:	624e5f43 	subvs	r5, lr, #268	; 0x10c
    2e74:	43664f72 	cmnmi	r6, #456	; 0x1c8
    2e78:	6e6e6168 	powvsez	f6, f6, #0.0
    2e7c:	41006c65 	tstmi	r0, r5, ror #24
    2e80:	445f4344 	ldrbmi	r4, [pc], #836	; 2e88 <__Stack_Size+0x2a88>
    2e84:	41617461 	cmnmi	r1, r1, ror #8
    2e88:	6e67696c 	cdpvs	9, 6, cr6, cr7, cr12, {3}
    2e8c:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    2e90:	6f4d5f4f 	svcvs	0x004d5f4f
    2e94:	495f6564 	ldmdbmi	pc, {r2, r5, r6, r8, sl, sp, lr}^
    2e98:	47004450 	smlsdmi	r0, r0, r4, r4
    2e9c:	5f4f4950 	svcpl	0x004f4950
    2ea0:	65657053 	strbvs	r7, [r5, #-83]!
    2ea4:	30355f64 	eorscc	r5, r5, r4, ror #30
    2ea8:	007a484d 	rsbseq	r4, sl, sp, asr #16
    2eac:	4349564e 	movtmi	r5, #38478	; 0x964e
    2eb0:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    2eb4:	72745374 	rsbsvc	r5, r4, #-805306367	; 0xd0000001
    2eb8:	75746375 	ldrbvc	r6, [r4, #-885]!
    2ebc:	41006572 	tstmi	r0, r2, ror r5
    2ec0:	435f4344 	cmpmi	pc, #268435457	; 0x10000001
    2ec4:	69746e6f 	ldmdbvs	r4!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2ec8:	756f756e 	strbvc	r7, [pc, #-1390]!	; 2962 <__Stack_Size+0x2562>
    2ecc:	6e6f4373 	mcrvs	3, 3, r4, cr15, cr3, {3}
    2ed0:	646f4d76 	strbtvs	r4, [pc], #3446	; 2ed8 <__Stack_Size+0x2ad8>
    2ed4:	564e0065 	strbpl	r0, [lr], -r5, rrx
    2ed8:	495f4349 	ldmdbmi	pc, {r0, r3, r6, r8, r9, lr}^
    2edc:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
    2ee0:	656e6e61 	strbvs	r6, [lr, #-3681]!
    2ee4:	4441006c 	strbmi	r0, [r1], #-108
    2ee8:	6f435f43 	svcvs	0x00435f43
    2eec:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2ef0:	74617275 	strbtvc	r7, [r1], #-629
    2ef4:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2ef8:	4f495047 	svcmi	0x00495047
    2efc:	646f4d5f 	strbtvs	r4, [pc], #3423	; 2f04 <__Stack_Size+0x2b04>
    2f00:	50495f65 	subpl	r5, r9, r5, ror #30
    2f04:	44410055 	strbmi	r0, [r1], #-85
    2f08:	78455f43 	stmdavc	r5, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    2f0c:	6e726574 	mrcvs	5, 3, r6, cr2, cr4, {3}
    2f10:	72546c61 	subsvc	r6, r4, #24832	; 0x6100
    2f14:	6f436769 	svcvs	0x00436769
    2f18:	4700766e 	strmi	r7, [r0, -lr, ror #12]
    2f1c:	5f4f4950 	svcpl	0x004f4950
    2f20:	65646f4d 	strbvs	r6, [r4, #-3917]!
    2f24:	4e49415f 	mcrmi	1, 2, r4, cr9, cr15, {2}
    2f28:	41535500 	cmpmi	r3, r0, lsl #10
    2f2c:	435f5452 	cmpmi	pc, #1375731712	; 0x52000000
    2f30:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    2f34:	61727567 	cmnvs	r2, r7, ror #10
    2f38:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    2f3c:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2f40:	52495f43 	subpl	r5, r9, #268	; 0x10c
    2f44:	61684351 	cmnvs	r8, r1, asr r3
    2f48:	6c656e6e 	stclvs	14, cr6, [r5], #-440
    2f4c:	65657250 	strbvs	r7, [r5, #-592]!
    2f50:	6974706d 	ldmdbvs	r4!, {r0, r2, r3, r5, r6, ip, sp, lr}^
    2f54:	72506e6f 	subsvc	r6, r0, #1776	; 0x6f0
    2f58:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    2f5c:	47007974 	smlsdxmi	r0, r4, r9, r7
    2f60:	534f4950 	movtpl	r4, #63824	; 0xf950
    2f64:	64656570 	strbtvs	r6, [r5], #-1392
    2f68:	7079545f 	rsbsvc	r5, r9, pc, asr r4
    2f6c:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    2f70:	6e754600 	cdpvs	6, 7, cr4, cr5, cr0, {0}
    2f74:	6f697463 	svcvs	0x00697463
    2f78:	536c616e 	cmnpl	ip, #-2147483621	; 0x8000001b
    2f7c:	65746174 	ldrbvs	r6, [r4, #-372]!
    2f80:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    2f84:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    2f88:	79547469 	ldmdbvc	r4, {r0, r3, r5, r6, sl, ip, sp, lr}^
    2f8c:	65446570 	strbvs	r6, [r4, #-1392]
    2f90:	50470066 	subpl	r0, r7, r6, rrx
    2f94:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]
    2f98:	5f65646f 	svcpl	0x0065646f
    2f9c:	5f74754f 	svcpl	0x0074754f
    2fa0:	47005050 	smlsdmi	r0, r0, r0, r5
    2fa4:	5f4f4950 	svcpl	0x004f4950
    2fa8:	74696e49 	strbtvc	r6, [r9], #-3657
    2fac:	75727453 	ldrbvc	r7, [r2, #-1107]!
    2fb0:	72757463 	rsbsvc	r7, r5, #1660944384	; 0x63000000
    2fb4:	79530065 	ldmdbvc	r3, {r0, r2, r5, r6}^
    2fb8:	63695473 	cmnvs	r9, #1929379840	; 0x73000000
    2fbc:	6f435f6b 	svcvs	0x00435f6b
    2fc0:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    2fc4:	74617275 	strbtvc	r7, [r1], #-629
    2fc8:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    2fcc:	4f495047 	svcmi	0x00495047
    2fd0:	646f4d5f 	strbtvs	r4, [pc], #3423	; 2fd8 <__Stack_Size+0x2bd8>
    2fd4:	4e495f65 	cdpmi	15, 4, cr5, cr9, cr5, {3}
    2fd8:	4f4c465f 	svcmi	0x004c465f
    2fdc:	4e495441 	cdpmi	4, 4, cr5, cr9, cr1, {2}
    2fe0:	50470047 	subpl	r0, r7, r7, asr #32
    2fe4:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]
    2fe8:	5f65646f 	svcpl	0x0065646f
    2fec:	4f5f4641 	svcmi	0x005f4641
    2ff0:	50470044 	subpl	r0, r7, r4, asr #32
    2ff4:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]
    2ff8:	0065646f 	rsbeq	r6, r5, pc, ror #8
    2ffc:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    3000:	6e495f54 	mcrvs	15, 2, r5, cr9, cr4, {2}
    3004:	74537469 	ldrbvc	r7, [r3], #-1129
    3008:	74637572 	strbtvc	r7, [r3], #-1394
    300c:	00657275 	rsbeq	r7, r5, r5, ror r2
    3010:	5f447852 	svcpl	0x00447852
    3014:	5f4c5844 	svcpl	0x004c5844
    3018:	65746e49 	ldrbvs	r6, [r4, #-3657]!
    301c:	70757272 	rsbsvc	r7, r5, r2, ror r2
    3020:	63700074 	cmnvs	r0, #116	; 0x74
    3024:	61685f75 	smcvs	34293
    3028:	65735f6c 	ldrbvs	r5, [r3, #-3948]!
    302c:	69745f74 	ldmdbvs	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    3030:	756f656d 	strbvc	r6, [pc, #-1389]!	; 2acb <__Stack_Size+0x26cb>
    3034:	78640074 	stmdavc	r4!, {r2, r4, r5, r6}^
    3038:	61685f6c 	cmnvs	r8, ip, ror #30
    303c:	78745f6c 	ldmdavc	r4!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    3040:	6c786400 	cfldrdvs	mvd6, [r8]
    3044:	6c61685f 	stclvs	8, cr6, [r1], #-380
    3048:	6f6c635f 	svcvs	0x006c635f
    304c:	70006573 	andvc	r6, r0, r3, ror r5
    3050:	6b636150 	blvs	18db598 <__Stack_Size+0x18db198>
    3054:	52007465 	andpl	r7, r0, #1694498816	; 0x65000000
    3058:	505f4478 	subspl	r4, pc, r8, ror r4
    305c:	495f5543 	ldmdbmi	pc, {r0, r1, r6, r8, sl, ip, lr}^
    3060:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    3064:	74707572 	ldrbtvc	r7, [r0], #-1394
    3068:	75637000 	strbvc	r7, [r3]!
    306c:	7475705f 	ldrbtvc	r7, [r5], #-95
    3070:	6575715f 	ldrbvs	r7, [r5, #-351]!
    3074:	55006575 	strpl	r6, [r0, #-1397]
    3078:	54524153 	ldrbpl	r4, [r2], #-339
    307c:	6f74535f 	svcvs	0x0074535f
    3080:	74694270 	strbtvc	r4, [r9], #-624
    3084:	63700073 	cmnvs	r0, #115	; 0x73
    3088:	75705f75 	ldrbvc	r5, [r0, #-3957]!
    308c:	79625f74 	stmdbvc	r2!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    3090:	52006574 	andpl	r6, r0, #486539264	; 0x1d000000
    3094:	52455345 	subpl	r5, r5, #335544321	; 0x14000001
    3098:	31444556 	cmpcc	r4, r6, asr r5
    309c:	75637000 	strbvc	r7, [r3]!
    30a0:	6565705f 	strbvs	r7, [r5, #-95]!
    30a4:	75715f6b 	ldrbvc	r5, [r1, #-3947]!
    30a8:	00657565 	rsbeq	r7, r5, r5, ror #10
    30ac:	5f756370 	svcpl	0x00756370
    30b0:	5f6c6168 	svcpl	0x006c6168
    30b4:	736f6c63 	cmnvc	pc, #25344	; 0x6300
    30b8:	53550065 	cmppl	r5, #101	; 0x65
    30bc:	5f545241 	svcpl	0x00545241
    30c0:	64726f57 	ldrbtvs	r6, [r2], #-3927
    30c4:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
    30c8:	70006874 	andvc	r6, r0, r4, ror r8
    30cc:	685f7563 	ldmdavs	pc, {r0, r1, r5, r6, r8, sl, ip, sp, lr}^
    30d0:	745f6c61 	ldrbvc	r6, [pc], #3169	; 30d8 <__Stack_Size+0x2cd8>
    30d4:	6f656d69 	svcvs	0x00656d69
    30d8:	55007475 	strpl	r7, [r0, #-1141]
    30dc:	54524153 	ldrbpl	r4, [r2], #-339
    30e0:	7561425f 	strbvc	r4, [r1, #-607]!
    30e4:	74615264 	strbtvc	r5, [r1], #-612
    30e8:	63700065 	cmnvs	r0, #101	; 0x65
    30ec:	65675f75 	strbvs	r5, [r7, #-3957]!
    30f0:	73715f74 	cmnvc	r1, #464	; 0x1d0
    30f4:	65746174 	ldrbvs	r6, [r4, #-372]!
    30f8:	75637000 	strbvc	r7, [r3]!
    30fc:	7465675f 	strbtvc	r6, [r5], #-1887
    3100:	6575715f 	ldrbvs	r7, [r5, #-351]!
    3104:	7a006575 	bvc	1c6e0 <__Stack_Size+0x1c2e0>
    3108:	685f6267 	ldmdavs	pc, {r0, r1, r2, r5, r6, r9, sp, lr}^
    310c:	635f6c61 	cmpvs	pc, #24832	; 0x6100
    3110:	65736f6c 	ldrbvs	r6, [r3, #-3948]!
    3114:	62677a00 	rsbvs	r7, r7, #0	; 0x0
    3118:	6c61685f 	stclvs	8, cr6, [r1], #-380
    311c:	0078745f 	rsbseq	r7, r8, pc, asr r4
    3120:	526d754e 	rsbpl	r7, sp, #327155712	; 0x13800000
    3124:	79427663 	stmdbvc	r2, {r0, r1, r5, r6, r9, sl, ip, sp, lr}^
    3128:	52006574 	andpl	r6, r0, #486539264	; 0x1d000000
    312c:	5a5f4478 	bpl	17d4314 <__Stack_Size+0x17d3f14>
    3130:	495f4749 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, lr}^
    3134:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    3138:	74707572 	ldrbtvc	r7, [r0], #-1394
    313c:	62677a00 	rsbvs	r7, r7, #0	; 0x0
    3140:	6c61685f 	stclvs	8, cr6, [r1], #-380
    3144:	65706f5f 	ldrbvs	r6, [r0, #-3935]!
    3148:	5355006e 	cmppl	r5, #110	; 0x6e
    314c:	5f545241 	svcpl	0x00545241
    3150:	69726150 	ldmdbvs	r2!, {r4, r6, r8, sp, lr}^
    3154:	47007974 	smlsdxmi	r0, r4, r9, r7
    3158:	00525054 	subseq	r5, r2, r4, asr r0
    315c:	5f6c7864 	svcpl	0x006c7864
    3160:	5f6c6168 	svcpl	0x006c6168
    3164:	61656c63 	cmnvs	r5, r3, ror #24
    3168:	78640072 	stmdavc	r4!, {r1, r4, r5, r6}^
    316c:	61685f6c 	cmnvs	r8, ip, ror #30
    3170:	706f5f6c 	rsbvc	r5, pc, ip, ror #30
    3174:	64006e65 	strvs	r6, [r0], #-3685
    3178:	685f6c78 	ldmdavs	pc, {r3, r4, r5, r6, sl, fp, sp, lr}^
    317c:	725f6c61 	subsvc	r6, pc, #24832	; 0x6100
    3180:	756e0078 	strbvc	r0, [lr, #-120]!
    3184:	6361506d 	cmnvs	r1, #109	; 0x6d
    3188:	0074656b 	rsbseq	r6, r4, fp, ror #10
    318c:	5f756370 	svcpl	0x00756370
    3190:	5f6c6168 	svcpl	0x006c6168
    3194:	6e65706f 	cdpvs	0, 6, cr7, cr5, cr15, {3}
    3198:	41535500 	cmpmi	r3, r0, lsl #10
    319c:	485f5452 	ldmdami	pc, {r1, r4, r6, sl, ip, lr}^
    31a0:	77647261 	strbvc	r7, [r4, -r1, ror #4]!
    31a4:	46657261 	strbtmi	r7, [r5], -r1, ror #4
    31a8:	43776f6c 	cmnmi	r7, #432	; 0x1b0
    31ac:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    31b0:	55006c6f 	strpl	r6, [r0, #-3183]
    31b4:	54524153 	ldrbpl	r4, [r2], #-339
    31b8:	646f4d5f 	strbtvs	r4, [pc], #3423	; 31c0 <__Stack_Size+0x2dc0>
    31bc:	4d430065 	stclmi	0, cr0, [r3, #-404]
    31c0:	5f303335 	svcpl	0x00303335
    31c4:	732f5748 	teqvc	pc, #18874368	; 0x1200000
    31c8:	752f6372 	strvc	r6, [pc, #-882]!	; 2e5e <__Stack_Size+0x2a5e>
    31cc:	74726173 	ldrbtvc	r6, [r2], #-371
    31d0:	5200632e 	andpl	r6, r0, #-1207959552	; 0xb8000000
    31d4:	52455345 	subpl	r5, r5, #335544321	; 0x14000001
    31d8:	30444556 	subcc	r4, r4, r6, asr r5
    31dc:	53455200 	movtpl	r5, #20992	; 0x5200
    31e0:	45565245 	ldrbmi	r5, [r6, #-581]
    31e4:	52003244 	andpl	r3, r0, #1073741828	; 0x40000004
    31e8:	52455345 	subpl	r5, r5, #335544321	; 0x14000001
    31ec:	33444556 	movtcc	r4, #17750	; 0x4556
    31f0:	53455200 	movtpl	r5, #20992	; 0x5200
    31f4:	45565245 	ldrbmi	r5, [r6, #-581]
    31f8:	52003444 	andpl	r3, r0, #1140850688	; 0x44000000
    31fc:	52455345 	subpl	r5, r5, #335544321	; 0x14000001
    3200:	35444556 	strbcc	r4, [r4, #-1366]
    3204:	53455200 	movtpl	r5, #20992	; 0x5200
    3208:	45565245 	ldrbmi	r5, [r6, #-581]
    320c:	70003644 	andvc	r3, r0, r4, asr #12
    3210:	635f7563 	cmpvs	pc, #415236096	; 0x18c00000
    3214:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    3218:	6575715f 	ldrbvs	r7, [r5, #-351]!
    321c:	64006575 	strvs	r6, [r0], #-1397
    3220:	685f6c78 	ldmdavs	pc, {r3, r4, r5, r6, sl, fp, sp, lr}^
    3224:	745f6c61 	ldrbvc	r6, [pc], #3169	; 322c <__Stack_Size+0x2e2c>
    3228:	6f656d69 	svcvs	0x00656d69
    322c:	64007475 	strvs	r7, [r0], #-1141
    3230:	685f6c78 	ldmdavs	pc, {r3, r4, r5, r6, sl, fp, sp, lr}^
    3234:	735f6c61 	cmpvc	pc, #24832	; 0x6100
    3238:	745f7465 	ldrbvc	r7, [pc], #1125	; 3240 <__Stack_Size+0x2e40>
    323c:	6f656d69 	svcvs	0x00656d69
    3240:	7a007475 	bvc	2041c <__Stack_Size+0x2001c>
    3244:	685f6267 	ldmdavs	pc, {r0, r1, r2, r5, r6, r9, sp, lr}^
    3248:	725f6c61 	subsvc	r6, pc, #24832	; 0x6100
    324c:	53550078 	cmppl	r5, #120	; 0x78
    3250:	5f545241 	svcpl	0x00545241
    3254:	74696e49 	strbtvc	r6, [r9], #-3657
    3258:	65707954 	ldrbvs	r7, [r0, #-2388]!
    325c:	00666544 	rsbeq	r6, r6, r4, asr #10
    3260:	64785462 	ldrbtvs	r5, [r8], #-1122
    3264:	61746144 	cmnvs	r4, r4, asr #2
    3268:	43444100 	movtmi	r4, #16640	; 0x4100
    326c:	6d740078 	ldclvs	0, cr0, [r4, #-480]!
    3270:	67657270 	undefined
    3274:	44410031 	strbmi	r0, [r1], #-49
    3278:	6e415f43 	cdpvs	15, 4, cr5, cr1, cr3, {2}
    327c:	676f6c61 	strbvs	r6, [pc, -r1, ror #24]!
    3280:	63746157 	cmnvs	r4, #-1073741803	; 0xc0000015
    3284:	676f6468 	strbvs	r6, [pc, -r8, ror #8]!
    3288:	00646d43 	rsbeq	r6, r4, r3, asr #26
    328c:	5f434441 	svcpl	0x00434441
    3290:	6f435449 	svcvs	0x00435449
    3294:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    3298:	43444100 	movtmi	r4, #16640	; 0x4100
    329c:	7465475f 	strbtvc	r4, [r5], #-1887
    32a0:	74666f53 	strbtvc	r6, [r6], #-3923
    32a4:	65726177 	ldrbvs	r6, [r2, #-375]!
    32a8:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
    32ac:	6a6e4974 	bvs	1b95884 <__Stack_Size+0x1b95484>
    32b0:	65746365 	ldrbvs	r6, [r4, #-869]!
    32b4:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    32b8:	646d4376 	strbtvs	r4, [sp], #-886
    32bc:	74617453 	strbtvc	r7, [r1], #-1107
    32c0:	41007375 	tstmi	r0, r5, ror r3
    32c4:	435f4344 	cmpmi	pc, #268435457	; 0x10000001
    32c8:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    32cc:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    32d0:	43444100 	movtmi	r4, #16640	; 0x4100
    32d4:	7465475f 	strbtvc	r4, [r5], #-1887
    32d8:	74535449 	ldrbvc	r5, [r3], #-1097
    32dc:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    32e0:	6d747300 	ldclvs	3, cr7, [r4]
    32e4:	31663233 	cmncc	r6, r3, lsr r2
    32e8:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    32ec:	732f6269 	teqvc	pc, #-1879048186	; 0x90000006
    32f0:	732f6372 	teqvc	pc, #-939524095	; 0xc8000001
    32f4:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    32f8:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    32fc:	6364615f 	cmnvs	r4, #-1073741801	; 0xc0000017
    3300:	4e00632e 	cdpmi	3, 0, cr6, cr0, cr14, {1}
    3304:	65626d75 	strbvs	r6, [r2, #-3445]!
    3308:	44410072 	strbmi	r0, [r1], #-114
    330c:	6d435f43 	stclvs	15, cr5, [r3, #-268]
    3310:	44410064 	strbmi	r0, [r1], #-100
    3314:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    3318:	74537469 	ldrbvc	r7, [r3], #-1129
    331c:	74637572 	strbtvc	r7, [r3], #-1394
    3320:	43444100 	movtmi	r4, #16640	; 0x4100
    3324:	616e415f 	cmnvs	lr, pc, asr r1
    3328:	57676f6c 	strbpl	r6, [r7, -ip, ror #30]!
    332c:	68637461 	stmdavs	r3!, {r0, r5, r6, sl, ip, sp, lr}^
    3330:	54676f64 	strbtpl	r6, [r7], #-3940
    3334:	73657268 	cmnvc	r5, #-2147483642	; 0x80000006
    3338:	646c6f68 	strbtvs	r6, [ip], #-3944
    333c:	6e6f4373 	mcrvs	3, 3, r4, cr15, cr3, {3}
    3340:	00676966 	rsbeq	r6, r7, r6, ror #18
    3344:	5f434441 	svcpl	0x00434441
    3348:	61656c43 	cmnvs	r5, r3, asr #24
    334c:	50544972 	subspl	r4, r4, r2, ror r9
    3350:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    3354:	6942676e 	stmdbvs	r2, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    3358:	44410074 	strbmi	r0, [r1], #-116
    335c:	65475f43 	strbvs	r5, [r7, #-3907]
    3360:	73655274 	cmnvc	r5, #1073741831	; 0x40000007
    3364:	61437465 	cmpvs	r3, r5, ror #8
    3368:	7262696c 	rsbvc	r6, r2, #1769472	; 0x1b0000
    336c:	6f697461 	svcvs	0x00697461
    3370:	6174536e 	cmnvs	r4, lr, ror #6
    3374:	00737574 	rsbseq	r7, r3, r4, ror r5
    3378:	5f434441 	svcpl	0x00434441
    337c:	47414c46 	strbmi	r4, [r1, -r6, asr #24]
    3380:	77654e00 	strbvc	r4, [r5, -r0, lsl #28]!
    3384:	74617453 	strbtvc	r7, [r1], #-1107
    3388:	44410065 	strbmi	r0, [r1], #-101
    338c:	6e415f43 	cdpvs	15, 4, cr5, cr1, cr3, {2}
    3390:	676f6c61 	strbvs	r6, [pc, -r1, ror #24]!
    3394:	63746157 	cmnvs	r4, #-1073741803	; 0xc0000015
    3398:	676f6468 	strbvs	r6, [pc, -r8, ror #8]!
    339c:	676e6953 	undefined
    33a0:	6843656c 	stmdavs	r3, {r2, r3, r5, r6, r8, sl, sp, lr}^
    33a4:	656e6e61 	strbvs	r6, [lr, #-3681]!
    33a8:	6e6f436c 	cdpvs	3, 6, cr4, cr15, cr12, {3}
    33ac:	00676966 	rsbeq	r6, r7, r6, ror #18
    33b0:	5f434441 	svcpl	0x00434441
    33b4:	75676552 	strbvc	r6, [r7, #-1362]!
    33b8:	4372616c 	cmnmi	r2, #27	; 0x1b
    33bc:	6e6e6168 	powvsez	f6, f6, #0.0
    33c0:	6f436c65 	svcvs	0x00436c65
    33c4:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    33c8:	616e6500 	cmnvs	lr, r0, lsl #10
    33cc:	73656c62 	cmnvc	r5, #25088	; 0x6200
    33d0:	75746174 	ldrbvc	r6, [r4, #-372]!
    33d4:	69480073 	stmdbvs	r8, {r0, r1, r4, r5, r6}^
    33d8:	68546867 	ldmdavs	r4, {r0, r1, r2, r5, r6, fp, sp, lr}^
    33dc:	68736572 	ldmdavs	r3!, {r1, r4, r5, r6, r8, sl, sp, lr}^
    33e0:	00646c6f 	rsbeq	r6, r4, pc, ror #24
    33e4:	5f434441 	svcpl	0x00434441
    33e8:	63736944 	cmnvs	r3, #1114112	; 0x110000
    33ec:	65646f4d 	strbvs	r6, [r4, #-3917]!
    33f0:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
    33f4:	436c656e 	cmnmi	ip, #461373440	; 0x1b800000
    33f8:	746e756f 	strbtvc	r7, [lr], #-1391
    33fc:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3400:	41006769 	tstmi	r0, r9, ror #14
    3404:	475f4344 	ldrbmi	r4, [pc, -r4, asr #6]
    3408:	6f437465 	svcvs	0x00437465
    340c:	7265766e 	rsbvc	r7, r5, #115343360	; 0x6e00000
    3410:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
    3414:	756c6156 	strbvc	r6, [ip, #-342]!
    3418:	6d740065 	ldclvs	0, cr0, [r4, #-404]!
    341c:	67657270 	undefined
    3420:	6e615200 	cdpvs	2, 6, cr5, cr1, cr0, {0}
    3424:	4441006b 	strbmi	r0, [r1], #-107
    3428:	75415f43 	strbvc	r5, [r1, #-3907]
    342c:	6e496f74 	mcrvs	15, 2, r6, cr9, cr4, {3}
    3430:	7463656a 	strbtvc	r6, [r3], #-1386
    3434:	6f436465 	svcvs	0x00436465
    3438:	6d43766e 	stclvs	6, cr7, [r3, #-440]
    343c:	44410064 	strbmi	r0, [r1], #-100
    3440:	78455f43 	stmdavc	r5, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    3444:	6e726574 	mrcvs	5, 3, r6, cr2, cr4, {3}
    3448:	72546c61 	subsvc	r6, r4, #24832	; 0x6100
    344c:	6f436769 	svcvs	0x00436769
    3450:	6d43766e 	stclvs	6, cr7, [r3, #-440]
    3454:	44410064 	strbmi	r0, [r1], #-100
    3458:	65475f43 	strbvs	r5, [r7, #-3907]
    345c:	666f5374 	undefined
    3460:	72617774 	rsbvc	r7, r1, #30408704	; 0x1d00000
    3464:	61745365 	cmnvs	r4, r5, ror #6
    3468:	6f437472 	svcvs	0x00437472
    346c:	7453766e 	ldrbvc	r7, [r3], #-1646
    3470:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    3474:	43444100 	movtmi	r4, #16640	; 0x4100
    3478:	7465535f 	strbtvc	r5, [r5], #-863
    347c:	656a6e49 	strbvs	r6, [sl, #-3657]!
    3480:	64657463 	strbtvs	r7, [r5], #-1123
    3484:	7366664f 	cmnvc	r6, #82837504	; 0x4f00000
    3488:	41007465 	tstmi	r0, r5, ror #8
    348c:	445f4344 	ldrbmi	r4, [pc], #836	; 3494 <__Stack_Size+0x3094>
    3490:	696e4965 	stmdbvs	lr!, {r0, r2, r5, r6, r8, fp, lr}^
    3494:	44410074 	strbmi	r0, [r1], #-116
    3498:	78455f43 	stmdavc	r5, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    349c:	6e726574 	mrcvs	5, 3, r6, cr2, cr4, {3}
    34a0:	72546c61 	subsvc	r6, r4, #24832	; 0x6100
    34a4:	6e496769 	cdpvs	7, 4, cr6, cr9, cr9, {3}
    34a8:	7463656a 	strbtvc	r6, [r3], #-1386
    34ac:	6f436465 	svcvs	0x00436465
    34b0:	6d43766e 	stclvs	6, cr7, [r3, #-440]
    34b4:	44410064 	strbmi	r0, [r1], #-100
    34b8:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    34bc:	7463656a 	strbtvc	r6, [r3], #-1386
    34c0:	69446465 	stmdbvs	r4, {r0, r2, r5, r6, sl, sp, lr}^
    34c4:	6f4d6373 	svcvs	0x004d6373
    34c8:	6d436564 	cfstr64vs	mvdx6, [r3, #-400]
    34cc:	44410064 	strbmi	r0, [r1], #-100
    34d0:	78455f43 	stmdavc	r5, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    34d4:	6e726574 	mrcvs	5, 3, r6, cr2, cr4, {3}
    34d8:	72546c61 	subsvc	r6, r4, #24832	; 0x6100
    34dc:	6e496769 	cdpvs	7, 4, cr6, cr9, cr9, {3}
    34e0:	7463656a 	strbtvc	r6, [r3], #-1386
    34e4:	6f436465 	svcvs	0x00436465
    34e8:	6f43766e 	svcvs	0x0043766e
    34ec:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    34f0:	776f4c00 	strbvc	r4, [pc, -r0, lsl #24]!
    34f4:	65726854 	ldrbvs	r6, [r2, #-2132]!
    34f8:	6c6f6873 	stclvs	8, cr6, [pc], #-460
    34fc:	44410064 	strbmi	r0, [r1], #-100
    3500:	65475f43 	strbvs	r5, [r7, #-3907]
    3504:	6a6e4974 	bvs	1b95adc <__Stack_Size+0x1b956dc>
    3508:	65746365 	ldrbvs	r6, [r4, #-869]!
    350c:	6e6f4364 	cdpvs	3, 6, cr4, cr15, cr4, {3}
    3510:	73726576 	cmnvc	r2, #494927872	; 0x1d800000
    3514:	566e6f69 	strbtpl	r6, [lr], -r9, ror #30
    3518:	65756c61 	ldrbvs	r6, [r5, #-3169]!
    351c:	43444100 	movtmi	r4, #16640	; 0x4100
    3520:	6168435f 	cmnvs	r8, pc, asr r3
    3524:	6c656e6e 	stclvs	14, cr6, [r5], #-440
    3528:	43444100 	movtmi	r4, #16640	; 0x4100
    352c:	6174535f 	cmnvs	r4, pc, asr r3
    3530:	61437472 	cmpvs	r3, r2, ror r4
    3534:	7262696c 	rsbvc	r6, r2, #1769472	; 0x1b0000
    3538:	6f697461 	svcvs	0x00697461
    353c:	6d74006e 	ldclvs	0, cr0, [r4, #-440]!
    3540:	67657270 	undefined
    3544:	6d740032 	ldclvs	0, cr0, [r4, #-200]!
    3548:	67657270 	undefined
    354c:	44410033 	strbmi	r0, [r1], #-51
    3550:	65475f43 	strbvs	r5, [r7, #-3907]
    3554:	6c614374 	stclvs	3, cr4, [r1], #-464
    3558:	61726269 	cmnvs	r2, r9, ror #4
    355c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    3560:	74617453 	strbtvc	r7, [r1], #-1107
    3564:	62007375 	andvs	r7, r0, #-738197503	; 0xd4000001
    3568:	74737469 	ldrbtvc	r7, [r3], #-1129
    356c:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    3570:	43444100 	movtmi	r4, #16640	; 0x4100
    3574:	666f535f 	undefined
    3578:	72617774 	rsbvc	r7, r1, #30408704	; 0x1d00000
    357c:	61745365 	cmnvs	r4, r5, ror #6
    3580:	6f437472 	svcvs	0x00437472
    3584:	6d43766e 	stclvs	6, cr7, [r3, #-440]
    3588:	44410064 	strbmi	r0, [r1], #-100
    358c:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    3590:	7463656a 	strbtvc	r6, [r3], #-1386
    3594:	65536465 	ldrbvs	r6, [r3, #-1125]
    3598:	6e657571 	mcrvs	5, 3, r7, cr5, cr1, {3}
    359c:	4c726563 	cfldr64mi	mvdx6, [r2], #-396
    35a0:	74676e65 	strbtvc	r6, [r7], #-3685
    35a4:	6e6f4368 	cdpvs	3, 6, cr4, cr15, cr8, {3}
    35a8:	00676966 	rsbeq	r6, r7, r6, ror #18
    35ac:	5f434441 	svcpl	0x00434441
    35b0:	6c616e41 	stclvs	14, cr6, [r1], #-260
    35b4:	6157676f 	cmpvs	r7, pc, ror #14
    35b8:	64686374 	strbtvs	r6, [r8], #-884
    35bc:	4100676f 	tstmi	r0, pc, ror #14
    35c0:	495f4344 	ldmdbmi	pc, {r2, r6, r8, r9, lr}^
    35c4:	63656a6e 	cmnvs	r5, #450560	; 0x6e000
    35c8:	43646574 	cmnmi	r4, #486539264	; 0x1d000000
    35cc:	6e6e6168 	powvsez	f6, f6, #0.0
    35d0:	6f436c65 	svcvs	0x00436c65
    35d4:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    35d8:	43444100 	movtmi	r4, #16640	; 0x4100
    35dc:	6d61535f 	stclvs	3, cr5, [r1, #-380]!
    35e0:	54656c70 	strbtpl	r6, [r5], #-3184
    35e4:	00656d69 	rsbeq	r6, r5, r9, ror #26
    35e8:	5f434441 	svcpl	0x00434441
    35ec:	75727453 	ldrbvc	r7, [r2, #-1107]!
    35f0:	6e497463 	cdpvs	4, 4, cr7, cr9, cr3, {3}
    35f4:	41007469 	tstmi	r0, r9, ror #8
    35f8:	535f4344 	cmppl	pc, #268435457	; 0x10000001
    35fc:	7774666f 	ldrbvc	r6, [r4, -pc, ror #12]!
    3600:	53657261 	cmnpl	r5, #268435462	; 0x10000006
    3604:	74726174 	ldrbtvc	r6, [r2], #-372
    3608:	656a6e49 	strbvs	r6, [sl, #-3657]!
    360c:	64657463 	strbtvs	r7, [r5], #-1123
    3610:	766e6f43 	strbtvc	r6, [lr], -r3, asr #30
    3614:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3618:	5f434441 	svcpl	0x00434441
    361c:	656a6e49 	strbvs	r6, [sl, #-3657]!
    3620:	64657463 	strbtvs	r7, [r5], #-1123
    3624:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
    3628:	006c656e 	rsbeq	r6, ip, lr, ror #10
    362c:	5f434441 	svcpl	0x00434441
    3630:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    3634:	5367616c 	cmnpl	r7, #27	; 0x1b
    3638:	75746174 	ldrbvc	r6, [r4, #-372]!
    363c:	44410073 	strbmi	r0, [r1], #-115
    3640:	65545f43 	ldrbvs	r5, [r4, #-3907]
    3644:	6553706d 	ldrbvs	r7, [r3, #-109]
    3648:	726f736e 	rsbvc	r7, pc, #-1207959551	; 0xb8000001
    364c:	66657256 	undefined
    3650:	43746e69 	cmnmi	r4, #1680	; 0x690
    3654:	4100646d 	tstmi	r0, sp, ror #8
    3658:	445f4344 	ldrbmi	r4, [pc], #836	; 3660 <__Stack_Size+0x3260>
    365c:	4d637369 	stclmi	3, cr7, [r3, #-420]!
    3660:	4365646f 	cmnmi	r5, #1862270976	; 0x6f000000
    3664:	4100646d 	tstmi	r0, sp, ror #8
    3668:	525f4344 	subspl	r4, pc, #268435457	; 0x10000001
    366c:	74657365 	strbtvc	r7, [r5], #-869
    3670:	696c6143 	stmdbvs	ip!, {r0, r1, r6, r8, sp, lr}^
    3674:	74617262 	strbtvc	r7, [r1], #-610
    3678:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    367c:	5f434441 	svcpl	0x00434441
    3680:	69005449 	stmdbvs	r0, {r0, r3, r6, sl, ip, lr}
    3684:	73616d74 	cmnvc	r1, #7424	; 0x1d00
    3688:	4441006b 	strbmi	r0, [r1], #-107
    368c:	79545f43 	ldmdbvc	r4, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    3690:	65446570 	strbvs	r6, [r4, #-1392]
    3694:	44410066 	strbmi	r0, [r1], #-102
    3698:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    369c:	41007469 	tstmi	r0, r9, ror #8
    36a0:	455f4344 	ldrbmi	r4, [pc, #-836]	; 3364 <__Stack_Size+0x2f64>
    36a4:	72657478 	rsbvc	r7, r5, #2013265920	; 0x78000000
    36a8:	546c616e 	strbtpl	r6, [ip], #-366
    36ac:	49676972 	stmdbmi	r7!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    36b0:	63656a6e 	cmnvs	r5, #450560	; 0x6e000
    36b4:	766e6f43 	strbtvc	r6, [lr], -r3, asr #30
    36b8:	43444100 	movtmi	r4, #16640	; 0x4100
    36bc:	414d445f 	cmpmi	sp, pc, asr r4
    36c0:	00646d43 	rsbeq	r6, r4, r3, asr #26
    36c4:	5f434441 	svcpl	0x00434441
    36c8:	44746547 	ldrbtmi	r6, [r4], #-1351
    36cc:	4d6c6175 	stfmie	f6, [ip, #-468]!
    36d0:	4365646f 	cmnmi	r5, #1862270976	; 0x6f000000
    36d4:	65766e6f 	ldrbvs	r6, [r6, #-3695]!
    36d8:	6f697372 	svcvs	0x00697372
    36dc:	6c61566e 	stclvs	6, cr5, [r1], #-440
    36e0:	46006575 	undefined
    36e4:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    36e8:	4354495f 	cmpmi	r4, #1556480	; 0x17c000
    36ec:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    36f0:	424f0067 	submi	r0, pc, #103	; 0x67
    36f4:	4457495f 	ldrbmi	r4, [r7], #-2399
    36f8:	52570047 	subspl	r0, r7, #71	; 0x47
    36fc:	445f3250 	ldrbmi	r3, [pc], #592	; 3704 <__Stack_Size+0x3304>
    3700:	00617461 	rsbeq	r7, r1, r1, ror #8
    3704:	535f424f 	cmppl	pc, #-268435452	; 0xf0000004
    3708:	00504f54 	subseq	r4, r0, r4, asr pc
    370c:	53414c46 	movtpl	r4, #7238	; 0x1c46
    3710:	72455f48 	subvc	r5, r5, #288	; 0x120
    3714:	4f657361 	svcmi	0x00657361
    3718:	6f697470 	svcvs	0x00697470
    371c:	7479426e 	ldrbtvc	r4, [r9], #-622
    3720:	72007365 	andvc	r7, r0, #-1811939327	; 0x94000001
    3724:	6f646165 	svcvs	0x00646165
    3728:	74737475 	ldrbtvc	r7, [r3], #-1141
    372c:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    3730:	414c4600 	cmpmi	ip, r0, lsl #12
    3734:	455f4853 	ldrbmi	r4, [pc, #-2131]	; 2ee9 <__Stack_Size+0x2ae9>
    3738:	524f5252 	subpl	r5, pc, #536870917	; 0x20000005
    373c:	5052575f 	subspl	r5, r2, pc, asr r7
    3740:	414c4600 	cmpmi	ip, r0, lsl #12
    3744:	455f4853 	ldrbmi	r4, [pc, #-2131]	; 2ef9 <__Stack_Size+0x2af9>
    3748:	65736172 	ldrbvs	r6, [r3, #-370]!
    374c:	65676150 	strbvs	r6, [r7, #-336]!
    3750:	414c4600 	cmpmi	ip, r0, lsl #12
    3754:	4c5f4853 	mrrcmi	8, 5, r4, pc, cr3
    3758:	6e657461 	cdpvs	4, 6, cr7, cr5, cr1, {3}
    375c:	46007963 	strmi	r7, [r0], -r3, ror #18
    3760:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    3764:	7465475f 	strbtvc	r4, [r5], #-1887
    3768:	66657250 	undefined
    376c:	68637465 	stmdavs	r3!, {r0, r2, r5, r6, sl, ip, sp, lr}^
    3770:	66667542 	strbtvs	r7, [r6], -r2, asr #10
    3774:	74537265 	ldrbvc	r7, [r3], #-613
    3778:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    377c:	6c656400 	cfstrdvs	mvd6, [r5]
    3780:	57007961 	strpl	r7, [r0, -r1, ror #18]
    3784:	00525052 	subseq	r5, r2, r2, asr r0
    3788:	53414c46 	movtpl	r4, #7238	; 0x1c46
    378c:	6e555f48 	cdpvs	15, 5, cr5, cr5, cr8, {2}
    3790:	6b636f6c 	blvs	18df548 <__Stack_Size+0x18df148>
    3794:	414c4600 	cmpmi	ip, r0, lsl #12
    3798:	455f4853 	ldrbmi	r4, [pc, #-2131]	; 2f4d <__Stack_Size+0x2b4d>
    379c:	65736172 	ldrbvs	r6, [r3, #-370]!
    37a0:	506c6c41 	rsbpl	r6, ip, r1, asr #24
    37a4:	73656761 	cmnvc	r5, #25427968	; 0x1840000
    37a8:	414c4600 	cmpmi	ip, r0, lsl #12
    37ac:	535f4853 	cmppl	pc, #5439488	; 0x530000
    37b0:	75746174 	ldrbvc	r6, [r4, #-372]!
    37b4:	52570073 	subspl	r0, r7, #115	; 0x73
    37b8:	57003050 	smlsdpl	r0, r0, r0, r3
    37bc:	00315052 	eorseq	r5, r1, r2, asr r0
    37c0:	32505257 	subscc	r5, r0, #1879048197	; 0x70000005
    37c4:	50525700 	subspl	r5, r2, r0, lsl #14
    37c8:	4c460033 	mcrrmi	0, 3, r0, r6, cr3
    37cc:	5f485341 	svcpl	0x00485341
    37d0:	57746547 	ldrbpl	r6, [r4, -r7, asr #10]!
    37d4:	65746972 	ldrbvs	r6, [r4, #-2418]!
    37d8:	746f7250 	strbtvc	r7, [pc], #592	; 37e0 <__Stack_Size+0x33e0>
    37dc:	69746365 	ldmdbvs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    37e0:	704f6e6f 	subvc	r6, pc, pc, ror #28
    37e4:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    37e8:	65747942 	ldrbvs	r7, [r4, #-2370]!
    37ec:	54504f00 	ldrbpl	r4, [r0], #-3840
    37f0:	5259454b 	subspl	r4, r9, #314572800	; 0x12c00000
    37f4:	414c4600 	cmpmi	ip, r0, lsl #12
    37f8:	555f4853 	ldrbpl	r4, [pc, #-2131]	; 2fad <__Stack_Size+0x2bad>
    37fc:	4f726573 	svcmi	0x00726573
    3800:	6f697470 	svcvs	0x00697470
    3804:	7479426e 	ldrbtvc	r4, [r9], #-622
    3808:	6e6f4365 	cdpvs	3, 6, cr4, cr15, cr5, {3}
    380c:	00676966 	rsbeq	r6, r7, r6, ror #18
    3810:	53414c46 	movtpl	r4, #7238	; 0x1c46
    3814:	65525f48 	ldrbvs	r5, [r2, #-3912]
    3818:	754f6461 	strbvc	r6, [pc, #-1121]	; 33bf <__Stack_Size+0x2fbf>
    381c:	6f725074 	svcvs	0x00725074
    3820:	74636574 	strbtvc	r6, [r3], #-1396
    3824:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    3828:	73616c66 	cmnvc	r1, #26112	; 0x6600
    382c:	61747368 	cmnvs	r4, r8, ror #6
    3830:	00737574 	rsbseq	r7, r3, r4, ror r5
    3834:	65676150 	strbvs	r6, [r7, #-336]!
    3838:	6464415f 	strbtvs	r4, [r4], #-351
    383c:	73736572 	cmnvc	r3, #478150656	; 0x1c800000
    3840:	414c4600 	cmpmi	ip, r0, lsl #12
    3844:	455f4853 	ldrbmi	r4, [pc, #-2131]	; 2ff9 <__Stack_Size+0x2bf9>
    3848:	524f5252 	subpl	r5, pc, #536870917	; 0x20000005
    384c:	0047505f 	subeq	r5, r7, pc, asr r0
    3850:	53414c46 	movtpl	r4, #7238	; 0x1c46
    3854:	6f4c5f48 	svcvs	0x004c5f48
    3858:	57006b63 	strpl	r6, [r0, -r3, ror #22]
    385c:	5f335052 	svcpl	0x00335052
    3860:	61746144 	cmnvs	r4, r4, asr #2
    3864:	6d747300 	ldclvs	3, cr7, [r4]
    3868:	31663233 	cmncc	r6, r3, lsr r2
    386c:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    3870:	732f6269 	teqvc	pc, #-1879048186	; 0x90000006
    3874:	732f6372 	teqvc	pc, #-939524095	; 0xc8000001
    3878:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    387c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    3880:	616c665f 	cmnvs	ip, pc, asr r6
    3884:	632e6873 	teqvs	lr, #7536640	; 0x730000
    3888:	414c4600 	cmpmi	ip, r0, lsl #12
    388c:	505f4853 	subspl	r4, pc, r3, asr r8
    3890:	65666572 	strbvs	r6, [r6, #-1394]!
    3894:	42686374 	rsbmi	r6, r8, #-805306367	; 0xd0000001
    3898:	65666675 	strbvs	r6, [r6, #-1653]!
    389c:	646d4372 	strbtvs	r4, [sp], #-882
    38a0:	414c4600 	cmpmi	ip, r0, lsl #12
    38a4:	475f4853 	undefined
    38a8:	6c467465 	cfstrdvs	mvd7, [r6], {101}
    38ac:	74536761 	ldrbvc	r6, [r3], #-1889
    38b0:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    38b4:	414c4600 	cmpmi	ip, r0, lsl #12
    38b8:	435f4853 	cmpmi	pc, #5439488	; 0x530000
    38bc:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    38c0:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    38c4:	414c4600 	cmpmi	ip, r0, lsl #12
    38c8:	435f4853 	cmpmi	pc, #5439488	; 0x530000
    38cc:	4c504d4f 	mrrcmi	13, 4, r4, r0, cr15
    38d0:	00455445 	subeq	r5, r5, r5, asr #8
    38d4:	53414c46 	movtpl	r4, #7238	; 0x1c46
    38d8:	55425f48 	strbpl	r5, [r2, #-3912]
    38dc:	57005953 	smlsdpl	r0, r3, r9, r5
    38e0:	5f315052 	svcpl	0x00315052
    38e4:	61746144 	cmnvs	r4, r4, asr #2
    38e8:	414c4600 	cmpmi	ip, r0, lsl #12
    38ec:	545f4853 	ldrbpl	r4, [pc], #2131	; 38f4 <__Stack_Size+0x34f4>
    38f0:	4f454d49 	svcmi	0x00454d49
    38f4:	54005455 	strpl	r5, [r0], #-1109
    38f8:	6f656d69 	svcvs	0x00656d69
    38fc:	46007475 	undefined
    3900:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    3904:	7465475f 	strbtvc	r4, [r5], #-1887
    3908:	64616552 	strbtvs	r6, [r1], #-1362
    390c:	5074754f 	rsbspl	r7, r4, pc, asr #10
    3910:	65746f72 	ldrbvs	r6, [r4, #-3954]!
    3914:	6f697463 	svcvs	0x00697463
    3918:	6174536e 	cmnvs	r4, lr, ror #6
    391c:	00737574 	rsbseq	r7, r3, r4, ror r5
    3920:	535f424f 	cmppl	pc, #-268435452	; 0xf0000004
    3924:	59424454 	stmdbpl	r2, {r2, r4, r6, sl, lr}^
    3928:	50525700 	subspl	r5, r2, r0, lsl #14
    392c:	61445f30 	cmpvs	r4, r0, lsr pc
    3930:	46006174 	undefined
    3934:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    3938:	6c61485f 	stclvs	8, cr4, [r1], #-380
    393c:	63794366 	cmnvs	r9, #-1744830463	; 0x98000001
    3940:	6341656c 	movtvs	r6, #5484	; 0x156c
    3944:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
    3948:	414c4600 	cmpmi	ip, r0, lsl #12
    394c:	475f4853 	undefined
    3950:	74537465 	ldrbvc	r7, [r3], #-1125
    3954:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    3958:	414c4600 	cmpmi	ip, r0, lsl #12
    395c:	455f4853 	ldrbmi	r4, [pc, #-2131]	; 3111 <__Stack_Size+0x2d11>
    3960:	6c62616e 	stfvse	f6, [r2], #-440
    3964:	69725765 	ldmdbvs	r2!, {r0, r2, r5, r6, r8, r9, sl, ip, lr}^
    3968:	72506574 	subsvc	r6, r0, #486539264	; 0x1d000000
    396c:	6365746f 	cmnvs	r5, #1862270976	; 0x6f000000
    3970:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    3974:	414c4600 	cmpmi	ip, r0, lsl #12
    3978:	535f4853 	cmppl	pc, #5439488	; 0x530000
    397c:	614c7465 	cmpvs	ip, r5, ror #8
    3980:	636e6574 	cmnvs	lr, #486539264	; 0x1d000000
    3984:	4c460079 	mcrrmi	0, 7, r0, r6, cr9
    3988:	5f485341 	svcpl	0x00485341
    398c:	666c6148 	strbtvs	r6, [ip], -r8, asr #2
    3990:	6c637943 	stclvs	9, cr7, [r3], #-268
    3994:	63634165 	cmnvs	r3, #1073741849	; 0x40000019
    3998:	43737365 	cmnmi	r3, #-1811939327	; 0x94000001
    399c:	4600646d 	strmi	r6, [r0], -sp, ror #8
    39a0:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    39a4:	6f72505f 	svcvs	0x0072505f
    39a8:	6d617267 	sfmvs	f7, 2, [r1, #-412]!
    39ac:	6974704f 	ldmdbvs	r4!, {r0, r1, r2, r3, r6, ip, sp, lr}^
    39b0:	79426e6f 	stmdbvc	r2, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    39b4:	61446574 	cmpvs	r4, r4, ror r5
    39b8:	46006174 	undefined
    39bc:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    39c0:	7465475f 	strbtvc	r4, [r5], #-1887
    39c4:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
    39c8:	6974704f 	ldmdbvs	r4!, {r0, r1, r2, r3, r6, ip, sp, lr}^
    39cc:	79426e6f 	stmdbvc	r2, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    39d0:	46006574 	undefined
    39d4:	4853414c 	ldmdami	r3, {r2, r3, r6, r8, lr}^
    39d8:	6f72505f 	svcvs	0x0072505f
    39dc:	6d617267 	sfmvs	f7, 2, [r1, #-412]!
    39e0:	666c6148 	strbtvs	r6, [ip], -r8, asr #2
    39e4:	64726f57 	ldrbtvs	r6, [r2], #-3927
    39e8:	414c4600 	cmpmi	ip, r0, lsl #12
    39ec:	465f4853 	undefined
    39f0:	0047414c 	subeq	r4, r7, ip, asr #2
    39f4:	52455355 	subpl	r5, r5, #1409286145	; 0x54000001
    39f8:	74614400 	strbtvc	r4, [r1], #-1024
    39fc:	44003061 	strmi	r3, [r0], #-97
    3a00:	31617461 	cmncc	r1, r1, ror #8
    3a04:	414c4600 	cmpmi	ip, r0, lsl #12
    3a08:	505f4853 	subspl	r4, pc, r3, asr r8
    3a0c:	73656761 	cmnvc	r5, #25427968	; 0x1840000
    3a10:	414c4600 	cmpmi	ip, r0, lsl #12
    3a14:	495f4853 	ldmdbmi	pc, {r0, r1, r4, r6, fp, lr}^
    3a18:	4c460054 	mcrrmi	0, 5, r0, r6, cr4
    3a1c:	5f485341 	svcpl	0x00485341
    3a20:	676f7250 	undefined
    3a24:	576d6172 	undefined
    3a28:	0064726f 	rsbeq	r7, r4, pc, ror #4
    3a2c:	45534552 	ldrbmi	r4, [r3, #-1362]
    3a30:	44455652 	strbmi	r5, [r5], #-1618
    3a34:	414c4600 	cmpmi	ip, r0, lsl #12
    3a38:	575f4853 	undefined
    3a3c:	46746961 	ldrbtmi	r6, [r4], -r1, ror #18
    3a40:	614c726f 	cmpvs	ip, pc, ror #4
    3a44:	704f7473 	subvc	r7, pc, r3, ror r4
    3a48:	74617265 	strbtvc	r7, [r1], #-613
    3a4c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
    3a50:	53414c46 	movtpl	r4, #7238	; 0x1c46
    3a54:	72505f48 	subsvc	r5, r0, #288	; 0x120
    3a58:	74656665 	strbtvc	r6, [r5], #-1637
    3a5c:	75426863 	strbvc	r6, [r2, #-2147]
    3a60:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
    3a64:	6e697000 	cdpvs	0, 6, cr7, cr9, cr0, {0}
    3a68:	00736f70 	rsbseq	r6, r3, r0, ror pc
    3a6c:	5f746942 	svcpl	0x00746942
    3a70:	00544553 	subseq	r4, r4, r3, asr r5
    3a74:	4f495047 	svcmi	0x00495047
    3a78:	6165525f 	cmnvs	r5, pc, asr r2
    3a7c:	74754f64 	ldrbtvc	r4, [r5], #-3940
    3a80:	44747570 	ldrbtmi	r7, [r4], #-1392
    3a84:	00617461 	rsbeq	r7, r1, r1, ror #8
    3a88:	4f495047 	svcmi	0x00495047
    3a8c:	6576455f 	ldrbvs	r4, [r6, #-1375]!
    3a90:	754f746e 	strbvc	r7, [pc, #-1134]	; 362a <__Stack_Size+0x322a>
    3a94:	74757074 	ldrbtvc	r7, [r5], #-116
    3a98:	00646d43 	rsbeq	r6, r4, r3, asr #26
    3a9c:	4f495047 	svcmi	0x00495047
    3aa0:	7274535f 	rsbsvc	r5, r4, #2080374785	; 0x7c000001
    3aa4:	49746375 	ldmdbmi	r4!, {r0, r2, r4, r5, r6, r8, r9, sp, lr}^
    3aa8:	0074696e 	rsbseq	r6, r4, lr, ror #18
    3aac:	56746942 	ldrbtpl	r6, [r4], -r2, asr #18
    3ab0:	42006c61 	andmi	r6, r0, #24832	; 0x6100
    3ab4:	525f7469 	subspl	r7, pc, #1761607680	; 0x69000000
    3ab8:	54455345 	strbpl	r5, [r5], #-837
    3abc:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    3ac0:	72575f4f 	subsvc	r5, r7, #316	; 0x13c
    3ac4:	42657469 	rsbmi	r7, r5, #1761607680	; 0x69000000
    3ac8:	47007469 	strmi	r7, [r0, -r9, ror #8]
    3acc:	5f4f4950 	svcpl	0x004f4950
    3ad0:	42746553 	rsbsmi	r6, r4, #348127232	; 0x14c00000
    3ad4:	00737469 	rsbseq	r7, r3, r9, ror #8
    3ad8:	4f495047 	svcmi	0x00495047
    3adc:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    3ae0:	58450074 	stmdapl	r5, {r2, r4, r5, r6}^
    3ae4:	52434954 	subpl	r4, r3, #1376256	; 0x150000
    3ae8:	6d747300 	ldclvs	3, cr7, [r4]
    3aec:	31663233 	cmncc	r6, r3, lsr r2
    3af0:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    3af4:	732f6269 	teqvc	pc, #-1879048186	; 0x90000006
    3af8:	732f6372 	teqvc	pc, #-939524095	; 0xc8000001
    3afc:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    3b00:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    3b04:	6970675f 	ldmdbvs	r0!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, sp, lr}^
    3b08:	00632e6f 	rsbeq	r2, r3, pc, ror #28
    3b0c:	6d6e6970 	stclvs	9, cr6, [lr, #-448]!
    3b10:	006b7361 	rsbeq	r7, fp, r1, ror #6
    3b14:	4f495047 	svcmi	0x00495047
    3b18:	726f505f 	rsbvc	r5, pc, #95	; 0x5f
    3b1c:	756f5374 	strbvc	r5, [pc, #-884]!	; 37b0 <__Stack_Size+0x33b0>
    3b20:	00656372 	rsbeq	r6, r5, r2, ror r3
    3b24:	4f495047 	svcmi	0x00495047
    3b28:	4965445f 	stmdbmi	r5!, {r0, r1, r2, r3, r4, r6, sl, lr}^
    3b2c:	0074696e 	rsbseq	r6, r4, lr, ror #18
    3b30:	4f495047 	svcmi	0x00495047
    3b34:	6576455f 	ldrbvs	r4, [r6, #-1375]!
    3b38:	754f746e 	strbvc	r7, [pc, #-1134]	; 36d2 <__Stack_Size+0x32d2>
    3b3c:	74757074 	ldrbtvc	r7, [r5], #-116
    3b40:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3b44:	47006769 	strmi	r6, [r0, -r9, ror #14]
    3b48:	5f4f4950 	svcpl	0x004f4950
    3b4c:	616d6552 	cmnvs	sp, r2, asr r5
    3b50:	50470070 	subpl	r0, r7, r0, ror r0
    3b54:	525f4f49 	subspl	r4, pc, #292	; 0x124
    3b58:	49646165 	stmdbmi	r4!, {r0, r2, r5, r6, r8, sp, lr}^
    3b5c:	7475706e 	ldrbtvc	r7, [r5], #-110
    3b60:	61746144 	cmnvs	r4, r4, asr #2
    3b64:	00746942 	rsbseq	r6, r4, r2, asr #18
    3b68:	4f495047 	svcmi	0x00495047
    3b6c:	7365525f 	cmnvc	r5, #-268435451	; 0xf0000005
    3b70:	69427465 	stmdbvs	r2, {r0, r2, r5, r6, sl, ip, sp, lr}^
    3b74:	50007374 	andpl	r7, r0, r4, ror r3
    3b78:	5674726f 	ldrbtpl	r7, [r4], -pc, ror #4
    3b7c:	63006c61 	movwvs	r6, #3169	; 0xc61
    3b80:	65727275 	ldrbvs	r7, [r2, #-629]!
    3b84:	6f6d746e 	svcvs	0x006d746e
    3b88:	47006564 	strmi	r6, [r0, -r4, ror #10]
    3b8c:	5f4f4950 	svcpl	0x004f4950
    3b90:	526e6950 	rsbpl	r6, lr, #1310720	; 0x140000
    3b94:	70616d65 	rsbvc	r6, r1, r5, ror #26
    3b98:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3b9c:	47006769 	strmi	r6, [r0, -r9, ror #14]
    3ba0:	5f4f4950 	svcpl	0x004f4950
    3ba4:	536e6950 	cmnpl	lr, #1310720	; 0x140000
    3ba8:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    3bac:	50470065 	subpl	r0, r7, r5, rrx
    3bb0:	525f4f49 	subspl	r4, pc, #292	; 0x124
    3bb4:	49646165 	stmdbmi	r4!, {r0, r2, r5, r6, r8, sp, lr}^
    3bb8:	7475706e 	ldrbtvc	r7, [r5], #-110
    3bbc:	61746144 	cmnvs	r4, r4, asr #2
    3bc0:	706d7400 	rsbvc	r7, sp, r0, lsl #8
    3bc4:	6b73616d 	blvs	1cdc180 <__Stack_Size+0x1cdbd80>
    3bc8:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    3bcc:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
    3bd0:	636f4c6e 	cmnvs	pc, #28160	; 0x6e00
    3bd4:	6e6f436b 	cdpvs	3, 6, cr4, cr15, cr11, {3}
    3bd8:	00676966 	rsbeq	r6, r7, r6, ror #18
    3bdc:	72727563 	rsbsvc	r7, r2, #415236096	; 0x18c00000
    3be0:	70746e65 	rsbsvc	r6, r4, r5, ror #28
    3be4:	47006e69 	strmi	r6, [r0, -r9, ror #28]
    3be8:	5f4f4950 	svcpl	0x004f4950
    3bec:	74697257 	strbtvc	r7, [r9], #-599
    3bf0:	6d740065 	ldclvs	0, cr0, [r4, #-404]!
    3bf4:	47003170 	smlsdxmi	r0, r0, r1, r3
    3bf8:	5f4f4950 	svcpl	0x004f4950
    3bfc:	49545845 	ldmdbmi	r4, {r0, r2, r6, fp, ip, lr}^
    3c00:	656e694c 	strbvs	r6, [lr, #-2380]!
    3c04:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3c08:	42006769 	andmi	r6, r0, #27525120	; 0x1a40000
    3c0c:	63417469 	movtvs	r7, #5225	; 0x1469
    3c10:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    3c14:	50414d00 	subpl	r4, r1, r0, lsl #26
    3c18:	50470052 	subpl	r0, r7, r2, asr r0
    3c1c:	00784f49 	rsbseq	r4, r8, r9, asr #30
    3c20:	4f495047 	svcmi	0x00495047
    3c24:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    3c28:	72745374 	rsbsvc	r5, r4, #-805306367	; 0xd0000001
    3c2c:	00746375 	rsbseq	r6, r4, r5, ror r3
    3c30:	52435645 	subpl	r5, r3, #72351744	; 0x4500000
    3c34:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    3c38:	65525f4f 	ldrbvs	r5, [r2, #-3919]
    3c3c:	754f6461 	strbvc	r6, [pc, #-1121]	; 37e3 <__Stack_Size+0x33e3>
    3c40:	74757074 	ldrbtvc	r7, [r5], #-116
    3c44:	61746144 	cmnvs	r4, r4, asr #2
    3c48:	00746942 	rsbseq	r6, r4, r2, asr #18
    3c4c:	4f495047 	svcmi	0x00495047
    3c50:	4946415f 	stmdbmi	r6, {r0, r1, r2, r3, r4, r6, r8, lr}^
    3c54:	4965444f 	stmdbmi	r5!, {r0, r1, r2, r3, r6, sl, lr}^
    3c58:	0074696e 	rsbseq	r6, r4, lr, ror #18
    3c5c:	52424149 	subpl	r4, r2, #1073741842	; 0x40000012
    3c60:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    3c64:	6c435f43 	mcrrvs	15, 4, r5, r3, cr3
    3c68:	49726165 	ldmdbmi	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    3c6c:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
    3c70:	656e6e61 	strbvs	r6, [lr, #-3681]!
    3c74:	6e65506c 	cdpvs	0, 6, cr5, cr5, cr12, {3}
    3c78:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    3c7c:	00746942 	rsbseq	r6, r4, r2, asr #18
    3c80:	4349564e 	movtmi	r5, #38478	; 0x964e
    3c84:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    3c88:	72745374 	rsbsvc	r5, r4, #-805306367	; 0xd0000001
    3c8c:	00746375 	rsbseq	r6, r4, r5, ror r3
    3c90:	4349564e 	movtmi	r5, #38478	; 0x964e
    3c94:	7465475f 	strbtvc	r4, [r5], #-1887
    3c98:	72727543 	rsbsvc	r7, r2, #281018368	; 0x10c00000
    3c9c:	50746e65 	rsbspl	r6, r4, r5, ror #28
    3ca0:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    3ca4:	5249676e 	subpl	r6, r9, #28835840	; 0x1b80000
    3ca8:	61684351 	cmnvs	r8, r1, asr r3
    3cac:	6c656e6e 	stclvs	14, cr6, [r5], #-440
    3cb0:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    3cb4:	65475f43 	strbvs	r5, [r7, #-3907]
    3cb8:	75614674 	strbvc	r4, [r1, #-1652]!
    3cbc:	6441746c 	strbvs	r7, [r1], #-1132
    3cc0:	73657264 	cmnvc	r5, #1073741830	; 0x40000006
    3cc4:	79530073 	ldmdbvc	r3, {r0, r1, r4, r5, r6}^
    3cc8:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    3ccc:	646e6148 	strbtvs	r6, [lr], #-328
    3cd0:	5372656c 	cmnpl	r2, #452984832	; 0x1b000000
    3cd4:	72506275 	subsvc	r6, r0, #1342177287	; 0x50000007
    3cd8:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    3cdc:	4e007974 	mcrmi	9, 0, r7, cr0, cr4, {3}
    3ce0:	5f434956 	svcpl	0x00434956
    3ce4:	50544553 	subspl	r4, r4, r3, asr r5
    3ce8:	414d4952 	cmpmi	sp, r2, asr r9
    3cec:	4e004b53 	mcrmi	11, 0, r4, cr0, cr3, {2}
    3cf0:	5f434956 	svcpl	0x00434956
    3cf4:	656e6547 	strbvs	r6, [lr, #-1351]!
    3cf8:	65746172 	ldrbvs	r6, [r4, #-370]!
    3cfc:	74737953 	ldrbtvc	r7, [r3], #-2387
    3d00:	65526d65 	ldrbvs	r6, [r2, #-3429]
    3d04:	00746573 	rsbseq	r6, r4, r3, ror r5
    3d08:	70706d74 	rsbsvc	r6, r0, r4, ror sp
    3d0c:	4e006572 	cfrshl64mi	mvdx0, mvdx2, r6
    3d10:	5f434956 	svcpl	0x00434956
    3d14:	45534552 	ldrbmi	r4, [r3, #-1362]
    3d18:	49525054 	ldmdbmi	r2, {r2, r4, r6, ip, lr}^
    3d1c:	4b53414d 	blmi	14d4258 <__Stack_Size+0x14d3e58>
    3d20:	75616600 	strbvc	r6, [r1, #-1536]!
    3d24:	6461746c 	strbtvs	r7, [r1], #-1132
    3d28:	73657264 	cmnvc	r5, #1073741830	; 0x40000006
    3d2c:	564e0073 	undefined
    3d30:	535f4349 	cmppl	pc, #603979777	; 0x24000001
    3d34:	65747379 	ldrbvs	r7, [r4, #-889]!
    3d38:	6e61486d 	cdpvs	8, 6, cr4, cr1, cr13, {3}
    3d3c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    3d40:	6f697250 	svcvs	0x00697250
    3d44:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    3d48:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3d4c:	73006769 	movwvc	r6, #1897	; 0x769
    3d50:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    3d54:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    3d58:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    3d5c:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    3d60:	6d74732f 	ldclvs	3, cr7, [r4, #-188]!
    3d64:	31663233 	cmncc	r6, r3, lsr r2
    3d68:	6e5f7830 	mrcvs	8, 2, r7, cr15, cr0, {1}
    3d6c:	2e636976 	mcrcs	9, 3, r6, cr3, cr6, {3}
    3d70:	564e0063 	strbpl	r0, [lr], -r3, rrx
    3d74:	475f4349 	ldrbmi	r4, [pc, -r9, asr #6]
    3d78:	50437465 	subpl	r7, r3, r5, ror #8
    3d7c:	00444955 	subeq	r4, r4, r5, asr r9
    3d80:	4349564e 	movtmi	r5, #38478	; 0x964e
    3d84:	6972505f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, ip, lr}^
    3d88:	7469726f 	strbtvc	r7, [r9], #-623
    3d8c:	6f724779 	svcvs	0x00724779
    3d90:	4e007075 	mcrmi	0, 0, r7, cr0, cr5, {3}
    3d94:	5f434956 	svcpl	0x00434956
    3d98:	45534552 	ldrbmi	r4, [r3, #-1362]
    3d9c:	55414654 	strbpl	r4, [r1, #-1620]
    3da0:	414d544c 	cmpmi	sp, ip, asr #8
    3da4:	4e004b53 	mcrmi	11, 0, r4, cr0, cr3, {2}
    3da8:	5f434956 	svcpl	0x00434956
    3dac:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    3db0:	65727275 	ldrbvs	r7, [r2, #-629]!
    3db4:	6341746e 	movtvs	r7, #5230	; 0x146e
    3db8:	65766974 	ldrbvs	r6, [r6, #-2420]!
    3dbc:	646e6148 	strbtvs	r6, [lr], #-328
    3dc0:	0072656c 	rsbseq	r6, r2, ip, ror #10
    3dc4:	74737953 	ldrbtvc	r7, [r3], #-2387
    3dc8:	61486d65 	cmpvs	r8, r5, ror #26
    3dcc:	656c646e 	strbvs	r6, [ip, #-1134]!
    3dd0:	43490072 	movtmi	r0, #36978	; 0x9072
    3dd4:	52005253 	andpl	r5, r0, #805306373	; 0x30000005
    3dd8:	56524553 	undefined
    3ddc:	00314445 	eorseq	r4, r1, r5, asr #8
    3de0:	4349564e 	movtmi	r5, #38478	; 0x964e
    3de4:	6e65475f 	mcrvs	7, 3, r4, cr5, cr15, {2}
    3de8:	74617265 	strbtvc	r7, [r1], #-613
    3dec:	726f4365 	rsbvc	r4, pc, #-1811939327	; 0x94000001
    3df0:	73655265 	cmnvc	r5, #1342177286	; 0x50000006
    3df4:	4e007465 	cdpmi	4, 0, cr7, cr0, cr5, {3}
    3df8:	5f434956 	svcpl	0x00434956
    3dfc:	53746547 	cmnpl	r4, #297795584	; 0x11c00000
    3e00:	65747379 	ldrbvs	r7, [r4, #-889]!
    3e04:	6e61486d 	cdpvs	8, 6, cr4, cr1, cr13, {3}
    3e08:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    3e0c:	69746341 	ldmdbvs	r4!, {r0, r6, r8, r9, sp, lr}^
    3e10:	69426576 	stmdbvs	r2, {r1, r2, r4, r5, r6, r8, sl, sp, lr}^
    3e14:	61745374 	cmnvs	r4, r4, ror r3
    3e18:	00737574 	rsbseq	r7, r3, r4, ror r5
    3e1c:	4349564e 	movtmi	r5, #38478	; 0x964e
    3e20:	5341425f 	movtpl	r4, #4703	; 0x125f
    3e24:	49525045 	ldmdbmi	r2, {r0, r2, r6, ip, lr}^
    3e28:	464e4f43 	strbmi	r4, [lr], -r3, asr #30
    3e2c:	42004749 	andmi	r4, r0, #19136512	; 0x1240000
    3e30:	00524146 	subseq	r4, r2, r6, asr #2
    3e34:	4349564e 	movtmi	r5, #38478	; 0x964e
    3e38:	7465535f 	strbtvc	r5, [r5], #-863
    3e3c:	43515249 	cmpmi	r1, #-1879048188	; 0x90000004
    3e40:	6e6e6168 	powvsez	f6, f6, #0.0
    3e44:	65506c65 	ldrbvs	r6, [r0, #-3173]
    3e48:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
    3e4c:	74694267 	strbtvc	r4, [r9], #-615
    3e50:	706d7400 	rsbvc	r7, sp, r0, lsl #8
    3e54:	00736f70 	rsbseq	r6, r3, r0, ror pc
    3e58:	52534643 	subspl	r4, r3, #70254592	; 0x4300000
    3e5c:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    3e60:	65535f43 	ldrbvs	r5, [r3, #-3907]
    3e64:	73795374 	cmnvc	r9, #-805306367	; 0xd0000001
    3e68:	486d6574 	stmdami	sp!, {r2, r4, r5, r6, r8, sl, sp, lr}^
    3e6c:	6c646e61 	stclvs	14, cr6, [r4], #-388
    3e70:	65507265 	ldrbvs	r7, [r0, #-613]
    3e74:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
    3e78:	74694267 	strbtvc	r4, [r9], #-615
    3e7c:	52494100 	subpl	r4, r9, #0	; 0x0
    3e80:	4e005243 	cdpmi	2, 0, cr5, cr0, cr3, {2}
    3e84:	5f434956 	svcpl	0x00434956
    3e88:	56746553 	undefined
    3e8c:	6f746365 	svcvs	0x00746365
    3e90:	62615472 	rsbvs	r5, r1, #1912602624	; 0x72000000
    3e94:	4900656c 	stmdbmi	r0, {r2, r3, r5, r6, r8, sl, sp, lr}
    3e98:	00525043 	subseq	r5, r2, r3, asr #32
    3e9c:	4349564e 	movtmi	r5, #38478	; 0x964e
    3ea0:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    3ea4:	48530074 	ldmdami	r3, {r2, r4, r5, r6}^
    3ea8:	53005250 	movwpl	r5, #592	; 0x250
    3eac:	52534348 	subspl	r4, r3, #536870913	; 0x20000001
    3eb0:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    3eb4:	65475f43 	strbvs	r5, [r7, #-3907]
    3eb8:	53414274 	movtpl	r4, #4724	; 0x1274
    3ebc:	49525045 	ldmdbmi	r2, {r0, r2, r6, ip, lr}^
    3ec0:	464d4d00 	strbmi	r4, [sp], -r0, lsl #26
    3ec4:	74005241 	strvc	r5, [r0], #-577
    3ec8:	7573706d 	ldrbvc	r7, [r3, #-109]!
    3ecc:	564e0062 	strbpl	r0, [lr], -r2, rrx
    3ed0:	535f4349 	cmppl	pc, #603979777	; 0x24000001
    3ed4:	65747379 	ldrbvs	r7, [r4, #-889]!
    3ed8:	6e61486d 	cdpvs	8, 6, cr4, cr1, cr13, {3}
    3edc:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    3ee0:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3ee4:	4e006769 	cdpmi	7, 0, cr6, cr0, cr9, {3}
    3ee8:	5f434956 	svcpl	0x00434956
    3eec:	74737953 	ldrbtvc	r7, [r3], #-2387
    3ef0:	504c6d65 	subpl	r6, ip, r5, ror #26
    3ef4:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    3ef8:	4e006769 	cdpmi	7, 0, cr6, cr0, cr9, {3}
    3efc:	5f434956 	svcpl	0x00434956
    3f00:	75727453 	ldrbvc	r7, [r2, #-1107]!
    3f04:	6e497463 	cdpvs	4, 4, cr7, cr9, cr3, {3}
    3f08:	49007469 	stmdbmi	r0, {r0, r3, r5, r6, sl, ip, sp, lr}
    3f0c:	00524543 	subseq	r4, r2, r3, asr #10
    3f10:	70706d74 	rsbsvc	r6, r0, r4, ror sp
    3f14:	726f6972 	rsbvc	r6, pc, #1867776	; 0x1c8000
    3f18:	00797469 	rsbseq	r7, r9, r9, ror #8
    3f1c:	524f5456 	subpl	r5, pc, #1442840576	; 0x56000000
    3f20:	50534900 	subspl	r4, r3, r0, lsl #18
    3f24:	46440052 	undefined
    3f28:	48005253 	stmdami	r0, {r0, r1, r4, r6, r9, ip, lr}
    3f2c:	00525346 	subseq	r5, r2, r6, asr #6
    3f30:	4349564e 	movtmi	r5, #38478	; 0x964e
    3f34:	5445535f 	strbpl	r5, [r5], #-863
    3f38:	4c554146 	ldfmie	f4, [r5], {70}
    3f3c:	53414d54 	movtpl	r4, #7508	; 0x1d54
    3f40:	4641004b 	strbmi	r0, [r1], -fp, asr #32
    3f44:	49005253 	stmdbmi	r0, {r0, r1, r4, r6, r9, ip, lr}
    3f48:	00524553 	subseq	r4, r2, r3, asr r5
    3f4c:	4349564e 	movtmi	r5, #38478	; 0x964e
    3f50:	7465475f 	strbtvc	r4, [r5], #-1887
    3f54:	6c756146 	ldfvse	f6, [r5], #-280
    3f58:	6e614874 	mcrvs	8, 3, r4, cr1, cr4, {3}
    3f5c:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    3f60:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    3f64:	00736563 	rsbseq	r6, r3, r3, ror #10
    3f68:	32706d74 	rsbscc	r6, r0, #7424	; 0x1d00
    3f6c:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    3f70:	65475f43 	strbvs	r5, [r7, #-3907]
    3f74:	73795374 	cmnvc	r9, #-805306367	; 0xd0000001
    3f78:	486d6574 	stmdami	sp!, {r2, r4, r5, r6, r8, sl, sp, lr}^
    3f7c:	6c646e61 	stclvs	14, cr6, [r4], #-388
    3f80:	65507265 	ldrbvs	r7, [r0, #-613]
    3f84:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
    3f88:	74694267 	strbtvc	r4, [r9], #-615
    3f8c:	74617453 	strbtvc	r7, [r1], #-1107
    3f90:	4e007375 	mcrmi	3, 0, r7, cr0, cr5, {3}
    3f94:	5f434956 	svcpl	0x00434956
    3f98:	61656c43 	cmnvs	r5, r3, asr #24
    3f9c:	73795372 	cmnvc	r9, #-939524095	; 0xc8000001
    3fa0:	486d6574 	stmdami	sp!, {r2, r4, r5, r6, r8, sl, sp, lr}^
    3fa4:	6c646e61 	stclvs	14, cr6, [r4], #-388
    3fa8:	65507265 	ldrbvs	r7, [r0, #-613]
    3fac:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
    3fb0:	74694267 	strbtvc	r4, [r9], #-615
    3fb4:	75616600 	strbvc	r6, [r1, #-1536]!
    3fb8:	6f73746c 	svcvs	0x0073746c
    3fbc:	65637275 	strbvs	r7, [r3, #-629]!
    3fc0:	79530073 	ldmdbvc	r3, {r0, r1, r4, r5, r6}^
    3fc4:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!
    3fc8:	646e6148 	strbtvs	r6, [lr], #-328
    3fcc:	5072656c 	rsbspl	r6, r2, ip, ror #10
    3fd0:	6d656572 	cfstr64vs	mvdx6, [r5, #-456]!
    3fd4:	6f697470 	svcvs	0x00697470
    3fd8:	6972506e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, ip, lr}^
    3fdc:	7469726f 	strbtvc	r7, [r9], #-623
    3fe0:	564e0079 	undefined
    3fe4:	475f4349 	ldrbmi	r4, [pc, -r9, asr #6]
    3fe8:	52497465 	subpl	r7, r9, #1694498816	; 0x65000000
    3fec:	61684351 	cmnvs	r8, r1, asr r3
    3ff0:	6c656e6e 	stclvs	14, cr6, [r5], #-440
    3ff4:	646e6550 	strbtvs	r6, [lr], #-1360
    3ff8:	42676e69 	rsbmi	r6, r7, #1680	; 0x690
    3ffc:	74537469 	ldrbvc	r7, [r3], #-1129
    4000:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    4004:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    4008:	43535f43 	cmpmi	r3, #268	; 0x10c
    400c:	49654442 	stmdbmi	r5!, {r1, r6, sl, lr}^
    4010:	0074696e 	rsbseq	r6, r4, lr, ror #18
    4014:	5077654e 	rsbspl	r6, r7, lr, asr #10
    4018:	726f6972 	rsbvc	r6, pc, #1867776	; 0x1c8000
    401c:	00797469 	rsbseq	r7, r9, r9, ror #8
    4020:	4349564e 	movtmi	r5, #38478	; 0x964e
    4024:	6365565f 	cmnvs	r5, #99614720	; 0x5f00000
    4028:	62615474 	rsbvs	r5, r1, #1946157056	; 0x74000000
    402c:	74636100 	strbtvc	r6, [r3], #-256
    4030:	69657669 	stmdbvs	r5!, {r0, r3, r5, r6, r9, sl, ip, sp, lr}^
    4034:	74737172 	ldrbtvc	r7, [r3], #-370
    4038:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    403c:	6e616800 	cdpvs	8, 6, cr6, cr1, cr0, {0}
    4040:	72656c64 	rsbvc	r6, r5, #25600	; 0x6400
    4044:	6b73616d 	blvs	1cdc600 <__Stack_Size+0x1cdc200>
    4048:	776f4c00 	strbvc	r4, [pc, -r0, lsl #24]!
    404c:	65776f50 	ldrbvs	r6, [r7, #-3920]!
    4050:	646f4d72 	strbtvs	r4, [pc], #3442	; 4058 <__Stack_Size+0x3c58>
    4054:	564e0065 	strbpl	r0, [lr], -r5, rrx
    4058:	475f4349 	ldrbmi	r4, [pc, -r9, asr #6]
    405c:	52497465 	subpl	r7, r9, #1694498816	; 0x65000000
    4060:	61684351 	cmnvs	r8, r1, asr r3
    4064:	6c656e6e 	stclvs	14, cr6, [r5], #-440
    4068:	69746341 	ldmdbvs	r4!, {r0, r6, r8, r9, sp, lr}^
    406c:	69426576 	stmdbvs	r2, {r1, r2, r4, r5, r6, r8, sl, sp, lr}^
    4070:	61745374 	cmnvs	r4, r4, ror r3
    4074:	00737574 	rsbseq	r7, r3, r4, ror r5
    4078:	4349564e 	movtmi	r5, #38478	; 0x964e
    407c:	4965445f 	stmdbmi	r5!, {r0, r1, r2, r3, r4, r6, sl, lr}^
    4080:	0074696e 	rsbseq	r6, r4, lr, ror #18
    4084:	4349564e 	movtmi	r5, #38478	; 0x964e
    4088:	6972505f 	ldmdbvs	r2!, {r0, r1, r2, r3, r4, r6, ip, lr}^
    408c:	7469726f 	strbtvc	r7, [r9], #-623
    4090:	6f724779 	svcvs	0x00724779
    4094:	6f437075 	svcvs	0x00437075
    4098:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    409c:	6e657000 	cdpvs	0, 6, cr7, cr5, cr0, {0}
    40a0:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    40a4:	73717269 	cmnvc	r1, #-1879048186	; 0x90000006
    40a8:	75746174 	ldrbvc	r6, [r4, #-372]!
    40ac:	57500073 	undefined
    40b0:	6e455f52 	mcrvs	15, 2, r5, cr5, cr2, {2}
    40b4:	53726574 	cmnpl	r2, #486539264	; 0x1d000000
    40b8:	444e4154 	strbmi	r4, [lr], #-340
    40bc:	6f4d5942 	svcvs	0x004d5942
    40c0:	50006564 	andpl	r6, r0, r4, ror #10
    40c4:	435f5257 	cmpmi	pc, #1879048197	; 0x70000005
    40c8:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    40cc:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    40d0:	52575000 	subspl	r5, r7, #0	; 0x0
    40d4:	4965445f 	stmdbmi	r5!, {r0, r1, r2, r3, r4, r6, sl, lr}^
    40d8:	0074696e 	rsbseq	r6, r4, lr, ror #18
    40dc:	5f525750 	svcpl	0x00525750
    40e0:	75676552 	strbvc	r6, [r7, #-1362]!
    40e4:	6f74616c 	svcvs	0x0074616c
    40e8:	57500072 	undefined
    40ec:	56505f52 	usubaddxpl	r5, r0, r2
    40f0:	76654c44 	strbtvc	r4, [r5], -r4, asr #24
    40f4:	50006c65 	andpl	r6, r0, r5, ror #24
    40f8:	465f5257 	undefined
    40fc:	0047414c 	subeq	r4, r7, ip, asr #2
    4100:	5f525750 	svcpl	0x00525750
    4104:	43445650 	movtmi	r5, #18000	; 0x4650
    4108:	7300646d 	movwvc	r6, #1133	; 0x46d
    410c:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    4110:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    4114:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    4118:	6372732f 	cmnvs	r2, #-1140850688	; 0xbc000000
    411c:	6d74732f 	ldclvs	3, cr7, [r4, #-188]!
    4120:	31663233 	cmncc	r6, r3, lsr r2
    4124:	705f7830 	subsvc	r7, pc, r0, lsr r8
    4128:	632e7277 	teqvs	lr, #1879048199	; 0x70000007
    412c:	52575000 	subspl	r5, r7, #0	; 0x0
    4130:	4456505f 	ldrbmi	r5, [r6], #-95
    4134:	6576654c 	ldrbvs	r6, [r6, #-1356]!
    4138:	6e6f436c 	cdpvs	3, 6, cr4, cr15, cr12, {3}
    413c:	00676966 	rsbeq	r6, r7, r6, ror #18
    4140:	5f525750 	svcpl	0x00525750
    4144:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    4148:	5367616c 	cmnpl	r7, #27	; 0x1b
    414c:	75746174 	ldrbvc	r6, [r4, #-372]!
    4150:	57500073 	undefined
    4154:	6e455f52 	mcrvs	15, 2, r5, cr5, cr2, {2}
    4158:	53726574 	cmnpl	r2, #486539264	; 0x1d000000
    415c:	4d504f54 	ldclmi	15, cr4, [r0, #-336]
    4160:	0065646f 	rsbeq	r6, r5, pc, ror #8
    4164:	5f525750 	svcpl	0x00525750
    4168:	504f5453 	subpl	r5, pc, r3, asr r4
    416c:	72746e45 	rsbsvc	r6, r4, #1104	; 0x450
    4170:	57500079 	undefined
    4174:	61425f52 	cmpvs	r2, r2, asr pc
    4178:	70756b63 	rsbsvc	r6, r5, r3, ror #22
    417c:	65636341 	strbvs	r6, [r3, #-833]!
    4180:	6d437373 	stclvs	3, cr7, [r3, #-460]
    4184:	57500064 	ldrbpl	r0, [r0, -r4, rrx]
    4188:	61575f52 	cmpvs	r7, r2, asr pc
    418c:	7055656b 	subsvc	r6, r5, fp, ror #10
    4190:	436e6950 	cmnmi	lr, #1310720	; 0x140000
    4194:	5200646d 	andpl	r6, r0, #1828716544	; 0x6d000000
    4198:	435f4343 	cmpmi	pc, #201326593	; 0xc000001
    419c:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    41a0:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    41a4:	42504100 	subsmi	r4, r0, #0	; 0x0
    41a8:	54535231 	ldrbpl	r5, [r3], #-561
    41ac:	43520052 	cmpmi	r2, #82	; 0x52
    41b0:	43485f43 	movtmi	r5, #36675	; 0x8f43
    41b4:	52004b4c 	andpl	r4, r0, #77824	; 0x13000
    41b8:	415f4343 	cmpmi	pc, r3, asr #6
    41bc:	4c434344 	mcrrmi	3, 4, r4, r3, cr4
    41c0:	6e6f434b 	cdpvs	3, 6, cr4, cr15, cr11, {2}
    41c4:	00676966 	rsbeq	r6, r7, r6, ror #18
    41c8:	5f434352 	svcpl	0x00434352
    41cc:	61656c43 	cmnvs	r5, r3, asr #24
    41d0:	50544972 	subspl	r4, r4, r2, ror r9
    41d4:	69646e65 	stmdbvs	r4!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    41d8:	6942676e 	stmdbvs	r2, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    41dc:	43520074 	cmpmi	r2, #116	; 0x74
    41e0:	50415f43 	subpl	r5, r1, r3, asr #30
    41e4:	65503242 	ldrbvs	r3, [r0, #-578]
    41e8:	68706972 	ldmdavs	r0!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    41ec:	65736552 	ldrbvs	r6, [r3, #-1362]!
    41f0:	646d4374 	strbtvs	r4, [sp], #-884
    41f4:	43435200 	movtmi	r5, #12800	; 0x3200
    41f8:	45534c5f 	ldrbmi	r4, [r3, #-3167]
    41fc:	43435200 	movtmi	r5, #12800	; 0x3200
    4200:	7465475f 	strbtvc	r4, [r5], #-1887
    4204:	74535449 	ldrbvc	r5, [r3], #-1097
    4208:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    420c:	43444200 	movtmi	r4, #16896	; 0x4200
    4210:	43520052 	cmpmi	r2, #82	; 0x52
    4214:	50415f43 	subpl	r5, r1, r3, asr #30
    4218:	65503242 	ldrbvs	r3, [r0, #-578]
    421c:	68706972 	ldmdavs	r0!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    4220:	43435200 	movtmi	r5, #12800	; 0x3200
    4224:	4c43505f 	mcrrmi	0, 5, r5, r3, cr15
    4228:	5200324b 	andpl	r3, r0, #-1342177276	; 0xb0000004
    422c:	505f4343 	subspl	r4, pc, r3, asr #6
    4230:	6d434c4c 	stclvs	12, cr4, [r3, #-304]
    4234:	43520064 	cmpmi	r2, #100	; 0x64
    4238:	6c435f43 	mcrrvs	15, 4, r5, r3, cr3
    423c:	736b636f 	cmnvc	fp, #-1140850687	; 0xbc000001
    4240:	65707954 	ldrbvs	r7, [r0, #-2388]!
    4244:	00666544 	rsbeq	r6, r6, r4, asr #10
    4248:	5f434352 	svcpl	0x00434352
    424c:	4d4c4c50 	stclmi	12, cr4, [ip, #-320]
    4250:	52006c75 	andpl	r6, r0, #29952	; 0x7500
    4254:	415f4343 	cmpmi	pc, r3, asr #6
    4258:	65504248 	ldrbvs	r4, [r0, #-584]
    425c:	68706972 	ldmdavs	r0!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    4260:	636f6c43 	cmnvs	pc, #17152	; 0x4300
    4264:	646d436b 	strbtvs	r4, [sp], #-875
    4268:	47464300 	strbmi	r4, [r6, -r0, lsl #6]
    426c:	43480052 	movtmi	r0, #32850	; 0x8052
    4270:	465f4b4c 	ldrbmi	r4, [pc], -ip, asr #22
    4274:	75716572 	ldrbvc	r6, [r1, #-1394]!
    4278:	79636e65 	stmdbvc	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
    427c:	42504100 	subsmi	r4, r0, #0	; 0x0
    4280:	524e4531 	subpl	r4, lr, #205520896	; 0xc400000
    4284:	65727000 	ldrbvs	r7, [r2]!
    4288:	52006373 	andpl	r6, r0, #-872415231	; 0xcc000001
    428c:	4d5f4343 	ldclmi	3, cr4, [pc, #-268]
    4290:	6f434f43 	svcvs	0x00434f43
    4294:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    4298:	43435200 	movtmi	r5, #12800	; 0x3200
    429c:	4965445f 	stmdbmi	r5!, {r0, r1, r2, r3, r4, r6, sl, lr}^
    42a0:	0074696e 	rsbseq	r6, r4, lr, ror #18
    42a4:	5f434352 	svcpl	0x00434352
    42a8:	74696157 	strbtvc	r6, [r9], #-343
    42ac:	48726f46 	ldmdami	r2!, {r1, r2, r6, r8, r9, sl, fp, sp, lr}^
    42b0:	74534553 	ldrbvc	r4, [r3], #-1363
    42b4:	55747261 	ldrbpl	r7, [r4, #-609]!
    42b8:	43520070 	cmpmi	r2, #112	; 0x70
    42bc:	54525f43 	ldrbpl	r5, [r2], #-3907
    42c0:	4b4c4343 	blmi	1314fd4 <__Stack_Size+0x1314bd4>
    42c4:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    42c8:	52006563 	andpl	r6, r0, #415236096	; 0x18c00000
    42cc:	415f4343 	cmpmi	pc, r3, asr #6
    42d0:	50314250 	eorspl	r4, r1, r0, asr r2
    42d4:	70697265 	rsbvc	r7, r9, r5, ror #4
    42d8:	73655268 	cmnvc	r5, #-2147483642	; 0x80000006
    42dc:	6d437465 	cfstrdvs	mvd7, [r3, #-404]
    42e0:	43520064 	cmpmi	r2, #100	; 0x64
    42e4:	4c505f43 	mrrcmi	15, 4, r5, r0, cr3
    42e8:	6e6f434c 	cdpvs	3, 6, cr4, cr15, cr12, {2}
    42ec:	00676966 	rsbeq	r6, r7, r6, ror #18
    42f0:	6d6c6c70 	stclvs	12, cr6, [ip, #-448]!
    42f4:	006c6c75 	rsbeq	r6, ip, r5, ror ip
    42f8:	5f434352 	svcpl	0x00434352
    42fc:	43425355 	movtmi	r5, #9045	; 0x2355
    4300:	6f434b4c 	svcvs	0x00434b4c
    4304:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    4308:	43435200 	movtmi	r5, #12800	; 0x3200
    430c:	49534c5f 	ldmdbmi	r3, {r0, r1, r2, r3, r4, r6, sl, fp, lr}^
    4310:	00646d43 	rsbeq	r6, r4, r3, asr #26
    4314:	5f434352 	svcpl	0x00434352
    4318:	53746547 	cmnpl	r4, #297795584	; 0x11c00000
    431c:	4c435359 	mcrrmi	3, 5, r5, r3, cr9
    4320:	756f534b 	strbvc	r5, [pc, #-843]!	; 3fdd <__Stack_Size+0x3bdd>
    4324:	00656372 	rsbeq	r6, r5, r2, ror r3
    4328:	32425041 	subcc	r5, r2, #65	; 0x41
    432c:	52545352 	subspl	r5, r4, #1207959553	; 0x48000001
    4330:	43435200 	movtmi	r5, #12800	; 0x3200
    4334:	4250415f 	subsmi	r4, r0, #-1073741801	; 0xc0000017
    4338:	72655031 	rsbvc	r5, r5, #49	; 0x31
    433c:	00687069 	rsbeq	r7, r8, r9, rrx
    4340:	736c6c70 	cmnvc	ip, #28672	; 0x7000
    4344:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    4348:	48410065 	stmdami	r1, {r0, r2, r5, r6}^
    434c:	524e4542 	subpl	r4, lr, #276824064	; 0x10800000
    4350:	43435200 	movtmi	r5, #12800	; 0x3200
    4354:	4c43505f 	mcrrmi	0, 5, r5, r3, cr15
    4358:	6f43314b 	svcvs	0x0043314b
    435c:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    4360:	61747300 	cmnvs	r4, r0, lsl #6
    4364:	72737574 	rsbsvc	r7, r3, #486539264	; 0x1d000000
    4368:	52006765 	andpl	r6, r0, #26476544	; 0x1940000
    436c:	415f4343 	cmpmi	pc, r3, asr #6
    4370:	50314250 	eorspl	r4, r1, r0, asr r2
    4374:	70697265 	rsbvc	r7, r9, r5, ror #4
    4378:	6f6c4368 	svcvs	0x006c4368
    437c:	6d436b63 	vstrvs	d22, [r3, #-396]
    4380:	50410064 	subpl	r0, r1, r4, rrx
    4384:	4e453242 	cdpmi	2, 4, cr3, cr5, cr2, {2}
    4388:	74530052 	ldrbvc	r0, [r3], #-82
    438c:	55747261 	ldrbpl	r7, [r4, #-609]!
    4390:	756f4370 	strbvc	r4, [pc, #-880]!	; 4028 <__Stack_Size+0x3c28>
    4394:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    4398:	43435200 	movtmi	r5, #12800	; 0x3200
    439c:	6361425f 	cmnvs	r1, #-268435451	; 0xf0000005
    43a0:	5270756b 	rsbspl	r7, r0, #448790528	; 0x1ac00000
    43a4:	74657365 	strbtvc	r7, [r5], #-869
    43a8:	00646d43 	rsbeq	r6, r4, r3, asr #26
    43ac:	5f434352 	svcpl	0x00434352
    43b0:	756a6441 	strbvc	r6, [sl, #-1089]!
    43b4:	53487473 	movtpl	r7, #33907	; 0x8473
    43b8:	6c614349 	stclvs	3, cr4, [r1], #-292
    43bc:	61726269 	cmnvs	r2, r9, ror #4
    43c0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    43c4:	756c6156 	strbvc	r6, [ip, #-342]!
    43c8:	44410065 	strbmi	r0, [r1], #-101
    43cc:	4b4c4343 	blmi	13150e0 <__Stack_Size+0x1314ce0>
    43d0:	6572465f 	ldrbvs	r4, [r2, #-1631]!
    43d4:	6e657571 	mcrvs	5, 3, r7, cr5, cr1, {3}
    43d8:	52007963 	andpl	r7, r0, #1622016	; 0x18c000
    43dc:	465f4343 	ldrbmi	r4, [pc], -r3, asr #6
    43e0:	0047414c 	subeq	r4, r7, ip, asr #2
    43e4:	5f434352 	svcpl	0x00434352
    43e8:	534c4c50 	movtpl	r4, #52304	; 0xcc50
    43ec:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    43f0:	43520065 	cmpmi	r2, #101	; 0x65
    43f4:	59535f43 	ldmdbpl	r3, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    43f8:	4b4c4353 	blmi	131514c <__Stack_Size+0x1314d4c>
    43fc:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    4400:	52006769 	andpl	r6, r0, #27525120	; 0x1a40000
    4404:	475f4343 	ldrbmi	r4, [pc, -r3, asr #6]
    4408:	6c467465 	cfstrdvs	mvd7, [r6], {101}
    440c:	74536761 	ldrbvc	r6, [r3], #-1889
    4410:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    4414:	43435200 	movtmi	r5, #12800	; 0x3200
    4418:	4354525f 	cmpmi	r4, #-268435451	; 0xf0000005
    441c:	434b4c43 	movtmi	r4, #48195	; 0xbc43
    4420:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    4424:	43520067 	cmpmi	r2, #103	; 0x67
    4428:	53555f43 	cmppl	r5, #268	; 0x10c
    442c:	4b4c4342 	blmi	131513c <__Stack_Size+0x1314d3c>
    4430:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    4434:	52006563 	andpl	r6, r0, #415236096	; 0x18c00000
    4438:	535f4343 	cmppl	pc, #201326593	; 0xc000001
    443c:	4c435359 	mcrrmi	3, 5, r5, r3, cr9
    4440:	5348004b 	movtpl	r0, #32843	; 0x804b
    4444:	61745345 	cmnvs	r4, r5, asr #6
    4448:	00737574 	rsbseq	r7, r3, r4, ror r5
    444c:	5f434352 	svcpl	0x00434352
    4450:	43455348 	movtmi	r5, #21320	; 0x5348
    4454:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    4458:	59530067 	ldmdbpl	r3, {r0, r1, r2, r5, r6}^
    445c:	4b4c4353 	blmi	13151b0 <__Stack_Size+0x1314db0>
    4460:	6572465f 	ldrbvs	r4, [r2, #-1631]!
    4464:	6e657571 	mcrvs	5, 3, r7, cr5, cr1, {3}
    4468:	52007963 	andpl	r7, r0, #1622016	; 0x18c000
    446c:	435f4343 	cmpmi	pc, #201326593	; 0xc000001
    4470:	6b636f6c 	blvs	18e0228 <__Stack_Size+0x18dfe28>
    4474:	43500073 	cmpmi	r0, #115	; 0x73
    4478:	5f324b4c 	svcpl	0x00324b4c
    447c:	71657246 	cmnvc	r5, r6, asr #4
    4480:	636e6575 	cmnvs	lr, #490733568	; 0x1d400000
    4484:	43520079 	cmpmi	r2, #121	; 0x79
    4488:	54495f43 	strbpl	r5, [r9], #-3907
    448c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    4490:	52006769 	andpl	r6, r0, #27525120	; 0x1a40000
    4494:	415f4343 	cmpmi	pc, r3, asr #6
    4498:	50324250 	eorspl	r4, r2, r0, asr r2
    449c:	70697265 	rsbvc	r7, r9, r5, ror #4
    44a0:	6f6c4368 	svcvs	0x006c4368
    44a4:	6d436b63 	vstrvs	d22, [r3, #-396]
    44a8:	43520064 	cmpmi	r2, #100	; 0x64
    44ac:	53485f43 	movtpl	r5, #36675	; 0x8f43
    44b0:	43520045 	cmpmi	r2, #69	; 0x45
    44b4:	59535f43 	ldmdbpl	r3, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
    44b8:	4b4c4353 	blmi	131520c <__Stack_Size+0x1314e0c>
    44bc:	72756f53 	rsbsvc	r6, r5, #332	; 0x14c
    44c0:	50006563 	andpl	r6, r0, r3, ror #10
    44c4:	314b4c43 	cmpcc	fp, r3, asr #24
    44c8:	6572465f 	ldrbvs	r4, [r2, #-1631]!
    44cc:	6e657571 	mcrvs	5, 3, r7, cr5, cr1, {3}
    44d0:	52007963 	andpl	r7, r0, #1622016	; 0x18c000
    44d4:	4c5f4343 	mrrcmi	3, 4, r4, pc, cr3
    44d8:	6f434553 	svcvs	0x00434553
    44dc:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    44e0:	42504100 	subsmi	r4, r0, #0	; 0x0
    44e4:	50424841 	subpl	r4, r2, r1, asr #16
    44e8:	63736572 	cmnvs	r3, #478150656	; 0x1c800000
    44ec:	6c626154 	stfvse	f6, [r2], #-336
    44f0:	43520065 	cmpmi	r2, #101	; 0x65
    44f4:	65475f43 	strbvs	r5, [r7, #-3907]
    44f8:	6f6c4374 	svcvs	0x006c4374
    44fc:	46736b63 	ldrbtmi	r6, [r3], -r3, ror #22
    4500:	00716572 	rsbseq	r6, r1, r2, ror r5
    4504:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    4508:	30316632 	eorscc	r6, r1, r2, lsr r6
    450c:	696c5f78 	stmdbvs	ip!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    4510:	72732f62 	rsbsvc	r2, r3, #392	; 0x188
    4514:	74732f63 	ldrbtvc	r2, [r3], #-3939
    4518:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    451c:	5f783031 	svcpl	0x00783031
    4520:	2e636372 	mcrcs	3, 3, r6, cr3, cr2, {3}
    4524:	43520063 	cmpmi	r2, #99	; 0x63
    4528:	54525f43 	ldrbpl	r5, [r2], #-3907
    452c:	4b4c4343 	blmi	1315240 <__Stack_Size+0x1314e40>
    4530:	00646d43 	rsbeq	r6, r4, r3, asr #26
    4534:	5f434352 	svcpl	0x00434352
    4538:	636f6c43 	cmnvs	pc, #17152	; 0x4300
    453c:	6365536b 	cmnvs	r5, #-1409286143	; 0xac000001
    4540:	74697275 	strbtvc	r7, [r9], #-629
    4544:	73795379 	cmnvc	r9, #-469762047	; 0xe4000001
    4548:	436d6574 	cmnmi	sp, #486539264	; 0x1d000000
    454c:	5200646d 	andpl	r6, r0, #1828716544	; 0x6d000000
    4550:	485f4343 	ldmdami	pc, {r0, r1, r6, r8, r9, lr}^
    4554:	434b4c43 	movtmi	r4, #48195	; 0xbc43
    4558:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    455c:	43520067 	cmpmi	r2, #103	; 0x67
    4560:	53485f43 	movtpl	r5, #36675	; 0x8f43
    4564:	646d4349 	strbtvs	r4, [sp], #-841
    4568:	43435200 	movtmi	r5, #12800	; 0x3200
    456c:	4f434d5f 	svcmi	0x00434d5f
    4570:	43435200 	movtmi	r5, #12800	; 0x3200
    4574:	0054495f 	subseq	r4, r4, pc, asr r9
    4578:	5f434352 	svcpl	0x00434352
    457c:	50424841 	subpl	r4, r2, r1, asr #16
    4580:	70697265 	rsbvc	r7, r9, r5, ror #4
    4584:	43520068 	cmpmi	r2, #104	; 0x68
    4588:	43505f43 	cmpmi	r0, #268	; 0x10c
    458c:	43324b4c 	teqmi	r2, #77824	; 0x13000
    4590:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    4594:	44410067 	strbmi	r0, [r1], #-103
    4598:	65725043 	ldrbvs	r5, [r2, #-67]!
    459c:	61546373 	cmpvs	r4, r3, ror r3
    45a0:	00656c62 	rsbeq	r6, r5, r2, ror #24
    45a4:	54737953 	ldrbtpl	r7, [r3], #-2387
    45a8:	5f6b6369 	svcpl	0x006b6369
    45ac:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    45b0:	746e756f 	strbtvc	r7, [lr], #-1391
    45b4:	53007265 	movwpl	r7, #613	; 0x265
    45b8:	69547379 	ldmdbvs	r4, {r0, r3, r4, r5, r6, r8, r9, ip, sp, lr}^
    45bc:	535f6b63 	cmppl	pc, #101376	; 0x18c00
    45c0:	65527465 	ldrbvs	r7, [r2, #-1125]
    45c4:	64616f6c 	strbtvs	r6, [r1], #-3948
    45c8:	73795300 	cmnvc	r9, #0	; 0x0
    45cc:	6b636954 	blvs	18deb24 <__Stack_Size+0x18de724>
    45d0:	7465475f 	strbtvc	r4, [r5], #-1887
    45d4:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    45d8:	74617453 	strbtvc	r7, [r1], #-1107
    45dc:	53007375 	movwpl	r7, #885	; 0x375
    45e0:	69547379 	ldmdbvs	r4, {r0, r3, r4, r5, r6, r8, r9, ip, sp, lr}^
    45e4:	465f6b63 	ldrbmi	r6, [pc], -r3, ror #22
    45e8:	0047414c 	subeq	r4, r7, ip, asr #2
    45ec:	494c4143 	stmdbmi	ip, {r0, r1, r6, r8, lr}^
    45f0:	74730042 	ldrbtvc	r0, [r3], #-66
    45f4:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    45f8:	5f783031 	svcpl	0x00783031
    45fc:	2f62696c 	svccs	0x0062696c
    4600:	2f637273 	svccs	0x00637273
    4604:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    4608:	30316632 	eorscc	r6, r1, r2, lsr r6
    460c:	79735f78 	ldmdbvc	r3!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    4610:	63697473 	cmnvs	r9, #1929379840	; 0x73000000
    4614:	00632e6b 	rsbeq	r2, r3, fp, ror #28
    4618:	4c525443 	cfldrdmi	mvd5, [r2], {67}
    461c:	73795300 	cmnvc	r9, #0	; 0x0
    4620:	6b636954 	blvs	18deb78 <__Stack_Size+0x18de778>
    4624:	756f435f 	strbvc	r4, [pc, #-863]!	; 42cd <__Stack_Size+0x3ecd>
    4628:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    462c:	00646d43 	rsbeq	r6, r4, r3, asr #26
    4630:	54737953 	ldrbtpl	r7, [r3], #-2387
    4634:	5f6b6369 	svcpl	0x006b6369
    4638:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    463c:	00726574 	rsbseq	r6, r2, r4, ror r5
    4640:	54737953 	ldrbtpl	r7, [r3], #-2387
    4644:	5f6b6369 	svcpl	0x006b6369
    4648:	534b4c43 	movtpl	r4, #48195	; 0xbc43
    464c:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    4650:	6e6f4365 	cdpvs	3, 6, cr4, cr15, cr5, {3}
    4654:	00676966 	rsbeq	r6, r7, r6, ror #18
    4658:	54737953 	ldrbtpl	r7, [r3], #-2387
    465c:	5f6b6369 	svcpl	0x006b6369
    4660:	534b4c43 	movtpl	r4, #48195	; 0xbc43
    4664:	6372756f 	cmnvs	r2, #465567744	; 0x1bc00000
    4668:	79530065 	ldmdbvc	r3, {r0, r2, r5, r6}^
    466c:	63695473 	cmnvs	r9, #1929379840	; 0x73000000
    4670:	54495f6b 	strbpl	r5, [r9], #-3947
    4674:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    4678:	69006769 	stmdbvs	r0, {r0, r3, r5, r6, r8, r9, sl, sp, lr}
    467c:	6765746e 	strbvs	r7, [r5, -lr, ror #8]!
    4680:	69647265 	stmdbvs	r4!, {r0, r2, r5, r6, r9, ip, sp, lr}^
    4684:	65646976 	strbvs	r6, [r4, #-2422]!
    4688:	53550072 	cmppl	r5, #114	; 0x72
    468c:	5f545241 	svcpl	0x00545241
    4690:	41485043 	cmpmi	r8, r3, asr #32
    4694:	41535500 	cmpmi	r3, r0, lsl #10
    4698:	535f5452 	cmppl	pc, #1375731712	; 0x52000000
    469c:	72507465 	subsvc	r7, r0, #1694498816	; 0x65000000
    46a0:	61637365 	cmnvs	r3, r5, ror #6
    46a4:	0072656c 	rsbseq	r6, r2, ip, ror #10
    46a8:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    46ac:	6e495f54 	mcrvs	15, 2, r5, cr9, cr4, {2}
    46b0:	55007469 	strpl	r7, [r0, #-1129]
    46b4:	54524153 	ldrbpl	r4, [r2], #-339
    46b8:	4e494c5f 	mcrmi	12, 2, r4, cr9, cr15, {2}
    46bc:	61657242 	cmnvs	r5, r2, asr #4
    46c0:	7465446b 	strbtvc	r4, [r5], #-1131
    46c4:	4c746365 	ldclmi	3, cr6, [r4], #-404
    46c8:	74676e65 	strbtvc	r6, [r7], #-3685
    46cc:	53550068 	cmppl	r5, #104	; 0x68
    46d0:	5f545241 	svcpl	0x00545241
    46d4:	65707954 	ldrbvs	r7, [r0, #-2388]!
    46d8:	00666544 	rsbeq	r6, r6, r4, asr #10
    46dc:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    46e0:	6c435f54 	mcrrvs	15, 5, r5, r3, cr4
    46e4:	496b636f 	stmdbmi	fp!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    46e8:	5474696e 	ldrbtpl	r6, [r4], #-2414
    46ec:	44657079 	strbtmi	r7, [r5], #-121
    46f0:	55006665 	strpl	r6, [r0, #-1637]
    46f4:	54524153 	ldrbpl	r4, [r2], #-339
    46f8:	646d435f 	strbtvs	r4, [sp], #-863
    46fc:	41535500 	cmpmi	r3, r0, lsl #10
    4700:	535f5452 	cmppl	pc, #1375731712	; 0x52000000
    4704:	44646e65 	strbtmi	r6, [r4], #-3685
    4708:	00617461 	rsbeq	r7, r1, r1, ror #8
    470c:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    4710:	61485f54 	cmpvs	r8, r4, asr pc
    4714:	7544666c 	strbvc	r6, [r4, #-1644]
    4718:	78656c70 	stmdavc	r5!, {r4, r5, r6, sl, fp, sp, lr}^
    471c:	00646d43 	rsbeq	r6, r4, r3, asr #26
    4720:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    4724:	61575f54 	cmpvs	r7, r4, asr pc
    4728:	7055656b 	subsvc	r6, r5, fp, ror #10
    472c:	41535500 	cmpmi	r3, r0, lsl #10
    4730:	445f5452 	ldrbmi	r5, [pc], #1106	; 4738 <__Stack_Size+0x4338>
    4734:	6d43414d 	stfvse	f4, [r3, #-308]
    4738:	53550064 	cmppl	r5, #100	; 0x64
    473c:	5f545241 	svcpl	0x00545241
    4740:	7473614c 	ldrbtvc	r6, [r3], #-332
    4744:	00746942 	rsbseq	r6, r4, r2, asr #18
    4748:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    474c:	72495f54 	subvc	r5, r9, #336	; 0x150
    4750:	6f4d4144 	svcvs	0x004d4144
    4754:	61006564 	tstvs	r0, r4, ror #10
    4758:	6c636270 	sfmvs	f6, 2, [r3], #-448
    475c:	006b636f 	rsbeq	r6, fp, pc, ror #6
    4760:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    4764:	6c435f54 	mcrrvs	15, 5, r5, r3, cr4
    4768:	49726165 	ldmdbmi	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    476c:	6e655054 	mcrvs	0, 3, r5, cr5, cr4, {2}
    4770:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
    4774:	00746942 	rsbseq	r6, r4, r2, asr #18
    4778:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    477c:	75475f54 	strbvc	r5, [r7, #-3924]
    4780:	54647261 	strbtpl	r7, [r4], #-609
    4784:	00656d69 	rsbeq	r6, r5, r9, ror #26
    4788:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    478c:	494c5f54 	stmdbmi	ip, {r2, r4, r6, r8, r9, sl, fp, ip, lr}^
    4790:	6572424e 	ldrbvs	r4, [r2, #-590]!
    4794:	65446b61 	strbvs	r6, [r4, #-2913]
    4798:	74636574 	strbtvc	r6, [r3], #-1396
    479c:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
    47a0:	6f436874 	svcvs	0x00436874
    47a4:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    47a8:	41535500 	cmpmi	r3, r0, lsl #10
    47ac:	465f5452 	undefined
    47b0:	0047414c 	subeq	r4, r7, ip, asr #2
    47b4:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    47b8:	65445f54 	strbvs	r5, [r4, #-3924]
    47bc:	74696e49 	strbtvc	r6, [r9], #-3657
    47c0:	41535500 	cmpmi	r3, r0, lsl #10
    47c4:	435f5452 	cmpmi	pc, #1375731712	; 0x52000000
    47c8:	6b636f6c 	blvs	18e0580 <__Stack_Size+0x18e0180>
    47cc:	74696e49 	strbtvc	r6, [r9], #-3657
    47d0:	75727453 	ldrbvc	r7, [r2, #-1107]!
    47d4:	55007463 	strpl	r7, [r0, #-1123]
    47d8:	54524153 	ldrbpl	r4, [r2], #-339
    47dc:	414d445f 	cmpmi	sp, pc, asr r4
    47e0:	00716552 	rsbseq	r6, r1, r2, asr r5
    47e4:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    47e8:	6c435f54 	mcrrvs	15, 5, r5, r3, cr4
    47ec:	536b636f 	cmnpl	fp, #-1140850687	; 0xbc000001
    47f0:	63757274 	cmnvs	r5, #1073741831	; 0x40000007
    47f4:	696e4974 	stmdbvs	lr!, {r2, r4, r5, r6, r8, fp, lr}^
    47f8:	73750074 	cmnvc	r5, #116	; 0x74
    47fc:	78747261 	ldmdavc	r4!, {r0, r5, r6, r9, ip, sp, lr}^
    4800:	65736162 	ldrbvs	r6, [r3, #-354]!
    4804:	43435200 	movtmi	r5, #12800	; 0x3200
    4808:	6f6c435f 	svcvs	0x006c435f
    480c:	53736b63 	cmnpl	r3, #101376	; 0x18c00
    4810:	75746174 	ldrbvc	r6, [r4, #-372]!
    4814:	53550073 	cmppl	r5, #115	; 0x73
    4818:	5f545241 	svcpl	0x00545241
    481c:	41746553 	cmnmi	r4, r3, asr r5
    4820:	65726464 	ldrbvs	r6, [r2, #-1124]!
    4824:	55007373 	strpl	r7, [r0, #-883]
    4828:	54524153 	ldrbpl	r4, [r2], #-339
    482c:	7465535f 	strbtvc	r5, [r5], #-863
    4830:	72617547 	rsbvc	r7, r1, #297795584	; 0x11c00000
    4834:	6d695464 	cfstrdvs	mvd5, [r9, #-400]!
    4838:	53550065 	cmppl	r5, #101	; 0x65
    483c:	5f545241 	svcpl	0x00545241
    4840:	646e6553 	strbtvs	r6, [lr], #-1363
    4844:	61657242 	cmnvs	r5, r2, asr #4
    4848:	5355006b 	cmppl	r5, #107	; 0x6b
    484c:	5f545241 	svcpl	0x00545241
    4850:	6f435449 	svcvs	0x00435449
    4854:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    4858:	41535500 	cmpmi	r3, r0, lsl #10
    485c:	00785452 	rsbseq	r5, r8, r2, asr r4
    4860:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    4864:	6d535f54 	ldclvs	15, cr5, [r3, #-336]
    4868:	43747261 	cmnmi	r4, #268435462	; 0x10000006
    486c:	43647261 	cmnmi	r4, #268435462	; 0x10000006
    4870:	5500646d 	strpl	r6, [r0, #-1133]
    4874:	54524153 	ldrbpl	r4, [r2], #-339
    4878:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    487c:	72745374 	rsbsvc	r5, r4, #-805306367	; 0xd0000001
    4880:	00746375 	rsbseq	r6, r4, r5, ror r3
    4884:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    4888:	64415f54 	strbvs	r5, [r1], #-3924
    488c:	73657264 	cmnvc	r5, #1073741830	; 0x40000006
    4890:	69620073 	stmdbvs	r2!, {r0, r1, r4, r5, r6}^
    4894:	736f7074 	cmnvc	pc, #116	; 0x74
    4898:	41535500 	cmpmi	r3, r0, lsl #10
    489c:	435f5452 	cmpmi	pc, #1375731712	; 0x52000000
    48a0:	7261656c 	rsbvc	r6, r1, #452984832	; 0x1b000000
    48a4:	67616c46 	strbvs	r6, [r1, -r6, asr #24]!
    48a8:	41535500 	cmpmi	r3, r0, lsl #10
    48ac:	475f5452 	undefined
    48b0:	54497465 	strbpl	r7, [r9], #-1125
    48b4:	74617453 	strbtvc	r7, [r1], #-1107
    48b8:	55007375 	strpl	r7, [r0, #-885]
    48bc:	54524153 	ldrbpl	r4, [r2], #-339
    48c0:	4472495f 	ldrbtmi	r4, [r2], #-2399
    48c4:	6e6f4341 	cdpvs	3, 6, cr4, cr15, cr1, {2}
    48c8:	00676966 	rsbeq	r6, r7, r6, ror #18
    48cc:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    48d0:	6c435f54 	mcrrvs	15, 5, r5, r3, cr4
    48d4:	006b636f 	rsbeq	r6, fp, pc, ror #6
    48d8:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    48dc:	65525f54 	ldrbvs	r5, [r2, #-3924]
    48e0:	76696563 	strbtvc	r6, [r9], -r3, ror #10
    48e4:	61577265 	cmpvs	r7, r5, ror #4
    48e8:	7055656b 	subsvc	r6, r5, fp, ror #10
    48ec:	00646d43 	rsbeq	r6, r4, r3, asr #26
    48f0:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    48f4:	72495f54 	subvc	r5, r9, #336	; 0x150
    48f8:	6d434144 	stfvse	f4, [r3, #-272]
    48fc:	53550064 	cmppl	r5, #100	; 0x64
    4900:	5f545241 	svcpl	0x00545241
    4904:	434e494c 	movtmi	r4, #59724	; 0xe94c
    4908:	6600646d 	strvs	r6, [r0], -sp, ror #8
    490c:	74636172 	strbtvc	r6, [r3], #-370
    4910:	616e6f69 	cmnvs	lr, r9, ror #30
    4914:	7669646c 	strbtvc	r6, [r9], -ip, ror #8
    4918:	72656469 	rsbvc	r6, r5, #1761607680	; 0x69000000
    491c:	41535500 	cmpmi	r3, r0, lsl #10
    4920:	535f5452 	cmppl	pc, #1375731712	; 0x52000000
    4924:	7472616d 	ldrbtvc	r6, [r2], #-365
    4928:	64726143 	ldrbtvs	r6, [r2], #-323
    492c:	4b43414e 	blmi	10d4e6c <__Stack_Size+0x10d4a6c>
    4930:	00646d43 	rsbeq	r6, r4, r3, asr #26
    4934:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    4938:	65475f54 	strbvs	r5, [r7, #-3924]
    493c:	616c4674 	smcvs	50276
    4940:	61745367 	cmnvs	r4, r7, ror #6
    4944:	00737574 	rsbseq	r7, r3, r4, ror r5
    4948:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    494c:	54495f54 	strbpl	r5, [r9], #-3924
    4950:	41535500 	cmpmi	r3, r0, lsl #10
    4954:	435f5452 	cmpmi	pc, #1375731712	; 0x52000000
    4958:	6b636f6c 	blvs	18e0710 <__Stack_Size+0x18e0310>
    495c:	74696e49 	strbtvc	r6, [r9], #-3657
    4960:	41535500 	cmpmi	r3, r0, lsl #10
    4964:	575f5452 	undefined
    4968:	55656b61 	strbpl	r6, [r5, #-2913]!
    496c:	6e6f4370 	mcrvs	3, 3, r4, cr15, cr0, {3}
    4970:	00676966 	rsbeq	r6, r7, r6, ror #18
    4974:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
    4978:	65525f54 	ldrbvs	r5, [r2, #-3924]
    497c:	76696563 	strbtvc	r6, [r9], -r3, ror #10
    4980:	74614465 	strbtvc	r4, [r1], #-1125
    4984:	53550061 	cmppl	r5, #97	; 0x61
    4988:	5f545241 	svcpl	0x00545241
    498c:	73657250 	cmnvc	r5, #5	; 0x5
    4990:	656c6163 	strbvs	r6, [ip, #-355]!
    4994:	53550072 	cmppl	r5, #114	; 0x72
    4998:	5f545241 	svcpl	0x00545241
    499c:	4c4f5043 	mcrrmi	0, 4, r5, pc, cr3
    49a0:	6d747300 	ldclvs	3, cr7, [r4]
    49a4:	31663233 	cmncc	r6, r3, lsr r2
    49a8:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    49ac:	732f6269 	teqvc	pc, #-1879048186	; 0x90000006
    49b0:	732f6372 	teqvc	pc, #-939524095	; 0xc8000001
    49b4:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    49b8:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    49bc:	6173755f 	cmnvs	r3, pc, asr r5
    49c0:	632e7472 	teqvs	lr, #1912602624	; 0x72000000
    49c4:	61737500 	cmnvs	r3, r0, lsl #10
    49c8:	65727472 	ldrbvs	r7, [r2, #-1138]!
    49cc:	53550067 	cmppl	r5, #103	; 0x67
    49d0:	5f545241 	svcpl	0x00545241
    49d4:	75727453 	ldrbvc	r7, [r2, #-1107]!
    49d8:	6e497463 	cdpvs	4, 4, cr7, cr9, cr3, {3}
    49dc:	5f007469 	svcpl	0x00007469
    49e0:	61747365 	cmnvs	r4, r5, ror #6
    49e4:	5f006b63 	svcpl	0x00006b63
    49e8:	74616473 	strbtvc	r6, [r1], #-1139
    49ec:	65520061 	ldrbvs	r0, [r2, #-97]
    49f0:	5f746573 	svcpl	0x00746573
    49f4:	646e6148 	strbtvs	r6, [lr], #-328
    49f8:	0072656c 	rsbseq	r6, r2, ip, ror #10
    49fc:	446c7570 	strbtmi	r7, [ip], #-1392
    4a00:	00747365 	rsbseq	r7, r4, r5, ror #6
    4a04:	6469735f 	strbtvs	r7, [r9], #-863
    4a08:	00617461 	rsbeq	r7, r1, r1, ror #8
    4a0c:	7362655f 	cmnvc	r2, #398458880	; 0x17c00000
    4a10:	655f0073 	ldrbvs	r0, [pc, #-115]	; 49a5 <__Stack_Size+0x45a5>
    4a14:	61746164 	cmnvs	r4, r4, ror #2
    4a18:	6d747300 	ldclvs	3, cr7, [r4]
    4a1c:	31663233 	cmncc	r6, r3, lsr r2
    4a20:	6c5f7830 	mrrcvs	8, 3, r7, pc, cr0
    4a24:	732f6269 	teqvc	pc, #-1879048186	; 0x90000006
    4a28:	732f6372 	teqvc	pc, #-939524095	; 0xc8000001
    4a2c:	32336d74 	eorscc	r6, r3, #7424	; 0x1d00
    4a30:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
    4a34:	6365765f 	cmnvs	r5, #99614720	; 0x5f00000
    4a38:	2e726f74 	mrccs	15, 3, r6, cr2, cr4, {3}
    4a3c:	5f670063 	svcpl	0x00670063
    4a40:	566e6670 	undefined
    4a44:	6f746365 	svcvs	0x00746365
    4a48:	70007372 	andvc	r7, r0, r2, ror r3
    4a4c:	72536c75 	subsvc	r6, r3, #29952	; 0x7500
    4a50:	735f0063 	cmpvc	pc, #99	; 0x63
    4a54:	00737362 	rsbseq	r7, r3, r2, ror #6
    4a58:	775c3a63 	ldrbvc	r3, [ip, -r3, ror #20]
    4a5c:	72616e69 	rsbvc	r6, r1, #1680	; 0x690
    4a60:	625c736d 	subsvs	r7, ip, #-1275068415	; 0xb4000001
    4a64:	646c6975 	strbtvs	r6, [ip], #-2421
    4a68:	6363675c 	cmnvs	r3, #24117248	; 0x1700000
    4a6c:	6975622d 	ldmdbvs	r5!, {r0, r2, r3, r5, r9, sp, lr}^
    4a70:	615c646c 	cmpvs	ip, ip, ror #8
    4a74:	652d6d72 	strvs	r6, [sp, #-3442]!
    4a78:	5c696261 	sfmpl	f6, 2, [r9], #-388
    4a7c:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    4a80:	6c5c6269 	lfmvs	f6, 2, [ip], {105}
    4a84:	5c636269 	sfmpl	f6, 2, [r3], #-420
    4a88:	6c647473 	cfstrdvs	mvd7, [r4], #-460
    4a8c:	2e006269 	cdpcs	2, 0, cr6, cr0, cr9, {3}
    4a90:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    4a94:	2f2e2e2f 	svccs	0x002e2e2f
    4a98:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    4a9c:	63672f2e 	cmnvs	r7, #184	; 0xb8
    4aa0:	2e342d63 	cdpcs	13, 3, cr2, cr4, cr3, {3}
    4aa4:	2f302e33 	svccs	0x00302e33
    4aa8:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    4aac:	6c2f6269 	sfmvs	f6, 4, [pc], #-420
    4ab0:	2f636269 	svccs	0x00636269
    4ab4:	6c647473 	cfstrdvs	mvd7, [r4], #-460
    4ab8:	612f6269 	teqvs	pc, r9, ror #4
    4abc:	69786574 	ldmdbvs	r8!, {r2, r4, r5, r6, r8, sl, sp, lr}^
    4ac0:	00632e74 	rsbeq	r2, r3, r4, ror lr
    4ac4:	74655f5f 	strbtvc	r5, [r5], #-3935
    4ac8:	6178635f 	cmnvs	r8, pc, asr r3
    4acc:	655f5f00 	ldrbvs	r5, [pc, #-3840]	; 3bd4 <__Stack_Size+0x37d4>
    4ad0:	6e6f5f74 	mcrvs	15, 3, r5, cr15, cr4, {3}
    4ad4:	74697865 	strbtvc	r7, [r9], #-2149
    4ad8:	615f5f00 	cmpvs	pc, r0, lsl #30
    4adc:	69786574 	ldmdbvs	r8!, {r2, r4, r5, r6, r8, sl, sp, lr}^
    4ae0:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    4ae4:	00736570 	rsbseq	r6, r3, r0, ror r5
    4ae8:	74655f5f 	strbtvc	r5, [r5], #-3935
    4aec:	6574615f 	ldrbvs	r6, [r4, #-351]!
    4af0:	00746978 	rsbseq	r6, r4, r8, ror r9
    4af4:	6f73645f 	svcvs	0x0073645f
    4af8:	6e61685f 	mcrvs	8, 3, r6, cr1, cr15, {2}
    4afc:	00656c64 	rsbeq	r6, r5, r4, ror #24
    4b00:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    4b04:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    4b08:	2f2e2e2f 	svccs	0x002e2e2f
    4b0c:	672f2e2e 	strvs	r2, [pc, -lr, lsr #28]!
    4b10:	342d6363 	strtcc	r6, [sp], #-867
    4b14:	302e332e 	eorcc	r3, lr, lr, lsr #6
    4b18:	77656e2f 	strbvc	r6, [r5, -pc, lsr #28]!
    4b1c:	2f62696c 	svccs	0x0062696c
    4b20:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    4b24:	6474732f 	ldrbtvs	r7, [r4], #-815
    4b28:	2f62696c 	svccs	0x0062696c
    4b2c:	74697865 	strbtvc	r7, [r9], #-2149
    4b30:	5f00632e 	svcpl	0x0000632e
    4b34:	657a6973 	ldrbvs	r6, [sl, #-2419]!
    4b38:	61725f00 	cmnvs	r2, r0, lsl #30
    4b3c:	3834646e 	ldmdacc	r4!, {r1, r2, r3, r5, r6, sl, sp, lr}
    4b40:	6d655f00 	stclvs	15, cr5, [r5]
    4b44:	65677265 	strbvs	r7, [r7, #-613]!
    4b48:	0079636e 	rsbseq	r6, r9, lr, ror #6
    4b4c:	7263775f 	rsbvc	r7, r3, #24903680	; 0x17c0000
    4b50:	626d6f74 	rsbvs	r6, sp, #464	; 0x1d0
    4b54:	6174735f 	cmnvs	r4, pc, asr r3
    4b58:	5f006574 	svcpl	0x00006574
    4b5c:	72736377 	rsbsvc	r6, r3, #-603979775	; 0xdc000001
    4b60:	626d6f74 	rsbvs	r6, sp, #464	; 0x1d0
    4b64:	74735f73 	ldrbtvc	r5, [r3], #-3955
    4b68:	00657461 	rsbeq	r7, r5, r1, ror #8
    4b6c:	66626c5f 	undefined
    4b70:	657a6973 	ldrbvs	r6, [sl, #-2419]!
    4b74:	626d5f00 	rsbvs	r5, sp, #0	; 0x0
    4b78:	776f7472 	undefined
    4b7c:	74735f63 	ldrbtvc	r5, [r3], #-3939
    4b80:	00657461 	rsbeq	r7, r5, r1, ror #8
    4b84:	7463775f 	strbtvc	r7, [r3], #-1887
    4b88:	5f626d6f 	svcpl	0x00626d6f
    4b8c:	74617473 	strbtvc	r7, [r1], #-1139
    4b90:	5f5f0065 	svcpl	0x005f0065
    4b94:	735f6d74 	cmpvc	pc, #7424	; 0x1d00
    4b98:	5f006365 	svcpl	0x00006365
    4b9c:	66756275 	undefined
    4ba0:	61625f00 	cmnvs	r2, r0, lsl #30
    4ba4:	5f006573 	svcpl	0x00006573
    4ba8:	5f6d745f 	svcpl	0x006d745f
    4bac:	72756f68 	rsbsvc	r6, r5, #416	; 0x1a0
    4bb0:	735f5f00 	cmpvc	pc, #0	; 0x0
    4bb4:	6f5f0066 	svcvs	0x005f0066
    4bb8:	78655f6e 	stmdavc	r5!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    4bbc:	615f7469 	cmpvs	pc, r9, ror #8
    4bc0:	00736772 	rsbseq	r6, r3, r2, ror r7
    4bc4:	6f6f635f 	svcvs	0x006f635f
    4bc8:	0065696b 	rsbeq	r6, r5, fp, ror #18
    4bcc:	67735f5f 	undefined
    4bd0:	0065756c 	rsbeq	r7, r5, ip, ror #10
    4bd4:	616c665f 	cmnvs	ip, pc, asr r6
    4bd8:	5f007367 	svcpl	0x00007367
    4bdc:	635f7369 	cmpvs	pc, #-1543503871	; 0xa4000001
    4be0:	5f006178 	svcpl	0x00006178
    4be4:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    4be8:	625f006e 	subsvs	r0, pc, #110	; 0x6e
    4bec:	69736b6c 	ldmdbvs	r3!, {r2, r3, r5, r6, r8, r9, fp, sp, lr}^
    4bf0:	5f00657a 	svcpl	0x0000657a
    4bf4:	62747663 	rsbsvs	r7, r4, #103809024	; 0x6300000
    4bf8:	5f006675 	svcpl	0x00006675
    4bfc:	7273626d 	rsbsvc	r6, r3, #-805306362	; 0xd0000006
    4c00:	63776f74 	cmnvs	r7, #464	; 0x1d0
    4c04:	74735f73 	ldrbtvc	r5, [r3], #-3955
    4c08:	00657461 	rsbeq	r7, r5, r1, ror #8
    4c0c:	72626d5f 	rsbvc	r6, r2, #6080	; 0x17c0
    4c10:	5f6e656c 	svcpl	0x006e656c
    4c14:	74617473 	strbtvc	r7, [r1], #-1139
    4c18:	665f0065 	ldrbvs	r0, [pc], -r5, rrx
    4c1c:	6772616e 	ldrbvs	r6, [r2, -lr, ror #2]!
    4c20:	665f0073 	undefined
    4c24:	5f00736e 	svcpl	0x0000736e
    4c28:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
    4c2c:	6c665f00 	stclvs	15, cr5, [r6]
    4c30:	5f6b636f 	svcpl	0x006b636f
    4c34:	735f0074 	cmpvc	pc, #116	; 0x74
    4c38:	72656474 	rsbvc	r6, r5, #1946157056	; 0x74000000
    4c3c:	425f0072 	subsmi	r0, pc, #114	; 0x72
    4c40:	6e696769 	cdpvs	7, 6, cr6, cr9, cr9, {3}
    4c44:	725f0074 	subsvc	r0, pc, #116	; 0x74
    4c48:	00646165 	rsbeq	r6, r4, r5, ror #2
    4c4c:	7365725f 	cmnvc	r5, #-268435451	; 0xf0000005
    4c50:	5f746c75 	svcpl	0x00746c75
    4c54:	5f5f006b 	svcpl	0x005f006b
    4c58:	5f006d74 	svcpl	0x00006d74
    4c5c:	6863775f 	stmdavs	r3!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, ip, sp, lr}^
    4c60:	735f0062 	cmpvc	pc, #98	; 0x62
    4c64:	756f6474 	strbvc	r6, [pc, #-1140]!	; 47f8 <__Stack_Size+0x43f8>
    4c68:	635f0074 	cmpvs	pc, #116	; 0x74
    4c6c:	656c7476 	strbvs	r7, [ip, #-1142]!
    4c70:	665f006e 	ldrbvs	r0, [pc], -lr, rrx
    4c74:	00656c69 	rsbeq	r6, r5, r9, ror #24
    4c78:	6f696e5f 	svcvs	0x00696e5f
    4c7c:	5f007362 	svcpl	0x00007362
    4c80:	78657461 	stmdavc	r5!, {r0, r5, r6, sl, ip, sp, lr}^
    4c84:	00307469 	eorseq	r7, r0, r9, ror #8
    4c88:	6769735f 	undefined
    4c8c:	5f6c616e 	svcpl	0x006c616e
    4c90:	00667562 	rsbeq	r7, r6, r2, ror #10
    4c94:	6373615f 	cmnvs	r3, #-1073741801	; 0xc0000017
    4c98:	656d6974 	strbvs	r6, [sp, #-2420]!
    4c9c:	6675625f 	undefined
    4ca0:	775f5f00 	ldrbvc	r5, [pc, -r0, lsl #30]
    4ca4:	77006863 	strvc	r6, [r0, -r3, ror #16]
    4ca8:	5f746e69 	svcpl	0x00746e69
    4cac:	6c5f0074 	mrrcvs	0, 7, r0, pc, cr4
    4cb0:	006b636f 	rsbeq	r6, fp, pc, ror #6
    4cb4:	6c756d5f 	ldclvs	13, cr6, [r5], #-380
    4cb8:	775f0074 	undefined
    4cbc:	65746972 	ldrbvs	r6, [r4, #-2418]!
    4cc0:	745f5f00 	ldrbvc	r5, [pc], #3840	; 4cc8 <__Stack_Size+0x48c8>
    4cc4:	65795f6d 	ldrbvs	r5, [r9, #-3949]!
    4cc8:	5f007261 	svcpl	0x00007261
    4ccc:	7478656e 	ldrbtvc	r6, [r8], #-1390
    4cd0:	5f5f0066 	svcpl	0x005f0066
    4cd4:	6d5f6d74 	ldclvs	13, cr6, [pc, #-464]
    4cd8:	5f006e6f 	svcpl	0x00006e6f
    4cdc:	6964735f 	stmdbvs	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, ip, sp, lr}^
    4ce0:	696e6964 	stmdbvs	lr!, {r2, r5, r6, r8, fp, sp, lr}^
    4ce4:	675f0074 	undefined
    4ce8:	616d6d61 	cmnvs	sp, r1, ror #26
    4cec:	6769735f 	undefined
    4cf0:	6d61676e 	stclvs	7, cr6, [r1, #-440]!
    4cf4:	72665f00 	rsbvc	r5, r6, #0	; 0x0
    4cf8:	696c6565 	stmdbvs	ip!, {r0, r2, r5, r6, r8, sl, sp, lr}^
    4cfc:	5f007473 	svcpl	0x00007473
    4d00:	4b434f4c 	blmi	10d8a38 <__Stack_Size+0x10d8638>
    4d04:	4345525f 	movtmi	r5, #21087	; 0x525f
    4d08:	49535255 	ldmdbmi	r3, {r0, r2, r4, r6, r9, ip, lr}^
    4d0c:	545f4556 	ldrbpl	r4, [pc], #1366	; 4d14 <__Stack_Size+0x4914>
    4d10:	656e5f00 	strbvs	r5, [lr, #-3840]!
    4d14:	5f5f0077 	svcpl	0x005f0077
    4d18:	795f6d74 	ldmdbvc	pc, {r2, r4, r5, r6, r8, sl, fp, sp, lr}^
    4d1c:	00796164 	rsbseq	r6, r9, r4, ror #2
    4d20:	62735f5f 	rsbsvs	r5, r3, #380	; 0x17c
    4d24:	5f006675 	svcpl	0x00006675
    4d28:	73626f69 	cmnvc	r2, #420	; 0x1a4
    4d2c:	465f5f00 	ldrbmi	r5, [pc], -r0, lsl #30
    4d30:	00454c49 	subeq	r4, r5, r9, asr #24
    4d34:	73626d5f 	cmnvc	r2, #6080	; 0x17c0
    4d38:	65746174 	ldrbvs	r6, [r4, #-372]!
    4d3c:	5f00745f 	svcpl	0x0000745f
    4d40:	4946735f 	stmdbmi	r6, {r0, r1, r2, r3, r4, r6, r8, r9, ip, sp, lr}^
    4d44:	5f00454c 	svcpl	0x0000454c
    4d48:	646e6172 	strbtvs	r6, [lr], #-370
    4d4c:	78656e5f 	stmdavc	r5!, {r0, r1, r2, r3, r4, r6, r9, sl, fp, sp, lr}^
    4d50:	6d5f0074 	ldclvs	0, cr0, [pc, #-464]
    4d54:	6e656c62 	cdpvs	12, 6, cr6, cr5, cr2, {3}
    4d58:	6174735f 	cmnvs	r4, pc, asr r3
    4d5c:	5f006574 	svcpl	0x00006574
    4d60:	00636e69 	rsbeq	r6, r3, r9, ror #28
    4d64:	646e695f 	strbtvs	r6, [lr], #-2399
    4d68:	75635f00 	strbvc	r5, [r3, #-3840]!
    4d6c:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
    4d70:	6f6c5f74 	svcvs	0x006c5f74
    4d74:	656c6163 	strbvs	r6, [ip, #-355]!
    4d78:	635f5f00 	cmpvs	pc, #0	; 0x0
    4d7c:	6e61656c 	cdpvs	5, 6, cr6, cr1, cr12, {3}
    4d80:	5f007075 	svcpl	0x00007075
    4d84:	7778616d 	ldrbvc	r6, [r8, -sp, ror #2]!
    4d88:	5f007364 	svcpl	0x00007364
    4d8c:	6e656572 	mcrvs	5, 3, r6, cr5, cr2, {3}
    4d90:	735f0074 	cmpvc	pc, #116	; 0x74
    4d94:	00646565 	rsbeq	r6, r4, r5, ror #10
    4d98:	6f635f5f 	svcvs	0x00635f5f
    4d9c:	00746e75 	rsbseq	r6, r4, r5, ror lr
    4da0:	61765f5f 	cmnvs	r6, pc, asr pc
    4da4:	0065756c 	rsbeq	r7, r5, ip, ror #10
    4da8:	6565735f 	strbvs	r7, [r5, #-863]!
    4dac:	665f006b 	ldrbvs	r0, [pc], -fp, rrx
    4db0:	5f736f70 	svcpl	0x00736f70
    4db4:	655f0074 	ldrbvs	r0, [pc, #-116]	; 4d48 <__Stack_Size+0x4948>
    4db8:	6f6e7272 	svcvs	0x006e7272
    4dbc:	745f5f00 	ldrbvc	r5, [pc], #3840	; 4dc4 <__Stack_Size+0x49c4>
    4dc0:	696d5f6d 	stmdbvs	sp!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    4dc4:	735f006e 	cmpvc	pc, #110	; 0x6e
    4dc8:	6f747274 	svcvs	0x00747274
    4dcc:	616c5f6b 	cmnvs	ip, fp, ror #30
    4dd0:	5f007473 	svcpl	0x00007473
    4dd4:	79746e66 	ldmdbvc	r4!, {r1, r2, r5, r6, r9, sl, fp, sp, lr}^
    4dd8:	00736570 	rsbseq	r6, r3, r0, ror r5
    4ddc:	6464615f 	strbtvs	r6, [r4], #-351
    4de0:	555f5f00 	ldrbpl	r5, [pc, #-3840]	; 3ee8 <__Stack_Size+0x3ae8>
    4de4:	676e6f4c 	strbvs	r6, [lr, -ip, asr #30]!
    4de8:	65675f00 	strbvs	r5, [r7, #-3840]!
    4dec:	74616474 	strbtvc	r6, [r1], #-1140
    4df0:	72655f65 	rsbvc	r5, r5, #404	; 0x194
    4df4:	675f0072 	undefined
    4df8:	61626f6c 	cmnvs	r2, ip, ror #30
    4dfc:	6d695f6c 	stclvs	15, cr5, [r9, #-432]!
    4e00:	65727570 	ldrbvs	r7, [r2, #-1392]!
    4e04:	7274705f 	rsbsvc	r7, r4, #95	; 0x5f
    4e08:	75635f00 	strbvc	r5, [r3, #-3840]!
    4e0c:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
    4e10:	61635f74 	smcvs	13812
    4e14:	6f676574 	svcvs	0x00676574
    4e18:	63007972 	movwvs	r7, #2418	; 0x972
    4e1c:	0065646f 	rsbeq	r6, r5, pc, ror #8
    4e20:	756e755f 	strbvc	r7, [lr, #-1375]!
    4e24:	5f646573 	svcpl	0x00646573
    4e28:	646e6172 	strbtvs	r6, [lr], #-370
    4e2c:	64775f00 	ldrbtvs	r5, [r7], #-3840
    4e30:	5f5f0073 	svcpl	0x005f0073
    4e34:	775f6d74 	undefined
    4e38:	00796164 	rsbseq	r6, r9, r4, ror #2
    4e3c:	756c675f 	strbvc	r6, [ip, #-1887]!
    4e40:	6e5f0065 	cdpvs	0, 5, cr0, cr15, cr5, {3}
    4e44:	6c6c616d 	stfvse	f6, [ip], #-436
    4e48:	5f00636f 	svcpl	0x0000636f
    4e4c:	6134366c 	teqvs	r4, ip, ror #12
    4e50:	6675625f 	undefined
    4e54:	69735f00 	ldmdbvs	r3!, {r8, r9, sl, fp, ip, lr}^
    4e58:	75665f67 	strbvc	r5, [r6, #-3943]!
    4e5c:	5f00636e 	svcpl	0x0000636e
    4e60:	6675626e 	ldrbtvs	r6, [r5], -lr, ror #4
    4e64:	6e755f00 	cdpvs	15, 7, cr5, cr5, cr0, {0}
    4e68:	64657375 	strbtvs	r7, [r5], #-885
    4e6c:	745f5f00 	ldrbvc	r5, [pc], #3840	; 4e74 <__Stack_Size+0x4a74>
    4e70:	73695f6d 	cmnvc	r9, #436	; 0x1b4
    4e74:	00747364 	rsbseq	r7, r4, r4, ror #6
    4e78:	636f6c5f 	cmnvs	pc, #24320	; 0x5f00
    4e7c:	69746c61 	ldmdbvs	r4!, {r0, r5, r6, sl, fp, sp, lr}^
    4e80:	625f656d 	subsvs	r6, pc, #457179136	; 0x1b400000
    4e84:	5f006675 	svcpl	0x00006675
    4e88:	00383472 	eorseq	r3, r8, r2, ror r4
    4e8c:	74626d5f 	strbtvc	r6, [r2], #-3423
    4e90:	5f63776f 	svcpl	0x0063776f
    4e94:	74617473 	strbtvc	r7, [r1], #-1139
    4e98:	705f0065 	subsvc	r0, pc, r5, rrx
    4e9c:	5f007335 	svcpl	0x00007335
    4ea0:	5f6d745f 	svcpl	0x006d745f
    4ea4:	7961646d 	stmdbvc	r1!, {r0, r2, r3, r5, r6, sl, sp, lr}^
    4ea8:	706d6900 	rsbvc	r6, sp, r0, lsl #18
    4eac:	5f657275 	svcpl	0x00657275
    4eb0:	61746164 	cmnvs	r4, r4, ror #2
    4eb4:	2f2e2e00 	svccs	0x002e2e00
    4eb8:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    4ebc:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    4ec0:	2f2e2e2f 	svccs	0x002e2e2f
    4ec4:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    4ec8:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
    4ecc:	656e2f30 	strbvs	r2, [lr, #-3888]!
    4ed0:	62696c77 	rsbvs	r6, r9, #30464	; 0x7700
    4ed4:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    4ed8:	65722f63 	ldrbvs	r2, [r2, #-3939]!
    4edc:	2f746e65 	svccs	0x00746e65
    4ee0:	75706d69 	ldrbvc	r6, [r0, #-3433]!
    4ee4:	632e6572 	teqvs	lr, #478150656	; 0x1c800000
    4ee8:	5c3a6300 	ldcpl	3, cr6, [sl]
    4eec:	616e6977 	smcvs	59031
    4ef0:	5c736d72 	ldclpl	13, cr6, [r3], #-456
    4ef4:	6c697562 	cfstr64vs	mvdx7, [r9], #-392
    4ef8:	63675c64 	cmnvs	r7, #25600	; 0x6400
    4efc:	75622d63 	strbvc	r2, [r2, #-3427]!
    4f00:	5c646c69 	stclpl	12, cr6, [r4], #-420
    4f04:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!
    4f08:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    4f0c:	77656e5c 	undefined
    4f10:	5c62696c 	stclpl	9, cr6, [r2], #-432
    4f14:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    4f18:	6565725c 	strbvs	r7, [r5, #-604]!
    4f1c:	5f00746e 	svcpl	0x0000746e
    4f20:	6e69665f 	mcrvs	6, 3, r6, cr9, cr15, {2}
    4f24:	72615f69 	rsbvc	r5, r1, #420	; 0x1a4
    4f28:	5f796172 	svcpl	0x00796172
    4f2c:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    4f30:	69730074 	ldmdbvs	r3!, {r2, r4, r5, r6}^
    4f34:	745f657a 	ldrbvc	r6, [pc], #1402	; 4f3c <__Stack_Size+0x4b3c>
    4f38:	665f5f00 	ldrbvs	r5, [pc], -r0, lsl #30
    4f3c:	5f696e69 	svcpl	0x00696e69
    4f40:	61727261 	cmnvs	r2, r1, ror #4
    4f44:	6e655f79 	mcrvs	15, 3, r5, cr5, cr9, {3}
    4f48:	5f5f0064 	svcpl	0x005f0064
    4f4c:	69657270 	stmdbvs	r5!, {r4, r5, r6, r9, ip, sp, lr}^
    4f50:	5f74696e 	svcpl	0x0074696e
    4f54:	61727261 	cmnvs	r2, r1, ror #4
    4f58:	6e655f79 	mcrvs	15, 3, r5, cr5, cr9, {3}
    4f5c:	2e2e0064 	cdpcs	0, 2, cr0, cr14, cr4, {3}
    4f60:	2f2e2e2f 	svccs	0x002e2e2f
    4f64:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    4f68:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    4f6c:	6363672f 	cmnvs	r3, #12320768	; 0xbc0000
    4f70:	332e342d 	teqcc	lr, #754974720	; 0x2d000000
    4f74:	6e2f302e 	cdpvs	0, 2, cr3, cr15, cr14, {1}
    4f78:	696c7765 	stmdbvs	ip!, {r0, r2, r5, r6, r8, r9, sl, ip, sp, lr}^
    4f7c:	696c2f62 	stmdbvs	ip!, {r1, r5, r6, r8, r9, sl, fp, sp}^
    4f80:	6d2f6362 	stcvs	3, cr6, [pc, #-392]!
    4f84:	2f637369 	svccs	0x00637369
    4f88:	74696e69 	strbtvc	r6, [r9], #-3689
    4f8c:	5f00632e 	svcpl	0x0000632e
    4f90:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    4f94:	72615f74 	rsbvc	r5, r1, #464	; 0x1d0
    4f98:	5f796172 	svcpl	0x00796172
    4f9c:	00646e65 	rsbeq	r6, r4, r5, ror #28
    4fa0:	696c5f5f 	stmdbvs	ip!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, fp, ip, lr}^
    4fa4:	695f6362 	ldmdbvs	pc, {r1, r5, r6, r8, r9, sp, lr}^
    4fa8:	5f74696e 	svcpl	0x0074696e
    4fac:	61727261 	cmnvs	r2, r1, ror #4
    4fb0:	3a630079 	bcc	18c519c <__Stack_Size+0x18c4d9c>
    4fb4:	6e69775c 	mcrvs	7, 3, r7, cr9, cr12, {2}
    4fb8:	736d7261 	cmnvc	sp, #268435462	; 0x10000006
    4fbc:	6975625c 	ldmdbvs	r5!, {r2, r3, r4, r6, r9, sp, lr}^
    4fc0:	675c646c 	ldrbvs	r6, [ip, -ip, ror #8]
    4fc4:	622d6363 	eorvs	r6, sp, #-1946157055	; 0x8c000001
    4fc8:	646c6975 	strbtvs	r6, [ip], #-2421
    4fcc:	6d72615c 	ldfvse	f6, [r2, #-368]!
    4fd0:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    4fd4:	656e5c69 	strbvs	r5, [lr, #-3177]!
    4fd8:	62696c77 	rsbvs	r6, r9, #30464	; 0x7700
    4fdc:	62696c5c 	rsbvs	r6, r9, #23552	; 0x5c00
    4fe0:	696d5c63 	stmdbvs	sp!, {r0, r1, r5, r6, sl, fp, ip, lr}^
    4fe4:	5f006373 	svcpl	0x00006373
    4fe8:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    4fec:	69665f63 	stmdbvs	r6!, {r0, r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    4ff0:	615f696e 	cmpvs	pc, lr, ror #18
    4ff4:	79617272 	stmdbvc	r1!, {r1, r4, r5, r6, r9, ip, sp, lr}^
    4ff8:	705f5f00 	subsvc	r5, pc, r0, lsl #30
    4ffc:	6e696572 	mcrvs	5, 3, r6, cr9, cr2, {3}
    5000:	615f7469 	cmpvs	pc, r9, ror #8
    5004:	79617272 	stmdbvc	r1!, {r1, r4, r5, r6, r9, ip, sp, lr}^
    5008:	6174735f 	cmnvs	r4, pc, asr r3
    500c:	5f007472 	svcpl	0x00007472
    5010:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    5014:	72615f74 	rsbvc	r5, r1, #464	; 0x1d0
    5018:	5f796172 	svcpl	0x00796172
    501c:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    5020:	6c610074 	stclvs	0, cr0, [r1], #-464
    5024:	656e6769 	strbvs	r6, [lr, #-1897]!
    5028:	72735f64 	rsbsvc	r5, r3, #400	; 0x190
    502c:	72730063 	rsbsvc	r0, r3, #99	; 0x63
    5030:	61003063 	tstvs	r0, r3, rrx
    5034:	6e67696c 	cdpvs	9, 6, cr6, cr7, cr12, {3}
    5038:	645f6465 	ldrbvs	r6, [pc], #1125	; 5040 <__Stack_Size+0x4c40>
    503c:	64007473 	strvs	r7, [r0], #-1139
    5040:	00307473 	eorseq	r7, r0, r3, ror r4
    5044:	775c3a63 	ldrbvc	r3, [ip, -r3, ror #20]
    5048:	72616e69 	rsbvc	r6, r1, #1680	; 0x690
    504c:	625c736d 	subsvs	r7, ip, #-1275068415	; 0xb4000001
    5050:	646c6975 	strbtvs	r6, [ip], #-2421
    5054:	6363675c 	cmnvs	r3, #24117248	; 0x1700000
    5058:	6975622d 	ldmdbvs	r5!, {r0, r2, r3, r5, r9, sp, lr}^
    505c:	615c646c 	cmpvs	ip, ip, ror #8
    5060:	652d6d72 	strvs	r6, [sp, #-3442]!
    5064:	5c696261 	sfmpl	f6, 2, [r9], #-388
    5068:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    506c:	6c5c6269 	lfmvs	f6, 2, [ip], {105}
    5070:	5c636269 	sfmpl	f6, 2, [r3], #-420
    5074:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    5078:	6d00676e 	stcvs	7, cr6, [r0, #-440]
    507c:	70636d65 	rsbvc	r6, r3, r5, ror #26
    5080:	656c0079 	strbvs	r0, [ip, #-121]!
    5084:	2e00306e 	cdpcs	0, 0, cr3, cr0, cr14, {3}
    5088:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    508c:	2f2e2e2f 	svccs	0x002e2e2f
    5090:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    5094:	63672f2e 	cmnvs	r7, #184	; 0xb8
    5098:	2e342d63 	cdpcs	13, 3, cr2, cr4, cr3, {3}
    509c:	2f302e33 	svccs	0x00302e33
    50a0:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440
    50a4:	6c2f6269 	sfmvs	f6, 4, [pc], #-420
    50a8:	2f636269 	svccs	0x00636269
    50ac:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    50b0:	6d2f676e 	stcvs	7, cr6, [pc, #-440]!
    50b4:	70636d65 	rsbvc	r6, r3, r5, ror #26
    50b8:	00632e79 	rsbeq	r2, r3, r9, ror lr
    50bc:	67696c61 	strbvs	r6, [r9, -r1, ror #24]!
    50c0:	5f64656e 	svcpl	0x0064656e
    50c4:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    50c8:	2f2e2e00 	svccs	0x002e2e00
    50cc:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    50d0:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    50d4:	2f2e2e2f 	svccs	0x002e2e2f
    50d8:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    50dc:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
    50e0:	656e2f30 	strbvs	r2, [lr, #-3888]!
    50e4:	62696c77 	rsbvs	r6, r9, #30464	; 0x7700
    50e8:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    50ec:	74732f63 	ldrbtvc	r2, [r3], #-3939
    50f0:	676e6972 	undefined
    50f4:	6d656d2f 	stclvs	13, cr6, [r5, #-188]!
    50f8:	2e746573 	mrccs	5, 3, r6, cr4, cr3, {3}
    50fc:	656d0063 	strbvs	r0, [sp, #-99]!
    5100:	7465736d 	strbtvc	r7, [r5], #-877
    5104:	66756200 	ldrbtvs	r6, [r5], -r0, lsl #4
    5108:	00726566 	rsbseq	r6, r2, r6, ror #10
    510c:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    5110:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    5114:	2f2e2e2f 	svccs	0x002e2e2f
    5118:	672f2e2e 	strvs	r2, [pc, -lr, lsr #28]!
    511c:	342d6363 	strtcc	r6, [sp], #-867
    5120:	302e332e 	eorcc	r3, lr, lr, lsr #6
    5124:	77656e2f 	strbvc	r6, [r5, -pc, lsr #28]!
    5128:	2f62696c 	svccs	0x0062696c
    512c:	6362696c 	cmnvs	r2, #1769472	; 0x1b0000
    5130:	6474732f 	ldrbtvs	r7, [r4], #-815
    5134:	2f62696c 	svccs	0x0062696c
    5138:	74615f5f 	strbtvc	r5, [r1], #-3935
    513c:	74697865 	strbtvc	r7, [r9], #-2149
    5140:	7400632e 	strvc	r6, [r0], #-814
    5144:	00657079 	rsbeq	r7, r5, r9, ror r0
    5148:	65725f5f 	ldrbvs	r5, [r2, #-3935]!
    514c:	74736967 	ldrbtvc	r6, [r3], #-2407
    5150:	655f7265 	ldrbvs	r7, [pc, #-613]	; 4ef3 <__Stack_Size+0x4af3>
    5154:	70746978 	rsbsvc	r6, r4, r8, ror r9
    5158:	00636f72 	rsbeq	r6, r3, r2, ror pc
    515c:	61635f5f 	cmnvs	r3, pc, asr pc
    5160:	655f6c6c 	ldrbvs	r6, [pc, #-3180]	; 44fc <__Stack_Size+0x40fc>
    5164:	70746978 	rsbsvc	r6, r4, r8, ror r9
    5168:	73636f72 	cmnvc	r3, #456	; 0x1c8
    516c:	2f2e2e00 	svccs	0x002e2e00
    5170:	2e2f2e2e 	cdpcs	14, 2, cr2, cr15, cr14, {1}
    5174:	2e2e2f2e 	cdpcs	15, 2, cr2, cr14, cr14, {1}
    5178:	2f2e2e2f 	svccs	0x002e2e2f
    517c:	2d636367 	stclcs	3, cr6, [r3, #-412]!
    5180:	2e332e34 	mrccs	14, 1, r2, cr3, cr4, {1}
    5184:	656e2f30 	strbvs	r2, [lr, #-3888]!
    5188:	62696c77 	rsbvs	r6, r9, #30464	; 0x7700
    518c:	62696c2f 	rsbvs	r6, r9, #12032	; 0x2f00
    5190:	74732f63 	ldrbtvc	r2, [r3], #-3939
    5194:	62696c64 	rsbvs	r6, r9, #25600	; 0x6400
    5198:	635f5f2f 	cmpvs	pc, #188	; 0xbc
    519c:	5f6c6c61 	svcpl	0x006c6c61
    51a0:	78657461 	stmdavc	r5!, {r0, r5, r6, sl, ip, sp, lr}^
    51a4:	632e7469 	teqvs	lr, #1761607680	; 0x69000000
    51a8:	73616c00 	cmnvc	r1, #0	; 0x0
    51ac:	72007074 	andvc	r7, r0, #116	; 0x74
    51b0:	61747365 	cmnvs	r4, r5, ror #6
    51b4:	Address 0x000051b4 is out of bounds.


Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	00000004 	andeq	r0, r0, r4
       4:	00000006 	andeq	r0, r0, r6
       8:	065d0001 	ldrbeq	r0, [sp], -r1
       c:	08000000 	stmdaeq	r0, {}
      10:	02000000 	andeq	r0, r0, #0	; 0x0
      14:	08147d00 	ldmdaeq	r4, {r8, sl, fp, ip, sp, lr}
      18:	18000000 	stmdane	r0, {}
      1c:	02000003 	andeq	r0, r0, #3	; 0x3
      20:	00187d00 	andseq	r7, r8, r0, lsl #26
      24:	00000000 	andeq	r0, r0, r0
      28:	60000000 	andvs	r0, r0, r0
      2c:	68000000 	stmdavs	r0, {}
      30:	01000000 	tsteq	r0, r0
      34:	008c5000 	addeq	r5, ip, r0
      38:	00940000 	addseq	r0, r4, r0
      3c:	00010000 	andeq	r0, r1, r0
      40:	0000bc50 	andeq	fp, r0, r0, asr ip
      44:	0000c200 	andeq	ip, r0, r0, lsl #4
      48:	50000100 	andpl	r0, r0, r0, lsl #2
      4c:	0000018e 	andeq	r0, r0, lr, lsl #3
      50:	00000194 	muleq	r0, r4, r1
      54:	9e500001 	cdpls	0, 5, cr0, cr0, cr1, {0}
      58:	a4000001 	strge	r0, [r0], #-1
      5c:	01000001 	tsteq	r0, r1
      60:	01ba5000 	undefined instruction 0x01ba5000
      64:	01c00000 	biceq	r0, r0, r0
      68:	00010000 	andeq	r0, r1, r0
      6c:	0001c250 	andeq	ip, r1, r0, asr r2
      70:	0001c800 	andeq	ip, r1, r0, lsl #16
      74:	50000100 	andpl	r0, r0, r0, lsl #2
      78:	000001ce 	andeq	r0, r0, lr, asr #3
      7c:	000001d4 	ldrdeq	r0, [r0], -r4
      80:	20500001 	subscs	r0, r0, r1
      84:	22000002 	andcs	r0, r0, #2	; 0x2
      88:	01000002 	tsteq	r0, r2
      8c:	00005000 	andeq	r5, r0, r0
      90:	00000000 	andeq	r0, r0, r0
      94:	01220000 	teqeq	r2, r0
      98:	01260000 	teqeq	r6, r0
      9c:	00010000 	andeq	r0, r1, r0
      a0:	00000050 	andeq	r0, r0, r0, asr r0
      a4:	00000000 	andeq	r0, r0, r0
      a8:	00010400 	andeq	r0, r1, r0, lsl #8
      ac:	00010600 	.word	0x00010600
      b0:	5d000100 	.word	0x5d000100
      b4:	00000106 	.word	0x00000106
      b8:	00000108 	.word	0x00000108
      bc:	047d0002 	.word	0x047d0002
      c0:	00000108 	.word	0x00000108
      c4:	00000110 	.word	0x00000110
      c8:	087d0002 	.word	0x087d0002
	...
      d4:	00000110 	.word	0x00000110
      d8:	00000112 	.word	0x00000112
      dc:	125d0001 	.word	0x125d0001
      e0:	14000001 	.word	0x14000001
      e4:	02000001 	.word	0x02000001
      e8:	14047d00 	.word	0x14047d00
      ec:	1c000001 	.word	0x1c000001
      f0:	02000001 	.word	0x02000001
      f4:	00087d00 	.word	0x00087d00
      f8:	00000000 	.word	0x00000000
#endif
}

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
      fc:	1c000000 	.word	0x1c000000
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
     100:	1e000001 	.word	0x1e000001

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
     104:	01000001 	.word	0x01000001
     108:	011e5d00 	.word	0x011e5d00
	nextframe_ = getMillis() + frameLength;
     10c:	01200000 	.word	0x01200000
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     110:	00020000 	.word	0x00020000
/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
	nextframe_ = getMillis() + frameLength;
     114:	0120047d 	.word	0x0120047d
     118:	01280000 	.word	0x01280000
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     11c:	00020000 	.word	0x00020000
     120:	0000087d 	.word	0x0000087d
     124:	00000000 	.word	0x00000000
		if (nextpose_[i] > pose_[i]) {
     128:	01280000 	.word	0x01280000
     12c:	012a0000 	.word	0x012a0000
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
     130:	00010000 	.word	0x00010000
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
     134:	00012a5d 	.word	0x00012a5d
     138:	00012c00 	.word	0x00012c00
     13c:	7d000200 	.word	0x7d000200
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
     140:	00012c04 	.word	0x00012c04
     144:	00013400 	.word	0x00013400
		PrintString(" - ");
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
     148:	7d000200 	.word	0x7d000200
     14c:	00000008 	.word	0x00000008
}
     150:	00000000 	.word	0x00000000
     154:	00009000 	.word	0x00009000
     158:	00009800 	.word	0x00009800
     15c:	50000100 	.word	0x50000100
     160:	0000009a 	.word	0x0000009a
     164:	000000bc 	.word	0x000000bc
     168:	00500001 	.word	0x00500001
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
     16c:	00000000 	.word	0x00000000
     170:	98000000 	.word	0x98000000
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
     174:	a8000000 	.word	0xa8000000
     178:	01000000 	.word	0x01000000
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     17c:	00005000 	.word	0x00005000
     180:	00000000 	.word	0x00000000
		nextpose_[i] = 512;
     184:	00a80000 	.word	0x00a80000
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
     188:	00ba0000 	.word	0x00ba0000
		pose_[i] = 512;
     18c:	00010000 	.word	0x00010000
		nextpose_[i] = 512;
     190:	00000050 	.word	0x00000050
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
     194:	00000000 	.word	0x00000000
     198:	0000c400 	.word	0x0000c400
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
     19c:	0000d200 	.word	0x0000d200
     1a0:	5d000100 	.word	0x5d000100
	nextframe_ = getMillis();
     1a4:	000000d2 	.word	0x000000d2
     1a8:	00000224 	.word	0x00000224
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     1ac:	0c7d0002 	.word	0x0c7d0002
	...
     1b8:	00000224 	.word	0x00000224
     1bc:	00000226 	.word	0x00000226
     1c0:	265d0001 	.word	0x265d0001
     1c4:	32000002 	.word	0x32000002
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1c8:	02000002 	.word	0x02000002
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
     1cc:	32047d00 	.word	0x32047d00
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d0:	58000002 	.word	0x58000002
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
     1d4:	02000002 	.word	0x02000002
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1d8:	00087d00 	.word	0x00087d00
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
     1dc:	00000000 	.word	0x00000000
     1e0:	58000000 	.word	0x58000000
		pose_[i] = 512;
		nextpose_[i] = 512;
     1e4:	5a000002 	.word	0x5a000002
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
     1e8:	01000002 	.word	0x01000002
		nextpose_[i] = 512;
     1ec:	025a5d00 	.word	0x025a5d00
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
     1f0:	05340000 	.word	0x05340000
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
     1f4:	00020000 	.word	0x00020000
     1f8:	00000c7d 	.word	0x00000c7d
	interpolating = 0;
     1fc:	00000000 	.word	0x00000000
	nextframe_ = getMillis();
     200:	02580000 	.word	0x02580000
     204:	02620000 	.word	0x02620000
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
     208:	00010000 	.word	0x00010000
     20c:	00000050 	.word	0x00000050
     210:	00000000 	.word	0x00000000
     214:	00026e00 	.word	0x00026e00
     218:	00030800 	.word	0x00030800
     21c:	50000100 	.word	0x50000100
     220:	00000308 	.word	0x00000308
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
     224:	0000031e 	.word	0x0000031e
     228:	1e520001 	.word	0x1e520001
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
     22c:	24000003 	.word	0x24000003
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
     230:	01000003 	.word	0x01000003
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
     234:	03645000 	.word	0x03645000
     238:	036a0000 	.word	0x036a0000
	dxl_set_txpacket_parameter(1, 2);
     23c:	00010000 	.word	0x00010000
     240:	00036a50 	.word	0x00036a50
     244:	00038200 	.word	0x00038200
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     248:	52000100 	.word	0x52000100
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
     24c:	000003c0 	.word	0x000003c0
     250:	000003c2 	.word	0x000003c2
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     254:	c2520001 	.word	0xc2520001
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     258:	cc000003 	.word	0xcc000003
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
     25c:	01000003 	.word	0x01000003
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     260:	04285300 	.word	0x04285300
     264:	04400000 	.word	0x04400000
     268:	00010000 	.word	0x00010000
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     26c:	00047e50 	.word	0x00047e50
     270:	00048200 	.word	0x00048200
     274:	52000100 	.word	0x52000100
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
     278:	00000482 	.word	0x00000482
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
     27c:	000004a2 	.word	0x000004a2
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
     280:	d4510001 	.word	0xd4510001
     284:	d8000004 	.word	0xd8000004
     288:	01000004 	.word	0x01000004
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
     28c:	05185100 	.word	0x05185100
     290:	05340000 	.word	0x05340000
     294:	00010000 	.word	0x00010000
	dxl_txrx_packet();
     298:	00000050 	.word	0x00000050
	u16 CommStatus = dxl_get_result();
     29c:	00000000 	.word	0x00000000
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
     2a0:	00053400 	.word	0x00053400
		PrintErrorCode();
     2a4:	00053600 	.word	0x00053600
	else
		PrintCommStatus(CommStatus);
     2a8:	5d000100 	.word	0x5d000100
#endif
}
     2ac:	00000536 	.word	0x00000536
     2b0:	000005e0 	.word	0x000005e0
     2b4:	087d0002 	.word	0x087d0002
	...
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
     2c0:	000005e0 	.word	0x000005e0

	if (interpolating == 0)
     2c4:	000005e4 	.word	0x000005e4
		return 0;
	int i;
	int complete = poseSize;
     2c8:	e45d0001 	.word	0xe45d0001
	if (!fWait) {
     2cc:	8c000005 	.word	0x8c000005
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
     2d0:	02000006 	.word	0x02000006
     2d4:	000c7d00 	.word	0x000c7d00
     2d8:	00000000 	.word	0x00000000
			return (getMillis() - nextframe_); // We still have some time to do something...
     2dc:	8c000000 	.word	0x8c000000
     2e0:	90000006 	.word	0x90000006
     2e4:	01000006 	.word	0x01000006
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
     2e8:	06905d00 	.word	0x06905d00
     2ec:	08100000 	.word	0x08100000
     2f0:	00020000 	.word	0x00020000
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     2f4:	0000107d 	.word	0x0000107d
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     2f8:	00000000 	.word	0x00000000
     2fc:	068c0000 	.word	0x068c0000
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
     300:	06a00000 	.word	0x06a00000
     304:	00010000 	.word	0x00010000
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     308:	0006be50 	.word	0x0006be50
		int diff = nextpose_[i] - pose_[i];
     30c:	0006ca00 	.word	0x0006ca00
     310:	50000100 	.word	0x50000100
     314:	000006ca 	.word	0x000006ca
     318:	000006d6 	.word	0x000006d6
     31c:	fc520001 	.word	0xfc520001
		if (diff == 0) {
     320:	10000006 	.word	0x10000006
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     324:	01000007 	.word	0x01000007
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
     328:	07405000 	.word	0x07405000
		int diff = nextpose_[i] - pose_[i];
		if (diff == 0) {
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
     32c:	07580000 	.word	0x07580000
					pose_[i] = nextpose_[i];
     330:	00010000 	.word	0x00010000
					complete--;
     334:	00078c50 	.word	0x00078c50
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     338:	0007a400 	.word	0x0007a400
     33c:	50000100 	.word	0x50000100
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     340:	000007d4 	.word	0x000007d4
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
     344:	00000810 	.word	0x00000810
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
     348:	00500001 	.word	0x00500001
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
     34c:	00000000 	.word	0x00000000
     350:	9a000000 	.word	0x9a000000
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
     354:	aa000006 	.word	0xaa000006
		interpolating = 0;
     358:	01000006 	.word	0x01000006
	BioloidControllerEx_writePose();
     35c:	00005100 	.word	0x00005100
     360:	00000000 	.word	0x00000000
	return 0;
}
     364:	08100000 	.word	0x08100000
     368:	08140000 	.word	0x08140000
     36c:	00010000 	.word	0x00010000
     370:	0008145d 	.word	0x0008145d
     374:	0008dc00 	.word	0x0008dc00
     378:	7d000200 	.word	0x7d000200
     37c:	00000008 	.word	0x00000008
     380:	00000000 	.word	0x00000000
	for (i = 0; i < poseSize; i++)
		//nextpose_[i] = pgm_read_word_near(addr+1+i) << BIOLOID_SHIFT;
		nextpose_[i] = pgm_read_word_near(addr + 1 + i);
}
/* read in current servo positions to the pose. */
void BioloidControllerEx_readPose() {
     384:	00081000 	.word	0x00081000
     388:	00083e00 	.word	0x00083e00
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
		//pose_[i] = dxl_read_word(id_[i],AXM_PRESENT_POSITION_L)<<BIOLOID_SHIFT;
		pose_[i] = dxl_read_word(id_[i], AXM_PRESENT_POSITION_L);
     38c:	50000100 	.word	0x50000100
     390:	0000083e 	.word	0x0000083e
     394:	00000844 	.word	0x00000844
     398:	50510001 	.word	0x50510001
     39c:	60000008 	.word	0x60000008
		PrintChar(id_[i]);
		PrintString(" - ");
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
     3a0:	01000008 	.word	0x01000008

#ifdef DEBUG_BIOLOIDEX
	PrintString("Bioloid controller --- READ POSE ---\n");
	PrintString("ID - POSICION\n");
#endif
	for (i = 0; i < poseSize; i++) {
     3a4:	08605000 	.word	0x08605000
     3a8:	08680000 	.word	0x08680000
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif
		mDelay(25);
	}
}
     3ac:	00010000 	.word	0x00010000
     3b0:	00087a52 	.word	0x00087a52
     3b4:	00088a00 	.word	0x00088a00
     3b8:	50000100 	.word	0x50000100
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitPosY[GaitCurrentLegNr] = -3 * g_InControlState.LegLiftHeight
				/ (3 + g_InControlState.gaitCur.HalfLiftHeight); // Easier to shift between div factor: /1 (3/3), /2 (3/6) and 3/4
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z
				/ g_InControlState.gaitCur.LiftDivFactor;
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y
     3bc:	0000088a 	.word	0x0000088a
				/ g_InControlState.gaitCur.LiftDivFactor;
	}

	//Optional Half heigth Rear 5 LiftedPos (5 lifted positions)
	else if (((g_InControlState.gaitCur.NrLiftedPos == 5 && (LegStep == -2)))
     3c0:	0000088e 	.word	0x0000088e
     3c4:	ae530001 	.word	0xae530001
     3c8:	c2000008 	.word	0xc2000008
     3cc:	01000008 	.word	0x01000008
     3d0:	00005000 	.word	0x00005000
     3d4:	00000000 	.word	0x00000000
     3d8:	08180000 	.word	0x08180000
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = -g_InControlState.TravelLength.x / 2;
     3dc:	081a0000 	.word	0x081a0000
     3e0:	00010000 	.word	0x00010000
     3e4:	00082254 	.word	0x00082254
     3e8:	0008dc00 	.word	0x0008dc00
     3ec:	54000100 	.word	0x54000100
	...
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     3f8:	000008dc 	.word	0x000008dc
     3fc:	000008ec 	.word	0x000008ec
     400:	00500001 	.word	0x00500001
		GaitPosZ[GaitCurrentLegNr] = -g_InControlState.TravelLength.z / 2;
     404:	00000000 	.word	0x00000000
     408:	0c000000 	.word	0x0c000000
     40c:	12000009 	.word	0x12000009
     410:	01000009 	.word	0x01000009
		GaitRotY[GaitCurrentLegNr] = -g_InControlState.TravelLength.y / 2;
     414:	09125d00 	.word	0x09125d00
     418:	091e0000 	.word	0x091e0000
     41c:	00020000 	.word	0x00020000
     420:	091e0c7d 	.word	0x091e0c7d
	}

	//Optional Half heigth Front 5 LiftedPos (5 lifted positions)
	else if ((g_InControlState.gaitCur.NrLiftedPos == 5)
     424:	09700000 	.word	0x09700000
     428:	00020000 	.word	0x00020000
     42c:	0000107d 	.word	0x0000107d
     430:	00000000 	.word	0x00000000
     434:	090c0000 	.word	0x090c0000
     438:	091c0000 	.word	0x091c0000
			&& (LegStep == 2
					|| LegStep == -(g_InControlState.gaitCur.StepsInGait - 2))
			&& TravelRequest) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     43c:	00010000 	.word	0x00010000
     440:	00091c50 	.word	0x00091c50
     444:	00093800 	.word	0x00093800
     448:	54000100 	.word	0x54000100
	...
		GaitPosY[GaitCurrentLegNr] = -g_InControlState.LegLiftHeight / 2;
     454:	0000090c 	.word	0x0000090c
     458:	00000928 	.word	0x00000928
     45c:	28510001 	.word	0x28510001
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     460:	70000009 	.word	0x70000009
     464:	01000009 	.word	0x01000009
     468:	00005500 	.word	0x00005500
     46c:	00000000 	.word	0x00000000
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     470:	09700000 	.word	0x09700000
     474:	09720000 	.word	0x09720000
     478:	00010000 	.word	0x00010000
     47c:	0009725d 	.word	0x0009725d
	}
	//_B_
	//Leg front down position //bug here?  From _A_ to _B_ there should only be one gaitstep, not 2!
	//For example, where is the case of LegStep==0+2 executed when NRLiftedPos=3?
	else if ((LegStep == g_InControlState.gaitCur.FrontDownPos
     480:	00097800 	.word	0x00097800
     484:	7d000200 	.word	0x7d000200
     488:	00097814 	.word	0x00097814
     48c:	000a5000 	.word	0x000a5000
     490:	7d000200 	.word	0x7d000200
     494:	00000018 	.word	0x00000018
     498:	00000000 	.word	0x00000000
     49c:	00097000 	.word	0x00097000
			|| LegStep
					== -(g_InControlState.gaitCur.StepsInGait
							- g_InControlState.gaitCur.FrontDownPos))
			&& GaitPosY[GaitCurrentLegNr] < 0) {
		GaitPosX[GaitCurrentLegNr] = g_InControlState.TravelLength.x / 2;
     4a0:	0009ac00 	.word	0x0009ac00
     4a4:	50000100 	.word	0x50000100
	...
		GaitPosZ[GaitCurrentLegNr] = g_InControlState.TravelLength.z / 2;
     4b0:	00000970 	.word	0x00000970
     4b4:	000009a4 	.word	0x000009a4
     4b8:	00510001 	.word	0x00510001
     4bc:	00000000 	.word	0x00000000
		GaitRotY[GaitCurrentLegNr] = g_InControlState.TravelLength.y / 2;
     4c0:	70000000 	.word	0x70000000
     4c4:	76000009 	.word	0x76000009
     4c8:	01000009 	.word	0x01000009
		GaitPosY[GaitCurrentLegNr] = 0;
     4cc:	09765200 	.word	0x09765200
     4d0:	09940000 	.word	0x09940000
	}

	//Move body forward
	else {
		GaitPosX[GaitCurrentLegNr] = GaitPosX[GaitCurrentLegNr]
     4d4:	00010000 	.word	0x00010000
     4d8:	00000056 	.word	0x00000056
     4dc:	00000000 	.word	0x00000000
     4e0:	00097000 	.word	0x00097000
     4e4:	00098a00 	.word	0x00098a00
     4e8:	53000100 	.word	0x53000100
	...
				- (g_InControlState.TravelLength.x
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitPosY[GaitCurrentLegNr] = 0;
     4f4:	00000988 	.word	0x00000988
		GaitPosZ[GaitCurrentLegNr] = GaitPosZ[GaitCurrentLegNr]
     4f8:	000009a8 	.word	0x000009a8
     4fc:	00540001 	.word	0x00540001
     500:	00000000 	.word	0x00000000
     504:	80000000 	.word	0x80000000
				- (g_InControlState.TravelLength.z
						/ (short) g_InControlState.gaitCur.TLDivFactor);
		GaitRotY[GaitCurrentLegNr] = GaitRotY[GaitCurrentLegNr]
     508:	a0000009 	.word	0xa0000009
     50c:	01000009 	.word	0x01000009
     510:	00005500 	.word	0x00005500
     514:	00000000 	.word	0x00000000
				- (g_InControlState.TravelLength.y
						/ (short) g_InControlState.gaitCur.TLDivFactor);
	}

}
     518:	0a500000 	.word	0x0a500000
     51c:	0a520000 	.word	0x0a520000
     520:	00010000 	.word	0x00010000
     524:	000a525d 	.word	0x000a525d
     528:	000a5600 	.word	0x000a5600
     52c:	7d000200 	.word	0x7d000200
     530:	000a5614 	.word	0x000a5614

}

//--------------------------------------------------------------------
//[GAIT Sequence]
void GaitSeq(void) {
     534:	000d2000 	.word	0x000d2000
	//Check if the Gait is in motion - If not if we are going to start a motion try to align our Gaitstep to start with a good foot
	// for the direction we are about to go...

	if (fWalking || (g_InControlState.ForceGaitStepCnt != 0))
     538:	7d000300 	.word	0x7d000300
     53c:	000000c8 	.word	0x000000c8
     540:	00000000 	.word	0x00000000
		TravelRequest = true;   // Is walking or was walking...
     544:	0a500000 	.word	0x0a500000
     548:	0a600000 	.word	0x0a600000
	else {
		TravelRequest = (abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
     54c:	00010000 	.word	0x00010000
     550:	00000050 	.word	0x00000050
     554:	00000000 	.word	0x00000000
     558:	000a5000 	.word	0x000a5000
     55c:	000a7c00 	.word	0x000a7c00
     560:	51000100 	.word	0x51000100
	...
     56c:	00000a50 	.word	0x00000a50
     570:	00000a66 	.word	0x00000a66
     574:	66520001 	.word	0x66520001
     578:	8a00000a 	.word	0x8a00000a
     57c:	0100000a 	.word	0x0100000a
				|| (abs(g_InControlState.TravelLength.y) > cTravelDeadZone);

		if (TravelRequest) {

		} else {    //Clear values under the cTravelDeadZone
			g_InControlState.TravelLength.x = 0;
     580:	00005000 	.word	0x00005000
			g_InControlState.TravelLength.z = 0;
     584:	00000000 	.word	0x00000000
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     588:	0a500000 	.word	0x0a500000
     58c:	0a5a0000 	.word	0x0a5a0000
     590:	00010000 	.word	0x00010000
		Gait(LegIndex);
     594:	000a5a53 	.word	0x000a5a53
			g_InControlState.TravelLength.y = 0; //Gait NOT in motion, return to home position
		}
	}

	//Calculate Gait sequence
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
     598:	000d2000 	.word	0x000d2000
     59c:	7d000200 	.word	0x7d000200
     5a0:	00000004 	.word	0x00000004
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5a4:	00000000 	.word	0x00000000
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5a8:	000a5000 	.word	0x000a5000
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5ac:	000a6600 	.word	0x000a6600
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
     5b0:	91000200 	.word	0x91000200
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) { // for all legs
		Gait(LegIndex);
	}    // next leg

		 //Advance to the next step
	g_InControlState.GaitStep++;
     5b4:	000a6600 	.word	0x000a6600
	if (g_InControlState.GaitStep > g_InControlState.gaitCur.StepsInGait)
		g_InControlState.GaitStep = 1;
     5b8:	000a9600 	.word	0x000a9600
     5bc:	52000100 	.word	0x52000100
	...

	// If we have a force count decrement it now...
	if (g_InControlState.ForceGaitStepCnt)
		g_InControlState.ForceGaitStepCnt--;
     5c8:	00000ab6 	.word	0x00000ab6
}
     5cc:	00000ad4 	.word	0x00000ad4
     5d0:	00570001 	.word	0x00570001
     5d4:	00000000 	.word	0x00000000
     5d8:	c0000000 	.word	0xc0000000
     5dc:	0400000a 	.word	0x0400000a
}
//--------------------------------------------------------------------
//[BalanceBody]
void BalanceBody(void) {

	TotalTransZ = TotalTransZ / BalanceDivFactor;
     5e0:	0100000b 	.word	0x0100000b
     5e4:	00005600 	.word	0x00005600
     5e8:	00000000 	.word	0x00000000
     5ec:	0a700000 	.word	0x0a700000
     5f0:	0aec0000 	.word	0x0aec0000
	TotalTransX = TotalTransX / BalanceDivFactor;
     5f4:	00010000 	.word	0x00010000
     5f8:	00000054 	.word	0x00000054
     5fc:	00000000 	.word	0x00000000
	TotalTransY = TotalTransY / BalanceDivFactor;
     600:	000a7600 	.word	0x000a7600
     604:	000ad600 	.word	0x000ad600
     608:	7d000200 	.word	0x7d000200
     60c:	000ad628 	.word	0x000ad628

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     610:	000adc00 	.word	0x000adc00
     614:	52000100 	.word	0x52000100
	...

#ifndef QUADMODE // ??? on PhantomX Hex at no movment YBal1 = 1800, on Quad = 0...  Need to experiment
	if (TotalYBal1 > 0)        //Rotate balance circle by +/- 180 deg
		TotalYBal1 -= 1800;
	else
		TotalYBal1 += 1800;
     620:	00000a8e 	.word	0x00000a8e
#endif

	if (TotalZBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     624:	00000ae4 	.word	0x00000ae4
     628:	2c7d0002 	.word	0x2c7d0002
     62c:	00000ae4 	.word	0x00000ae4
		TotalZBal1 += 3600;
     630:	00000af0 	.word	0x00000af0
     634:	00510001 	.word	0x00510001

	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
     638:	00000000 	.word	0x00000000
     63c:	20000000 	.word	0x20000000
		TotalXBal1 += 3600;
     640:	2200000d 	.word	0x2200000d
     644:	0100000d 	.word	0x0100000d

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
     648:	0d225d00 	.word	0x0d225d00
     64c:	0d260000 	.word	0x0d260000
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     650:	00020000 	.word	0x00020000
     654:	0d26147d 	.word	0x0d26147d
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     658:	0ea40000 	.word	0x0ea40000
	if (TotalXBal1 < -1800) //Compensate for extreme balance positions that causes overflow
		TotalXBal1 += 3600;

	//Balance rotation
	TotalYBal1 = -TotalYBal1 / BalanceDivFactor;
	TotalXBal1 = -TotalXBal1 / BalanceDivFactor;
     65c:	00020000 	.word	0x00020000
     660:	0000207d 	.word	0x0000207d
	TotalZBal1 = TotalZBal1 / BalanceDivFactor;
     664:	00000000 	.word	0x00000000
     668:	0d200000 	.word	0x0d200000

}
     66c:	0d2e0000 	.word	0x0d2e0000
     670:	00010000 	.word	0x00010000
     674:	00000050 	.word	0x00000050
     678:	00000000 	.word	0x00000000
     67c:	000d2000 	.word	0x000d2000
     680:	000d2800 	.word	0x000d2800
     684:	51000100 	.word	0x51000100
     688:	00000d28 	.word	0x00000d28
//sin4        - Output Sinus of AngleDeg
//cos4          - Output Cosinus of AngleDeg
void GetSinCos(short AngleDeg1) {
	short ABSAngleDeg1;   //Absolute value of the Angle in Degrees, decimals = 1
	//Get the absolute value of AngleDeg
	if (AngleDeg1 < 0)
     68c:	00000d80 	.word	0x00000d80
     690:	00550001 	.word	0x00550001
		ABSAngleDeg1 = AngleDeg1 * -1;
     694:	00000000 	.word	0x00000000
     698:	20000000 	.word	0x20000000
	else
		ABSAngleDeg1 = AngleDeg1;

	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
     69c:	2e00000d 	.word	0x2e00000d
     6a0:	0100000d 	.word	0x0100000d
     6a4:	00005200 	.word	0x00005200
     6a8:	00000000 	.word	0x00000000
     6ac:	0d200000 	.word	0x0d200000
     6b0:	0d2e0000 	.word	0x0d2e0000
     6b4:	00010000 	.word	0x00010000
     6b8:	000d2e53 	.word	0x000d2e53
     6bc:	000ea400 	.word	0x000ea400
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
     6c0:	56000100 	.word	0x56000100
	...
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6cc:	00000ea4 	.word	0x00000ea4
     6d0:	00000ea6 	.word	0x00000ea6
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6d4:	00500001 	.word	0x00500001
     6d8:	00000000 	.word	0x00000000
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));

	if (AngleDeg1 >= 0 && AngleDeg1 <= 900)     // 0 to 90 deg
			{
		sin4 = pgm_read_word(&GetSin[AngleDeg1 / 5]); // 5 is the presision (0.5) of the table
     6dc:	a4000000 	.word	0xa4000000
     6e0:	aa00000e 	.word	0xaa00000e
     6e4:	0100000e 	.word	0x0100000e
     6e8:	0eaa5300 	.word	0x0eaa5300
     6ec:	0ebe0000 	.word	0x0ebe0000
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
     6f0:	00010000 	.word	0x00010000
     6f4:	0000005c 	.word	0x0000005c
     6f8:	00000000 	.word	0x00000000
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
     6fc:	000ea600 	.word	0x000ea600
     700:	000eaa00 	.word	0x000eaa00
     704:	50000100 	.word	0x50000100
     708:	00000eaa 	.word	0x00000eaa
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     70c:	00000eb8 	.word	0x00000eb8
     710:	ba530001 	.word	0xba530001
     714:	bc00000e 	.word	0xbc00000e
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     718:	0100000e 	.word	0x0100000e
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     71c:	0ebc5300 	.word	0x0ebc5300
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     720:	0ebc0000 	.word	0x0ebc0000
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     724:	00010000 	.word	0x00010000
     728:	00000050 	.word	0x00000050
     72c:	00000000 	.word	0x00000000
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     730:	000ec000 	.word	0x000ec000
		cos4 = pgm_read_word(&GetSin[(900 - (AngleDeg1)) / 5]);
	}

	else if (AngleDeg1 > 900 && AngleDeg1 <= 1800)     // 90 to 180 deg
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
     734:	000ec600 	.word	0x000ec600
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
     738:	5d000100 	.word	0x5d000100
     73c:	00000ec6 	.word	0x00000ec6
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
     740:	00000f70 	.word	0x00000f70
     744:	147d0002 	.word	0x147d0002
	...
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     750:	00000ed8 	.word	0x00000ed8
     754:	00000edc 	.word	0x00000edc
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     758:	dc500001 	.word	0xdc500001
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     75c:	de00000e 	.word	0xde00000e
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     760:	0100000e 	.word	0x0100000e
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     764:	0ede5c00 	.word	0x0ede5c00
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     768:	0eec0000 	.word	0x0eec0000
			{
		sin4 = pgm_read_word(&GetSin[(900 - (AngleDeg1 - 900)) / 5]); // 5 is the presision (0.5) of the table
		cos4 = -pgm_read_word(&GetSin[(AngleDeg1 - 900) / 5]);
	} else if (AngleDeg1 > 1800 && AngleDeg1 <= 2700) // 180 to 270 deg
			{
		sin4 = -pgm_read_word(&GetSin[(AngleDeg1 - 1800) / 5]); // 5 is the presision (0.5) of the table
     76c:	00010000 	.word	0x00010000
     770:	000eec53 	.word	0x000eec53
     774:	000eee00 	.word	0x000eee00
     778:	5c000100 	.word	0x5c000100
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
     77c:	00000eee 	.word	0x00000eee
     780:	00000ef0 	.word	0x00000ef0
     784:	f0530001 	.word	0xf0530001
     788:	f800000e 	.word	0xf800000e
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
     78c:	0100000e 	.word	0x0100000e
     790:	0ef85000 	.word	0x0ef85000
     794:	0efc0000 	.word	0x0efc0000
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     798:	00010000 	.word	0x00010000
     79c:	0000005c 	.word	0x0000005c
     7a0:	00000000 	.word	0x00000000
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7a4:	000ef800 	.word	0x000ef800
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7a8:	000efc00 	.word	0x000efc00
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7ac:	50000100 	.word	0x50000100
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b0:	00000efc 	.word	0x00000efc
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7b4:	00000efe 	.word	0x00000efe
		cos4 = -pgm_read_word(&GetSin[(2700 - AngleDeg1) / 5]);
	}

	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
     7b8:	fe5c0001 	.word	0xfe5c0001
     7bc:	0400000e 	.word	0x0400000e
     7c0:	0100000f 	.word	0x0100000f
     7c4:	0f045300 	.word	0x0f045300
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
     7c8:	0f080000 	.word	0x0f080000
     7cc:	00010000 	.word	0x00010000
     7d0:	000f085c 	.word	0x000f085c
	//Shift rotation to a full circle of 360 deg -> AngleDeg // 360
	if (AngleDeg1 < 0)    //Negative values
		AngleDeg1 = 3600 - (ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600)));
	else
		//Positive values
		AngleDeg1 = ABSAngleDeg1 - (3600 * (ABSAngleDeg1 / 3600));
     7d4:	000f0e00 	.word	0x000f0e00
     7d8:	53000100 	.word	0x53000100
     7dc:	00000f0e 	.word	0x00000f0e
     7e0:	00000f10 	.word	0x00000f10
     7e4:	105c0001 	.word	0x105c0001
     7e8:	1200000f 	.word	0x1200000f
     7ec:	0100000f 	.word	0x0100000f
     7f0:	0f125300 	.word	0x0f125300
     7f4:	0f1a0000 	.word	0x0f1a0000
     7f8:	00010000 	.word	0x00010000
	else if (AngleDeg1 > 2700 && AngleDeg1 <= 3600) // 270 to 360 deg
			{
		sin4 = -pgm_read_word(&GetSin[(3600 - AngleDeg1) / 5]); // 5 is the presision (0.5) of the table
		cos4 = pgm_read_word(&GetSin[(AngleDeg1 - 2700) / 5]);
	}
}
     7fc:	000f1a50 	.word	0x000f1a50
     800:	000f2000 	.word	0x000f2000
     804:	5c000100 	.word	0x5c000100
	...
//cos4        - Input Cosinus
//AngleRad4     - Output Angle in AngleRad4
long GetArcCos(short cos4) {
	boolean NegativeValue/*:1*/;    //If the the value is Negative
	//Check for negative value
	if (cos4 < 0) {
     810:	00000ed4 	.word	0x00000ed4
     814:	00000ed8 	.word	0x00000ed8
     818:	d8500001 	.word	0xd8500001
		cos4 = -cos4;
     81c:	dc00000e 	.word	0xdc00000e
     820:	0100000e 	.word	0x0100000e
		NegativeValue = 1;
	} else
		NegativeValue = 0;

	//Limit cos4 to his maximal value
	cos4 = min(cos4, c4DEC);
     824:	0f1a5c00 	.word	0x0f1a5c00
     828:	0f200000 	.word	0x0f200000
     82c:	00010000 	.word	0x00010000

	if ((cos4 >= 0) && (cos4 < 9000)) {
     830:	000f2050 	.word	0x000f2050
     834:	000f2200 	.word	0x000f2200
     838:	5c000100 	.word	0x5c000100
		AngleRad4 = (byte) pgm_read_byte(&GetACos[cos4 / 79]);
     83c:	00000f22 	.word	0x00000f22
     840:	00000f28 	.word	0x00000f28
     844:	28530001 	.word	0x28530001
		AngleRad4 = ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255) ;
     848:	2c00000f 	.word	0x2c00000f
     84c:	0100000f 	.word	0x0100000f
	} else if ((cos4 >= 9000) && (cos4 < 9900)) {
     850:	0f2c5c00 	.word	0x0f2c5c00
     854:	0f320000 	.word	0x0f320000
     858:	00010000 	.word	0x00010000
     85c:	000f3253 	.word	0x000f3253
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9000) / 8 + 114]);
     860:	000f3400 	.word	0x000f3400
     864:	5c000100 	.word	0x5c000100
     868:	00000f34 	.word	0x00000f34
     86c:	00000f36 	.word	0x00000f36
     870:	36530001 	.word	0x36530001
     874:	7000000f 	.word	0x7000000f
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     878:	0100000f 	.word	0x0100000f
	} else if ((cos4 >= 9900) && (cos4 <= 10000)) {
     87c:	00005000 	.word	0x00005000
     880:	00000000 	.word	0x00000000
     884:	0f700000 	.word	0x0f700000
		AngleRad4 = (byte) pgm_read_byte(&GetACos[(cos4 - 9900) / 2 + 227]);
     888:	0f8c0000 	.word	0x0f8c0000
     88c:	00010000 	.word	0x00010000
     890:	000f9250 	.word	0x000f9250
		AngleRad4 = (long) ((long) AngleRad4 * 616) / c1DEC; //616=acos resolution (pi/2/255)
     894:	000fae00 	.word	0x000fae00
     898:	50000100 	.word	0x50000100
     89c:	00000fb4 	.word	0x00000fb4
     8a0:	00000fb4 	.word	0x00000fb4
     8a4:	00500001 	.word	0x00500001
     8a8:	00000000 	.word	0x00000000
     8ac:	b8000000 	.word	0xb8000000
	}

	//Add negative sign
	if (NegativeValue)
		AngleRad4 = 31416 - AngleRad4;
     8b0:	bc00000f 	.word	0xbc00000f
     8b4:	0100000f 	.word	0x0100000f
     8b8:	0fbc5d00 	.word	0x0fbc5d00
     8bc:	0fc60000 	.word	0x0fc60000
     8c0:	00020000 	.word	0x00020000

	return AngleRad4;
}
     8c4:	0fc6047d 	.word	0x0fc6047d
     8c8:	0ff00000 	.word	0x0ff00000
     8cc:	00020000 	.word	0x00020000
     8d0:	0000087d 	.word	0x0000087d
     8d4:	00000000 	.word	0x00000000
     8d8:	0ff00000 	.word	0x0ff00000

unsigned long isqrt32(unsigned long n) //
{
     8dc:	0ff20000 	.word	0x0ff20000
     8e0:	00010000 	.word	0x00010000

	root = 0;
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
     8e4:	000ff25d 	.word	0x000ff25d
     8e8:	00100800 	.word	0x00100800
     8ec:	7d000200 	.word	0x7d000200
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
     8f0:	00100814 	.word	0x00100814
			remainder = remainder - root - place;
     8f4:	00107c00 	.word	0x00107c00
     8f8:	7d000200 	.word	0x7d000200
			root = root + (place << 1);
     8fc:	00000018 	.word	0x00000018

	while (place > remainder)
		place = place >> 2;
	while (place) {
		if (remainder >= root + place) {
			remainder = remainder - root - place;
     900:	00000000 	.word	0x00000000
			root = root + (place << 1);
		}
		root = root >> 1;
		place = place >> 2;
     904:	000ff000 	.word	0x000ff000
	remainder = n;
	place = 0x40000000; // OR place = 0x4000; OR place = 0x40; - respectively

	while (place > remainder)
		place = place >> 2;
	while (place) {
     908:	00100400 	.word	0x00100400
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
	XYhyp2 = isqrt32(
     90c:	50000100 	.word	0x50000100
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     910:	00001004 	.word	0x00001004
	XYhyp2 = isqrt32(
     914:	0000107c 	.word	0x0000107c
     918:	00550001 	.word	0x00550001
//(GETATAN2) Simplyfied ArcTan2 function based on fixed point ArcCos
//ArcTanX         - Input X
//ArcTanY         - Input Y
//ArcTan4          - Output ARCTAN2(X/Y)
//XYhyp2            - Output presenting Hypotenuse of X and Y
short GetATan2(short AtanX, short AtanY) {
     91c:	00000000 	.word	0x00000000
	XYhyp2 = isqrt32(
     920:	84000000 	.word	0x84000000
     924:	86000010 	.word	0x86000010
     928:	01000010 	.word	0x01000010
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);
     92c:	10865d00 	.word	0x10865d00
     930:	108a0000 	.word	0x108a0000
     934:	00020000 	.word	0x00020000
     938:	108a047d 	.word	0x108a047d
     93c:	10c00000 	.word	0x10c00000
     940:	00020000 	.word	0x00020000
     944:	0000087d 	.word	0x0000087d

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
     948:	00000000 	.word	0x00000000
		Atan4 = -AngleRad4;
     94c:	10a40000 	.word	0x10a40000
	else
		Atan4 = AngleRad4;
     950:	10b40000 	.word	0x10b40000
	XYhyp2 = isqrt32(
			((long) AtanX * AtanX * c4DEC) + ((long) AtanY * AtanY * c4DEC));
	GetArcCos(((long) AtanX * (long) c6DEC) / (long) XYhyp2);

	if (AtanY < 0) // removed overhead... Atan4 = AngleRad4 * (AtanY/abs(AtanY));
		Atan4 = -AngleRad4;
     954:	00010000 	.word	0x00010000
	else
		Atan4 = AngleRad4;
     958:	0010b452 	.word	0x0010b452
     95c:	0010c000 	.word	0x0010c000
	return Atan4;
}
     960:	52000100 	.word	0x52000100
	...
     96c:	000010aa 	.word	0x000010aa

}

//--------------------------------------------------------------------
//[BalCalcOneLeg]
void BalCalcOneLeg(long PosX, long PosZ, long PosY, byte BalLegNr) {
     970:	000010b4 	.word	0x000010b4
	long CPR_Y;            //Final Y value for centerpoint of rotation
	long CPR_Z;            //Final Z value for centerpoint of rotation

	long lAtan;
	//Calculating totals from center of the body to the feet
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BalLegNr]) + PosZ;
     974:	b4500001 	.word	0xb4500001
     978:	c0000010 	.word	0xc0000010
	CPR_X = (short) pgm_read_word(&cOffsetX[BalLegNr]) + PosX;
     97c:	01000010 	.word	0x01000010
     980:	00005000 	.word	0x00005000
	CPR_Y = 150 + PosY; // using the value 150 to lower the centerpoint of rotation 'g_InControlState.BodyPos.y +

	TotalTransY += (long) PosY;
     984:	00000000 	.word	0x00000000
     988:	10c00000 	.word	0x10c00000
     98c:	10c20000 	.word	0x10c20000
	TotalTransZ += (long) CPR_Z;
     990:	00010000 	.word	0x00010000
     994:	0010c25d 	.word	0x0010c25d
     998:	0010c600 	.word	0x0010c600
	TotalTransX += (long) CPR_X;
     99c:	7d000200 	.word	0x7d000200
     9a0:	0010c604 	.word	0x0010c604
     9a4:	00115c00 	.word	0x00115c00
     9a8:	7d000200 	.word	0x7d000200

	lAtan = GetATan2(CPR_X, CPR_Z);
     9ac:	00000008 	.word	0x00000008
	TotalYBal1 += (lAtan * 1800) / 31415;
     9b0:	00000000 	.word	0x00000000
     9b4:	00115c00 	.word	0x00115c00
     9b8:	00115e00 	.word	0x00115e00
     9bc:	5d000100 	.word	0x5d000100
     9c0:	0000115e 	.word	0x0000115e
     9c4:	00001162 	.word	0x00001162
     9c8:	047d0002 	.word	0x047d0002
     9cc:	00001162 	.word	0x00001162

	lAtan = GetATan2(CPR_X, CPR_Y);
     9d0:	00001178 	.word	0x00001178
     9d4:	087d0002 	.word	0x087d0002
	...
	TotalZBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     9e0:	00001178 	.word	0x00001178
     9e4:	0000117a 	.word	0x0000117a
     9e8:	7a5d0001 	.word	0x7a5d0001
     9ec:	7e000011 	.word	0x7e000011
     9f0:	02000011 	.word	0x02000011
     9f4:	7e047d00 	.word	0x7e047d00
     9f8:	bc000011 	.word	0xbc000011
     9fc:	02000011 	.word	0x02000011

	lAtan = GetATan2(CPR_Z, CPR_Y);
     a00:	00087d00 	.word	0x00087d00
     a04:	00000000 	.word	0x00000000
	TotalXBal1 += ((lAtan * 1800) / 31415) - 900; //Rotate balance circle 90 deg
     a08:	bc000000 	.word	0xbc000000
     a0c:	be000011 	.word	0xbe000011
     a10:	01000011 	.word	0x01000011
     a14:	11be5d00 	.word	0x11be5d00
     a18:	11c20000 	.word	0x11c20000
     a1c:	00020000 	.word	0x00020000
     a20:	11c2147d 	.word	0x11c2147d
     a24:	124c0000 	.word	0x124c0000

}
     a28:	00020000 	.word	0x00020000
     a2c:	0000187d 	.word	0x0000187d
     a30:	00000000 	.word	0x00000000
     a34:	11bc0000 	.word	0x11bc0000
     a38:	11c40000 	.word	0x11c40000
     a3c:	00010000 	.word	0x00010000
     a40:	0011c450 	.word	0x0011c450
     a44:	0011e400 	.word	0x0011e400
     a48:	54000100 	.word	0x54000100
	...
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a54:	000011bc 	.word	0x000011bc
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a58:	000011ca 	.word	0x000011ca
     a5c:	ca510001 	.word	0xca510001
     a60:	4c000011 	.word	0x4c000011
//SinG                  - Sin buffer for BodyRotZ
//CosG               - Cos buffer for BodyRotZ
//BodyFKPosX         - Output Position X of feet with Rotation
//BodyFKPosY         - Output Position Y of feet with Rotation
//BodyFKPosZ         - Output Position Z of feet with Rotation
void BodyFK(short PosX, short PosZ, short PosY, short RotationY, byte BodyIKLeg) {
     a64:	01000012 	.word	0x01000012
	short CPR_X;            //Final X value for centerpoint of rotation
	short CPR_Y;            //Final Y value for centerpoint of rotation
	short CPR_Z;            //Final Z value for centerpoint of rotation

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
     a68:	00005600 	.word	0x00005600
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
     a6c:	00000000 	.word	0x00000000
     a70:	124c0000 	.word	0x124c0000
     a74:	124e0000 	.word	0x124e0000

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     a78:	00010000 	.word	0x00010000

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a7c:	00124e5d 	.word	0x00124e5d
     a80:	0012a000 	.word	0x0012a000
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a84:	7d000200 	.word	0x7d000200
     a88:	00000010 	.word	0x00000010

	//Calculating totals from center of the body to the feet
	CPR_X = (short) pgm_read_word(&cOffsetX[BodyIKLeg]) + PosX
			+ g_InControlState.BodyRotOffset.x;
	CPR_Y = PosY + g_InControlState.BodyRotOffset.y; //Define centerpoint for rotation along the Y-axis
	CPR_Z = (short) pgm_read_word(&cOffsetZ[BodyIKLeg]) + PosZ
     a8c:	00000000 	.word	0x00000000
	//Successive global rotation matrix:
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
     a90:	00126000 	.word	0x00126000
     a94:	00127a00 	.word	0x00127a00
	SinG4 = sin4;
     a98:	54000100 	.word	0x54000100
	CosG4 = cos4;
     a9c:	0000127e 	.word	0x0000127e
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa0:	000012a0 	.word	0x000012a0
	CosG4 = cos4;
     aa4:	00540001 	.word	0x00540001
	//Math shorts for rotation: Alfa [A] = Xrotate, Beta [B] = Zrotate, Gamma [G] = Yrotate
	//Sinus Alfa = SinA, cosinus Alfa = cosA. and so on...

	//First calculate sinus and cosinus for each rotation:
	GetSinCos(g_InControlState.BodyRot1.x + TotalXBal1);
	SinG4 = sin4;
     aa8:	00000000 	.word	0x00000000
	CosG4 = cos4;

	GetSinCos(g_InControlState.BodyRot1.z + TotalZBal1);
     aac:	a0000000 	.word	0xa0000000
	SinB4 = sin4;
     ab0:	a2000012 	.word	0xa2000012
     ab4:	01000012 	.word	0x01000012
	CosB4 = cos4;
     ab8:	12a25d00 	.word	0x12a25d00

	GetSinCos(g_InControlState.BodyRot1.y + (RotationY * c1DEC) + TotalYBal1);
     abc:	12a40000 	.word	0x12a40000
     ac0:	00020000 	.word	0x00020000
     ac4:	12a4047d 	.word	0x12a4047d
     ac8:	12d80000 	.word	0x12d80000
     acc:	00020000 	.word	0x00020000

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     ad0:	0000087d 	.word	0x0000087d
     ad4:	00000000 	.word	0x00000000
     ad8:	12d80000 	.word	0x12d80000
     adc:	12da0000 	.word	0x12da0000
     ae0:	00010000 	.word	0x00010000
     ae4:	0012da5d 	.word	0x0012da5d
     ae8:	0012de00 	.word	0x0012de00
     aec:	7d000200 	.word	0x7d000200
     af0:	0012de0c 	.word	0x0012de0c
     af4:	00131000 	.word	0x00131000
     af8:	7d000200 	.word	0x7d000200
     afc:	00000010 	.word	0x00000010
     b00:	00000000 	.word	0x00000000
     b04:	00131000 	.word	0x00131000
     b08:	00131200 	.word	0x00131200
     b0c:	5d000100 	.word	0x5d000100
     b10:	00001312 	.word	0x00001312
     b14:	00001320 	.word	0x00001320
     b18:	047d0002 	.word	0x047d0002
     b1c:	00001320 	.word	0x00001320
     b20:	00001344 	.word	0x00001344
     b24:	087d0002 	.word	0x087d0002
	...
     b30:	00001344 	.word	0x00001344
     b34:	0000134a 	.word	0x0000134a
     b38:	4a5d0001 	.word	0x4a5d0001
     b3c:	68000013 	.word	0x68000013
     b40:	02000014 	.word	0x02000014
     b44:	00087d00 	.word	0x00087d00
     b48:	00000000 	.word	0x00000000
     b4c:	68000000 	.word	0x68000000
     b50:	6a000014 	.word	0x6a000014
     b54:	01000014 	.word	0x01000014
     b58:	146a5d00 	.word	0x146a5d00
     b5c:	146e0000 	.word	0x146e0000
     b60:	00020000 	.word	0x00020000
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b64:	146e147d 	.word	0x146e147d
     b68:	15540000 	.word	0x15540000

	SinA4 = sin4;
	CosA4 = cos4;

	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
     b6c:	00020000 	.word	0x00020000
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     b70:	0000207d 	.word	0x0000207d
     b74:	00000000 	.word	0x00000000
     b78:	14680000 	.word	0x14680000
     b7c:	14760000 	.word	0x14760000
     b80:	00010000 	.word	0x00010000
     b84:	00147650 	.word	0x00147650
     b88:	00153c00 	.word	0x00153c00
     b8c:	7d000200 	.word	0x7d000200
     b90:	00153c00 	.word	0x00153c00
     b94:	00155400 	.word	0x00155400
     b98:	91000200 	.word	0x91000200
     b9c:	00000074 	.word	0x00000074
     ba0:	00000000 	.word	0x00000000
     ba4:	00149600 	.word	0x00149600
     ba8:	00149c00 	.word	0x00149c00
     bac:	7d000200 	.word	0x7d000200
     bb0:	00149c04 	.word	0x00149c04
     bb4:	0014c400 	.word	0x0014c400
     bb8:	91000200 	.word	0x91000200
     bbc:	0014c478 	.word	0x0014c478
     bc0:	00151200 	.word	0x00151200
     bc4:	7d000200 	.word	0x7d000200
     bc8:	00151204 	.word	0x00151204
     bcc:	00153600 	.word	0x00153600
     bd0:	91000200 	.word	0x91000200
     bd4:	00153c78 	.word	0x00153c78
     bd8:	00155400 	.word	0x00155400
     bdc:	91000200 	.word	0x91000200
     be0:	00000078 	.word	0x00000078
     be4:	00000000 	.word	0x00000000
     be8:	0014b000 	.word	0x0014b000
     bec:	0014e000 	.word	0x0014e000
     bf0:	55000100 	.word	0x55000100
	...
     bfc:	00001554 	.word	0x00001554
     c00:	0000155c 	.word	0x0000155c
     c04:	5c5d0001 	.word	0x5c5d0001
     c08:	8a000015 	.word	0x8a000015
     c0c:	02000015 	.word	0x02000015
     c10:	8a147d00 	.word	0x8a147d00
     c14:	e0000015 	.word	0xe0000015
     c18:	02000015 	.word	0x02000015
     c1c:	00207d00 	.word	0x00207d00
     c20:	00000000 	.word	0x00000000
     c24:	54000000 	.word	0x54000000
     c28:	72000015 	.word	0x72000015
     c2c:	01000015 	.word	0x01000015
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c30:	15725000 	.word	0x15725000
	//Calcualtion of rotation matrix:
	BodyFKPosX = ((long) CPR_X * c2DEC
			- ((long) CPR_X * c2DEC * CosA4 / c4DEC * CosB4 / c4DEC
					- (long) CPR_Z * c2DEC * CosB4 / c4DEC * SinA4 / c4DEC
					+ (long) CPR_Y * c2DEC * SinB4 / c4DEC)) / c2DEC;
	BodyFKPosZ = ((long) CPR_Z * c2DEC
     c34:	15e00000 	.word	0x15e00000
     c38:	00010000 	.word	0x00010000
     c3c:	00000056 	.word	0x00000056
     c40:	00000000 	.word	0x00000000
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * CosG4 / c4DEC
					- (long) CPR_Z * c2DEC * SinA4 / c4DEC * SinB4 / c4DEC
							* SinG4 / c4DEC
					- (long) CPR_Y * c2DEC * CosB4 / c4DEC * SinG4 / c4DEC))
			/ c2DEC;
	BodyFKPosY = ((long) CPR_Y * c2DEC
     c44:	00155400 	.word	0x00155400
     c48:	00155a00 	.word	0x00155a00
     c4c:	51000100 	.word	0x51000100
	...
     c58:	00001554 	.word	0x00001554
     c5c:	00001568 	.word	0x00001568
     c60:	00520001 	.word	0x00520001
     c64:	00000000 	.word	0x00000000
     c68:	54000000 	.word	0x54000000
     c6c:	74000015 	.word	0x74000015
     c70:	01000015 	.word	0x01000015
     c74:	00005300 	.word	0x00005300
     c78:	00000000 	.word	0x00000000
     c7c:	15e00000 	.word	0x15e00000
     c80:	15e20000 	.word	0x15e20000
     c84:	00010000 	.word	0x00010000
     c88:	0015e25d 	.word	0x0015e25d
     c8c:	0015e400 	.word	0x0015e400
     c90:	7d000200 	.word	0x7d000200
     c94:	0015e414 	.word	0x0015e414
     c98:	00166400 	.word	0x00166400
     c9c:	7d000200 	.word	0x7d000200
     ca0:	00000018 	.word	0x00000018
     ca4:	00000000 	.word	0x00000000
     ca8:	0015f400 	.word	0x0015f400
     cac:	00164200 	.word	0x00164200
     cb0:	50000100 	.word	0x50000100
	...
     cbc:	00001664 	.word	0x00001664
     cc0:	00001666 	.word	0x00001666
     cc4:	665d0001 	.word	0x665d0001
     cc8:	b8000016 	.word	0xb8000016
     ccc:	02000016 	.word	0x02000016
     cd0:	00087d00 	.word	0x00087d00
     cd4:	00000000 	.word	0x00000000
     cd8:	b8000000 	.word	0xb8000000
     cdc:	ba000016 	.word	0xba000016
     ce0:	01000016 	.word	0x01000016
     ce4:	16ba5d00 	.word	0x16ba5d00
					+ (long) CPR_Z * c2DEC * CosA4 / c4DEC * SinG4 / c4DEC
					+ (long) CPR_Z * c2DEC * CosG4 / c4DEC * SinA4 / c4DEC
							* SinB4 / c4DEC
					+ (long) CPR_Y * c2DEC * CosB4 / c4DEC * CosG4 / c4DEC))
			/ c2DEC;
}
     ce8:	16bc0000 	.word	0x16bc0000
     cec:	00020000 	.word	0x00020000
     cf0:	16bc047d 	.word	0x16bc047d
     cf4:	17140000 	.word	0x17140000
     cf8:	00020000 	.word	0x00020000
     cfc:	0000087d 	.word	0x0000087d
     d00:	00000000 	.word	0x00000000
     d04:	17140000 	.word	0x17140000
     d08:	17160000 	.word	0x17160000
     d0c:	00010000 	.word	0x00010000
     d10:	0017165d 	.word	0x0017165d
     d14:	00171800 	.word	0x00171800
     d18:	7d000200 	.word	0x7d000200
     d1c:	00171814 	.word	0x00171814
//FemurAngle1           - Output Angle of Femur in degrees
//TibiaAngle1           - Output Angle of Tibia in degrees
//CoxaAngle1            - Output Angle of Coxa in degrees
//--------------------------------------------------------------------
void LegIK(short IKFeetPosX, short IKFeetPosY, short IKFeetPosZ,
		byte LegIKLegNr) {
     d20:	001cb000 	.word	0x001cb000
     d24:	7d000200 	.word	0x7d000200
     d28:	00000028 	.word	0x00000028
	long Temp1;
	long Temp2;
	long T3;

	//Calculate IKCoxaAngle and IKFeetPosXZ
	GetATan2(IKFeetPosX, IKFeetPosZ);
     d2c:	00000000 	.word	0x00000000
	CoxaAngle1[LegIKLegNr] = (((long) Atan4 * 180) / 3141)
     d30:	00172e00 	.word	0x00172e00
     d34:	00173000 	.word	0x00173000
     d38:	7d000200 	.word	0x7d000200
     d3c:	00173600 	.word	0x00173600
     d40:	001c1400 	.word	0x001c1400
     d44:	7d000200 	.word	0x7d000200
     d48:	001c1400 	.word	0x001c1400
     d4c:	001c3800 	.word	0x001c3800
     d50:	91000200 	.word	0x91000200
     d54:	001c526c 	.word	0x001c526c
	//Length between the Coxa and tars [foot]
	IKFeetPosXZ = XYhyp2 / c2DEC;

	//Using GetAtan2 for solving IKA1 and IKSW
	//IKA14 - Angle between SW line and the ground in radians
	IKA14 = GetATan2(IKFeetPosY - TarsOffsetY,
     d58:	001cb000 	.word	0x001cb000
     d5c:	91000200 	.word	0x91000200
     d60:	0000006c 	.word	0x0000006c
     d64:	00000000 	.word	0x00000000
     d68:	00183400 	.word	0x00183400
     d6c:	00183800 	.word	0x00183800
     d70:	7d000200 	.word	0x7d000200

	//IKSW2 - Length between femur axis and tars
	IKSW2 = XYhyp2;

	//IKA2 - Angle of the line S>W with respect to the femur in radians
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     d74:	0018f604 	.word	0x0018f604
     d78:	001bf200 	.word	0x001bf200
     d7c:	7d000200 	.word	0x7d000200
     d80:	001bf204 	.word	0x001bf204
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			+ ((long) IKSW2 * IKSW2));
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);
     d84:	001c3800 	.word	0x001c3800
     d88:	91000200 	.word	0x91000200
     d8c:	001c5270 	.word	0x001c5270
     d90:	001cb000 	.word	0x001cb000
     d94:	91000200 	.word	0x91000200
     d98:	00000070 	.word	0x00000070
     d9c:	00000000 	.word	0x00000000
     da0:	00183600 	.word	0x00183600
     da4:	00183800 	.word	0x00183800
     da8:	7d000200 	.word	0x7d000200
     dac:	0018ee08 	.word	0x0018ee08
     db0:	001bf200 	.word	0x001bf200
     db4:	7d000200 	.word	0x7d000200

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     db8:	001bf208 	.word	0x001bf208
     dbc:	001c3800 	.word	0x001c3800
     dc0:	91000200 	.word	0x91000200
     dc4:	001c5274 	.word	0x001c5274
     dc8:	001cb000 	.word	0x001cb000
     dcc:	91000200 	.word	0x91000200
     dd0:	00000074 	.word	0x00000074
     dd4:	00000000 	.word	0x00000000
     dd8:	00182600 	.word	0x00182600
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     ddc:	001b7c00 	.word	0x001b7c00
	Temp2 = (long) (2 * (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])) * c2DEC
			* (unsigned long) IKSW2;
	T3 = Temp1 / (Temp2 / c4DEC);
	IKA24 = GetArcCos(T3);

	FemurAngle1[LegIKLegNr] = -(long) (IKA14 + IKA24) * 180
     de0:	7d000200 	.word	0x7d000200
			/ 3141+ 900 + CFEMURHORNOFFSET1(LegIKLegNr);  //Normal

	//IKTibiaAngle
	Temp1 = ((((long) (byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
     de4:	001b7c0c 	.word	0x001b7c0c
     de8:	001ba000 	.word	0x001ba000
			+ ((long) (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr])
					* (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))) * c4DEC
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);
     dec:	91000200 	.word	0x91000200
     df0:	001ba078 	.word	0x001ba078
     df4:	001bf200 	.word	0x001bf200
     df8:	7d000200 	.word	0x7d000200
     dfc:	001bf20c 	.word	0x001bf20c
     e00:	001c3800 	.word	0x001c3800
     e04:	91000200 	.word	0x91000200
     e08:	001c5278 	.word	0x001c5278

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e0c:	001cb000 	.word	0x001cb000
     e10:	91000200 	.word	0x91000200
     e14:	00000078 	.word	0x00000078
     e18:	00000000 	.word	0x00000000
     e1c:	00182e00 	.word	0x00182e00
     e20:	0018e800 	.word	0x0018e800
     e24:	57000100 	.word	0x57000100
     e28:	000018e8 	.word	0x000018e8
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e2c:	000018ea 	.word	0x000018ea
			- ((long) IKSW2 * IKSW2));
	Temp2 = 2 * ((long) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])))
			* (long) ((byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]));
	GetArcCos(Temp1 / Temp2);

	TibiaAngle1[LegIKLegNr] = -(1450 - (long) AngleRad4 * 180 / 3141
     e30:	fc530001 	.word	0xfc530001
			+ CTIBIAHORNOFFSET1(LegIKLegNr)); //!!!!!!!!!!!!145 instead of 1800

	//Set the Solution quality
	if (IKSW2
     e34:	38000018 	.word	0x38000018
     e38:	0100001c 	.word	0x0100001c
     e3c:	1c525700 	.word	0x1c525700
     e40:	1cb00000 	.word	0x1cb00000
     e44:	00010000 	.word	0x00010000
			< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
					+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]) - 30)
					* c2DEC))
		IKSolution = 1;
     e48:	00000057 	.word	0x00000057
	else {
		if (IKSW2
     e4c:	00000000 	.word	0x00000000
     e50:	00185000 	.word	0x00185000
				< ((word) ((byte) pgm_read_byte(&cFemurLength[LegIKLegNr])
						+ (byte) pgm_read_byte(&cTibiaLength[LegIKLegNr]))
						* c2DEC))
			IKSolutionWarning = 1;
     e54:	00185c00 	.word	0x00185c00
     e58:	51000100 	.word	0x51000100
		else
			IKSolutionError = 1;
     e5c:	00001876 	.word	0x00001876
	}

}
     e60:	000018c8 	.word	0x000018c8
     e64:	d0510001 	.word	0xd0510001
     e68:	d2000018 	.word	0xd2000018
     e6c:	01000018 	.word	0x01000018
     e70:	00005100 	.word	0x00005100
     e74:	00000000 	.word	0x00000000
     e78:	1cb00000 	.word	0x1cb00000
     e7c:	1cb20000 	.word	0x1cb20000
     e80:	00010000 	.word	0x00010000
     e84:	001cb25d 	.word	0x001cb25d
     e88:	001cb400 	.word	0x001cb400
     e8c:	7d000200 	.word	0x7d000200
     e90:	001cb414 	.word	0x001cb414
     e94:	0021cc00 	.word	0x0021cc00
     e98:	7d000200 	.word	0x7d000200
     e9c:	00000020 	.word	0x00000020
     ea0:	00000000 	.word	0x00000000
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ea4:	001cc000 	.word	0x001cc000
	if (sVal < s) {
     ea8:	001d2e00 	.word	0x001d2e00
     eac:	54000100 	.word	0x54000100
		return s;
	}

	s = (short) pgm_read_word(sMax);
     eb0:	00001dd8 	.word	0x00001dd8
     eb4:	00001dfc 	.word	0x00001dfc
     eb8:	c8540001 	.word	0xc8540001

		return s;
	}
	return sVal;

}
     ebc:	d600001e 	.word	0xd600001e
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec0:	0100001e 	.word	0x0100001e
}

//--------------------------------------------------------------------
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
     ec4:	1fc45400 	.word	0x1fc45400
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     ec8:	1fc80000 	.word	0x1fc80000
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ecc:	00010000 	.word	0x00010000
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     ed0:	0020d454 	.word	0x0020d454
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ed4:	0020ea00 	.word	0x0020ea00
	if (sVal < s) {
     ed8:	54000100 	.word	0x54000100
     edc:	0000212e 	.word	0x0000212e
     ee0:	000021cc 	.word	0x000021cc
		return s;
	}

	s = (short) pgm_read_word(sMax);
     ee4:	00540001 	.word	0x00540001
     ee8:	00000000 	.word	0x00000000
     eec:	0c000000 	.word	0x0c000000
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
     ef0:	10000000 	.word	0x10000000
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     ef4:	01000000 	.word	0x01000000
	if (sVal < s) {
     ef8:	00005000 	.word	0x00005000
     efc:	00000000 	.word	0x00000000
     f00:	00440000 	.word	0x00440000
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f04:	004c0000 	.word	0x004c0000
     f08:	00010000 	.word	0x00010000
     f0c:	00004c50 	.word	0x00004c50
short CheckServoAngleBounds(short sID, short sVal, const short *sMin,
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
     f10:	00007c00 	.word	0x00007c00
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f14:	51000100 	.word	0x51000100
	...
		const short *sMax) {

	// Pull into simple function as so I can report errors on debug
	// Note ID is bogus, but something to let me know which one.
	short s = (short) pgm_read_word(sMin);
	if (sVal < s) {
     f20:	0000004c 	.word	0x0000004c
     f24:	00000060 	.word	0x00000060
		return s;
	}

	s = (short) pgm_read_word(sMax);
     f28:	62500001 	.word	0x62500001
     f2c:	6c000000 	.word	0x6c000000
     f30:	01000000 	.word	0x01000000
		CoxaAngle1[LegIndex] = CheckServoAngleBounds(s++, CoxaAngle1[LegIndex],
				&cCoxaMin1[LegIndex], &cCoxaMax1[LegIndex]);
		FemurAngle1[LegIndex] = CheckServoAngleBounds(s++,
				FemurAngle1[LegIndex], &cFemurMin1[LegIndex],
				&cFemurMax1[LegIndex]);
		TibiaAngle1[LegIndex] = CheckServoAngleBounds(s++,
     f34:	00005000 	.word	0x00005000
     f38:	00000000 	.word	0x00000000
//[CHECK ANGLES] Checks the mechanical limits of the servos
//--------------------------------------------------------------------
void CheckAngles(void) {
#ifndef SERVOS_DO_MINMAX
	short s = 0;  // BUGBUG just some index so we can get a hint who errored out
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
     f3c:	007c0000 	.word	0x007c0000
     f40:	00840000 	.word	0x00840000
				TibiaAngle1[LegIndex], &cTibiaMin1[LegIndex],
				&cTibiaMax1[LegIndex]);

	}
#endif
}
     f44:	00010000 	.word	0x00010000
     f48:	00008450 	.word	0x00008450
     f4c:	0000b400 	.word	0x0000b400
     f50:	51000100 	.word	0x51000100
	...
     f5c:	00000084 	.word	0x00000084
     f60:	00000098 	.word	0x00000098
     f64:	9a500001 	.word	0x9a500001
     f68:	a4000000 	.word	0xa4000000
     f6c:	01000000 	.word	0x01000000
// SmoothControl (From Zenta) -  This function makes the body
//            rotation and translation much smoother
//--------------------------------------------------------------------
short SmoothControl(short CtrlMoveInp, short CtrlMoveOut, byte CtrlDivider) {

	if (CtrlMoveOut < (CtrlMoveInp - 4))
     f70:	00005000 	.word	0x00005000
     f74:	00000000 	.word	0x00000000
		return CtrlMoveOut + abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f78:	00b40000 	.word	0x00b40000
     f7c:	00b80000 	.word	0x00b80000
     f80:	00010000 	.word	0x00010000
     f84:	0000b85d 	.word	0x0000b85d
     f88:	0000e400 	.word	0x0000e400
     f8c:	7d000200 	.word	0x7d000200
     f90:	00000008 	.word	0x00000008
	else if (CtrlMoveOut > (CtrlMoveInp + 4))
     f94:	00000000 	.word	0x00000000
		return CtrlMoveOut - abs((CtrlMoveOut - CtrlMoveInp) / CtrlDivider);
     f98:	0000fc00 	.word	0x0000fc00
     f9c:	0000fe00 	.word	0x0000fe00
     fa0:	5d000100 	.word	0x5d000100
     fa4:	000000fe 	.word	0x000000fe
     fa8:	0000016c 	.word	0x0000016c
     fac:	107d0002 	.word	0x107d0002
	...
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
     fb8:	000000fc 	.word	0x000000fc
     fbc:	00000108 	.word	0x00000108
     fc0:	00500001 	.word	0x00500001

//--------------------------------------------------------------------
// GetLegsXZLength -
//--------------------------------------------------------------------
word g_wLegsXZLength = 0xffff;
word GetLegsXZLength(void) {
     fc4:	00000000 	.word	0x00000000
	// Could save away or could do a little math on one leg...
	if (g_wLegsXZLength != 0xffff)
		return g_wLegsXZLength;

	return isqrt32((LegPosX[0] * LegPosX[0]) + (LegPosZ[0] * LegPosZ[0]));
     fc8:	6c000000 	.word	0x6c000000
     fcc:	6e000001 	.word	0x6e000001
     fd0:	01000001 	.word	0x01000001
     fd4:	016e5d00 	.word	0x016e5d00
     fd8:	01720000 	.word	0x01720000
     fdc:	00020000 	.word	0x00020000
}
     fe0:	01720c7d 	.word	0x01720c7d
     fe4:	01c80000 	.word	0x01c80000
     fe8:	00020000 	.word	0x00020000
     fec:	0000107d 	.word	0x0000107d

#ifndef MAX_XZ_LEG_ADJUST
#define MAX_XZ_LEG_ADJUST   (word)(cCoxaLength[0]+cTibiaLength[0] + cFemurLength[0]/4)
#endif

void AdjustLegPositions(word XZLength1) {
     ff0:	00000000 	.word	0x00000000
     ff4:	016c0000 	.word	0x016c0000
     ff8:	01a60000 	.word	0x01a60000
     ffc:	00010000 	.word	0x00010000
    1000:	00000050 	.word	0x00000050
		XZLength1 = MAX_XZ_LEG_ADJUST;
	if (XZLength1 < MIN_XZ_LEG_ADJUST)
		XZLength1 = MIN_XZ_LEG_ADJUST;

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
    1004:	00000000 	.word	0x00000000
    1008:	00017600 	.word	0x00017600
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    100c:	0001a000 	.word	0x0001a000

	// see if same length as when we came in
	if (XZLength1 == g_wLegsXZLength)
		return;

	g_wLegsXZLength = XZLength1;
    1010:	52000100 	.word	0x52000100
	...
	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		GetSinCos((short) pgm_read_word(&cCoxaAngle1[LegIndex]));

		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
    101c:	000001c8 	.word	0x000001c8
    1020:	000001ca 	.word	0x000001ca
    1024:	ca5d0001 	.word	0xca5d0001
    1028:	24000001 	.word	0x24000001
    102c:	02000002 	.word	0x02000002
    1030:	00087d00 	.word	0x00087d00
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
    1034:	00000000 	.word	0x00000000
    1038:	24000000 	.word	0x24000000
    103c:	26000002 	.word	0x26000002
    1040:	01000002 	.word	0x01000002
    1044:	02265d00 	.word	0x02265d00
    1048:	022a0000 	.word	0x022a0000
		return;

	g_wLegsXZLength = XZLength1;

	u8 LegIndex;
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    104c:	00020000 	.word	0x00020000
		LegPosX[LegIndex] = ((long) ((long) cos4 * XZLength1)) / c4DEC; //Set start positions for each leg
		LegPosZ[LegIndex] = -((long) ((long) sin4 * XZLength1)) / c4DEC;
	}

	// Make sure we cycle through one gait to have the legs all move into their new locations...
	g_InControlState.ForceGaitStepCnt = g_InControlState.gaitCur.StepsInGait;
    1050:	022a147d 	.word	0x022a147d
    1054:	02bc0000 	.word	0x02bc0000
}
    1058:	00020000 	.word	0x00020000
    105c:	0000187d 	.word	0x0000187d
    1060:	00000000 	.word	0x00000000
    1064:	02540000 	.word	0x02540000
    1068:	025a0000 	.word	0x025a0000
    106c:	00010000 	.word	0x00010000
    1070:	00000054 	.word	0x00000054
    1074:	00000000 	.word	0x00000000
    1078:	0002bc00 	.word	0x0002bc00
		g_InControlState.aCoxaInitAngle1[LegIndex] = (short)pgm_read_word(&cCoxaAngle1[LegIndex]);
#endif
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    107c:	0002be00 	.word	0x0002be00
		else if (g_InControlState.aCoxaInitAngle1[LegIndex] < -700)
		g_InControlState.aCoxaInitAngle1[LegIndex] = -700;
	}
	g_wLegsXZLength = 0xffff;
#endif
}
    1080:	5d000100 	.word	0x5d000100
//     to be appropriate for the current y location of the body...
//--------------------------------------------------------------------

u8 g_iLegInitIndex = 0x00; // remember which index we are currently using...

void AdjustLegPositionsToBodyHeight() {
    1084:	000002be 	.word	0x000002be
    1088:	000002c2 	.word	0x000002c2
#ifdef CNT_HEX_INITS
	// Lets see which of our units we should use...
	// Note: We will also limit our body height here...
	if (g_InControlState.BodyPos.y
    108c:	147d0002 	.word	0x147d0002
			> (short) pgm_read_byte(&g_abHexMaxBodyY[CNT_HEX_INITS-1]))
		g_InControlState.BodyPos.y = (short) pgm_read_byte(
    1090:	000002c2 	.word	0x000002c2
				&g_abHexMaxBodyY[CNT_HEX_INITS-1]);

	u8 i;
	word XZLength1 = pgm_read_byte(&g_abHexIntXZ[CNT_HEX_INITS-1]);
	for (i = 0; i < (CNT_HEX_INITS - 1); i++) { // Don't need to look at last entry as we already init to assume this one...
		if (g_InControlState.BodyPos.y
    1094:	00000384 	.word	0x00000384
    1098:	187d0002 	.word	0x187d0002
	...
    10a4:	000002bc 	.word	0x000002bc
    10a8:	000002d2 	.word	0x000002d2
				<= (short) pgm_read_byte(&g_abHexMaxBodyY[i])) {
			XZLength1 = pgm_read_byte(&g_abHexIntXZ[i]);
			break;
		}
	}
	if (i != g_iLegInitIndex) {
    10ac:	e6500001 	.word	0xe6500001
		g_iLegInitIndex = i;  // remember the current index...
		AdjustLegPositions(XZLength1);
    10b0:	ec000002 	.word	0xec000002
	}
#endif // CNT_HEX_INITS
}
    10b4:	01000002 	.word	0x01000002
    10b8:	03605000 	.word	0x03605000
    10bc:	03620000 	.word	0x03620000
}
//--------------------------------------------------------------------
//[CHECK VOLTAGE]
//Reads the input voltage and shuts down the bot when the power drops
byte s_bLVBeepCnt;
boolean CheckVoltage() {
    10c0:	00010000 	.word	0x00010000
    10c4:	00000050 	.word	0x00000050
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10c8:	00000000 	.word	0x00000000

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10cc:	00030c00 	.word	0x00030c00
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d0:	00030e00 	.word	0x00030e00

	// BUGBUG:: if voltage is 0 it failed to retrieve don't hang program...
	//    if (!Voltage)
	//      return;

	if (!g_fLowVoltageShutdown) {
    10d4:	53000100 	.word	0x53000100
boolean CheckVoltage() {
#ifdef cTurnOffVol
	// Moved to Servo Driver - BUGBUG: Need to do when I merge back...
	//    Voltage = analogRead(cVoltagePin); // Battery voltage
	//    Voltage = ((long)Voltage*1955)/1000;
	Voltage = ReadAnalog(VBUS) >> 4;
    10d8:	0000031e 	.word	0x0000031e

	if (!g_fLowVoltageShutdown) {
		/**PrintString("Voltage : ");
		Printu32d(Voltage);
		PrintString("\n");*/
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {
    10dc:	0000032c 	.word	0x0000032c
    10e0:	32530001 	.word	0x32530001
    10e4:	3c000003 	.word	0x3c000003


			//Turn off
			g_InControlState.BodyPos.x = 0;
    10e8:	01000003 	.word	0x01000003
			g_InControlState.TravelLength.x = 0;
			g_InControlState.TravelLength.z = 0;

#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
    10ec:	034a5300 	.word	0x034a5300
    10f0:	03580000 	.word	0x03580000
#endif
			g_fLowVoltageShutdown = 1;
    10f4:	00010000 	.word	0x00010000
			s_bLVBeepCnt = 0;    // how many times we beeped...
    10f8:	00035c53 	.word	0x00035c53
		if ((Voltage < cTurnOffVol) || (Voltage >= 1999)) {


			//Turn off
			g_InControlState.BodyPos.x = 0;
			g_InControlState.BodyPos.y = 0;
    10fc:	00036000 	.word	0x00036000
			g_InControlState.BodyPos.z = 0;
			g_InControlState.BodyRot1.x = 0;
    1100:	53000100 	.word	0x53000100
	...
#ifdef OPT_SINGLELEG
			g_InControlState.TravelLength.y = 0;
			g_InControlState.SelectedLeg = 255;
#endif
			g_fLowVoltageShutdown = 1;
			s_bLVBeepCnt = 0;    // how many times we beeped...
    110c:	00000384 	.word	0x00000384
			g_InControlState.fRobotOn = false;
    1110:	00000386 	.word	0x00000386
		}
#ifdef cTurnOnVol
	} else if ((Voltage > cTurnOnVol) && (Voltage < 1999)) {
    1114:	865d0001 	.word	0x865d0001
    1118:	8a000003 	.word	0x8a000003

		g_fLowVoltageShutdown = 0;
    111c:	02000003 	.word	0x02000003
    1120:	8a147d00 	.word	0x8a147d00

#endif
	} else {
		if (s_bLVBeepCnt < 5) {
    1124:	bc000003 	.word	0xbc000003
    1128:	02000003 	.word	0x02000003
			s_bLVBeepCnt++;
    112c:	00187d00 	.word	0x00187d00

			//MSound( 1, 45, 2000);
			Buzzed(45, 2000);
    1130:	00000000 	.word	0x00000000
    1134:	0000      	.short	0x0000
    1136:	00          	.byte	0x00
    1137:	48          	.byte	0x48
    1138:	4a000000 	.word	0x4a000000
		}
		mDelay(2000);
    113c:	01000000 	.word	0x01000000
    1140:	004a5d00 	.word	0x004a5d00
    1144:	004e0000 	.word	0x004e0000
	}
#endif

	return g_fLowVoltageShutdown;
}
    1148:	00020000 	.word	0x00020000
    114c:	004e147d 	.word	0x004e147d
    1150:	00b40000 	.word	0x00b40000
    1154:	00020000 	.word	0x00020000
    1158:	0000207d 	.word	0x0000207d

//==============================================================================
// BackgroundProcess - Allows us to have some background processing for those
//    servo drivers that need us to do things like polling...
//==============================================================================
void BackgroundProcess(void) {
    115c:	00000000 	.word	0x00000000
    1160:	00480000 	.word	0x00480000
	if (g_fAXSpeedControl)
    1164:	00520000 	.word	0x00520000
		return;  // nothing to do in this mode...

	if (ServosEnabled) {
		//DebugToggle(A3);
		BioloidControllerEx_interpolateStep(false); // Do our background stuff...
    1168:	00010000 	.word	0x00010000
		Battery_Monitor_Alarm();
    116c:	00005250 	.word	0x00005250
	}
}
    1170:	0000b400 	.word	0x0000b400
    1174:	54000100 	.word	0x54000100
	...
//--------------------------------------------------------------------
static u8 g_iIdleServoNum = (u8) - 1;
static u8 g_iIdleLedState = 1;  // what state to we wish to set...
void IdleTime(void) {
	// Each time we call this set servos LED on or off...
	g_iIdleServoNum++;
    1180:	00000062 	.word	0x00000062
	if (g_iIdleServoNum >= NUMSERVOS) {
    1184:	0000007e 	.word	0x0000007e
    1188:	047d0002 	.word	0x047d0002
		g_iIdleServoNum = 0;
    118c:	0000007e 	.word	0x0000007e
		g_iIdleLedState = 1 - g_iIdleLedState;
    1190:	00000084 	.word	0x00000084
    1194:	78910002 	.word	0x78910002
	}
	dxl_write_byte(pgm_read_byte(&cPinTable[g_iIdleServoNum]), AXM_LED,
    1198:	00000084 	.word	0x00000084
    119c:	000000b4 	.word	0x000000b4
    11a0:	047d0002 	.word	0x047d0002
	...
			g_iIdleLedState);
	//ax12ReadPacket(6);  // get the response...


}
    11ac:	000000b4 	.word	0x000000b4
    11b0:	000000b6 	.word	0x000000b6
    11b4:	b65d0001 	.word	0xb65d0001
    11b8:	ba000000 	.word	0xba000000

//--------------------------------------------------------------------
//[SetRegOnAllServos] Function that is called to set the state of one
//  register in all of the servos, like Torque on...
//--------------------------------------------------------------------
void SetRegOnAllServos(u8 bReg, u8 bVal) {
    11bc:	02000000 	.word	0x02000000
    11c0:	ba147d00 	.word	0xba147d00
    11c4:	44000000 	.word	0x44000000
	 ax12write(bVal);

  }
  ax12write(0xff - (checksum % 256));
  setRX(0);*/
	 dxl_set_txpacket_id (BROADCAST_ID);
    11c8:	02000001 	.word	0x02000001
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    11cc:	00207d00 	.word	0x00207d00
	dxl_set_txpacket_parameter(0,bReg);
    11d0:	00000000 	.word	0x00000000
    11d4:	b4000000 	.word	0xb4000000
	dxl_set_txpacket_parameter(1,2);
    11d8:	be000000 	.word	0xbe000000
    11dc:	01000000 	.word	0x01000000
    11e0:	00be5000 	.word	0x00be5000
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
    11e4:	01440000 	.word	0x01440000
    11e8:	00010000 	.word	0x00010000
    11ec:	00000055 	.word	0x00000055
    11f0:	00000000 	.word	0x00000000
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    11f4:	0000d200 	.word	0x0000d200
    11f8:	0000ee00 	.word	0x0000ee00
    11fc:	7d000200 	.word	0x7d000200
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1200:	0000ee00 	.word	0x0000ee00
    1204:	00010600 	.word	0x00010600
    1208:	91000200 	.word	0x91000200
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
		byte id = pgm_read_byte(&cPinTable[i]);
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
    120c:	00010674 	.word	0x00010674
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
    1210:	00010800 	.word	0x00010800
	 dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction(INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0,bReg);
	dxl_set_txpacket_parameter(1,2);
  int i;
	for (i = 0; i < poseSize; i++) {
    1214:	7d000200 	.word	0x7d000200
    1218:	00010800 	.word	0x00010800
    121c:	00012200 	.word	0x00012200
		dxl_set_txpacket_parameter(2 + 3 * i, id);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(bVal));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(bVal));
	}

	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
    1220:	91000200 	.word	0x91000200
    1224:	00012274 	.word	0x00012274
    1228:	00014400 	.word	0x00014400
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- SetRegOnAllServos ---\n");
#endif
	dxl_txrx_packet();
    122c:	7d000200 	.word	0x7d000200
	...

	u16 CommStatus = dxl_get_result();
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
		PrintErrorCode();
    1238:	0000c200 	.word	0x0000c200
	else
		PrintCommStatus(CommStatus);
    123c:	0000c400 	.word	0x0000c400
#endif
}
    1240:	7d000200 	.word	0x7d000200
    1244:	0000ce04 	.word	0x0000ce04
    1248:	0000f200 	.word	0x0000f200
//--------------------------------------------------------------------
//[MakeSureServosAreOn] Function that is called to handle when you are
//  transistioning from servos all off to being on.  May need to read
//  in the current pose...
//--------------------------------------------------------------------
void MakeSureServosAreOn(void) {
    124c:	7d000200 	.word	0x7d000200

	if (ServosEnabled) {

		if (!g_fServosFree)
    1250:	0000f204 	.word	0x0000f204
			return;    // we are not free

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {
    1254:	00010800 	.word	0x00010800
    1258:	91000200 	.word	0x91000200

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
    125c:	00010878 	.word	0x00010878
    1260:	00014400 	.word	0x00014400
    1264:	7d000200 	.word	0x7d000200
    1268:	00000004 	.word	0x00000004
						AXM_PRESENT_POSITION_L);
				mDelay(25);
    126c:	00000000 	.word	0x00000000
    1270:	00014400 	.word	0x00014400

		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		if (g_fAXSpeedControl) {

			int i;
			for (i = 0; i < NUMSERVOS; i++) {
    1274:	00014600 	.word	0x00014600
    1278:	5d000100 	.word	0x5d000100
				g_awGoalAXPos[i] = dxl_read_word(pgm_read_byte(&cPinTable[i]),
						AXM_PRESENT_POSITION_L);
				mDelay(25);
			}
		} else {
			BioloidControllerEx_readPose();
    127c:	00000146 	.word	0x00000146
		}

		SetRegOnAllServos(AXM_TORQUE_ENABLE, 1);  // Use sync write to do it.
    1280:	0000014a 	.word	0x0000014a
    1284:	147d0002 	.word	0x147d0002

		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = false;
    1288:	0000014a 	.word	0x0000014a
	}

}
    128c:	000001cc 	.word	0x000001cc
    1290:	207d0002 	.word	0x207d0002
	...
    129c:	00000144 	.word	0x00000144

//------------------------------------------------------------------------------------------
//[BeginServoUpdate] Does whatever preperation that is needed to starrt a move of our servos
//------------------------------------------------------------------------------------------
void BeginServoUpdate(void)    // Start the update
		{
    12a0:	0000014e 	.word	0x0000014e

	MakeSureServosAreOn();
    12a4:	4e500001 	.word	0x4e500001
	if (ServosEnabled) {

		if (g_fAXSpeedControl) {
    12a8:	cc000001 	.word	0xcc000001
    12ac:	01000001 	.word	0x01000001

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
				g_awCurAXPos[i] = g_awGoalAXPos[i];
    12b0:	00005500 	.word	0x00005500
    12b4:	00000000 	.word	0x00000000
    12b8:	01520000 	.word	0x01520000
		if (g_fAXSpeedControl) {

#ifdef USE_AX12_SPEED_CONTROL
			// If we are trying our own Servo control need to save away the new positions...
			byte i;
			for (i = 0; i < NUMSERVOS; i++) {
    12bc:	01540000 	.word	0x01540000
				g_awCurAXPos[i] = g_awGoalAXPos[i];
			}
#endif
		} else
			BioloidControllerEx_interpolateStep(true); // Make sure we call at least once
    12c0:	00020000 	.word	0x00020000
    12c4:	015e047d 	.word	0x015e047d

	}
}
    12c8:	01800000 	.word	0x01800000
    12cc:	00020000 	.word	0x00020000
    12d0:	0180047d 	.word	0x0180047d
    12d4:	01940000 	.word	0x01940000
}

//--------------------------------------------------------------------
//[FREE SERVOS] Frees all the servos
//--------------------------------------------------------------------
void FreeServos(void) {
    12d8:	00020000 	.word	0x00020000
    12dc:	01947891 	.word	0x01947891

	if (!g_fServosFree) {
    12e0:	01cc0000 	.word	0x01cc0000
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
    12e4:	00020000 	.word	0x00020000
    12e8:	0000047d 	.word	0x0000047d
    12ec:	00000000 	.word	0x00000000
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
			Relax(pgm_read_byte(&cPinTable[i]));
    12f0:	01cc0000 	.word	0x01cc0000
    12f4:	01ce0000 	.word	0x01ce0000
    12f8:	00010000 	.word	0x00010000

	if (!g_fServosFree) {
		CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
		SetRegOnAllServos(AXM_TORQUE_ENABLE, 0);  // do this as one statement...
		byte i;
		for (i = 0; i < NUMSERVOS; i++) {
    12fc:	0001ce5d 	.word	0x0001ce5d
			Relax(pgm_read_byte(&cPinTable[i]));
		}
		CommanderInputController_AllowControllerInterrupts(true);
		g_fServosFree = true;
    1300:	0001d200 	.word	0x0001d200
	}
}
    1304:	7d000200 	.word	0x7d000200
    1308:	0001d214 	.word	0x0001d214
    130c:	00022400 	.word	0x00022400
extern void SetRegOnAllServos(u8 bReg, u8 bVal);

//--------------------------------------------------------------------
//Init
//--------------------------------------------------------------------
void Servo_Init(void) {
    1310:	7d000200 	.word	0x7d000200
	// First lets get the actual servo positions for all of our servos...
	//pinMode(0, OUTPUT);
	g_fServosFree = true;
    1314:	00000020 	.word	0x00000020

  poseSize = NUMSERVOS;
    1318:	00000000 	.word	0x00000000
    131c:	0001cc00 	.word	0x0001cc00
  BioloidControllerEx_readPose();
    1320:	0001d800 	.word	0x0001d800
#ifdef cVoltagePin
	for (byte i=0; i < 8; i++)
	GetBatteryVoltage();  // init the voltage pin
#endif

	g_fAXSpeedControl = false;
    1324:	50000100 	.word	0x50000100
    1328:	000001d8 	.word	0x000001d8



	// Added - try to speed things up later if we do a query...
	SetRegOnAllServos(AXM_RETURN_DELAY_TIME, 0); // tell servos to give us back their info as quick as they can...
    132c:	00000224 	.word	0x00000224
    1330:	00570001 	.word	0x00570001

}
    1334:	00000000 	.word	0x00000000
    1338:	d8000000 	.word	0xd8000000
    133c:	f2000001 	.word	0xf2000001
    1340:	02000001 	.word	0x02000001

}

void setupPhoenix() {

	g_fShowDebugPrompt = true;
    1344:	f2047d00 	.word	0xf2047d00
void readSensors(){


}

void setupPhoenix() {
    1348:	00000001 	.word	0x00000001

	g_fShowDebugPrompt = true;
	g_fDebugOutput = false;
    134c:	02000002 	.word	0x02000002
    1350:	00789100 	.word	0x00789100
	//init BioloidEx
	BioloidControllerEx();
    1354:	24000002 	.word	0x24000002

	// Init our ServoDriver
	Servo_Init();
    1358:	02000002 	.word	0x02000002

	mDelay(10);
    135c:	00047d00 	.word	0x00047d00

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1360:	00000000 	.word	0x00000000
    1364:	24000000 	.word	0x24000000
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    1368:	26000002 	.word	0x26000002
    136c:	01000002 	.word	0x01000002
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1370:	02265d00 	.word	0x02265d00

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
		LegPosX[LegIndex] = (short) pgm_read_word(&cInitPosX[LegIndex]); //Set start positions for each leg
    1374:	022a0000 	.word	0x022a0000
    1378:	00020000 	.word	0x00020000
		LegPosY[LegIndex] = (short) pgm_read_word(&cInitPosY[LegIndex]);
    137c:	022a147d 	.word	0x022a147d
    1380:	027c0000 	.word	0x027c0000
		LegPosZ[LegIndex] = (short) pgm_read_word(&cInitPosZ[LegIndex]);
    1384:	00020000 	.word	0x00020000
    1388:	0000207d 	.word	0x0000207d
    138c:	00000000 	.word	0x00000000
	Servo_Init();

	mDelay(10);

	// Setup Init Positions
	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1390:	02240000 	.word	0x02240000
    1394:	02320000 	.word	0x02320000
    1398:	00010000 	.word	0x00010000

	ResetLegInitAngles();

	//Single leg control. Make sure no leg is selected
#ifdef OPT_SINGLELEG
	g_InControlState.SelectedLeg = 255; // No Leg selected
    139c:	00023250 	.word	0x00023250
    13a0:	00027c00 	.word	0x00027c00
	g_InControlState.PrevSelectedLeg = 255;
    13a4:	57000100 	.word	0x57000100
	...
	g_InControlState.BodyPos.y = 0;
	g_InControlState.BodyPos.z = 0;

//Body Rotations
	g_InControlState.BodyRot1.x = 0;
	g_InControlState.BodyRot1.y = 0;
    13b0:	0000022e 	.word	0x0000022e
	g_InControlState.BodyRot1.z = 0;
	g_InControlState.BodyRotOffset.x = 0;
    13b4:	0000024c 	.word	0x0000024c
	g_InControlState.BodyRotOffset.y = 0; //Input Y offset value to adjust centerpoint of rotation
	g_InControlState.BodyRotOffset.z = 0;
    13b8:	047d0002 	.word	0x047d0002

	//Gait
	g_InControlState.GaitType = 0;
    13bc:	0000024c 	.word	0x0000024c
	g_InControlState.BalanceMode = 0;
    13c0:	0000025a 	.word	0x0000025a
	g_InControlState.LegLiftHeight = 50;
	g_InControlState.ForceGaitStepCnt = 0; // added to try to adjust starting positions depending on height...
    13c4:	78910002 	.word	0x78910002
	g_InControlState.GaitStep = 1;
    13c8:	0000025a 	.word	0x0000025a
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    13cc:	0000027c 	.word	0x0000027c
	g_InControlState.BodyRotOffset.z = 0;

	//Gait
	g_InControlState.GaitType = 0;
	g_InControlState.BalanceMode = 0;
	g_InControlState.LegLiftHeight = 50;
    13d0:	047d0002 	.word	0x047d0002
	...
void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    13dc:	0000027c 	.word	0x0000027c
    13e0:	00000280 	.word	0x00000280
//==============================================================================

// If both PS2 and XBee are defined then we will become secondary to the xbee
void CommanderInputController_Init(void) {

	g_BodyYOffset = 0;
    13e4:	805d0001 	.word	0x805d0001
    13e8:	90000002 	.word	0x90000002
    13ec:	02000002 	.word	0x02000002
	g_BodyYShift = 0;
	//begin(XBEE_BAUD);
	GPSeq = 0;  // init to something...
    13f0:	900c7d00 	.word	0x900c7d00
    13f4:	e0000002 	.word	0xe0000002

	ControlMode = WALKMODE;
    13f8:	02000002 	.word	0x02000002
	HeightSpeedMode = NORM_NORM;
    13fc:	00107d00 	.word	0x00107d00
	//    DoubleHeightOn = false;
	DoubleTravelOn = false;
    1400:	00000000 	.word	0x00000000
	bJoystickWalkMode = 0;
    1404:	7c000000 	.word	0x7c000000
	GaitSelect();

	CommanderInputController_Init();

	// Servo Driver
	ServoMoveTime = 150;
    1408:	8e000002 	.word	0x8e000002
	g_InControlState.fRobotOn = 0;
    140c:	01000002 	.word	0x01000002
	g_fLowVoltageShutdown = false;
    1410:	028e5000 	.word	0x028e5000

}
    1414:	02a60000 	.word	0x02a60000
    1418:	00010000 	.word	0x00010000
    141c:	0002aa55 	.word	0x0002aa55
    1420:	0002c200 	.word	0x0002c200
    1424:	55000100 	.word	0x55000100
	...
    1430:	00000288 	.word	0x00000288
    1434:	000002a2 	.word	0x000002a2
    1438:	b2540001 	.word	0xb2540001
    143c:	c6000002 	.word	0xc6000002
    1440:	01000002 	.word	0x01000002
    1444:	00005400 	.word	0x00005400
    1448:	00000000 	.word	0x00000000
    144c:	02e00000 	.word	0x02e00000
    1450:	02e40000 	.word	0x02e40000
    1454:	00010000 	.word	0x00010000
    1458:	0002e45d 	.word	0x0002e45d
    145c:	0002fc00 	.word	0x0002fc00
    1460:	7d000200 	.word	0x7d000200
    1464:	00000008 	.word	0x00000008
//[CommitServoDriver Updates the positions of the servos - This outputs
//         as much of the command as we can without committing it.  This
//         allows us to once the previous update was completed to quickly
//        get the next command to start
//--------------------------------------------------------------------
void CommitServoDriver(word wMoveTime) {
    1468:	00000000 	.word	0x00000000
    146c:	0002e000 	.word	0x0002e000
    1470:	0002ee00 	.word	0x0002ee00


	CommanderInputController_AllowControllerInterrupts(false); // If on xbee on hserial tell hserial to not processess...
	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1474:	50000100 	.word	0x50000100

      }
      ax12write(0xff - (checksum % 256));
      setRX(0);
*/
  	    dxl_set_txpacket_id (BROADCAST_ID);
    1478:	000002ee 	.word	0x000002ee
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
    147c:	000002fc 	.word	0x000002fc
    1480:	00540001 	.word	0x00540001
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
    1484:	00000000 	.word	0x00000000
    1488:	fc000000 	.word	0xfc000000
		dxl_set_txpacket_parameter(1, 2);
    148c:	fe000002 	.word	0xfe000002
    1490:	01000002 	.word	0x01000002
    1494:	02fe5d00 	.word	0x02fe5d00
    1498:	03000000 	.word	0x03000000
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
			wSpeed = CalculateAX12MoveSpeed(g_awCurAXPos[i], g_awGoalAXPos[i], wMoveTime);    // What order should we store these values?
    149c:	00020000 	.word	0x00020000
    14a0:	0300047d 	.word	0x0300047d
    14a4:	03080000 	.word	0x03080000
    14a8:	00020000 	.word	0x00020000
			//dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
			byte id = pgm_read_byte(&cPinTable[i]);
			dxl_set_txpacket_parameter(2 + 3 * i, id);
    14ac:	0000087d 	.word	0x0000087d
    14b0:	00000000 	.word	0x00000000
    14b4:	02fc0000 	.word	0x02fc0000
    14b8:	03040000 	.word	0x03040000
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(g_awGoalAXPos[i]));
    14bc:	00010000 	.word	0x00010000
    14c0:	00000050 	.word	0x00000050
    14c4:	00000000 	.word	0x00000000
    14c8:	00030800 	.word	0x00030800
    14cc:	00030a00 	.word	0x00030a00
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
    14d0:	5d000100 	.word	0x5d000100
    14d4:	0000030a 	.word	0x0000030a
    14d8:	0000030e 	.word	0x0000030e
    14dc:	0c7d0002 	.word	0x0c7d0002
    14e0:	0000030e 	.word	0x0000030e
    14e4:	00000324 	.word	0x00000324
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
    14e8:	107d0002 	.word	0x107d0002
	...
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
    14f4:	00000308 	.word	0x00000308
    14f8:	00000312 	.word	0x00000312
    14fc:	12500001 	.word	0x12500001
    1500:	24000003 	.word	0x24000003
		dxl_set_txpacket_instruction(INST_SYNC_WRITE);
		dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
		dxl_set_txpacket_parameter(1, 2);
      int i;
      word wSpeed;
		for (i = 0; i < poseSize; i++) {
    1504:	01000003 	.word	0x01000003
    1508:	00005500 	.word	0x00005500
    150c:	00000000 	.word	0x00000000
    1510:	03240000 	.word	0x03240000
			dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(g_awGoalAXPos[i]));
			dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(wSpeed));
		    dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(wSpeed));
		}

		dxl_set_txpacket_length((4 + 1) * poseSize + 4);
    1514:	03260000 	.word	0x03260000
    1518:	00010000 	.word	0x00010000
    151c:	0003265d 	.word	0x0003265d
#ifdef DEBUG_BIOLOIDEX
	PrintString("DriverAX12 --- CommitServoDriver ---\n");
#endif
		dxl_txrx_packet();
    1520:	00032a00 	.word	0x00032a00

			u16 CommStatus = dxl_get_result();
    1524:	7d000200 	.word	0x7d000200
#ifdef USING_PC_UART
			if (CommStatus == DXL_RXSUCCESS)
    1528:	00032a04 	.word	0x00032a04
				PrintErrorCode();
    152c:	00036e00 	.word	0x00036e00
			else
				PrintCommStatus(CommStatus);
    1530:	7d000200 	.word	0x7d000200
    1534:	00000010 	.word	0x00000010
#endif
#endif
		} else {
			BioloidControllerEx_interpolateSetup(wMoveTime);
    1538:	00000000 	.word	0x00000000

	}

	CommanderInputController_AllowControllerInterrupts(true);

}
    153c:	00032400 	.word	0x00032400
    1540:	00035400 	.word	0x00035400
    1544:	50000100 	.word	0x50000100
	...
    1550:	00000370 	.word	0x00000370
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    1554:	00000372 	.word	0x00000372
    1558:	725d0001 	.word	0x725d0001
    155c:	76000003 	.word	0x76000003
    1560:	02000003 	.word	0x02000003
    1564:	76047d00 	.word	0x76047d00


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1568:	e6000003 	.word	0xe6000003
	word wCoxaSDV;        // Coxa value in servo driver units
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    156c:	02000003 	.word	0x02000003
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1570:	00107d00 	.word	0x00107d00
    1574:	00000000 	.word	0x00000000
    1578:	70000000 	.word	0x70000000
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
    157c:	cc000003 	.word	0xcc000003
    1580:	01000003 	.word	0x01000003
    1584:	00005000 	.word	0x00005000


void OutputServoInfoForLeg(byte LegIndex, short sCoxaAngle1, short sFemurAngle1,
		short sTibiaAngle1)

		{
    1588:	00000000 	.word	0x00000000
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    158c:	03e80000 	.word	0x03e80000
	word wFemurSDV;        //
	word wTibiaSDV;        //

	// The Main code now takes care of the inversion before calling.
	wCoxaSDV = (((long) (sCoxaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;
	wFemurSDV = (((long) ((long) (sFemurAngle1)) * cPwmMult) / cPwmDiv
    1590:	03ea0000 	.word	0x03ea0000
			+ cPFConst);
	wTibiaSDV = (((long) (sTibiaAngle1)) * cPwmMult) / cPwmDiv + cPFConst;

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
    1594:	00010000 	.word	0x00010000
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    1598:	0003ea5d 	.word	0x0003ea5d

	if (ServosEnabled) {
		if (g_fAXSpeedControl) {
#ifdef USE_AX12_SPEED_CONTROL
			// Save away the new positions...
			g_awGoalAXPos[FIRSTCOXAPIN + LegIndex] = wCoxaSDV; // What order should we store these values?
    159c:	0003ec00 	.word	0x0003ec00
			g_awGoalAXPos[FIRSTFEMURPIN + LegIndex] = wFemurSDV;
    15a0:	7d000200 	.word	0x7d000200
			g_awGoalAXPos[FIRSTTIBIAPIN + LegIndex] = wTibiaSDV;
    15a4:	0003ec04 	.word	0x0003ec04
    15a8:	00045c00 	.word	0x00045c00
    15ac:	7d000200 	.word	0x7d000200

#endif
		} else {
			BioloidControllerEx_setNextPose(
    15b0:	00000018 	.word	0x00000018
    15b4:	00000000 	.word	0x00000000
					pgm_read_byte(&cPinTable[FIRSTCOXAPIN + LegIndex]),
					wCoxaSDV);
			BioloidControllerEx_setNextPose(
    15b8:	0003e800 	.word	0x0003e800
    15bc:	00040600 	.word	0x00040600
    15c0:	50000100 	.word	0x50000100
	...
					wTibiaSDV);

		}
	}
	CommanderInputController_AllowControllerInterrupts(true); // Ok for hserial again...
}
    15cc:	00000402 	.word	0x00000402
    15d0:	0000040a 	.word	0x0000040a
    15d4:	00530001 	.word	0x00530001
    15d8:	00000000 	.word	0x00000000
    15dc:	02000000 	.word	0x02000000

void StartUpdateServos() {
    15e0:	26000004 	.word	0x26000004
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update
    15e4:	01000004 	.word	0x01000004
    15e8:	00005000 	.word	0x00005000
    15ec:	00000000 	.word	0x00000000

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {

		OutputServoInfoForLeg(LegIndex,
    15f0:	03f20000 	.word	0x03f20000
    15f4:	04140000 	.word	0x04140000
    15f8:	00010000 	.word	0x00010000
    15fc:	00041652 	.word	0x00041652
    1600:	00043000 	.word	0x00043000
    1604:	52000100 	.word	0x52000100
    1608:	00000440 	.word	0x00000440
    160c:	0000044e 	.word	0x0000044e
    1610:	00520001 	.word	0x00520001
    1614:	00000000 	.word	0x00000000
    1618:	22000000 	.word	0x22000000
    161c:	4e000004 	.word	0x4e000004
    1620:	01000004 	.word	0x01000004
    1624:	00005100 	.word	0x00005100
    1628:	00000000 	.word	0x00000000
    162c:	045c0000 	.word	0x045c0000
    1630:	045e0000 	.word	0x045e0000
    1634:	00010000 	.word	0x00010000
    1638:	00045e5d 	.word	0x00045e5d
    163c:	00046200 	.word	0x00046200
    1640:	7d000200 	.word	0x7d000200
	byte LegIndex;

	// First call off to the init...
	BeginServoUpdate();    // Start the update

	for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    1644:	00046204 	.word	0x00046204
				cTibiaInv[LegIndex] ?
						-TibiaAngle1[LegIndex] : TibiaAngle1[LegIndex]);

	}

}
    1648:	0004cc00 	.word	0x0004cc00
    164c:	7d000200 	.word	0x7d000200
    1650:	00000018 	.word	0x00000018
    1654:	00000000 	.word	0x00000000
    1658:	00045c00 	.word	0x00045c00
    165c:	00049600 	.word	0x00049600
    1660:	50000100 	.word	0x50000100
	...
word g_wLastVoltage = 0xffff;    // save the last voltage we retrieved...
byte g_bLegVoltage = 0;		// what leg did we last check?
unsigned long g_ulTimeLastBatteryVoltage;
#define VOLTAGE_REPEAT_MAX  3
word GetBatteryVoltage(void) {
	if (interpolating && (g_wLastVoltage != 0xffff)
    166c:	00000460 	.word	0x00000460
    1670:	00000482 	.word	0x00000482
    1674:	86520001 	.word	0x86520001
    1678:	a0000004 	.word	0xa0000004
    167c:	01000004 	.word	0x01000004
    1680:	04b05200 	.word	0x04b05200
    1684:	04c00000 	.word	0x04c00000
			&& ((getMillis() - g_ulTimeLastBatteryVoltage)
					< VOLTAGE_MAX_TIME_BETWEEN_CALLS))
		return g_wLastVoltage;
    1688:	00010000 	.word	0x00010000

	register u8 bLoopCnt = VOLTAGE_REPEAT_MAX;
	do {
		register word wVoltage = dxl_read_byte(1, AXM_PRESENT_VOLTAGE);
    168c:	00000052 	.word	0x00000052
    1690:	00000000 	.word	0x00000000
    1694:	00049200 	.word	0x00049200
		if (wVoltage != 0xffff) {
			g_ulTimeLastBatteryVoltage = getMillis();
    1698:	0004c000 	.word	0x0004c000
			g_wLastVoltage = wVoltage * 10;
    169c:	51000100 	.word	0x51000100
	...
		}
	} while (--bLoopCnt);

	return 0;

}
    16a8:	000004cc 	.word	0x000004cc
    16ac:	000004ce 	.word	0x000004ce
    16b0:	ce5d0001 	.word	0xce5d0001
    16b4:	d0000004 	.word	0xd0000004
// ReadMsgs
//==============================================================================

/* process messages coming from Commander
 *  format = 0xFF RIGHT_H RIGHT_V LEFT_H LEFT_V BUTTONS EXT CHECKSUM */
int Commander_ReadMsgs() {
    16b8:	02000004 	.word	0x02000004
	 }
	 #endif
	 */
	//while (CheckZBNewArrive() > 0) {
	while (1) {
		if (zgb_rx_check_arduino() == 1) {
    16bc:	d0047d00 	.word	0xd0047d00
    16c0:	d8000004 	.word	0xd8000004

			leftV = (signed char) (zgb_rx_data_right_V_());
    16c4:	02000004 	.word	0x02000004
    16c8:	00087d00 	.word	0x00087d00
			leftH = (signed char) (zgb_rx_data_right_H_());
    16cc:	00000000 	.word	0x00000000
    16d0:	cc000000 	.word	0xcc000000
			rightV = (signed char) (zgb_rx_data_left_V_());
    16d4:	d4000004 	.word	0xd4000004
    16d8:	01000004 	.word	0x01000004
			rightH = (signed char) (zgb_rx_data_left_H_());
    16dc:	00005000 	.word	0x00005000
    16e0:	00000000 	.word	0x00000000
			buttons = zgb_rx_data_buttons();
    16e4:	04d80000 	.word	0x04d80000
    16e8:	04de0000 	.word	0x04de0000
			ext = zgb_rx_data_extra();
    16ec:	00010000 	.word	0x00010000
    16f0:	0004de5d 	.word	0x0004de5d

	}

	return 0;

}
    16f4:	00056000 	.word	0x00056000
    16f8:	7d000200 	.word	0x7d000200
    16fc:	00000008 	.word	0x00000008
    1700:	00000000 	.word	0x00000000
    1704:	0004d800 	.word	0x0004d800
    1708:	0004dc00 	.word	0x0004dc00
    170c:	50000100 	.word	0x50000100
    1710:	000004e0 	.word	0x000004e0

//==============================================================================
// This is The main code to input function to read inputs from the Commander and then
//process any commands.
//==============================================================================
void CommanderInputController_ControlInput(void) {
    1714:	000004e4 	.word	0x000004e4

	// See if we have a new command available...
	if (Commander_ReadMsgs() > 0) {
    1718:	e8500001 	.word	0xe8500001
    171c:	f0000004 	.word	0xf0000004
    1720:	01000004 	.word	0x01000004
    1724:	04f45000 	.word	0x04f45000
		// If we receive a valid message than turn robot on...
		boolean fAdjustLegPositions = false;
		short sLegInitXZAdjust = 0;
		short sLegInitAngleAdjust = 0;

		if (!g_InControlState.fRobotOn) {
    1728:	04fc0000 	.word	0x04fc0000
    172c:	00010000 	.word	0x00010000
			g_InControlState.fRobotOn = true;
    1730:	00050050 	.word	0x00050050
    1734:	00050800 	.word	0x00050800
		}

		// [SWITCH MODES]

		// Cycle through modes...
		if ((buttons & BUT_LT) && !(buttonsPrev & BUT_LT)) {
    1738:	50000100 	.word	0x50000100
    173c:	0000050c 	.word	0x0000050c
    1740:	00000514 	.word	0x00000514
    1744:	18500001 	.word	0x18500001
    1748:	20000005 	.word	0x20000005
    174c:	01000005 	.word	0x01000005

			if (++ControlMode >= MODECNT) {
    1750:	05245000 	.word	0x05245000
    1754:	052c0000 	.word	0x052c0000
    1758:	00010000 	.word	0x00010000
    175c:	00053050 	.word	0x00053050
				ControlMode = WALKMODE;    // cycled back around...
				Buzzed(50, 2000);
    1760:	00053800 	.word	0x00053800
    1764:	50000100 	.word	0x50000100
    1768:	0000053c 	.word	0x0000053c
				Buzzed(50, 3000);
    176c:	00000560 	.word	0x00000560
    1770:	00500001 	.word	0x00500001

			} else {
				Buzzed(50, 2000);
    1774:	00000000 	.word	0x00000000
    1778:	60000000 	.word	0x60000000
    177c:	62000005 	.word	0x62000005
			}
			if (ControlMode != SINGLELEGMODE)
    1780:	01000005 	.word	0x01000005
    1784:	05625d00 	.word	0x05625d00
				g_InControlState.SelectedLeg = 255;
    1788:	05660000 	.word	0x05660000
    178c:	00020000 	.word	0x00020000
    1790:	0566047d 	.word	0x0566047d

		}

		//[Common functions]
		//Switch Balance mode on/off
		if ((buttons & BUT_L4) && !(buttonsPrev & BUT_L4)) {
    1794:	05f40000 	.word	0x05f40000
    1798:	00020000 	.word	0x00020000
    179c:	0000087d 	.word	0x0000087d
    17a0:	00000000 	.word	0x00000000
    17a4:	05f40000 	.word	0x05f40000
    17a8:	05f60000 	.word	0x05f60000

			g_InControlState.BalanceMode = !g_InControlState.BalanceMode;
    17ac:	00010000 	.word	0x00010000
    17b0:	0005f65d 	.word	0x0005f65d
    17b4:	00064e00 	.word	0x00064e00
    17b8:	7d000200 	.word	0x7d000200
    17bc:	00000010 	.word	0x00000010
			if (g_InControlState.BalanceMode) {
    17c0:	00000000 	.word	0x00000000
				Buzzed(250, 1500);
    17c4:	0005f400 	.word	0x0005f400
    17c8:	0005fc00 	.word	0x0005fc00
			} else {
				Buzzed(100, 2000);
    17cc:	50000100 	.word	0x50000100
    17d0:	000005fc 	.word	0x000005fc
				Buzzed(50, 4000);
    17d4:	0000064e 	.word	0x0000064e
    17d8:	00550001 	.word	0x00550001
    17dc:	00000000 	.word	0x00000000
			}
		}

		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
    17e0:	50000000 	.word	0x50000000
    17e4:	52000006 	.word	0x52000006
    17e8:	01000006 	.word	0x01000006
    17ec:	06525d00 	.word	0x06525d00
    17f0:	06540000 	.word	0x06540000
    17f4:	00020000 	.word	0x00020000
			if (g_BodyYOffset > 0)
    17f8:	0654047d 	.word	0x0654047d
    17fc:	065c0000 	.word	0x065c0000
				g_BodyYOffset = 0;
    1800:	00020000 	.word	0x00020000
    1804:	0000087d 	.word	0x0000087d
			else
				g_BodyYOffset = 35;
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1808:	00000000 	.word	0x00000000
		//Stand up, sit down
		if ((buttons & BUT_L5) && !(buttonsPrev & BUT_L5)) {
			if (g_BodyYOffset > 0)
				g_BodyYOffset = 0;
			else
				g_BodyYOffset = 35;
    180c:	06500000 	.word	0x06500000
			fAdjustLegPositions = true;
			g_fDynamicLegXZLength = false;
    1810:	06580000 	.word	0x06580000
    1814:	00010000 	.word	0x00010000

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1818:	00000050 	.word	0x00000050
		int ly = leftV;
		if (buttons & BUT_L6) {
    181c:	00000000 	.word	0x00000000

		// We will use L6 with the Right joystick to control both body offset as well as Speed...
		// We move each pass through this by a percentage of how far we are from center in each direction
		// We get feedback with height by seeing the robot move up and down.  For Speed, I put in sounds
		// which give an idea, but only for those whoes robot has a speaker
		int lx = leftH;
    1820:	00065c00 	.word	0x00065c00
    1824:	00065e00 	.word	0x00065e00
		int ly = leftV;
    1828:	5d000100 	.word	0x5d000100
    182c:	0000065e 	.word	0x0000065e
		if (buttons & BUT_L6) {
    1830:	00000662 	.word	0x00000662
    1834:	047d0002 	.word	0x047d0002
			// raise or lower the robot on the joystick up /down
			// Maybe should have Min/Max
			int delta = rightV / 25;
    1838:	00000662 	.word	0x00000662
    183c:	0000068c 	.word	0x0000068c
    1840:	087d0002 	.word	0x087d0002
	...
    184c:	0000068c 	.word	0x0000068c
			if (delta) {
    1850:	0000068e 	.word	0x0000068e
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
    1854:	8e5d0001 	.word	0x8e5d0001
    1858:	90000006 	.word	0x90000006
    185c:	02000006 	.word	0x02000006
    1860:	90047d00 	.word	0x90047d00
    1864:	98000006 	.word	0x98000006
    1868:	02000006 	.word	0x02000006
    186c:	00087d00 	.word	0x00087d00
    1870:	00000000 	.word	0x00000000
    1874:	98000000 	.word	0x98000000
			sLegInitAngleAdjust = ly / 8;
			lx = 0;
			ly = 0;

			// Likewise for Speed control
			delta = rightH / 16;   //
    1878:	9a000006 	.word	0x9a000006
    187c:	01000006 	.word	0x01000006
    1880:	069a5d00 	.word	0x069a5d00
    1884:	069c0000 	.word	0x069c0000
    1888:	00020000 	.word	0x00020000
			if ((delta < 0) && g_InControlState.SpeedControl) {
    188c:	069c047d 	.word	0x069c047d
    1890:	06a40000 	.word	0x06a40000
    1894:	00020000 	.word	0x00020000
				if ((word)(-delta) < g_InControlState.SpeedControl)
    1898:	0000087d 	.word	0x0000087d
					g_InControlState.SpeedControl += delta;
    189c:	00000000 	.word	0x00000000
				else
					g_InControlState.SpeedControl = 0;
    18a0:	06a40000 	.word	0x06a40000
    18a4:	06a60000 	.word	0x06a60000

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
    18a8:	00010000 	.word	0x00010000
    18ac:	0006a65d 	.word	0x0006a65d
    18b0:	0006a800 	.word	0x0006a800
				g_InControlState.SpeedControl += delta;
				if (g_InControlState.SpeedControl > 2000)
    18b4:	7d000200 	.word	0x7d000200
					g_InControlState.SpeedControl = 0;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}
			if ((delta > 0) && (g_InControlState.SpeedControl < 2000)) {
				g_InControlState.SpeedControl += delta;
    18b8:	0006a804 	.word	0x0006a804
				if (g_InControlState.SpeedControl > 2000)
					g_InControlState.SpeedControl = 2000;
    18bc:	0006b600 	.word	0x0006b600
    18c0:	7d000200 	.word	0x7d000200

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
    18c4:	00000008 	.word	0x00000008
    18c8:	00000000 	.word	0x00000000
    18cc:	0006a400 	.word	0x0006a400
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18d0:	0006ac00 	.word	0x0006ac00
    18d4:	50000100 	.word	0x50000100
	...
			sLegInitAngleAdjust = ly / 8;
    18e0:	0000003c 	.word	0x0000003c
    18e4:	00000048 	.word	0x00000048
    18e8:	4a500001 	.word	0x4a500001
    18ec:	56000000 	.word	0x56000000
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f0:	01000000 	.word	0x01000000
				g_BodyYOffset = max(min(g_BodyYOffset + delta, MAX_BODY_Y), 0);
				fAdjustLegPositions = true;
			}

			// Also use right Horizontal to manually adjust the initial leg positions.
			sLegInitXZAdjust = lx / 10;        // play with this.
    18f4:	00005000 	.word	0x00005000
					g_InControlState.SpeedControl = 2000;

				Buzzed(50, 1000 + g_InControlState.SpeedControl);
			}

			rightH = 0; // don't walk when adjusting the speed here...
    18f8:	00000000 	.word	0x00000000
		}

		//[Walk functions]
		if (ControlMode == WALKMODE) {
    18fc:	007c0000 	.word	0x007c0000
    1900:	00880000 	.word	0x00880000
    1904:	00010000 	.word	0x00010000

			//Switch gates
			if (((buttons & BUT_R1) && !(buttonsPrev & BUT_R1))
    1908:	00008a50 	.word	0x00008a50
    190c:	00009000 	.word	0x00009000
    1910:	50000100 	.word	0x50000100
	...
    191c:	0000009c 	.word	0x0000009c
    1920:	000000a0 	.word	0x000000a0
    1924:	00500001 	.word	0x00500001
    1928:	00000000 	.word	0x00000000
    192c:	a4000000 	.word	0xa4000000
    1930:	a6000000 	.word	0xa6000000
    1934:	01000000 	.word	0x01000000
    1938:	00005000 	.word	0x00005000
    193c:	00000000 	.word	0x00000000
    1940:	00a80000 	.word	0x00a80000
    1944:	00aa0000 	.word	0x00aa0000
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1948:	00010000 	.word	0x00010000
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    194c:	00000050 	.word	0x00000050
    1950:	00000000 	.word	0x00000000
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
    1954:	0000bc00 	.word	0x0000bc00
					&& abs(g_InControlState.TravelLength.x) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.z) < cTravelDeadZone
					&& abs(g_InControlState.TravelLength.y * 2)
							< cTravelDeadZone) {

				g_InControlState.GaitType = g_InControlState.GaitType + 1; // Go to the next gait...
    1958:	0000c600 	.word	0x0000c600
				if (g_InControlState.GaitType < NUM_GAITS) { // Make sure we did not exceed number of gaits...
					Buzzed(50, 2000);
    195c:	53000100 	.word	0x53000100
    1960:	000000c8 	.word	0x000000c8
    1964:	000000ce 	.word	0x000000ce
				} else {
					Buzzed(50, 2000);
    1968:	dc530001 	.word	0xdc530001
    196c:	e4000000 	.word	0xe4000000
    1970:	01000000 	.word	0x01000000
					Buzzed(50, 2250);
    1974:	00005300 	.word	0x00005300
    1978:	00000000 	.word	0x00000000
					g_InControlState.GaitType = 0;
    197c:	00b00000 	.word	0x00b00000
    1980:	00be0000 	.word	0x00be0000
}

void GaitSelect(void) {
	//Gait selector
	// First pass simply use defined table, next up will allow robots to add or relace set...
	if (g_InControlState.GaitType < NUM_GAITS) {
    1984:	00010000 	.word	0x00010000
    1988:	0000ce51 	.word	0x0000ce51
    198c:	0000e400 	.word	0x0000e400

		g_InControlState.gaitCur = APG[g_InControlState.GaitType];
    1990:	51000100 	.word	0x51000100
	...
    199c:	000000e4 	.word	0x000000e4
    19a0:	000000e6 	.word	0x000000e6
				}
				GaitSelect();
			}

			//Double leg lift height
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    19a4:	e65d0001 	.word	0xe65d0001
    19a8:	ea000000 	.word	0xea000000
    19ac:	02000000 	.word	0x02000000
    19b0:	ea0c7d00 	.word	0xea0c7d00
    19b4:	68000000 	.word	0x68000000
				Buzzed(50, 2000);
    19b8:	02000002 	.word	0x02000002
    19bc:	00107d00 	.word	0x00107d00
				HeightSpeedMode = (HeightSpeedMode + 1) & 0x3; // wrap around mode
    19c0:	00000000 	.word	0x00000000
    19c4:	44000000 	.word	0x44000000
    19c8:	52000001 	.word	0x52000001
    19cc:	01000001 	.word	0x01000001
				DoubleTravelOn = HeightSpeedMode & 0x1;
    19d0:	01665000 	.word	0x01665000
    19d4:	01c20000 	.word	0x01c20000
				if (HeightSpeedMode & 0x2)
    19d8:	00010000 	.word	0x00010000
    19dc:	00020450 	.word	0x00020450
					g_InControlState.LegLiftHeight = 80;
    19e0:	00020c00 	.word	0x00020c00
    19e4:	51000100 	.word	0x51000100
				else
					g_InControlState.LegLiftHeight = 50;
			}

			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {
    19e8:	0000020c 	.word	0x0000020c
    19ec:	00000216 	.word	0x00000216
    19f0:	16500001 	.word	0x16500001
    19f4:	38000002 	.word	0x38000002
    19f8:	01000002 	.word	0x01000002

				if ((++bJoystickWalkMode) > 1)
    19fc:	024c5100 	.word	0x024c5100
    1a00:	02680000 	.word	0x02680000
    1a04:	00010000 	.word	0x00010000

					bJoystickWalkMode = 0;
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a08:	00000050 	.word	0x00000050
			// Switch between Walk method 1 && Walk method 2
			if ((buttons & BUT_R2) && !(buttonsPrev & BUT_R2)) {

				if ((++bJoystickWalkMode) > 1)

					bJoystickWalkMode = 0;
    1a0c:	00000000 	.word	0x00000000
				Buzzed(50, 2000 + bJoystickWalkMode * 250);
    1a10:	00018e00 	.word	0x00018e00
    1a14:	0001e000 	.word	0x0001e000
    1a18:	51000100 	.word	0x51000100
    1a1c:	0000020c 	.word	0x0000020c
			}

			//Walking
			switch (bJoystickWalkMode) {
    1a20:	00000216 	.word	0x00000216
    1a24:	4c510001 	.word	0x4c510001
    1a28:	68000002 	.word	0x68000002
			case 0:
				g_InControlState.TravelLength.x = -lx;
    1a2c:	01000002 	.word	0x01000002
    1a30:	00005100 	.word	0x00005100
    1a34:	00000000 	.word	0x00000000
				g_InControlState.TravelLength.z = -ly;
    1a38:	02080000 	.word	0x02080000
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
				break;
			case 1:
				g_InControlState.TravelLength.z = (rightV); //Right Stick Up/Down
    1a3c:	020c0000 	.word	0x020c0000
    1a40:	00010000 	.word	0x00010000
    1a44:	00021652 	.word	0x00021652
				g_InControlState.TravelLength.y = -(rightH) / 4; //Right Stick Left/Right
    1a48:	00022e00 	.word	0x00022e00
    1a4c:	52000100 	.word	0x52000100
	...
    1a58:	00000268 	.word	0x00000268
    1a5c:	0000026a 	.word	0x0000026a
				break;

			}

			if (!DoubleTravelOn) {  //(Double travel length)
    1a60:	6a5d0001 	.word	0x6a5d0001
				g_InControlState.TravelLength.x =
    1a64:	70000002 	.word	0x70000002
    1a68:	02000002 	.word	0x02000002
    1a6c:	700c7d00 	.word	0x700c7d00
						g_InControlState.TravelLength.x / 2;
				g_InControlState.TravelLength.z =
    1a70:	64000002 	.word	0x64000002
    1a74:	02000003 	.word	0x02000003
    1a78:	00107d00 	.word	0x00107d00
			}

		}

		//[Translate functions]
		g_BodyYShift = 0;
    1a7c:	00000000 	.word	0x00000000
    1a80:	d8000000 	.word	0xd8000000
		if (ControlMode == TRANSLATEMODE) {
    1a84:	0e000002 	.word	0x0e000002
    1a88:	01000003 	.word	0x01000003

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
    1a8c:	030e5100 	.word	0x030e5100
    1a90:	031a0000 	.word	0x031a0000
    1a94:	00010000 	.word	0x00010000
    1a98:	00000051 	.word	0x00000051
    1a9c:	00000000 	.word	0x00000000
    1aa0:	0002da00 	.word	0x0002da00
    1aa4:	00030e00 	.word	0x00030e00
    1aa8:	50000100 	.word	0x50000100
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1aac:	0000030e 	.word	0x0000030e
    1ab0:	00000314 	.word	0x00000314
    1ab4:	00500001 	.word	0x00500001
    1ab8:	00000000 	.word	0x00000000
    1abc:	64000000 	.word	0x64000000
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac0:	66000003 	.word	0x66000003
		//[Translate functions]
		g_BodyYShift = 0;
		if (ControlMode == TRANSLATEMODE) {

		      g_InControlState.BodyPos.x =  SmoothControl(((lx)*2/3), g_InControlState.BodyPos.x, SmDiv);
		      g_InControlState.BodyPos.z =  SmoothControl(((ly)*2/3), g_InControlState.BodyPos.z, SmDiv);
    1ac4:	01000003 	.word	0x01000003
		      g_InControlState.BodyRot1.y = SmoothControl(((rightH)*2), g_InControlState.BodyRot1.y, SmDiv);
    1ac8:	03665d00 	.word	0x03665d00
    1acc:	03c40000 	.word	0x03c40000
    1ad0:	00020000 	.word	0x00020000
    1ad4:	0000087d 	.word	0x0000087d


			//      g_InControlState.BodyPos.x = (lx)/2;
			//      g_InControlState.BodyPos.z = -(ly)/3;
			//      g_InControlState.BodyRot1.y = (rightH)*2;
			g_BodyYShift = (-(rightV) / 2);
    1ad8:	00000000 	.word	0x00000000
    1adc:	03840000 	.word	0x03840000
    1ae0:	038e0000 	.word	0x038e0000
    1ae4:	00010000 	.word	0x00010000
    1ae8:	00039053 	.word	0x00039053
    1aec:	00039600 	.word	0x00039600
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
    1af0:	53000100 	.word	0x53000100
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1af4:	000003a4 	.word	0x000003a4
    1af8:	000003aa 	.word	0x000003aa
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1afc:	00530001 	.word	0x00530001
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
			g_InControlState.BodyRot1.y = (rightH) * 2;
    1b00:	00000000 	.word	0x00000000
			g_BodyYShift = (-(rightV) / 2);
		}

		//[Rotate functions]
		if (ControlMode == ROTATEMODE) {
			g_InControlState.BodyRot1.x = (ly);
    1b04:	78000000 	.word	0x78000000
			g_InControlState.BodyRot1.y = (rightH) * 2;
			g_InControlState.BodyRot1.z = (lx);
			g_BodyYShift = (-(rightV) / 2);
    1b08:	86000003 	.word	0x86000003
    1b0c:	01000003 	.word	0x01000003
    1b10:	03965100 	.word	0x03965100
    1b14:	03aa0000 	.word	0x03aa0000
    1b18:	00010000 	.word	0x00010000
		}

		//[Single leg functions]
#ifdef OPT_SINGLELEG
		if (ControlMode == SINGLELEGMODE) {
    1b1c:	00000051 	.word	0x00000051

			//Switch leg for single leg control
			if ((buttons & BUT_R1) && !(buttonsPrev & BUT_R1)) {
    1b20:	00000000 	.word	0x00000000
    1b24:	0003c400 	.word	0x0003c400
    1b28:	0003c600 	.word	0x0003c600
    1b2c:	5d000100 	.word	0x5d000100
    1b30:	000003c6 	.word	0x000003c6
				Buzzed(50,2000);
    1b34:	000003cc 	.word	0x000003cc
    1b38:	147d0002 	.word	0x147d0002
    1b3c:	000003cc 	.word	0x000003cc
				if (g_InControlState.SelectedLeg < (CNT_LEGS-1)) {
    1b40:	0000046c 	.word	0x0000046c
    1b44:	187d0002 	.word	0x187d0002
	...
					g_InControlState.SelectedLeg = g_InControlState.SelectedLeg + 1;
    1b50:	000003c4 	.word	0x000003c4
			   g_InControlState.SLLeg.x= (signed char)((int)((int)lx+128)/2); //Left Stick Right/Left
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
    1b54:	0000045e 	.word	0x0000045e
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b58:	5e500001 	.word	0x5e500001
    1b5c:	6c000004 	.word	0x6c000004
    1b60:	01000004 	.word	0x01000004
    1b64:	00005000 	.word	0x00005000
    1b68:	00000000 	.word	0x00000000
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b6c:	03c40000 	.word	0x03c40000
    1b70:	03d00000 	.word	0x03d00000
    1b74:	00010000 	.word	0x00010000
      		   g_InControlState.SLLeg.y= (signed char)((int)((int)rightV+128)/10); //Right Stick Up/Down
		       g_InControlState.SLLeg.z = (signed char)((int)((int)ly+128)/2); //Left Stick Up/Down

#else
			g_InControlState.SLLeg.x = lx; //Left Stick Right/Left
			g_InControlState.SLLeg.y = rightV / 3 - 20;//Right Stick Up/Down
    1b78:	0003d051 	.word	0x0003d051
			g_InControlState.SLLeg.z = ly;//Left Stick Up/Down

#endif
			// Hold single leg in place
			if ((buttons & BUT_RT) && !(buttonsPrev & BUT_RT)) {
    1b7c:	00046c00 	.word	0x00046c00
    1b80:	57000100 	.word	0x57000100
	...
				Buzzed(50,2000);
    1b8c:	000003c4 	.word	0x000003c4
				g_InControlState.fSLHold = !g_InControlState.fSLHold;
    1b90:	000003ca 	.word	0x000003ca
    1b94:	ca520001 	.word	0xca520001
    1b98:	6c000003 	.word	0x6c000003
    1b9c:	01000004 	.word	0x01000004
			}
		}
#endif

		//Calculate walking time delay
		g_InControlState.InputTimeDelay = 128- max(max(abs(lx), abs(ly)), abs(rightH));
    1ba0:	00005600 	.word	0x00005600
    1ba4:	00000000 	.word	0x00000000
    1ba8:	03c40000 	.word	0x03c40000
    1bac:	03d00000 	.word	0x03d00000
    1bb0:	00010000 	.word	0x00010000
    1bb4:	0003d053 	.word	0x0003d053
    1bb8:	00046c00 	.word	0x00046c00
    1bbc:	55000100 	.word	0x55000100
	...
    1bc8:	000003ee 	.word	0x000003ee
    1bcc:	0000045e 	.word	0x0000045e
    1bd0:	00510001 	.word	0x00510001

		//Calculate g_InControlState.BodyPos.y
		g_InControlState.BodyPos.y = max(g_BodyYOffset + g_BodyYShift, 0);
    1bd4:	00000000 	.word	0x00000000
    1bd8:	6c000000 	.word	0x6c000000
    1bdc:	6e000004 	.word	0x6e000004
    1be0:	01000004 	.word	0x01000004
    1be4:	046e5d00 	.word	0x046e5d00
    1be8:	04740000 	.word	0x04740000

		if (sLegInitXZAdjust || sLegInitAngleAdjust) {
    1bec:	00020000 	.word	0x00020000
    1bf0:	0474047d 	.word	0x0474047d
			// User asked for manual leg adjustment - only do when we have finished any previous adjustment

			if (!g_InControlState.ForceGaitStepCnt) {
    1bf4:	04ac0000 	.word	0x04ac0000
				if (sLegInitXZAdjust)
    1bf8:	00020000 	.word	0x00020000
					g_fDynamicLegXZLength = true;
    1bfc:	0000087d 	.word	0x0000087d
    1c00:	00000000 	.word	0x00000000

				sLegInitXZAdjust += GetLegsXZLength(); // Add on current length to our adjustment...
    1c04:	046c0000 	.word	0x046c0000
    1c08:	04960000 	.word	0x04960000
				// Handle maybe change angles...
				if (sLegInitAngleAdjust)
					RotateLegInitAngles(sLegInitAngleAdjust);

				// Give system time to process previous calls
				AdjustLegPositions(sLegInitXZAdjust);
    1c0c:	00010000 	.word	0x00010000
			}
		}

		if (fAdjustLegPositions && !g_fDynamicLegXZLength)
    1c10:	00000050 	.word	0x00000050
    1c14:	00000000 	.word	0x00000000
    1c18:	00046c00 	.word	0x00046c00
			AdjustLegPositionsToBodyHeight(); // Put main workings into main program file
    1c1c:	00049600 	.word	0x00049600
		// Save away the buttons state as to not process the same press twice.
		buttonsPrev = buttons;
    1c20:	51000100 	.word	0x51000100
	...
		extPrev = ext;
    1c2c:	0000046c 	.word	0x0000046c
		g_ulLastMsgTime = getMillis();
    1c30:	00000472 	.word	0x00000472
    1c34:	72520001 	.word	0x72520001
	} else {
		// We did not receive a valid packet.  check for a timeout to see if we should turn robot off...
		if (g_InControlState.fRobotOn) {
    1c38:	96000004 	.word	0x96000004
			if ((getMillis() - g_ulLastMsgTime) > ARBOTIX_TO)
    1c3c:	01000004 	.word	0x01000004
    1c40:	00005c00 	.word	0x00005c00
    1c44:	00000000 	.word	0x00000000
    1c48:	04ac0000 	.word	0x04ac0000
    1c4c:	04ae0000 	.word	0x04ae0000
				CommanderTurnRobotOff();
    1c50:	00010000 	.word	0x00010000
		}
	}

}
    1c54:	0004ae5d 	.word	0x0004ae5d
    1c58:	0004b200 	.word	0x0004b200
    1c5c:	7d000200 	.word	0x7d000200
    1c60:	0004b204 	.word	0x0004b204
    1c64:	0004fc00 	.word	0x0004fc00
    1c68:	7d000200 	.word	0x7d000200
    1c6c:	00000008 	.word	0x00000008
    1c70:	00000000 	.word	0x00000000
    1c74:	0004ac00 	.word	0x0004ac00
    1c78:	0004cc00 	.word	0x0004cc00
    1c7c:	50000100 	.word	0x50000100
	...
    1c88:	000004ac 	.word	0x000004ac
    1c8c:	000004cc 	.word	0x000004cc
    1c90:	00510001 	.word	0x00510001
    1c94:	00000000 	.word	0x00000000
    1c98:	d8000000 	.word	0xd8000000
    1c9c:	da000004 	.word	0xda000004
    1ca0:	01000004 	.word	0x01000004
    1ca4:	04de5000 	.word	0x04de5000
    1ca8:	04e60000 	.word	0x04e60000
    1cac:	00010000 	.word	0x00010000

extern void setupPhoenix(void);
extern void readSensors(void);


int Big_main(void) {
    1cb0:	0004e652 	.word	0x0004e652

	// Must include this line in all programs using "cm530.h/.c"
	SysInit();
    1cb4:	0004e600 	.word	0x0004e600
	setupPhoenix();
    1cb8:	50000100 	.word	0x50000100
	...

	while (1){
		while (1) {
			//Start time
			unsigned long lTimeWaitEnd;
			lTimerStart = getMillis();
    1cc4:	000004fc 	.word	0x000004fc
    1cc8:	000004fe 	.word	0x000004fe
#ifdef MILLIS
			PrintString("Barebones lTimerStart ");
			Printu32d(lTimerStart);
			PrintString("\n");
#endif
			DoBackgroundProcess();
    1ccc:	fe5d0001 	.word	0xfe5d0001
			//Read input
			CheckVoltage();        // check our voltages...
    1cd0:	04000004 	.word	0x04000004
			if (!g_fLowVoltageShutdown) {
    1cd4:	02000005 	.word	0x02000005
    1cd8:	04047d00 	.word	0x04047d00
				CommanderInputController_ControlInput();
    1cdc:	38000005 	.word	0x38000005
			}
			WriteOutputs();        // Write Outputs
			//Single leg control
			SingleLegControl();
    1ce0:	02000005 	.word	0x02000005
			DoBackgroundProcess();
    1ce4:	00087d00 	.word	0x00087d00

			//Gait
			GaitSeq();
    1ce8:	00000000 	.word	0x00000000

			DoBackgroundProcess();
    1cec:	fc000000 	.word	0xfc000000

			//Balance calculations
			TotalTransX = 0;     //reset values used for calculation of balance
    1cf0:	20000004 	.word	0x20000004
    1cf4:	01000005 	.word	0x01000005
			TotalTransZ = 0;
    1cf8:	00005000 	.word	0x00005000
			TotalTransY = 0;
    1cfc:	00000000 	.word	0x00000000
    1d00:	04fc0000 	.word	0x04fc0000
			TotalXBal1 = 0;
    1d04:	05200000 	.word	0x05200000
			TotalYBal1 = 0;
    1d08:	00010000 	.word	0x00010000
    1d0c:	00000051 	.word	0x00000051
			TotalZBal1 = 0;
    1d10:	00000000 	.word	0x00000000

			if (g_InControlState.BalanceMode) {
    1d14:	0004fc00 	.word	0x0004fc00
    1d18:	00050200 	.word	0x00050200
    1d1c:	52000100 	.word	0x52000100

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d20:	00000502 	.word	0x00000502

					DoBackgroundProcess();
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d24:	00000520 	.word	0x00000520
    1d28:	005c0001 	.word	0x005c0001
    1d2c:	00000000 	.word	0x00000000

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs

					DoBackgroundProcess();
    1d30:	38000000 	.word	0x38000000
					BalCalcOneLeg(-LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d34:	3a000005 	.word	0x3a000005
    1d38:	01000005 	.word	0x01000005
    1d3c:	053a5d00 	.word	0x053a5d00
    1d40:	053e0000 	.word	0x053e0000
    1d44:	00020000 	.word	0x00020000
    1d48:	053e047d 	.word	0x053e047d
    1d4c:	05480000 	.word	0x05480000
    1d50:	00020000 	.word	0x00020000
    1d54:	0000087d 	.word	0x0000087d
    1d58:	00000000 	.word	0x00000000
    1d5c:	05380000 	.word	0x05380000
    1d60:	05440000 	.word	0x05440000
    1d64:	00010000 	.word	0x00010000
    1d68:	00000050 	.word	0x00000050
    1d6c:	00000000 	.word	0x00000000
			TotalYBal1 = 0;
			TotalZBal1 = 0;

			if (g_InControlState.BalanceMode) {

				for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) { // balance calculations for all Right legs
    1d70:	00054800 	.word	0x00054800
    1d74:	00054a00 	.word	0x00054a00
    1d78:	5d000100 	.word	0x5d000100
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1d7c:	0000054a 	.word	0x0000054a
    1d80:	0000054e 	.word	0x0000054e
					DoBackgroundProcess();
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d84:	047d0002 	.word	0x047d0002
    1d88:	0000054e 	.word	0x0000054e
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
					DoBackgroundProcess();
    1d8c:	00000590 	.word	0x00000590
					BalCalcOneLeg(LegPosX[LegIndex] + GaitPosX[LegIndex],
    1d90:	087d0002 	.word	0x087d0002
	...
    1d9c:	00000548 	.word	0x00000548
    1da0:	0000056a 	.word	0x0000056a
    1da4:	00500001 	.word	0x00500001
    1da8:	00000000 	.word	0x00000000
    1dac:	48000000 	.word	0x48000000
    1db0:	6a000005 	.word	0x6a000005
    1db4:	01000005 	.word	0x01000005
    1db8:	00005100 	.word	0x00005100
    1dbc:	00000000 	.word	0x00000000
    1dc0:	05900000 	.word	0x05900000
    1dc4:	05920000 	.word	0x05920000
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}

				for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) { // balance calculations for all Right legs
    1dc8:	00010000 	.word	0x00010000
    1dcc:	0005925d 	.word	0x0005925d
    1dd0:	00059600 	.word	0x00059600
							LegPosZ[LegIndex] + GaitPosZ[LegIndex],
							(LegPosY[LegIndex]
									 - (short) pgm_read_word(&cInitPosY[LegIndex]))
									 + GaitPosY[LegIndex], LegIndex);
				}
				BalanceBody();
    1dd4:	7d000200 	.word	0x7d000200
			}

			//Reset IKsolution indicators
			IKSolution = 0;
    1dd8:	00059604 	.word	0x00059604
    1ddc:	0005dc00 	.word	0x0005dc00
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1de0:	7d000200 	.word	0x7d000200
			}

			//Reset IKsolution indicators
			IKSolution = 0;
			IKSolutionWarning = 0;
			IKSolutionError = 0;
    1de4:	00000008 	.word	0x00000008
    1de8:	00000000 	.word	0x00000000

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
				DoBackgroundProcess();
    1dec:	00059000 	.word	0x00059000
				BodyFK(
    1df0:	0005ac00 	.word	0x0005ac00
    1df4:	50000100 	.word	0x50000100
	...
    1e00:	000005dc 	.word	0x000005dc
    1e04:	000005de 	.word	0x000005de
    1e08:	de5d0001 	.word	0xde5d0001
    1e0c:	e0000005 	.word	0xe0000005
    1e10:	02000005 	.word	0x02000005
    1e14:	e0047d00 	.word	0xe0047d00
    1e18:	e8000005 	.word	0xe8000005
    1e1c:	02000005 	.word	0x02000005
    1e20:	00087d00 	.word	0x00087d00
    1e24:	00000000 	.word	0x00000000
    1e28:	e8000000 	.word	0xe8000000
    1e2c:	ea000005 	.word	0xea000005
    1e30:	01000005 	.word	0x01000005
    1e34:	05ea5d00 	.word	0x05ea5d00
    1e38:	05ec0000 	.word	0x05ec0000
    1e3c:	00020000 	.word	0x00020000
    1e40:	05ec047d 	.word	0x05ec047d
    1e44:	06100000 	.word	0x06100000
    1e48:	00020000 	.word	0x00020000
    1e4c:	0000087d 	.word	0x0000087d
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);

				LegIK(
    1e50:	00000000 	.word	0x00000000
    1e54:	05e80000 	.word	0x05e80000
    1e58:	05f00000 	.word	0x05f00000
    1e5c:	00010000 	.word	0x00010000
    1e60:	00000050 	.word	0x00000050
    1e64:	00000000 	.word	0x00000000
    1e68:	0000a800 	.word	0x0000a800
    1e6c:	0000aa00 	.word	0x0000aa00
    1e70:	5d000100 	.word	0x5d000100
    1e74:	000000aa 	.word	0x000000aa
    1e78:	000001c8 	.word	0x000001c8
    1e7c:	107d0002 	.word	0x107d0002
	...
    1e88:	000000e8 	.word	0x000000e8
    1e8c:	0000016a 	.word	0x0000016a
    1e90:	92500001 	.word	0x92500001
    1e94:	a2000001 	.word	0xa2000001
    1e98:	01000001 	.word	0x01000001
    1e9c:	00005000 	.word	0x00005000
    1ea0:	00000000 	.word	0x00000000
    1ea4:	011c0000 	.word	0x011c0000
    1ea8:	01780000 	.word	0x01780000
    1eac:	00010000 	.word	0x00010000
    1eb0:	00019251 	.word	0x00019251
    1eb4:	0001c800 	.word	0x0001c800
    1eb8:	51000100 	.word	0x51000100
	...
			IKSolutionWarning = 0;
			IKSolutionError = 0;

			//Do IK for all Right legs

			for (LegIndex = 0; LegIndex < (CNT_LEGS / 2); LegIndex++) {
    1ec4:	000001c8 	.word	0x000001c8
    1ec8:	000001ca 	.word	0x000001ca
    1ecc:	ca5d0001 	.word	0xca5d0001
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1ed0:	ce000001 	.word	0xce000001
    1ed4:	02000001 	.word	0x02000001
				DoBackgroundProcess();
    1ed8:	ce0c7d00 	.word	0xce0c7d00
				BodyFK(
    1edc:	c0000001 	.word	0xc0000001
    1ee0:	02000002 	.word	0x02000002
    1ee4:	00107d00 	.word	0x00107d00
    1ee8:	00000000 	.word	0x00000000
    1eec:	0a000000 	.word	0x0a000000
    1ef0:	74000002 	.word	0x74000002
    1ef4:	01000002 	.word	0x01000002
    1ef8:	029a5000 	.word	0x029a5000
    1efc:	02aa0000 	.word	0x02aa0000
    1f00:	00010000 	.word	0x00010000
    1f04:	00000050 	.word	0x00000050
    1f08:	00000000 	.word	0x00000000
    1f0c:	00023e00 	.word	0x00023e00
    1f10:	00028200 	.word	0x00028200
    1f14:	51000100 	.word	0x51000100
    1f18:	0000029a 	.word	0x0000029a
    1f1c:	000002c0 	.word	0x000002c0
    1f20:	00510001 	.word	0x00510001
    1f24:	00000000 	.word	0x00000000
    1f28:	c0000000 	.word	0xc0000000
    1f2c:	c2000002 	.word	0xc2000002
    1f30:	01000002 	.word	0x01000002
    1f34:	02c25d00 	.word	0x02c25d00
    1f38:	02c60000 	.word	0x02c60000
    1f3c:	00020000 	.word	0x00020000
    1f40:	02c6047d 	.word	0x02c6047d
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z
						+ GaitPosZ[LegIndex] - TotalTransZ,
						LegPosY[LegIndex] + g_InControlState.BodyPos.y
						+ GaitPosY[LegIndex] - TotalTransY,
						GaitRotY[LegIndex], LegIndex);
				LegIK(
    1f44:	03040000 	.word	0x03040000
    1f48:	00020000 	.word	0x00020000
    1f4c:	0000107d 	.word	0x0000107d
    1f50:	00000000 	.word	0x00000000
    1f54:	02c00000 	.word	0x02c00000
    1f58:	02c80000 	.word	0x02c80000
    1f5c:	00010000 	.word	0x00010000
    1f60:	00000050 	.word	0x00000050
    1f64:	00000000 	.word	0x00000000
    1f68:	0002c400 	.word	0x0002c400
    1f6c:	0002e200 	.word	0x0002e200
    1f70:	52000100 	.word	0x52000100
	...
    1f7c:	000002c8 	.word	0x000002c8
    1f80:	000002d4 	.word	0x000002d4
    1f84:	00500001 	.word	0x00500001
    1f88:	00000000 	.word	0x00000000
    1f8c:	04000000 	.word	0x04000000
    1f90:	06000003 	.word	0x06000003
    1f94:	01000003 	.word	0x01000003
    1f98:	03065d00 	.word	0x03065d00
    1f9c:	03080000 	.word	0x03080000
    1fa0:	00020000 	.word	0x00020000
    1fa4:	0308047d 	.word	0x0308047d
    1fa8:	03100000 	.word	0x03100000
    1fac:	00020000 	.word	0x00020000
    1fb0:	0000087d 	.word	0x0000087d
    1fb4:	00000000 	.word	0x00000000
    1fb8:	03100000 	.word	0x03100000
    1fbc:	03120000 	.word	0x03120000
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Do IK for all Left legs
			for (LegIndex = (CNT_LEGS / 2); LegIndex < CNT_LEGS; LegIndex++) {
    1fc0:	00010000 	.word	0x00010000
    1fc4:	0003125d 	.word	0x0003125d
    1fc8:	00031400 	.word	0x00031400
						LegPosZ[LegIndex] + g_InControlState.BodyPos.z - BodyFKPosZ
						+ GaitPosZ[LegIndex] - TotalTransZ, LegIndex);
			}

			//Check mechanical limits
			CheckAngles();
    1fcc:	7d000200 	.word	0x7d000200

			//Drive Servos
			if (g_InControlState.fRobotOn) {
    1fd0:	00031404 	.word	0x00031404
    1fd4:	00034000 	.word	0x00034000
    1fd8:	7d000200 	.word	0x7d000200
				if (g_InControlState.fRobotOn && !g_InControlState.fPrev_RobotOn) {
					// MSound(3, 60, 2000, 80, 2250, 100, 2500);
					Buzzed(30, 2000);
    1fdc:	00000008 	.word	0x00000008
    1fe0:	00000000 	.word	0x00000000
    1fe4:	00031000 	.word	0x00031000
					Buzzed(80, 2250);
    1fe8:	00031800 	.word	0x00031800
    1fec:	50000100 	.word	0x50000100
	...
					Buzzed(100, 2500);
    1ff8:	00000014 	.word	0x00000014

				}

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
    1ffc:	0000001e 	.word	0x0000001e
    2000:	00500001 	.word	0x00500001
    2004:	00000000 	.word	0x00000000
    2008:	40000000 	.word	0x40000000
    200c:	42000000 	.word	0x42000000
    2010:	01000000 	.word	0x01000000
    2014:	00425d00 	.word	0x00425d00
    2018:	00460000 	.word	0x00460000
    201c:	00020000 	.word	0x00020000
    2020:	0046147d 	.word	0x0046147d
    2024:	00f40000 	.word	0x00f40000
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2028:	00020000 	.word	0x00020000
    202c:	0000287d 	.word	0x0000287d
    2030:	00000000 	.word	0x00000000
    2034:	00600000 	.word	0x00600000
    2038:	00ba0000 	.word	0x00ba0000
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
    203c:	00010000 	.word	0x00010000

				//Calculate Servo Move time
				if ((abs(g_InControlState.TravelLength.x) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.z) > cTravelDeadZone)
						|| (abs(g_InControlState.TravelLength.y*2) > cTravelDeadZone)) {
					ServoMoveTime = g_InControlState.gaitCur.NomGaitSpeed
    2040:	00000055 	.word	0x00000055
							+ (g_InControlState.InputTimeDelay * 2)
							+ g_InControlState.SpeedControl;

					//Add aditional delay when Balance mode is on
					if (g_InControlState.BalanceMode)
						ServoMoveTime = ServoMoveTime + BALANCE_DELAY;
    2044:	00000000 	.word	0x00000000
    2048:	00006a00 	.word	0x00006a00
				} else
					//Movement speed excl. Walking
					ServoMoveTime = 200 + g_InControlState.SpeedControl;
    204c:	0000bc00 	.word	0x0000bc00
    2050:	54000100 	.word	0x54000100
	...

				// note we broke up the servo driver into start/commit that way we can output all of the servo information
				// before we wait and only have the termination information to output after the wait.  That way we hopefully
				// be more accurate with our timings...
				DoBackgroundProcess();
				StartUpdateServos();
    205c:	000000f4 	.word	0x000000f4

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    2060:	000000f6 	.word	0x000000f6
					if ((GaitPosX[LegIndex] > cGPlimit)
    2064:	f65d0001 	.word	0xf65d0001
    2068:	f8000000 	.word	0xf8000000
    206c:	02000000 	.word	0x02000000
    2070:	f8047d00 	.word	0xf8047d00
    2074:	28000000 	.word	0x28000000
    2078:	02000001 	.word	0x02000001
    207c:	00087d00 	.word	0x00087d00
    2080:	00000000 	.word	0x00000000
    2084:	28000000 	.word	0x28000000
    2088:	2c000001 	.word	0x2c000001
    208c:	01000001 	.word	0x01000001
    2090:	012c5d00 	.word	0x012c5d00
    2094:	01640000 	.word	0x01640000
    2098:	00020000 	.word	0x00020000
    209c:	0000107d 	.word	0x0000107d
							|| (GaitPosZ[LegIndex] > cGPlimit)
							|| (GaitPosZ[LegIndex] < -cGPlimit)
							|| (GaitRotY[LegIndex] > cGPlimit)
							|| (GaitRotY[LegIndex] < -cGPlimit)) {

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
    20a0:	00000000 	.word	0x00000000
    20a4:	01280000 	.word	0x01280000
    20a8:	01300000 	.word	0x01300000

				// See if we need to sync our processor with the servo driver while walking to ensure the prev is completed
				//before sending the next one

				// Finding any incident of GaitPos/Rot <>0:
				for (LegIndex = 0; LegIndex < CNT_LEGS; LegIndex++) {
    20ac:	00010000 	.word	0x00010000
    20b0:	00013050 	.word	0x00013050

						bExtraCycle = g_InControlState.gaitCur.NrLiftedPos + 1;	//For making sure that we are using timed move until all legs are down
						break;
					}
				}
				if (bExtraCycle > 0) {
    20b4:	00013800 	.word	0x00013800
					bExtraCycle--;
    20b8:	54000100 	.word	0x54000100
    20bc:	00000138 	.word	0x00000138
					fWalking = !(bExtraCycle == 0);
    20c0:	0000013c 	.word	0x0000013c
    20c4:	3c500001 	.word	0x3c500001

					//Get endtime and calculate wait time
					lTimeWaitEnd = lTimerStart + PrevServoMoveTime;
    20c8:	64000001 	.word	0x64000001
    20cc:	01000001 	.word	0x01000001
    20d0:	00005400 	.word	0x00005400
					PrintString("\n");
#endif
					//DebugWrite(A1, HIGH);
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    20d4:	00000000 	.word	0x00000000
					} while (getMillis() < lTimeWaitEnd);
    20d8:	014a0000 	.word	0x014a0000
    20dc:	01580000 	.word	0x01580000
					PrintString("\n");
#endif

				}
				// Only do commit if we are actually doing something...
				CommitServoDriver(ServoMoveTime);
    20e0:	00010000 	.word	0x00010000
    20e4:	00015a56 	.word	0x00015a56
    20e8:	00016400 	.word	0x00016400
			} else {
				//Turn the bot off - May need to add ajust here...
				if (g_InControlState.fPrev_RobotOn || (AllDown = 0)) {
    20ec:	56000100 	.word	0x56000100
	...
					ServoMoveTime = 600;
    20f8:	00000164 	.word	0x00000164
    20fc:	00000166 	.word	0x00000166
					StartUpdateServos();
    2100:	665d0001 	.word	0x665d0001
					CommitServoDriver(ServoMoveTime);
    2104:	6a000001 	.word	0x6a000001
					//MSound(3, 100, 2500, 80, 2250, 60, 2000);
					Buzzed(100, 2500);
    2108:	02000001 	.word	0x02000001
    210c:	6a147d00 	.word	0x6a147d00
    2110:	cc000001 	.word	0xcc000001
					Buzzed(80, 2250);
    2114:	02000001 	.word	0x02000001
    2118:	00187d00 	.word	0x00187d00
					Buzzed(60, 2000);
    211c:	00000000 	.word	0x00000000
    2120:	8e000000 	.word	0x8e000000
    2124:	92000001 	.word	0x92000001

					//lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
					lTimeWaitEnd = getMillis() + 600; // setup to process background stuff while we wait...
    2128:	01000001 	.word	0x01000001
    212c:	019e5000 	.word	0x019e5000
					Printu32d(lTimeWaitEnd);
					PrintString("\n");
#endif
					do {
						// Wait the appropriate time, call any background process while waiting...
						DoBackgroundProcess();
    2130:	01a00000 	.word	0x01a00000
					} while (getMillis() < lTimeWaitEnd);
    2134:	00010000 	.word	0x00010000
    2138:	00000050 	.word	0x00000050
				} else {
					FreeServos();
				}

				// Allow the Servo driver to do stuff durint our idle time
				IdleTime();
    213c:	00000000 	.word	0x00000000
				mDelay(20); // give a pause between times we call if nothing is happening
    2140:	0001cc00 	.word	0x0001cc00
			}
			PrevServoMoveTime = ServoMoveTime;
    2144:	0001ce00 	.word	0x0001ce00
    2148:	5d000100 	.word	0x5d000100

			//Store previous g_InControlState.fRobotOn State
			if (g_InControlState.fRobotOn)
    214c:	000001ce 	.word	0x000001ce
    2150:	000001d2 	.word	0x000001d2
				g_InControlState.fPrev_RobotOn = 1;
			else
				g_InControlState.fPrev_RobotOn = 0;
    2154:	147d0002 	.word	0x147d0002
    2158:	000001d2 	.word	0x000001d2
    215c:	000002ec 	.word	0x000002ec
    2160:	387d0002 	.word	0x387d0002
	...
    216c:	000001cc 	.word	0x000001cc
    2170:	0000020e 	.word	0x0000020e
    2174:	0e500001 	.word	0x0e500001
    2178:	ec000002 	.word	0xec000002
    217c:	02000002 	.word	0x02000002
    2180:	00187d00 	.word	0x00187d00
    2184:	00000000 	.word	0x00000000
    2188:	2a000000 	.word	0x2a000000
    218c:	2c000002 	.word	0x2c000002
    2190:	02000002 	.word	0x02000002
    2194:	2c689100 	.word	0x2c689100
    2198:	32000002 	.word	0x32000002
    219c:	01000002 	.word	0x01000002
    21a0:	02325500 	.word	0x02325500
    21a4:	02800000 	.word	0x02800000
    21a8:	00020000 	.word	0x00020000
    21ac:	02800c7d 	.word	0x02800c7d
    21b0:	02ce0000 	.word	0x02ce0000
    21b4:	00020000 	.word	0x00020000
    21b8:	02ce6891 	.word	0x02ce6891
    21bc:	02d00000 	.word	0x02d00000
    21c0:	00010000 	.word	0x00010000
    21c4:	0002d055 	.word	0x0002d055
    21c8:	0002ec00 	.word	0x0002ec00
    21cc:	91000200 	.word	0x91000200
    21d0:	00000068 	.word	0x00000068
    21d4:	00000000 	.word	0x00000000
    21d8:	0001d600 	.word	0x0001d600
    21dc:	00024600 	.word	0x00024600
    21e0:	5c000100 	.word	0x5c000100
    21e4:	00000276 	.word	0x00000276
    21e8:	000002ec 	.word	0x000002ec
    21ec:	005c0001 	.word	0x005c0001
    21f0:	00000000 	.word	0x00000000
    21f4:	ec000000 	.word	0xec000000
    21f8:	ee000002 	.word	0xee000002
    21fc:	01000002 	.word	0x01000002
    2200:	02ee5d00 	.word	0x02ee5d00
    2204:	02f40000 	.word	0x02f40000
    2208:	00020000 	.word	0x00020000
    220c:	02f4147d 	.word	0x02f4147d
    2210:	039c0000 	.word	0x039c0000
    2214:	00030000 	.word	0x00030000
    2218:	0000c07d 	.word	0x0000c07d
    221c:	00000000 	.word	0x00000000
    2220:	ec000000 	.word	0xec000000
    2224:	fa000002 	.word	0xfa000002
    2228:	01000002 	.word	0x01000002
    222c:	00005000 	.word	0x00005000
    2230:	00000000 	.word	0x00000000
    2234:	030c0000 	.word	0x030c0000
    2238:	03300000 	.word	0x03300000
    223c:	00010000 	.word	0x00010000
    2240:	00037654 	.word	0x00037654
    2244:	00037a00 	.word	0x00037a00
    2248:	54000100 	.word	0x54000100
	...
    2254:	00000330 	.word	0x00000330
    2258:	0000037a 	.word	0x0000037a
    225c:	82540001 	.word	0x82540001
    2260:	84000003 	.word	0x84000003
    2264:	01000003 	.word	0x01000003
    2268:	00005400 	.word	0x00005400
    226c:	00000000 	.word	0x00000000
    2270:	039c0000 	.word	0x039c0000
    2274:	039e0000 	.word	0x039e0000
    2278:	00010000 	.word	0x00010000
    227c:	00039e5d 	.word	0x00039e5d
    2280:	0003a200 	.word	0x0003a200
    2284:	7d000200 	.word	0x7d000200
    2288:	0003a204 	.word	0x0003a204
    228c:	0003b400 	.word	0x0003b400
    2290:	7d000200 	.word	0x7d000200
    2294:	00000008 	.word	0x00000008
    2298:	00000000 	.word	0x00000000
    229c:	0003a400 	.word	0x0003a400
    22a0:	0003aa00 	.word	0x0003aa00
    22a4:	50000100 	.word	0x50000100
    22a8:	000003aa 	.word	0x000003aa
    22ac:	000003b4 	.word	0x000003b4
    22b0:	00500001 	.word	0x00500001
    22b4:	00000000 	.word	0x00000000
    22b8:	b4000000 	.word	0xb4000000
    22bc:	b6000003 	.word	0xb6000003
    22c0:	01000003 	.word	0x01000003
    22c4:	03b65d00 	.word	0x03b65d00
    22c8:	03be0000 	.word	0x03be0000
    22cc:	00020000 	.word	0x00020000
    22d0:	03be047d 	.word	0x03be047d
    22d4:	03f00000 	.word	0x03f00000
    22d8:	00020000 	.word	0x00020000
    22dc:	0000087d 	.word	0x0000087d
    22e0:	00000000 	.word	0x00000000
    22e4:	03c00000 	.word	0x03c00000
    22e8:	03d00000 	.word	0x03d00000
    22ec:	00010000 	.word	0x00010000
    22f0:	0003d851 	.word	0x0003d851
    22f4:	0003f000 	.word	0x0003f000
    22f8:	51000100 	.word	0x51000100
	...
    2304:	000003f0 	.word	0x000003f0
    2308:	000003f2 	.word	0x000003f2
    230c:	f25d0001 	.word	0xf25d0001
    2310:	f6000003 	.word	0xf6000003
    2314:	02000003 	.word	0x02000003
    2318:	f6147d00 	.word	0xf6147d00
    231c:	8c000003 	.word	0x8c000003
    2320:	02000007 	.word	0x02000007
    2324:	00207d00 	.word	0x00207d00
    2328:	00000000 	.word	0x00000000
    232c:	58000000 	.word	0x58000000
    2330:	5c000004 	.word	0x5c000004
    2334:	01000004 	.word	0x01000004
    2338:	045c5000 	.word	0x045c5000
    233c:	04640000 	.word	0x04640000
    2340:	00010000 	.word	0x00010000
    2344:	00046455 	.word	0x00046455
    2348:	00046a00 	.word	0x00046a00
    234c:	50000100 	.word	0x50000100
    2350:	0000046a 	.word	0x0000046a
    2354:	00000482 	.word	0x00000482
    2358:	82550001 	.word	0x82550001
    235c:	8c000004 	.word	0x8c000004
    2360:	01000004 	.word	0x01000004
    2364:	048c5000 	.word	0x048c5000
    2368:	05240000 	.word	0x05240000
    236c:	00010000 	.word	0x00010000
    2370:	0005a255 	.word	0x0005a255
    2374:	0005e200 	.word	0x0005e200
    2378:	55000100 	.word	0x55000100
    237c:	00000634 	.word	0x00000634
    2380:	00000638 	.word	0x00000638
    2384:	30550001 	.word	0x30550001
    2388:	8c000007 	.word	0x8c000007
    238c:	01000007 	.word	0x01000007
    2390:	00005500 	.word	0x00005500
    2394:	00000000 	.word	0x00000000
    2398:	06880000 	.word	0x06880000
    239c:	069c0000 	.word	0x069c0000
    23a0:	00010000 	.word	0x00010000
    23a4:	0006a651 	.word	0x0006a651
    23a8:	0006ae00 	.word	0x0006ae00
    23ac:	51000100 	.word	0x51000100
	...
    23bc:	00000002 	.word	0x00000002
    23c0:	00500001 	.word	0x00500001
    23c4:	00000000 	.word	0x00000000
    23c8:	16000000 	.word	0x16000000
    23cc:	28000000 	.word	0x28000000
    23d0:	01000000 	.word	0x01000000
    23d4:	00005000 	.word	0x00005000
    23d8:	00000000 	.word	0x00000000
    23dc:	002c0000 	.word	0x002c0000
    23e0:	002e0000 	.word	0x002e0000
    23e4:	00010000 	.word	0x00010000
    23e8:	00002e5d 	.word	0x00002e5d
    23ec:	00006400 	.word	0x00006400
    23f0:	7d000200 	.word	0x7d000200
    23f4:	0000000c 	.word	0x0000000c
    23f8:	00000000 	.word	0x00000000
    23fc:	00003800 	.word	0x00003800
    2400:	00003a00 	.word	0x00003a00
    2404:	52000100 	.word	0x52000100
    2408:	00000042 	.word	0x00000042
    240c:	00000064 	.word	0x00000064
    2410:	00520001 	.word	0x00520001
    2414:	00000000 	.word	0x00000000
    2418:	7c000000 	.word	0x7c000000
    241c:	80000000 	.word	0x80000000
    2420:	01000000 	.word	0x01000000
    2424:	00005000 	.word	0x00005000
    2428:	00000000 	.word	0x00000000
    242c:	008c0000 	.word	0x008c0000
    2430:	00900000 	.word	0x00900000
    2434:	00010000 	.word	0x00010000
    2438:	00000050 	.word	0x00000050
    243c:	00000000 	.word	0x00000000
    2440:	0000b000 	.word	0x0000b000
    2444:	0000b200 	.word	0x0000b200
    2448:	5d000100 	.word	0x5d000100
    244c:	000000b2 	.word	0x000000b2
    2450:	000000b4 	.word	0x000000b4
    2454:	147d0002 	.word	0x147d0002
    2458:	000000b4 	.word	0x000000b4
    245c:	000001fc 	.word	0x000001fc
    2460:	887d0003 	.word	0x887d0003
    2464:	00000001 	.word	0x00000001
    2468:	00000000 	.word	0x00000000
    246c:	0000c000 	.word	0x0000c000
    2470:	0000e200 	.word	0x0000e200
    2474:	7d000200 	.word	0x7d000200
    2478:	0000e204 	.word	0x0000e204
    247c:	0000fa00 	.word	0x0000fa00
    2480:	91000300 	.word	0x91000300
    2484:	00fa7f90 	.word	0x00fa7f90
    2488:	01ae0000 	.word	0x01ae0000
    248c:	00020000 	.word	0x00020000
    2490:	01ae047d 	.word	0x01ae047d
    2494:	01fc0000 	.word	0x01fc0000
    2498:	00030000 	.word	0x00030000
    249c:	007f9091 	.word	0x007f9091
    24a0:	00000000 	.word	0x00000000
    24a4:	c8000000 	.word	0xc8000000
    24a8:	a8000000 	.word	0xa8000000
    24ac:	02000001 	.word	0x02000001
    24b0:	a8087d00 	.word	0xa8087d00
    24b4:	ae000001 	.word	0xae000001
    24b8:	03000001 	.word	0x03000001
    24bc:	7f949100 	.word	0x7f949100
    24c0:	000001ae 	.word	0x000001ae
    24c4:	000001fc 	.word	0x000001fc
    24c8:	087d0002 	.word	0x087d0002
	...
    24d4:	000000da 	.word	0x000000da
    24d8:	000000dc 	.word	0x000000dc
    24dc:	e8520001 	.word	0xe8520001
    24e0:	06000000 	.word	0x06000000
    24e4:	01000001 	.word	0x01000001
    24e8:	01545200 	.word	0x01545200
    24ec:	017a0000 	.word	0x017a0000
    24f0:	00010000 	.word	0x00010000
    24f4:	0001ae52 	.word	0x0001ae52
    24f8:	0001b000 	.word	0x0001b000
    24fc:	52000100 	.word	0x52000100
	...
    2508:	000000c8 	.word	0x000000c8
    250c:	000000ce 	.word	0x000000ce
    2510:	08500001 	.word	0x08500001
    2514:	54000001 	.word	0x54000001
    2518:	01000001 	.word	0x01000001
    251c:	01a85000 	.word	0x01a85000
    2520:	01c00000 	.word	0x01c00000
    2524:	00010000 	.word	0x00010000
    2528:	0001d050 	.word	0x0001d050
    252c:	0001fc00 	.word	0x0001fc00
    2530:	50000100 	.word	0x50000100
	...
    253c:	00000134 	.word	0x00000134
    2540:	00000144 	.word	0x00000144
    2544:	00530001 	.word	0x00530001
    2548:	00000000 	.word	0x00000000
    254c:	72000000 	.word	0x72000000
    2550:	82000001 	.word	0x82000001
    2554:	01000001 	.word	0x01000001
    2558:	00005400 	.word	0x00005400
    255c:	00000000 	.word	0x00000000
    2560:	01fc0000 	.word	0x01fc0000
    2564:	02040000 	.word	0x02040000
    2568:	00010000 	.word	0x00010000
    256c:	0002045d 	.word	0x0002045d
    2570:	00023c00 	.word	0x00023c00
    2574:	7d000200 	.word	0x7d000200
    2578:	00000010 	.word	0x00000010
    257c:	00000000 	.word	0x00000000
    2580:	0001fc00 	.word	0x0001fc00
    2584:	00020c00 	.word	0x00020c00
    2588:	50000100 	.word	0x50000100
    258c:	0000020c 	.word	0x0000020c
    2590:	0000023c 	.word	0x0000023c
    2594:	00540001 	.word	0x00540001
    2598:	00000000 	.word	0x00000000
    259c:	fc000000 	.word	0xfc000000
    25a0:	0c000001 	.word	0x0c000001
    25a4:	01000002 	.word	0x01000002
    25a8:	020c5100 	.word	0x020c5100
    25ac:	023c0000 	.word	0x023c0000
    25b0:	00010000 	.word	0x00010000
    25b4:	00000055 	.word	0x00000055
    25b8:	00000000 	.word	0x00000000
    25bc:	0001fc00 	.word	0x0001fc00
    25c0:	00020c00 	.word	0x00020c00
    25c4:	52000100 	.word	0x52000100
    25c8:	0000020c 	.word	0x0000020c
    25cc:	0000023c 	.word	0x0000023c
    25d0:	00560001 	.word	0x00560001
    25d4:	00000000 	.word	0x00000000
    25d8:	3c000000 	.word	0x3c000000
    25dc:	3e000002 	.word	0x3e000002
    25e0:	01000002 	.word	0x01000002
    25e4:	023e5d00 	.word	0x023e5d00
    25e8:	02440000 	.word	0x02440000
    25ec:	00020000 	.word	0x00020000
    25f0:	0244047d 	.word	0x0244047d
    25f4:	024c0000 	.word	0x024c0000
    25f8:	00020000 	.word	0x00020000
    25fc:	0000087d 	.word	0x0000087d
    2600:	00000000 	.word	0x00000000
    2604:	023c0000 	.word	0x023c0000
    2608:	02480000 	.word	0x02480000
    260c:	00010000 	.word	0x00010000
    2610:	00000050 	.word	0x00000050
    2614:	00000000 	.word	0x00000000
    2618:	00023c00 	.word	0x00023c00
    261c:	00024800 	.word	0x00024800
    2620:	51000100 	.word	0x51000100
	...
    262c:	0000024c 	.word	0x0000024c
    2630:	0000024e 	.word	0x0000024e
    2634:	4e5d0001 	.word	0x4e5d0001
    2638:	50000002 	.word	0x50000002
    263c:	02000002 	.word	0x02000002
    2640:	50147d00 	.word	0x50147d00
    2644:	88000002 	.word	0x88000002
    2648:	02000002 	.word	0x02000002
    264c:	00307d00 	.word	0x00307d00
    2650:	00000000 	.word	0x00000000
    2654:	88000000 	.word	0x88000000
    2658:	8a000002 	.word	0x8a000002
    265c:	01000002 	.word	0x01000002
    2660:	028a5d00 	.word	0x028a5d00
    2664:	02ac0000 	.word	0x02ac0000
    2668:	00020000 	.word	0x00020000
    266c:	0000107d 	.word	0x0000107d
    2670:	00000000 	.word	0x00000000
    2674:	02ac0000 	.word	0x02ac0000
    2678:	02ae0000 	.word	0x02ae0000
    267c:	00010000 	.word	0x00010000
    2680:	0002ae5d 	.word	0x0002ae5d
    2684:	0002b000 	.word	0x0002b000
    2688:	7d000200 	.word	0x7d000200
    268c:	0002b014 	.word	0x0002b014
    2690:	00033000 	.word	0x00033000
    2694:	7d000200 	.word	0x7d000200
    2698:	00000028 	.word	0x00000028
    269c:	00000000 	.word	0x00000000
    26a0:	0002ac00 	.word	0x0002ac00
    26a4:	0002ba00 	.word	0x0002ba00
    26a8:	50000100 	.word	0x50000100
    26ac:	000002ba 	.word	0x000002ba
    26b0:	000002f4 	.word	0x000002f4
    26b4:	0c7d0002 	.word	0x0c7d0002
    26b8:	000002f4 	.word	0x000002f4
    26bc:	00000330 	.word	0x00000330
    26c0:	78910002 	.word	0x78910002
	...
    26cc:	000002ac 	.word	0x000002ac
    26d0:	000002ba 	.word	0x000002ba
    26d4:	ba510001 	.word	0xba510001
    26d8:	f4000002 	.word	0xf4000002
    26dc:	02000002 	.word	0x02000002
    26e0:	f4087d00 	.word	0xf4087d00
    26e4:	30000002 	.word	0x30000002
    26e8:	02000003 	.word	0x02000003
    26ec:	00749100 	.word	0x00749100
    26f0:	00000000 	.word	0x00000000
    26f4:	ac000000 	.word	0xac000000
    26f8:	ba000002 	.word	0xba000002
    26fc:	01000002 	.word	0x01000002
    2700:	02ba5200 	.word	0x02ba5200
    2704:	02f40000 	.word	0x02f40000
    2708:	00020000 	.word	0x00020000
    270c:	02f4047d 	.word	0x02f4047d
    2710:	03300000 	.word	0x03300000
    2714:	00020000 	.word	0x00020000
    2718:	00007091 	.word	0x00007091
    271c:	00000000 	.word	0x00000000
    2720:	02c60000 	.word	0x02c60000
    2724:	02f20000 	.word	0x02f20000
    2728:	00010000 	.word	0x00010000
    272c:	00030451 	.word	0x00030451
    2730:	00033000 	.word	0x00033000
    2734:	51000100 	.word	0x51000100
	...
    2740:	00000330 	.word	0x00000330
    2744:	00000332 	.word	0x00000332
    2748:	325d0001 	.word	0x325d0001
    274c:	48000003 	.word	0x48000003
    2750:	02000003 	.word	0x02000003
    2754:	48147d00 	.word	0x48147d00
    2758:	ec000003 	.word	0xec000003
    275c:	02000003 	.word	0x02000003
    2760:	00187d00 	.word	0x00187d00
    2764:	00000000 	.word	0x00000000
    2768:	30000000 	.word	0x30000000
    276c:	4e000003 	.word	0x4e000003
    2770:	01000003 	.word	0x01000003
    2774:	034e5000 	.word	0x034e5000
    2778:	03940000 	.word	0x03940000
    277c:	00010000 	.word	0x00010000
    2780:	0003b655 	.word	0x0003b655
    2784:	0003ec00 	.word	0x0003ec00
    2788:	55000100 	.word	0x55000100
	...
    2794:	00000330 	.word	0x00000330
    2798:	00000368 	.word	0x00000368
    279c:	b6510001 	.word	0xb6510001
    27a0:	ec000003 	.word	0xec000003
    27a4:	01000003 	.word	0x01000003
    27a8:	00005100 	.word	0x00005100
    27ac:	00000000 	.word	0x00000000
    27b0:	03300000 	.word	0x03300000
    27b4:	03380000 	.word	0x03380000
    27b8:	00010000 	.word	0x00010000
    27bc:	00033852 	.word	0x00033852
    27c0:	00038a00 	.word	0x00038a00
    27c4:	54000100 	.word	0x54000100
    27c8:	000003b6 	.word	0x000003b6
    27cc:	000003ec 	.word	0x000003ec
    27d0:	00540001 	.word	0x00540001
    27d4:	00000000 	.word	0x00000000
    27d8:	8a000000 	.word	0x8a000000
    27dc:	b6000003 	.word	0xb6000003
    27e0:	01000003 	.word	0x01000003
    27e4:	03c85400 	.word	0x03c85400
    27e8:	03ec0000 	.word	0x03ec0000
    27ec:	00010000 	.word	0x00010000
    27f0:	00000054 	.word	0x00000054
    27f4:	00000000 	.word	0x00000000
    27f8:	00038a00 	.word	0x00038a00
    27fc:	00038e00 	.word	0x00038e00
    2800:	50000100 	.word	0x50000100
    2804:	0000038e 	.word	0x0000038e
    2808:	00000396 	.word	0x00000396
    280c:	96550001 	.word	0x96550001
    2810:	9c000003 	.word	0x9c000003
    2814:	01000003 	.word	0x01000003
    2818:	039c5000 	.word	0x039c5000
    281c:	03ae0000 	.word	0x03ae0000
    2820:	00010000 	.word	0x00010000
    2824:	0003ae55 	.word	0x0003ae55
    2828:	0003b600 	.word	0x0003b600
    282c:	50000100 	.word	0x50000100
    2830:	000003c8 	.word	0x000003c8
    2834:	000003ca 	.word	0x000003ca
    2838:	ca500001 	.word	0xca500001
    283c:	ec000003 	.word	0xec000003
    2840:	01000003 	.word	0x01000003
    2844:	00005500 	.word	0x00005500
    2848:	00000000 	.word	0x00000000
    284c:	03ec0000 	.word	0x03ec0000
    2850:	03ee0000 	.word	0x03ee0000
    2854:	00010000 	.word	0x00010000
    2858:	0003ee5d 	.word	0x0003ee5d
    285c:	0003f200 	.word	0x0003f200
    2860:	7d000200 	.word	0x7d000200
    2864:	0003f204 	.word	0x0003f204
    2868:	00040400 	.word	0x00040400
    286c:	7d000200 	.word	0x7d000200
    2870:	00000008 	.word	0x00000008
    2874:	00000000 	.word	0x00000000
    2878:	00016000 	.word	0x00016000
    287c:	00017000 	.word	0x00017000
    2880:	50000100 	.word	0x50000100
    2884:	00000172 	.word	0x00000172
    2888:	0000017c 	.word	0x0000017c
    288c:	84500001 	.word	0x84500001
    2890:	9a000001 	.word	0x9a000001
    2894:	01000001 	.word	0x01000001
    2898:	01a25000 	.word	0x01a25000
    289c:	01a40000 	.word	0x01a40000
    28a0:	00010000 	.word	0x00010000
    28a4:	00000050 	.word	0x00000050
    28a8:	00000000 	.word	0x00000000
    28ac:	0001b400 	.word	0x0001b400
    28b0:	0001b600 	.word	0x0001b600
    28b4:	5d000100 	.word	0x5d000100
    28b8:	000001b6 	.word	0x000001b6
    28bc:	000001ba 	.word	0x000001ba
    28c0:	047d0002 	.word	0x047d0002
    28c4:	000001ba 	.word	0x000001ba
    28c8:	000001f4 	.word	0x000001f4
    28cc:	087d0002 	.word	0x087d0002
	...
    28dc:	00000002 	.word	0x00000002
    28e0:	025d0001 	.word	0x025d0001
    28e4:	06000000 	.word	0x06000000
    28e8:	02000000 	.word	0x02000000
    28ec:	06047d00 	.word	0x06047d00
    28f0:	2c000000 	.word	0x2c000000
    28f4:	02000000 	.word	0x02000000
    28f8:	00087d00 	.word	0x00087d00
	...
    2904:	0e000000 	.word	0x0e000000
    2908:	01000000 	.word	0x01000000
    290c:	00185000 	.word	0x00185000
    2910:	001c0000 	.word	0x001c0000
    2914:	00010000 	.word	0x00010000
    2918:	00000050 	.word	0x00000050
	...
    2924:	00001200 	.word	0x00001200
    2928:	51000100 	.word	0x51000100
    292c:	00000018 	.word	0x00000018
    2930:	00000020 	.word	0x00000020
    2934:	00510001 	.word	0x00510001
    2938:	00000000 	.word	0x00000000
    293c:	2c000000 	.word	0x2c000000
    2940:	2e000000 	.word	0x2e000000
    2944:	01000000 	.word	0x01000000
    2948:	002e5d00 	.word	0x002e5d00
    294c:	011c0000 	.word	0x011c0000
    2950:	00020000 	.word	0x00020000
    2954:	0000087d 	.word	0x0000087d
    2958:	00000000 	.word	0x00000000
    295c:	002c0000 	.word	0x002c0000
    2960:	00440000 	.word	0x00440000
    2964:	00010000 	.word	0x00010000
    2968:	00004c50 	.word	0x00004c50
    296c:	00006200 	.word	0x00006200
    2970:	50000100 	.word	0x50000100
    2974:	00000072 	.word	0x00000072
    2978:	00000088 	.word	0x00000088
    297c:	c8500001 	.word	0xc8500001
    2980:	da000000 	.word	0xda000000
    2984:	01000000 	.word	0x01000000
    2988:	010c5000 	.word	0x010c5000
    298c:	010e0000 	.word	0x010e0000
    2990:	00010000 	.word	0x00010000
    2994:	00000050 	.word	0x00000050
    2998:	00000000 	.word	0x00000000
    299c:	0000c600 	.word	0x0000c600
    29a0:	0000c800 	.word	0x0000c800
    29a4:	54000100 	.word	0x54000100
    29a8:	000000d0 	.word	0x000000d0
    29ac:	0000011c 	.word	0x0000011c
    29b0:	00540001 	.word	0x00540001
    29b4:	00000000 	.word	0x00000000
    29b8:	1c000000 	.word	0x1c000000
    29bc:	1e000001 	.word	0x1e000001
    29c0:	01000001 	.word	0x01000001
    29c4:	011e5d00 	.word	0x011e5d00
    29c8:	01220000 	.word	0x01220000
    29cc:	00020000 	.word	0x00020000
    29d0:	0122047d 	.word	0x0122047d
    29d4:	015e0000 	.word	0x015e0000
    29d8:	00020000 	.word	0x00020000
    29dc:	0000087d 	.word	0x0000087d
    29e0:	00000000 	.word	0x00000000
    29e4:	01600000 	.word	0x01600000
    29e8:	01620000 	.word	0x01620000
    29ec:	00010000 	.word	0x00010000
    29f0:	0001625d 	.word	0x0001625d
    29f4:	00019e00 	.word	0x00019e00
    29f8:	7d000200 	.word	0x7d000200
    29fc:	00000010 	.word	0x00000010
    2a00:	00000000 	.word	0x00000000
    2a04:	00016000 	.word	0x00016000
    2a08:	00016e00 	.word	0x00016e00
    2a0c:	50000100 	.word	0x50000100
    2a10:	0000016e 	.word	0x0000016e
    2a14:	0000018c 	.word	0x0000018c
    2a18:	00550001 	.word	0x00550001
	...
    2a24:	02000000 	.word	0x02000000
    2a28:	01000000 	.word	0x01000000
    2a2c:	00025d00 	.word	0x00025d00
    2a30:	00060000 	.word	0x00060000
    2a34:	00020000 	.word	0x00020000
    2a38:	0006047d 	.word	0x0006047d
    2a3c:	00240000 	.word	0x00240000
    2a40:	00020000 	.word	0x00020000
    2a44:	0000087d 	.word	0x0000087d
	...
    2a50:	00120000 	.word	0x00120000
    2a54:	00010000 	.word	0x00010000
    2a58:	00000050 	.word	0x00000050
	...
    2a64:	00000200 	.word	0x00000200
    2a68:	5d000100 	.word	0x5d000100
    2a6c:	00000002 	.word	0x00000002
    2a70:	00000006 	.word	0x00000006
    2a74:	047d0002 	.word	0x047d0002
    2a78:	00000006 	.word	0x00000006
    2a7c:	0000002c 	.word	0x0000002c
    2a80:	087d0002 	.word	0x087d0002
	...
    2a90:	0000000e 	.word	0x0000000e
    2a94:	18500001 	.word	0x18500001
    2a98:	1c000000 	.word	0x1c000000
    2a9c:	01000000 	.word	0x01000000
    2aa0:	00005000 	.word	0x00005000
	...
    2aac:	00120000 	.word	0x00120000
    2ab0:	00010000 	.word	0x00010000
    2ab4:	00001851 	.word	0x00001851
    2ab8:	00002000 	.word	0x00002000
    2abc:	51000100 	.word	0x51000100
	...
    2acc:	00000002 	.word	0x00000002
    2ad0:	025d0001 	.word	0x025d0001
    2ad4:	04000000 	.word	0x04000000
    2ad8:	02000000 	.word	0x02000000
    2adc:	040c7d00 	.word	0x040c7d00
    2ae0:	3c000000 	.word	0x3c000000
    2ae4:	02000000 	.word	0x02000000
    2ae8:	00107d00 	.word	0x00107d00
	...
    2af4:	0c000000 	.word	0x0c000000
    2af8:	01000000 	.word	0x01000000
    2afc:	00005000 	.word	0x00005000
	...
    2b08:	000c0000 	.word	0x000c0000
    2b0c:	00010000 	.word	0x00010000
    2b10:	00000c51 	.word	0x00000c51
    2b14:	00003c00 	.word	0x00003c00
    2b18:	54000100 	.word	0x54000100
	...
    2b24:	0000003c 	.word	0x0000003c
    2b28:	0000003e 	.word	0x0000003e
    2b2c:	3e5d0001 	.word	0x3e5d0001
    2b30:	42000000 	.word	0x42000000
    2b34:	02000000 	.word	0x02000000
    2b38:	42047d00 	.word	0x42047d00
    2b3c:	4a000000 	.word	0x4a000000
    2b40:	02000000 	.word	0x02000000
    2b44:	00087d00 	.word	0x00087d00
    2b48:	00000000 	.word	0x00000000
    2b4c:	3c000000 	.word	0x3c000000
    2b50:	46000000 	.word	0x46000000
    2b54:	01000000 	.word	0x01000000
    2b58:	00005000 	.word	0x00005000
    2b5c:	00000000 	.word	0x00000000
    2b60:	003c0000 	.word	0x003c0000
    2b64:	00400000 	.word	0x00400000
    2b68:	00010000 	.word	0x00010000
    2b6c:	00000051 	.word	0x00000051
    2b70:	00000000 	.word	0x00000000
    2b74:	00003c00 	.word	0x00003c00
    2b78:	00004600 	.word	0x00004600
    2b7c:	52000100 	.word	0x52000100
	...
    2b88:	00000040 	.word	0x00000040
    2b8c:	00000042 	.word	0x00000042
    2b90:	425d0001 	.word	0x425d0001
    2b94:	4c000000 	.word	0x4c000000
    2b98:	02000000 	.word	0x02000000
    2b9c:	4c047d00 	.word	0x4c047d00
    2ba0:	56000000 	.word	0x56000000
    2ba4:	02000000 	.word	0x02000000
    2ba8:	00087d00 	.word	0x00087d00
    2bac:	00000000 	.word	0x00000000
    2bb0:	40000000 	.word	0x40000000
    2bb4:	4a000000 	.word	0x4a000000
    2bb8:	01000000 	.word	0x01000000
    2bbc:	00005000 	.word	0x00005000
    2bc0:	00000000 	.word	0x00000000
    2bc4:	01180000 	.word	0x01180000
    2bc8:	011c0000 	.word	0x011c0000
    2bcc:	00010000 	.word	0x00010000
    2bd0:	00011c5d 	.word	0x00011c5d
    2bd4:	00021400 	.word	0x00021400
    2bd8:	7d000200 	.word	0x7d000200
    2bdc:	00000008 	.word	0x00000008
    2be0:	00000000 	.word	0x00000000
    2be4:	00021400 	.word	0x00021400
    2be8:	00021600 	.word	0x00021600
    2bec:	5d000100 	.word	0x5d000100
    2bf0:	00000216 	.word	0x00000216
    2bf4:	0000021a 	.word	0x0000021a
    2bf8:	047d0002 	.word	0x047d0002
    2bfc:	0000021a 	.word	0x0000021a
    2c00:	0000024c 	.word	0x0000024c
    2c04:	087d0002 	.word	0x087d0002
	...
    2c10:	00000214 	.word	0x00000214
    2c14:	00000232 	.word	0x00000232
    2c18:	00500001 	.word	0x00500001
    2c1c:	00000000 	.word	0x00000000
    2c20:	4c000000 	.word	0x4c000000
    2c24:	4e000002 	.word	0x4e000002
    2c28:	01000002 	.word	0x01000002
    2c2c:	024e5d00 	.word	0x024e5d00
    2c30:	02520000 	.word	0x02520000
    2c34:	00020000 	.word	0x00020000
    2c38:	02520c7d 	.word	0x02520c7d
    2c3c:	02900000 	.word	0x02900000
    2c40:	00020000 	.word	0x00020000
    2c44:	0000107d 	.word	0x0000107d
    2c48:	00000000 	.word	0x00000000
    2c4c:	026e0000 	.word	0x026e0000
    2c50:	02840000 	.word	0x02840000
    2c54:	00010000 	.word	0x00010000
    2c58:	00000050 	.word	0x00000050
	...
    2c64:	00000200 	.word	0x00000200
    2c68:	5d000100 	.word	0x5d000100
    2c6c:	00000002 	.word	0x00000002
    2c70:	00000006 	.word	0x00000006
    2c74:	047d0002 	.word	0x047d0002
    2c78:	00000006 	.word	0x00000006
    2c7c:	00000040 	.word	0x00000040
    2c80:	087d0002 	.word	0x087d0002
	...
    2c8c:	00000040 	.word	0x00000040
    2c90:	00000042 	.word	0x00000042
    2c94:	425d0001 	.word	0x425d0001
    2c98:	46000000 	.word	0x46000000
    2c9c:	02000000 	.word	0x02000000
    2ca0:	46047d00 	.word	0x46047d00
    2ca4:	64000000 	.word	0x64000000
    2ca8:	02000000 	.word	0x02000000
    2cac:	00087d00 	.word	0x00087d00
    2cb0:	00000000 	.word	0x00000000
    2cb4:	64000000 	.word	0x64000000
    2cb8:	66000000 	.word	0x66000000
    2cbc:	01000000 	.word	0x01000000
    2cc0:	00665d00 	.word	0x00665d00
    2cc4:	00680000 	.word	0x00680000
    2cc8:	00020000 	.word	0x00020000
    2ccc:	0068107d 	.word	0x0068107d
    2cd0:	014c0000 	.word	0x014c0000
    2cd4:	00020000 	.word	0x00020000
    2cd8:	0000287d 	.word	0x0000287d
    2cdc:	00000000 	.word	0x00000000
    2ce0:	014c0000 	.word	0x014c0000
    2ce4:	014e0000 	.word	0x014e0000
    2ce8:	00010000 	.word	0x00010000
    2cec:	00014e5d 	.word	0x00014e5d
    2cf0:	00015000 	.word	0x00015000
    2cf4:	7d000200 	.word	0x7d000200
    2cf8:	00015014 	.word	0x00015014
    2cfc:	00032400 	.word	0x00032400
    2d00:	7d000200 	.word	0x7d000200
    2d04:	00000020 	.word	0x00000020
    2d08:	00000000 	.word	0x00000000
    2d0c:	00032400 	.word	0x00032400
    2d10:	00032600 	.word	0x00032600
    2d14:	5d000100 	.word	0x5d000100
    2d18:	00000326 	.word	0x00000326
    2d1c:	0000032c 	.word	0x0000032c
    2d20:	107d0002 	.word	0x107d0002
    2d24:	0000032c 	.word	0x0000032c
    2d28:	00000392 	.word	0x00000392
    2d2c:	187d0002 	.word	0x187d0002
	...
    2d38:	00000394 	.word	0x00000394
    2d3c:	00000396 	.word	0x00000396
    2d40:	965d0001 	.word	0x965d0001
    2d44:	98000003 	.word	0x98000003
    2d48:	02000003 	.word	0x02000003
    2d4c:	98047d00 	.word	0x98047d00
    2d50:	28000003 	.word	0x28000003
    2d54:	02000004 	.word	0x02000004
    2d58:	00087d00 	.word	0x00087d00
    2d5c:	00000000 	.word	0x00000000
    2d60:	28000000 	.word	0x28000000
    2d64:	2a000004 	.word	0x2a000004
    2d68:	01000004 	.word	0x01000004
    2d6c:	042a5d00 	.word	0x042a5d00
    2d70:	04300000 	.word	0x04300000
    2d74:	00020000 	.word	0x00020000
    2d78:	0430047d 	.word	0x0430047d
    2d7c:	04540000 	.word	0x04540000
    2d80:	00020000 	.word	0x00020000
    2d84:	0000087d 	.word	0x0000087d
    2d88:	00000000 	.word	0x00000000
    2d8c:	0000      	.short	0x0000
    2d8e:	0022      	.short	0x0022
    2d90:	00240000 	.word	0x00240000
    2d94:	00010000 	.word	0x00010000
    2d98:	00003450 	.word	0x00003450
    2d9c:	00004200 	.word	0x00004200
    2da0:	50000100 	.word	0x50000100
	...
    2dac:	0000005e 	.word	0x0000005e
    2db0:	00000060 	.word	0x00000060
    2db4:	6a500001 	.word	0x6a500001
    2db8:	6a000000 	.word	0x6a000000
    2dbc:	01000000 	.word	0x01000000
    2dc0:	00005000 	.word	0x00005000
    2dc4:	00000000 	.word	0x00000000
    2dc8:	00d80000 	.word	0x00d80000
    2dcc:	00da0000 	.word	0x00da0000
    2dd0:	00010000 	.word	0x00010000
    2dd4:	0000da5d 	.word	0x0000da5d
    2dd8:	0000e200 	.word	0x0000e200
    2ddc:	7d000200 	.word	0x7d000200
    2de0:	0000e214 	.word	0x0000e214
    2de4:	00012c00 	.word	0x00012c00
    2de8:	7d000200 	.word	0x7d000200
    2dec:	00000020 	.word	0x00000020
    2df0:	00000000 	.word	0x00000000
    2df4:	0000d800 	.word	0x0000d800
    2df8:	0000ec00 	.word	0x0000ec00
    2dfc:	50000100 	.word	0x50000100
    2e00:	000000ec 	.word	0x000000ec
    2e04:	0000012c 	.word	0x0000012c
    2e08:	00550001 	.word	0x00550001
    2e0c:	00000000 	.word	0x00000000
    2e10:	d8000000 	.word	0xd8000000
    2e14:	e6000000 	.word	0xe6000000
    2e18:	01000000 	.word	0x01000000
    2e1c:	00e65100 	.word	0x00e65100
    2e20:	012c0000 	.word	0x012c0000
    2e24:	00010000 	.word	0x00010000
    2e28:	00000054 	.word	0x00000054
    2e2c:	00000000 	.word	0x00000000
    2e30:	0000ec00 	.word	0x0000ec00
    2e34:	00011a00 	.word	0x00011a00
    2e38:	50000100 	.word	0x50000100
	...
    2e44:	00000158 	.word	0x00000158
    2e48:	0000015a 	.word	0x0000015a
    2e4c:	5a5d0001 	.word	0x5a5d0001
    2e50:	62000001 	.word	0x62000001
    2e54:	02000001 	.word	0x02000001
    2e58:	62147d00 	.word	0x62147d00
    2e5c:	b4000001 	.word	0xb4000001
    2e60:	02000001 	.word	0x02000001
    2e64:	00207d00 	.word	0x00207d00
    2e68:	00000000 	.word	0x00000000
    2e6c:	58000000 	.word	0x58000000
    2e70:	6e000001 	.word	0x6e000001
    2e74:	01000001 	.word	0x01000001
    2e78:	016e5000 	.word	0x016e5000
    2e7c:	01b40000 	.word	0x01b40000
    2e80:	00010000 	.word	0x00010000
    2e84:	00000055 	.word	0x00000055
    2e88:	00000000 	.word	0x00000000
    2e8c:	00015800 	.word	0x00015800
    2e90:	00016600 	.word	0x00016600
    2e94:	51000100 	.word	0x51000100
    2e98:	00000166 	.word	0x00000166
    2e9c:	000001b4 	.word	0x000001b4
    2ea0:	00540001 	.word	0x00540001
    2ea4:	00000000 	.word	0x00000000
    2ea8:	6e000000 	.word	0x6e000000
    2eac:	a2000001 	.word	0xa2000001
    2eb0:	01000001 	.word	0x01000001
    2eb4:	00005000 	.word	0x00005000
    2eb8:	00000000 	.word	0x00000000
    2ebc:	01c80000 	.word	0x01c80000
    2ec0:	01ca0000 	.word	0x01ca0000
    2ec4:	00010000 	.word	0x00010000
    2ec8:	0001ca5d 	.word	0x0001ca5d
    2ecc:	0001ce00 	.word	0x0001ce00
    2ed0:	7d000200 	.word	0x7d000200
    2ed4:	0001ce04 	.word	0x0001ce04
    2ed8:	00024000 	.word	0x00024000
    2edc:	7d000200 	.word	0x7d000200
    2ee0:	00000008 	.word	0x00000008
    2ee4:	00000000 	.word	0x00000000
    2ee8:	00024000 	.word	0x00024000
    2eec:	00024200 	.word	0x00024200
    2ef0:	5d000100 	.word	0x5d000100
    2ef4:	00000242 	.word	0x00000242
    2ef8:	00000248 	.word	0x00000248
    2efc:	047d0002 	.word	0x047d0002
    2f00:	00000248 	.word	0x00000248
    2f04:	00000252 	.word	0x00000252
    2f08:	087d0002 	.word	0x087d0002
	...
    2f14:	00000240 	.word	0x00000240
    2f18:	00000246 	.word	0x00000246
    2f1c:	00500001 	.word	0x00500001
    2f20:	00000000 	.word	0x00000000
    2f24:	54000000 	.word	0x54000000
    2f28:	56000002 	.word	0x56000002
    2f2c:	01000002 	.word	0x01000002
    2f30:	02565d00 	.word	0x02565d00
    2f34:	02a80000 	.word	0x02a80000
    2f38:	00020000 	.word	0x00020000
    2f3c:	0000107d 	.word	0x0000107d
    2f40:	00000000 	.word	0x00000000
    2f44:	02540000 	.word	0x02540000
    2f48:	025e0000 	.word	0x025e0000
    2f4c:	00010000 	.word	0x00010000
    2f50:	00025e50 	.word	0x00025e50
    2f54:	0002a800 	.word	0x0002a800
    2f58:	56000100 	.word	0x56000100
	...
    2f64:	00000254 	.word	0x00000254
    2f68:	0000025e 	.word	0x0000025e
    2f6c:	5e510001 	.word	0x5e510001
    2f70:	a8000002 	.word	0xa8000002
    2f74:	01000002 	.word	0x01000002
    2f78:	00005500 	.word	0x00005500
    2f7c:	00000000 	.word	0x00000000
    2f80:	02a80000 	.word	0x02a80000
    2f84:	02aa0000 	.word	0x02aa0000
    2f88:	00010000 	.word	0x00010000
    2f8c:	0002aa5d 	.word	0x0002aa5d
    2f90:	0002ae00 	.word	0x0002ae00
    2f94:	7d000200 	.word	0x7d000200
    2f98:	0002ae04 	.word	0x0002ae04
    2f9c:	0002bc00 	.word	0x0002bc00
    2fa0:	7d000200 	.word	0x7d000200
    2fa4:	00000008 	.word	0x00000008
    2fa8:	00000000 	.word	0x00000000
    2fac:	0002bc00 	.word	0x0002bc00
    2fb0:	0002be00 	.word	0x0002be00
    2fb4:	5d000100 	.word	0x5d000100
    2fb8:	000002be 	.word	0x000002be
    2fbc:	000002c2 	.word	0x000002c2
    2fc0:	047d0002 	.word	0x047d0002
    2fc4:	000002c2 	.word	0x000002c2
    2fc8:	000002e0 	.word	0x000002e0
    2fcc:	087d0002 	.word	0x087d0002
	...
    2fd8:	000002e0 	.word	0x000002e0
    2fdc:	000002e2 	.word	0x000002e2
    2fe0:	e25d0001 	.word	0xe25d0001
    2fe4:	e6000002 	.word	0xe6000002
    2fe8:	02000002 	.word	0x02000002
    2fec:	e6047d00 	.word	0xe6047d00
    2ff0:	f4000002 	.word	0xf4000002
    2ff4:	02000002 	.word	0x02000002
    2ff8:	00087d00 	.word	0x00087d00
    2ffc:	00000000 	.word	0x00000000
    3000:	f4000000 	.word	0xf4000000
    3004:	f6000002 	.word	0xf6000002
    3008:	01000002 	.word	0x01000002
    300c:	02f65d00 	.word	0x02f65d00
    3010:	02f80000 	.word	0x02f80000
    3014:	00020000 	.word	0x00020000
    3018:	02f80c7d 	.word	0x02f80c7d
    301c:	03540000 	.word	0x03540000
    3020:	00020000 	.word	0x00020000
    3024:	0000207d 	.word	0x0000207d
    3028:	00000000 	.word	0x00000000
    302c:	02f40000 	.word	0x02f40000
    3030:	02fc0000 	.word	0x02fc0000
    3034:	00010000 	.word	0x00010000
    3038:	0002fc50 	.word	0x0002fc50
    303c:	00030400 	.word	0x00030400
    3040:	54000100 	.word	0x54000100
	...
    304c:	00000354 	.word	0x00000354
    3050:	00000356 	.word	0x00000356
    3054:	565d0001 	.word	0x565d0001
    3058:	58000003 	.word	0x58000003
    305c:	02000003 	.word	0x02000003
    3060:	580c7d00 	.word	0x580c7d00
    3064:	c4000003 	.word	0xc4000003
    3068:	02000003 	.word	0x02000003
    306c:	00207d00 	.word	0x00207d00
    3070:	00000000 	.word	0x00000000
    3074:	54000000 	.word	0x54000000
    3078:	5c000003 	.word	0x5c000003
    307c:	01000003 	.word	0x01000003
    3080:	035c5000 	.word	0x035c5000
    3084:	03640000 	.word	0x03640000
    3088:	00010000 	.word	0x00010000
    308c:	00000054 	.word	0x00000054
    3090:	00000000 	.word	0x00000000
    3094:	0003c400 	.word	0x0003c400
    3098:	0003c600 	.word	0x0003c600
    309c:	5d000100 	.word	0x5d000100
    30a0:	000003c6 	.word	0x000003c6
    30a4:	000003c8 	.word	0x000003c8
    30a8:	0c7d0002 	.word	0x0c7d0002
    30ac:	000003c8 	.word	0x000003c8
    30b0:	00000424 	.word	0x00000424
    30b4:	207d0002 	.word	0x207d0002
	...
    30c0:	000003c4 	.word	0x000003c4
    30c4:	000003cc 	.word	0x000003cc
    30c8:	cc500001 	.word	0xcc500001
    30cc:	d4000003 	.word	0xd4000003
    30d0:	01000003 	.word	0x01000003
    30d4:	00005400 	.word	0x00005400
    30d8:	00000000 	.word	0x00000000
    30dc:	04240000 	.word	0x04240000
    30e0:	04260000 	.word	0x04260000
    30e4:	00010000 	.word	0x00010000
    30e8:	0004265d 	.word	0x0004265d
    30ec:	0004b400 	.word	0x0004b400
    30f0:	7d000200 	.word	0x7d000200
    30f4:	00000008 	.word	0x00000008
    30f8:	00000000 	.word	0x00000000
    30fc:	0004b400 	.word	0x0004b400
    3100:	0004b600 	.word	0x0004b600
    3104:	5d000100 	.word	0x5d000100
    3108:	000004b6 	.word	0x000004b6
    310c:	000004f4 	.word	0x000004f4
    3110:	107d0002 	.word	0x107d0002
	...
    311c:	000004b4 	.word	0x000004b4
    3120:	000004be 	.word	0x000004be
    3124:	be500001 	.word	0xbe500001
    3128:	f4000004 	.word	0xf4000004
    312c:	01000004 	.word	0x01000004
    3130:	00005600 	.word	0x00005600
    3134:	00000000 	.word	0x00000000
    3138:	04b40000 	.word	0x04b40000
    313c:	04be0000 	.word	0x04be0000
    3140:	00010000 	.word	0x00010000
    3144:	0004be51 	.word	0x0004be51
    3148:	0004f400 	.word	0x0004f400
    314c:	55000100 	.word	0x55000100
	...
    3158:	000004f4 	.word	0x000004f4
    315c:	000004f6 	.word	0x000004f6
    3160:	f65d0001 	.word	0xf65d0001
    3164:	94000004 	.word	0x94000004
    3168:	02000005 	.word	0x02000005
    316c:	00087d00 	.word	0x00087d00
    3170:	00000000 	.word	0x00000000
    3174:	94000000 	.word	0x94000000
    3178:	96000005 	.word	0x96000005
    317c:	01000005 	.word	0x01000005
    3180:	05965d00 	.word	0x05965d00
    3184:	05980000 	.word	0x05980000
    3188:	00020000 	.word	0x00020000
    318c:	0598047d 	.word	0x0598047d
    3190:	05a00000 	.word	0x05a00000
    3194:	00020000 	.word	0x00020000
    3198:	0000087d 	.word	0x0000087d
    319c:	00000000 	.word	0x00000000
    31a0:	05a00000 	.word	0x05a00000
    31a4:	05a20000 	.word	0x05a20000
    31a8:	00010000 	.word	0x00010000
    31ac:	0005a25d 	.word	0x0005a25d
    31b0:	0005d000 	.word	0x0005d000
    31b4:	7d000200 	.word	0x7d000200
    31b8:	00000008 	.word	0x00000008
    31bc:	00000000 	.word	0x00000000
    31c0:	0005a000 	.word	0x0005a000
    31c4:	0005a800 	.word	0x0005a800
    31c8:	50000100 	.word	0x50000100
    31cc:	000005a8 	.word	0x000005a8
    31d0:	000005d0 	.word	0x000005d0
    31d4:	00540001 	.word	0x00540001
    31d8:	00000000 	.word	0x00000000
    31dc:	d0000000 	.word	0xd0000000
    31e0:	d2000005 	.word	0xd2000005
    31e4:	01000005 	.word	0x01000005
    31e8:	05d25d00 	.word	0x05d25d00
    31ec:	05d80000 	.word	0x05d80000
    31f0:	00020000 	.word	0x00020000
    31f4:	05d8047d 	.word	0x05d8047d
    31f8:	05e40000 	.word	0x05e40000
    31fc:	00020000 	.word	0x00020000
    3200:	0000087d 	.word	0x0000087d
    3204:	00000000 	.word	0x00000000
    3208:	05d00000 	.word	0x05d00000
    320c:	05d60000 	.word	0x05d60000
    3210:	00010000 	.word	0x00010000
    3214:	0005d650 	.word	0x0005d650
    3218:	0005e000 	.word	0x0005e000
    321c:	53000100 	.word	0x53000100
	...
    3228:	00000002 	.word	0x00000002
    322c:	00000008 	.word	0x00000008
    3230:	14530001 	.word	0x14530001
    3234:	18000000 	.word	0x18000000
    3238:	01000000 	.word	0x01000000
    323c:	001e5300 	.word	0x001e5300
    3240:	002e0000 	.word	0x002e0000
    3244:	00010000 	.word	0x00010000
    3248:	00002e5c 	.word	0x00002e5c
    324c:	00004800 	.word	0x00004800
    3250:	52000100 	.word	0x52000100
	...
    325c:	00000084 	.word	0x00000084
    3260:	00000086 	.word	0x00000086
    3264:	00510001 	.word	0x00510001
    3268:	00000000 	.word	0x00000000
    326c:	a8000000 	.word	0xa8000000
    3270:	aa000000 	.word	0xaa000000
    3274:	01000000 	.word	0x01000000
    3278:	00005000 	.word	0x00005000
    327c:	00000000 	.word	0x00000000
    3280:	00c00000 	.word	0x00c00000
    3284:	00c20000 	.word	0x00c20000
    3288:	00010000 	.word	0x00010000
    328c:	00000050 	.word	0x00000050
    3290:	00000000 	.word	0x00000000
    3294:	0000e000 	.word	0x0000e000
    3298:	0000e200 	.word	0x0000e200
    329c:	50000100 	.word	0x50000100
	...
    32a8:	000000ec 	.word	0x000000ec
    32ac:	000000f0 	.word	0x000000f0
    32b0:	00510001 	.word	0x00510001
    32b4:	00000000 	.word	0x00000000
    32b8:	10000000 	.word	0x10000000
    32bc:	14000001 	.word	0x14000001
    32c0:	01000001 	.word	0x01000001
    32c4:	01145d00 	.word	0x01145d00
    32c8:	01a60000 	.word	0x01a60000
    32cc:	00020000 	.word	0x00020000
    32d0:	00000c7d 	.word	0x00000c7d
    32d4:	00000000 	.word	0x00000000
    32d8:	01100000 	.word	0x01100000
    32dc:	012e0000 	.word	0x012e0000
    32e0:	00010000 	.word	0x00010000
    32e4:	00012e51 	.word	0x00012e51
    32e8:	00013800 	.word	0x00013800
    32ec:	54000100 	.word	0x54000100
    32f0:	00000138 	.word	0x00000138
    32f4:	00000144 	.word	0x00000144
    32f8:	44510001 	.word	0x44510001
    32fc:	a6000001 	.word	0xa6000001
    3300:	01000001 	.word	0x01000001
    3304:	00005400 	.word	0x00005400
    3308:	00000000 	.word	0x00000000
    330c:	01100000 	.word	0x01100000
    3310:	011e0000 	.word	0x011e0000
    3314:	00010000 	.word	0x00010000
    3318:	00011e52 	.word	0x00011e52
    331c:	0001a600 	.word	0x0001a600
    3320:	5c000100 	.word	0x5c000100
	...
    332c:	00000110 	.word	0x00000110
    3330:	00000120 	.word	0x00000120
    3334:	20530001 	.word	0x20530001
    3338:	a6000001 	.word	0xa6000001
    333c:	01000001 	.word	0x01000001
    3340:	00005500 	.word	0x00005500
    3344:	00000000 	.word	0x00000000
    3348:	012e0000 	.word	0x012e0000
    334c:	01380000 	.word	0x01380000
    3350:	00010000 	.word	0x00010000
    3354:	00014451 	.word	0x00014451
    3358:	0001a600 	.word	0x0001a600
    335c:	51000100 	.word	0x51000100
	...
    3368:	000001bc 	.word	0x000001bc
    336c:	000001be 	.word	0x000001be
    3370:	00500001 	.word	0x00500001
    3374:	00000000 	.word	0x00000000
    3378:	f8000000 	.word	0xf8000000
    337c:	00000001 	.word	0x00000001
    3380:	01000002 	.word	0x01000002
    3384:	00005100 	.word	0x00005100
    3388:	00000000 	.word	0x00000000
    338c:	01fa0000 	.word	0x01fa0000
    3390:	02000000 	.word	0x02000000
    3394:	00010000 	.word	0x00010000
    3398:	00020053 	.word	0x00020053
    339c:	00020400 	.word	0x00020400
    33a0:	51000100 	.word	0x51000100
	...
    33ac:	0000022c 	.word	0x0000022c
    33b0:	0000022e 	.word	0x0000022e
    33b4:	00500001 	.word	0x00500001
    33b8:	00000000 	.word	0x00000000
    33bc:	38000000 	.word	0x38000000
    33c0:	3c000002 	.word	0x3c000002
    33c4:	01000002 	.word	0x01000002
    33c8:	023c5d00 	.word	0x023c5d00
    33cc:	029a0000 	.word	0x029a0000
    33d0:	00020000 	.word	0x00020000
    33d4:	00000c7d 	.word	0x00000c7d
    33d8:	00000000 	.word	0x00000000
    33dc:	02380000 	.word	0x02380000
    33e0:	02560000 	.word	0x02560000
    33e4:	00010000 	.word	0x00010000
    33e8:	00025651 	.word	0x00025651
    33ec:	00026000 	.word	0x00026000
    33f0:	5c000100 	.word	0x5c000100
    33f4:	00000260 	.word	0x00000260
    33f8:	0000026c 	.word	0x0000026c
    33fc:	6c510001 	.word	0x6c510001
    3400:	9a000002 	.word	0x9a000002
    3404:	01000002 	.word	0x01000002
    3408:	00005c00 	.word	0x00005c00
    340c:	00000000 	.word	0x00000000
    3410:	02380000 	.word	0x02380000
    3414:	02460000 	.word	0x02460000
    3418:	00010000 	.word	0x00010000
    341c:	00024652 	.word	0x00024652
    3420:	00029a00 	.word	0x00029a00
    3424:	55000100 	.word	0x55000100
	...
    3430:	00000238 	.word	0x00000238
    3434:	00000248 	.word	0x00000248
    3438:	48530001 	.word	0x48530001
    343c:	9a000002 	.word	0x9a000002
    3440:	01000002 	.word	0x01000002
    3444:	00005400 	.word	0x00005400
    3448:	00000000 	.word	0x00000000
    344c:	02560000 	.word	0x02560000
    3450:	02600000 	.word	0x02600000
    3454:	00010000 	.word	0x00010000
    3458:	00026c51 	.word	0x00026c51
    345c:	00027600 	.word	0x00027600
    3460:	51000100 	.word	0x51000100
    3464:	00000276 	.word	0x00000276
    3468:	0000029a 	.word	0x0000029a
    346c:	00530001 	.word	0x00530001
    3470:	00000000 	.word	0x00000000
    3474:	9c000000 	.word	0x9c000000
    3478:	a0000002 	.word	0xa0000002
    347c:	01000002 	.word	0x01000002
    3480:	00005100 	.word	0x00005100
    3484:	00000000 	.word	0x00000000
    3488:	02ac0000 	.word	0x02ac0000
    348c:	02ae0000 	.word	0x02ae0000
    3490:	00010000 	.word	0x00010000
    3494:	0002ae5d 	.word	0x0002ae5d
    3498:	0002b400 	.word	0x0002b400
    349c:	7d000200 	.word	0x7d000200
    34a0:	00000008 	.word	0x00000008
    34a4:	00000000 	.word	0x00000000
    34a8:	0002ac00 	.word	0x0002ac00
    34ac:	0002b000 	.word	0x0002b000
    34b0:	50000100 	.word	0x50000100
	...
    34bc:	000002b4 	.word	0x000002b4
    34c0:	000002b6 	.word	0x000002b6
    34c4:	b65d0001 	.word	0xb65d0001
    34c8:	c2000002 	.word	0xc2000002
    34cc:	02000002 	.word	0x02000002
    34d0:	00087d00 	.word	0x00087d00
    34d4:	00000000 	.word	0x00000000
    34d8:	b4000000 	.word	0xb4000000
    34dc:	b8000002 	.word	0xb8000002
    34e0:	01000002 	.word	0x01000002
    34e4:	00005000 	.word	0x00005000
    34e8:	00000000 	.word	0x00000000
    34ec:	02c40000 	.word	0x02c40000
    34f0:	02d00000 	.word	0x02d00000
    34f4:	00010000 	.word	0x00010000
    34f8:	00000051 	.word	0x00000051
    34fc:	00000000 	.word	0x00000000
    3500:	0002c600 	.word	0x0002c600
    3504:	0002d000 	.word	0x0002d000
    3508:	53000100 	.word	0x53000100
    350c:	000002d0 	.word	0x000002d0
    3510:	000002d4 	.word	0x000002d4
    3514:	00510001 	.word	0x00510001
    3518:	00000000 	.word	0x00000000
    351c:	dc000000 	.word	0xdc000000
    3520:	e4000002 	.word	0xe4000002
    3524:	01000002 	.word	0x01000002
    3528:	00005100 	.word	0x00005100
    352c:	00000000 	.word	0x00000000
    3530:	02de0000 	.word	0x02de0000
    3534:	02e40000 	.word	0x02e40000
    3538:	00010000 	.word	0x00010000
    353c:	0002e453 	.word	0x0002e453
    3540:	0002e800 	.word	0x0002e800
    3544:	51000100 	.word	0x51000100
	...
    3550:	00000304 	.word	0x00000304
    3554:	0000030e 	.word	0x0000030e
    3558:	00500001 	.word	0x00500001
    355c:	00000000 	.word	0x00000000
    3560:	10000000 	.word	0x10000000
    3564:	14000003 	.word	0x14000003
    3568:	01000003 	.word	0x01000003
    356c:	00005100 	.word	0x00005100
    3570:	00000000 	.word	0x00000000
    3574:	03180000 	.word	0x03180000
    3578:	03240000 	.word	0x03240000
    357c:	00010000 	.word	0x00010000
    3580:	00032650 	.word	0x00032650
    3584:	00033000 	.word	0x00033000
    3588:	50000100 	.word	0x50000100
	...
    3594:	00000318 	.word	0x00000318
    3598:	00000328 	.word	0x00000328
    359c:	28510001 	.word	0x28510001
    35a0:	32000003 	.word	0x32000003
    35a4:	01000003 	.word	0x01000003
    35a8:	00005300 	.word	0x00005300
    35ac:	00000000 	.word	0x00000000
    35b0:	03240000 	.word	0x03240000
    35b4:	03260000 	.word	0x03260000
    35b8:	00010000 	.word	0x00010000
    35bc:	00033050 	.word	0x00033050
    35c0:	00033000 	.word	0x00033000
    35c4:	50000100 	.word	0x50000100
	...
    35d0:	00000334 	.word	0x00000334
    35d4:	00000338 	.word	0x00000338
    35d8:	00510001 	.word	0x00510001
    35dc:	00000000 	.word	0x00000000
    35e0:	3c000000 	.word	0x3c000000
    35e4:	3e000003 	.word	0x3e000003
    35e8:	01000003 	.word	0x01000003
    35ec:	033e5d00 	.word	0x033e5d00
    35f0:	03420000 	.word	0x03420000
    35f4:	00020000 	.word	0x00020000
    35f8:	0342047d 	.word	0x0342047d
    35fc:	03940000 	.word	0x03940000
    3600:	00020000 	.word	0x00020000
    3604:	0000107d 	.word	0x0000107d
    3608:	00000000 	.word	0x00000000
    360c:	033c0000 	.word	0x033c0000
    3610:	03440000 	.word	0x03440000
    3614:	00010000 	.word	0x00010000
    3618:	00034650 	.word	0x00034650
    361c:	00039400 	.word	0x00039400
    3620:	7d000200 	.word	0x7d000200
    3624:	00000004 	.word	0x00000004
	...
    3630:	00000e00 	.word	0x00000e00
    3634:	50000100 	.word	0x50000100
	...
    3640:	00000018 	.word	0x00000018
    3644:	00000026 	.word	0x00000026
    3648:	00500001 	.word	0x00500001
    364c:	00000000 	.word	0x00000000
    3650:	30000000 	.word	0x30000000
    3654:	3e000000 	.word	0x3e000000
    3658:	01000000 	.word	0x01000000
    365c:	00005000 	.word	0x00005000
    3660:	00000000 	.word	0x00000000
    3664:	00c40000 	.word	0x00c40000
    3668:	00d00000 	.word	0x00d00000
    366c:	00010000 	.word	0x00010000
    3670:	0000d250 	.word	0x0000d250
    3674:	0000de00 	.word	0x0000de00
    3678:	50000100 	.word	0x50000100
	...
    3684:	000000d0 	.word	0x000000d0
    3688:	000000d2 	.word	0x000000d2
    368c:	de500001 	.word	0xde500001
    3690:	de000000 	.word	0xde000000
    3694:	01000000 	.word	0x01000000
    3698:	00005000 	.word	0x00005000
    369c:	00000000 	.word	0x00000000
    36a0:	00fc0000 	.word	0x00fc0000
    36a4:	00fe0000 	.word	0x00fe0000
    36a8:	00010000 	.word	0x00010000
    36ac:	00010850 	.word	0x00010850
    36b0:	00010a00 	.word	0x00010a00
    36b4:	50000100 	.word	0x50000100
    36b8:	00000116 	.word	0x00000116
    36bc:	00000116 	.word	0x00000116
    36c0:	00500001 	.word	0x00500001
    36c4:	00000000 	.word	0x00000000
    36c8:	1c000000 	.word	0x1c000000
    36cc:	1e000001 	.word	0x1e000001
    36d0:	01000001 	.word	0x01000001
    36d4:	011e5d00 	.word	0x011e5d00
    36d8:	01220000 	.word	0x01220000
    36dc:	00020000 	.word	0x00020000
    36e0:	0122087d 	.word	0x0122087d
    36e4:	01b00000 	.word	0x01b00000
    36e8:	00020000 	.word	0x00020000
    36ec:	0000107d 	.word	0x0000107d
    36f0:	00000000 	.word	0x00000000
    36f4:	011c0000 	.word	0x011c0000
    36f8:	012c0000 	.word	0x012c0000
    36fc:	00010000 	.word	0x00010000
    3700:	00012c50 	.word	0x00012c50
    3704:	0001b000 	.word	0x0001b000
    3708:	51000100 	.word	0x51000100
	...
    3714:	0000012e 	.word	0x0000012e
    3718:	00000130 	.word	0x00000130
    371c:	3a500001 	.word	0x3a500001
    3720:	3c000001 	.word	0x3c000001
    3724:	01000001 	.word	0x01000001
    3728:	01485000 	.word	0x01485000
    372c:	01a80000 	.word	0x01a80000
    3730:	00010000 	.word	0x00010000
    3734:	00000050 	.word	0x00000050
    3738:	00000000 	.word	0x00000000
    373c:	00014a00 	.word	0x00014a00
    3740:	00014c00 	.word	0x00014c00
    3744:	91000200 	.word	0x91000200
    3748:	00014c7c 	.word	0x00014c7c
    374c:	00015200 	.word	0x00015200
    3750:	7d000200 	.word	0x7d000200
    3754:	00015204 	.word	0x00015204
    3758:	00015800 	.word	0x00015800
    375c:	91000200 	.word	0x91000200
    3760:	0001587c 	.word	0x0001587c
    3764:	00015e00 	.word	0x00015e00
    3768:	7d000200 	.word	0x7d000200
    376c:	00015e04 	.word	0x00015e04
    3770:	00018600 	.word	0x00018600
    3774:	91000200 	.word	0x91000200
    3778:	00018e7c 	.word	0x00018e7c
    377c:	0001b000 	.word	0x0001b000
    3780:	91000200 	.word	0x91000200
    3784:	0000007c 	.word	0x0000007c
    3788:	00000000 	.word	0x00000000
    378c:	0001b000 	.word	0x0001b000
    3790:	0001b200 	.word	0x0001b200
    3794:	5d000100 	.word	0x5d000100
    3798:	000001b2 	.word	0x000001b2
    379c:	000001b8 	.word	0x000001b8
    37a0:	147d0002 	.word	0x147d0002
    37a4:	000001b8 	.word	0x000001b8
    37a8:	0000020c 	.word	0x0000020c
    37ac:	187d0002 	.word	0x187d0002
	...
    37b8:	000001b0 	.word	0x000001b0
    37bc:	000001c4 	.word	0x000001c4
    37c0:	c4500001 	.word	0xc4500001
    37c4:	0c000001 	.word	0x0c000001
    37c8:	01000002 	.word	0x01000002
    37cc:	00005500 	.word	0x00005500
    37d0:	00000000 	.word	0x00000000
    37d4:	01b00000 	.word	0x01b00000
    37d8:	01cc0000 	.word	0x01cc0000
    37dc:	00010000 	.word	0x00010000
    37e0:	0001cc51 	.word	0x0001cc51
    37e4:	00020c00 	.word	0x00020c00
    37e8:	56000100 	.word	0x56000100
	...
    37f4:	000001b0 	.word	0x000001b0
    37f8:	000001cc 	.word	0x000001cc
    37fc:	cc520001 	.word	0xcc520001
    3800:	0c000001 	.word	0x0c000001
    3804:	01000002 	.word	0x01000002
    3808:	00005700 	.word	0x00005700
    380c:	00000000 	.word	0x00000000
    3810:	01ce0000 	.word	0x01ce0000
    3814:	01ea0000 	.word	0x01ea0000
    3818:	00010000 	.word	0x00010000
    381c:	0001f050 	.word	0x0001f050
    3820:	0001fc00 	.word	0x0001fc00
    3824:	50000100 	.word	0x50000100
	...
    3830:	0000020c 	.word	0x0000020c
    3834:	0000020e 	.word	0x0000020e
    3838:	0e5d0001 	.word	0x0e5d0001
    383c:	12000002 	.word	0x12000002
    3840:	02000002 	.word	0x02000002
    3844:	120c7d00 	.word	0x120c7d00
    3848:	a8000002 	.word	0xa8000002
    384c:	02000002 	.word	0x02000002
    3850:	00107d00 	.word	0x00107d00
    3854:	00000000 	.word	0x00000000
    3858:	0c000000 	.word	0x0c000000
    385c:	16000002 	.word	0x16000002
    3860:	01000002 	.word	0x01000002
    3864:	02165000 	.word	0x02165000
    3868:	02a80000 	.word	0x02a80000
    386c:	00010000 	.word	0x00010000
    3870:	00000055 	.word	0x00000055
    3874:	00000000 	.word	0x00000000
    3878:	00021c00 	.word	0x00021c00
    387c:	00022600 	.word	0x00022600
    3880:	50000100 	.word	0x50000100
    3884:	00000246 	.word	0x00000246
    3888:	00000272 	.word	0x00000272
    388c:	78500001 	.word	0x78500001
    3890:	98000002 	.word	0x98000002
    3894:	01000002 	.word	0x01000002
    3898:	00005000 	.word	0x00005000
    389c:	00000000 	.word	0x00000000
    38a0:	02a80000 	.word	0x02a80000
    38a4:	02aa0000 	.word	0x02aa0000
    38a8:	00010000 	.word	0x00010000
    38ac:	0002aa5d 	.word	0x0002aa5d
    38b0:	00036800 	.word	0x00036800
    38b4:	7d000200 	.word	0x7d000200
    38b8:	00000008 	.word	0x00000008
    38bc:	00000000 	.word	0x00000000
    38c0:	0002a800 	.word	0x0002a800
    38c4:	0002ae00 	.word	0x0002ae00
    38c8:	50000100 	.word	0x50000100
    38cc:	000002ae 	.word	0x000002ae
    38d0:	00000368 	.word	0x00000368
    38d4:	00540001 	.word	0x00540001
    38d8:	00000000 	.word	0x00000000
    38dc:	ca000000 	.word	0xca000000
    38e0:	de000002 	.word	0xde000002
    38e4:	01000002 	.word	0x01000002
    38e8:	02de5100 	.word	0x02de5100
    38ec:	03020000 	.word	0x03020000
    38f0:	00010000 	.word	0x00010000
    38f4:	00030251 	.word	0x00030251
    38f8:	00032600 	.word	0x00032600
    38fc:	51000100 	.word	0x51000100
    3900:	00000326 	.word	0x00000326
    3904:	00000346 	.word	0x00000346
    3908:	46510001 	.word	0x46510001
    390c:	4c000003 	.word	0x4c000003
    3910:	01000003 	.word	0x01000003
    3914:	00005100 	.word	0x00005100
    3918:	00000000 	.word	0x00000000
    391c:	02e40000 	.word	0x02e40000
    3920:	03020000 	.word	0x03020000
    3924:	00010000 	.word	0x00010000
    3928:	00030252 	.word	0x00030252
    392c:	00030800 	.word	0x00030800
    3930:	52000100 	.word	0x52000100
	...
    393c:	00000308 	.word	0x00000308
    3940:	00000326 	.word	0x00000326
    3944:	26520001 	.word	0x26520001
    3948:	28000003 	.word	0x28000003
    394c:	01000003 	.word	0x01000003
    3950:	00005200 	.word	0x00005200
    3954:	00000000 	.word	0x00000000
    3958:	03280000 	.word	0x03280000
    395c:	03460000 	.word	0x03460000
    3960:	00010000 	.word	0x00010000
    3964:	00034652 	.word	0x00034652
    3968:	00035200 	.word	0x00035200
    396c:	52000100 	.word	0x52000100
	...
    3978:	000002b4 	.word	0x000002b4
    397c:	000002d8 	.word	0x000002d8
    3980:	de500001 	.word	0xde500001
    3984:	fc000002 	.word	0xfc000002
    3988:	01000002 	.word	0x01000002
    398c:	03025000 	.word	0x03025000
    3990:	03200000 	.word	0x03200000
    3994:	00010000 	.word	0x00010000
    3998:	00032650 	.word	0x00032650
    399c:	00034000 	.word	0x00034000
    39a0:	50000100 	.word	0x50000100
    39a4:	00000346 	.word	0x00000346
    39a8:	00000358 	.word	0x00000358
    39ac:	00500001 	.word	0x00500001
    39b0:	00000000 	.word	0x00000000
    39b4:	68000000 	.word	0x68000000
    39b8:	6a000003 	.word	0x6a000003
    39bc:	01000003 	.word	0x01000003
    39c0:	036a5d00 	.word	0x036a5d00
    39c4:	03ac0000 	.word	0x03ac0000
    39c8:	00020000 	.word	0x00020000
    39cc:	0000107d 	.word	0x0000107d
    39d0:	00000000 	.word	0x00000000
    39d4:	03680000 	.word	0x03680000
    39d8:	036e0000 	.word	0x036e0000
    39dc:	00010000 	.word	0x00010000
    39e0:	00036e50 	.word	0x00036e50
    39e4:	0003ac00 	.word	0x0003ac00
    39e8:	56000100 	.word	0x56000100
	...
    39f4:	00000368 	.word	0x00000368
    39f8:	00000374 	.word	0x00000374
    39fc:	74510001 	.word	0x74510001
    3a00:	ac000003 	.word	0xac000003
    3a04:	01000003 	.word	0x01000003
    3a08:	00005500 	.word	0x00005500
    3a0c:	00000000 	.word	0x00000000
    3a10:	03760000 	.word	0x03760000
    3a14:	037e0000 	.word	0x037e0000
    3a18:	00010000 	.word	0x00010000
    3a1c:	00039650 	.word	0x00039650
    3a20:	0003a200 	.word	0x0003a200
    3a24:	50000100 	.word	0x50000100
	...
    3a30:	000003ac 	.word	0x000003ac
    3a34:	000003ae 	.word	0x000003ae
    3a38:	ae5d0001 	.word	0xae5d0001
    3a3c:	e4000003 	.word	0xe4000003
    3a40:	02000003 	.word	0x02000003
    3a44:	00107d00 	.word	0x00107d00
    3a48:	00000000 	.word	0x00000000
    3a4c:	ac000000 	.word	0xac000000
    3a50:	b2000003 	.word	0xb2000003
    3a54:	01000003 	.word	0x01000003
    3a58:	03b25000 	.word	0x03b25000
    3a5c:	03e40000 	.word	0x03e40000
    3a60:	00010000 	.word	0x00010000
    3a64:	00000056 	.word	0x00000056
    3a68:	00000000 	.word	0x00000000
    3a6c:	0003ac00 	.word	0x0003ac00
    3a70:	0003b800 	.word	0x0003b800
    3a74:	51000100 	.word	0x51000100
    3a78:	000003b8 	.word	0x000003b8
    3a7c:	000003e4 	.word	0x000003e4
    3a80:	00550001 	.word	0x00550001
    3a84:	00000000 	.word	0x00000000
    3a88:	ba000000 	.word	0xba000000
    3a8c:	c0000003 	.word	0xc0000003
    3a90:	01000003 	.word	0x01000003
    3a94:	03d05000 	.word	0x03d05000
    3a98:	03dc0000 	.word	0x03dc0000
    3a9c:	00010000 	.word	0x00010000
    3aa0:	00000050 	.word	0x00000050
    3aa4:	00000000 	.word	0x00000000
    3aa8:	0003e400 	.word	0x0003e400
    3aac:	0003e600 	.word	0x0003e600
    3ab0:	5d000100 	.word	0x5d000100
    3ab4:	000003e6 	.word	0x000003e6
    3ab8:	0000042c 	.word	0x0000042c
    3abc:	107d0002 	.word	0x107d0002
	...
    3ac8:	000003e4 	.word	0x000003e4
    3acc:	000003ea 	.word	0x000003ea
    3ad0:	ea500001 	.word	0xea500001
    3ad4:	2c000003 	.word	0x2c000003
    3ad8:	01000004 	.word	0x01000004
    3adc:	00005600 	.word	0x00005600
    3ae0:	00000000 	.word	0x00000000
    3ae4:	03e40000 	.word	0x03e40000
    3ae8:	03f00000 	.word	0x03f00000
    3aec:	00010000 	.word	0x00010000
    3af0:	0003f051 	.word	0x0003f051
    3af4:	00042c00 	.word	0x00042c00
    3af8:	55000100 	.word	0x55000100
	...
    3b04:	000003f2 	.word	0x000003f2
    3b08:	000003f8 	.word	0x000003f8
    3b0c:	0a500001 	.word	0x0a500001
    3b10:	12000004 	.word	0x12000004
    3b14:	01000004 	.word	0x01000004
    3b18:	04165000 	.word	0x04165000
    3b1c:	04240000 	.word	0x04240000
    3b20:	00010000 	.word	0x00010000
    3b24:	00000050 	.word	0x00000050
    3b28:	00000000 	.word	0x00000000
    3b2c:	00042c00 	.word	0x00042c00
    3b30:	00042e00 	.word	0x00042e00
    3b34:	5d000100 	.word	0x5d000100
    3b38:	0000042e 	.word	0x0000042e
    3b3c:	000004a4 	.word	0x000004a4
    3b40:	087d0002 	.word	0x087d0002
	...
    3b4c:	00000438 	.word	0x00000438
    3b50:	00000442 	.word	0x00000442
    3b54:	62500001 	.word	0x62500001
    3b58:	80000004 	.word	0x80000004
    3b5c:	01000004 	.word	0x01000004
    3b60:	04865000 	.word	0x04865000
    3b64:	04940000 	.word	0x04940000
    3b68:	00010000 	.word	0x00010000
    3b6c:	00000050 	.word	0x00000050
    3b70:	00000000 	.word	0x00000000
    3b74:	0004a400 	.word	0x0004a400
    3b78:	0004a600 	.word	0x0004a600
    3b7c:	5d000100 	.word	0x5d000100
    3b80:	000004a6 	.word	0x000004a6
    3b84:	000004e0 	.word	0x000004e0
    3b88:	087d0002 	.word	0x087d0002
	...
    3b94:	000004b0 	.word	0x000004b0
    3b98:	000004c0 	.word	0x000004c0
    3b9c:	ce500001 	.word	0xce500001
    3ba0:	da000004 	.word	0xda000004
    3ba4:	01000004 	.word	0x01000004
    3ba8:	00005000 	.word	0x00005000
    3bac:	00000000 	.word	0x00000000
    3bb0:	04e00000 	.word	0x04e00000
    3bb4:	04e20000 	.word	0x04e20000
    3bb8:	00010000 	.word	0x00010000
    3bbc:	0004e25d 	.word	0x0004e25d
    3bc0:	0004e600 	.word	0x0004e600
    3bc4:	7d000200 	.word	0x7d000200
    3bc8:	0004e60c 	.word	0x0004e60c
    3bcc:	00052800 	.word	0x00052800
    3bd0:	7d000200 	.word	0x7d000200
    3bd4:	00000010 	.word	0x00000010
    3bd8:	00000000 	.word	0x00000000
    3bdc:	0004e000 	.word	0x0004e000
    3be0:	0004ea00 	.word	0x0004ea00
    3be4:	50000100 	.word	0x50000100
    3be8:	000004ea 	.word	0x000004ea
    3bec:	00000528 	.word	0x00000528
    3bf0:	00550001 	.word	0x00550001
    3bf4:	00000000 	.word	0x00000000
    3bf8:	f0000000 	.word	0xf0000000
    3bfc:	f8000004 	.word	0xf8000004
    3c00:	01000004 	.word	0x01000004
    3c04:	05125000 	.word	0x05125000
    3c08:	051e0000 	.word	0x051e0000
    3c0c:	00010000 	.word	0x00010000
    3c10:	00000050 	.word	0x00000050
	...
    3c1c:	00000200 	.word	0x00000200
    3c20:	5d000100 	.word	0x5d000100
    3c24:	00000002 	.word	0x00000002
    3c28:	0000001c 	.word	0x0000001c
    3c2c:	147d0002 	.word	0x147d0002
    3c30:	0000001c 	.word	0x0000001c
    3c34:	000000a6 	.word	0x000000a6
    3c38:	207d0002 	.word	0x207d0002
	...
    3c48:	00000022 	.word	0x00000022
    3c4c:	5c510001 	.word	0x5c510001
    3c50:	64000000 	.word	0x64000000
    3c54:	01000000 	.word	0x01000000
    3c58:	00a25100 	.word	0x00a25100
    3c5c:	00a60000 	.word	0x00a60000
    3c60:	00010000 	.word	0x00010000
    3c64:	00000051 	.word	0x00000051
    3c68:	00000000 	.word	0x00000000
    3c6c:	00002200 	.word	0x00002200
    3c70:	00003400 	.word	0x00003400
    3c74:	53000100 	.word	0x53000100
    3c78:	00000054 	.word	0x00000054
    3c7c:	0000006a 	.word	0x0000006a
    3c80:	6e530001 	.word	0x6e530001
    3c84:	7a000000 	.word	0x7a000000
    3c88:	01000000 	.word	0x01000000
    3c8c:	009a5300 	.word	0x009a5300
    3c90:	00a60000 	.word	0x00a60000
    3c94:	00010000 	.word	0x00010000
    3c98:	00000053 	.word	0x00000053
    3c9c:	00000000 	.word	0x00000000
    3ca0:	0000b800 	.word	0x0000b800
    3ca4:	0000c200 	.word	0x0000c200
    3ca8:	50000100 	.word	0x50000100
	...
    3cb4:	000000c4 	.word	0x000000c4
    3cb8:	000000c6 	.word	0x000000c6
    3cbc:	00500001 	.word	0x00500001
    3cc0:	00000000 	.word	0x00000000
    3cc4:	cc000000 	.word	0xcc000000
    3cc8:	d6000000 	.word	0xd6000000
    3ccc:	01000000 	.word	0x01000000
    3cd0:	00005000 	.word	0x00005000
    3cd4:	00000000 	.word	0x00000000
    3cd8:	00d80000 	.word	0x00d80000
    3cdc:	00da0000 	.word	0x00da0000
    3ce0:	00010000 	.word	0x00010000
    3ce4:	00000050 	.word	0x00000050
    3ce8:	00000000 	.word	0x00000000
    3cec:	00010800 	.word	0x00010800
    3cf0:	00011800 	.word	0x00011800
    3cf4:	51000100 	.word	0x51000100
	...
    3d00:	00000110 	.word	0x00000110
    3d04:	00000114 	.word	0x00000114
    3d08:	14530001 	.word	0x14530001
    3d0c:	18000001 	.word	0x18000001
    3d10:	01000001 	.word	0x01000001
    3d14:	01185200 	.word	0x01185200
    3d18:	011c0000 	.word	0x011c0000
    3d1c:	00010000 	.word	0x00010000
    3d20:	00011c51 	.word	0x00011c51
    3d24:	00011e00 	.word	0x00011e00
    3d28:	53000100 	.word	0x53000100
    3d2c:	0000011e 	.word	0x0000011e
    3d30:	00000128 	.word	0x00000128
    3d34:	00510001 	.word	0x00510001
    3d38:	00000000 	.word	0x00000000
    3d3c:	34000000 	.word	0x34000000
    3d40:	36000001 	.word	0x36000001
    3d44:	01000001 	.word	0x01000001
    3d48:	01365d00 	.word	0x01365d00
    3d4c:	01940000 	.word	0x01940000
    3d50:	00020000 	.word	0x00020000
    3d54:	00000c7d 	.word	0x00000c7d
    3d58:	00000000 	.word	0x00000000
    3d5c:	01340000 	.word	0x01340000
    3d60:	01400000 	.word	0x01400000
    3d64:	00010000 	.word	0x00010000
    3d68:	00014051 	.word	0x00014051
    3d6c:	00019400 	.word	0x00019400
    3d70:	55000100 	.word	0x55000100
	...
    3d7c:	0000014a 	.word	0x0000014a
    3d80:	00000152 	.word	0x00000152
    3d84:	525c0001 	.word	0x525c0001
    3d88:	5a000001 	.word	0x5a000001
    3d8c:	01000001 	.word	0x01000001
    3d90:	015a5200 	.word	0x015a5200
    3d94:	01780000 	.word	0x01780000
    3d98:	00010000 	.word	0x00010000
    3d9c:	0001785c 	.word	0x0001785c
    3da0:	00017c00 	.word	0x00017c00
    3da4:	53000100 	.word	0x53000100
    3da8:	0000017c 	.word	0x0000017c
    3dac:	00000194 	.word	0x00000194
    3db0:	00520001 	.word	0x00520001
    3db4:	00000000 	.word	0x00000000
    3db8:	94000000 	.word	0x94000000
    3dbc:	96000001 	.word	0x96000001
    3dc0:	01000001 	.word	0x01000001
    3dc4:	01965d00 	.word	0x01965d00
    3dc8:	01c80000 	.word	0x01c80000
    3dcc:	00020000 	.word	0x00020000
    3dd0:	0000087d 	.word	0x0000087d
    3dd4:	00000000 	.word	0x00000000
    3dd8:	01940000 	.word	0x01940000
    3ddc:	01a20000 	.word	0x01a20000
    3de0:	00010000 	.word	0x00010000
    3de4:	00000050 	.word	0x00000050
    3de8:	00000000 	.word	0x00000000
    3dec:	00019400 	.word	0x00019400
    3df0:	0001a800 	.word	0x0001a800
    3df4:	51000100 	.word	0x51000100
	...
    3e00:	000001c8 	.word	0x000001c8
    3e04:	000001ca 	.word	0x000001ca
    3e08:	ca5d0001 	.word	0xca5d0001
    3e0c:	d0000001 	.word	0xd0000001
    3e10:	02000001 	.word	0x02000001
    3e14:	d0047d00 	.word	0xd0047d00
    3e18:	e0000001 	.word	0xe0000001
    3e1c:	02000001 	.word	0x02000001
    3e20:	00087d00 	.word	0x00087d00
    3e24:	00000000 	.word	0x00000000
    3e28:	e0000000 	.word	0xe0000000
    3e2c:	e2000001 	.word	0xe2000001
    3e30:	01000001 	.word	0x01000001
    3e34:	01e25d00 	.word	0x01e25d00
    3e38:	01e60000 	.word	0x01e60000
    3e3c:	00020000 	.word	0x00020000
    3e40:	01e6047d 	.word	0x01e6047d
    3e44:	02880000 	.word	0x02880000
    3e48:	00020000 	.word	0x00020000
    3e4c:	0000107d 	.word	0x0000107d
    3e50:	00000000 	.word	0x00000000
    3e54:	01e00000 	.word	0x01e00000
    3e58:	01e80000 	.word	0x01e80000
    3e5c:	00010000 	.word	0x00010000
    3e60:	0001ea50 	.word	0x0001ea50
    3e64:	00028800 	.word	0x00028800
    3e68:	7d000200 	.word	0x7d000200
    3e6c:	00000004 	.word	0x00000004
    3e70:	00000000 	.word	0x00000000
    3e74:	00          	.byte	0x00
    3e75:	64          	.byte	0x64
    3e76:	0000      	.short	0x0000
    3e78:	00006800 	.word	0x00006800
    3e7c:	50000100 	.word	0x50000100
	...
    3e88:	00000078 	.word	0x00000078
    3e8c:	0000007a 	.word	0x0000007a
    3e90:	7a5d0001 	.word	0x7a5d0001
    3e94:	f4000000 	.word	0xf4000000
    3e98:	02000000 	.word	0x02000000
    3e9c:	000c7d00 	.word	0x000c7d00
    3ea0:	00000000 	.word	0x00000000
    3ea4:	78000000 	.word	0x78000000
    3ea8:	a2000000 	.word	0xa2000000
    3eac:	01000000 	.word	0x01000000
    3eb0:	00d85000 	.word	0x00d85000
    3eb4:	00f40000 	.word	0x00f40000
    3eb8:	00010000 	.word	0x00010000
    3ebc:	00000050 	.word	0x00000050
    3ec0:	00000000 	.word	0x00000000
    3ec4:	00009200 	.word	0x00009200
    3ec8:	00009800 	.word	0x00009800
    3ecc:	52000100 	.word	0x52000100
    3ed0:	00000098 	.word	0x00000098
    3ed4:	000000a6 	.word	0x000000a6
    3ed8:	a6510001 	.word	0xa6510001
    3edc:	be000000 	.word	0xbe000000
    3ee0:	01000000 	.word	0x01000000
    3ee4:	00005300 	.word	0x00005300
    3ee8:	00000000 	.word	0x00000000
    3eec:	00bc0000 	.word	0x00bc0000
    3ef0:	00c40000 	.word	0x00c40000
    3ef4:	00010000 	.word	0x00010000
    3ef8:	0000c451 	.word	0x0000c451
    3efc:	0000ce00 	.word	0x0000ce00
    3f00:	53000100 	.word	0x53000100
	...
    3f0c:	000000ae 	.word	0x000000ae
    3f10:	000000cc 	.word	0x000000cc
    3f14:	00520001 	.word	0x00520001
    3f18:	00000000 	.word	0x00000000
    3f1c:	18000000 	.word	0x18000000
    3f20:	22000001 	.word	0x22000001
    3f24:	01000001 	.word	0x01000001
    3f28:	00005000 	.word	0x00005000
    3f2c:	00000000 	.word	0x00000000
    3f30:	01480000 	.word	0x01480000
    3f34:	01500000 	.word	0x01500000
    3f38:	00010000 	.word	0x00010000
    3f3c:	00000050 	.word	0x00000050
    3f40:	00000000 	.word	0x00000000
    3f44:	00017000 	.word	0x00017000
    3f48:	00017a00 	.word	0x00017a00
    3f4c:	50000100 	.word	0x50000100
	...
    3f58:	000001a0 	.word	0x000001a0
    3f5c:	000001a4 	.word	0x000001a4
    3f60:	00510001 	.word	0x00510001
    3f64:	00000000 	.word	0x00000000
    3f68:	f0000000 	.word	0xf0000000
    3f6c:	f4000001 	.word	0xf4000001
    3f70:	01000001 	.word	0x01000001
    3f74:	00005000 	.word	0x00005000
    3f78:	00000000 	.word	0x00000000
    3f7c:	02180000 	.word	0x02180000
    3f80:	021a0000 	.word	0x021a0000
    3f84:	00010000 	.word	0x00010000
    3f88:	00021a5d 	.word	0x00021a5d
    3f8c:	00027000 	.word	0x00027000
    3f90:	7d000200 	.word	0x7d000200
    3f94:	00000008 	.word	0x00000008
    3f98:	00000000 	.word	0x00000000
    3f9c:	00021800 	.word	0x00021800
    3fa0:	00024200 	.word	0x00024200
    3fa4:	50000100 	.word	0x50000100
	...
    3fb0:	00000218 	.word	0x00000218
    3fb4:	00000230 	.word	0x00000230
    3fb8:	00510001 	.word	0x00510001
    3fbc:	00000000 	.word	0x00000000
    3fc0:	18000000 	.word	0x18000000
    3fc4:	3a000002 	.word	0x3a000002
    3fc8:	01000002 	.word	0x01000002
    3fcc:	00005200 	.word	0x00005200
    3fd0:	00000000 	.word	0x00000000
    3fd4:	02400000 	.word	0x02400000
    3fd8:	02520000 	.word	0x02520000
    3fdc:	00010000 	.word	0x00010000
    3fe0:	00000051 	.word	0x00000051
    3fe4:	00000000 	.word	0x00000000
    3fe8:	00022800 	.word	0x00022800
    3fec:	00023000 	.word	0x00023000
    3ff0:	53000100 	.word	0x53000100
    3ff4:	00000230 	.word	0x00000230
    3ff8:	0000023c 	.word	0x0000023c
    3ffc:	3c510001 	.word	0x3c510001
    4000:	4e000002 	.word	0x4e000002
    4004:	01000002 	.word	0x01000002
    4008:	00005200 	.word	0x00005200
    400c:	00000000 	.word	0x00000000
    4010:	02700000 	.word	0x02700000
    4014:	02720000 	.word	0x02720000
    4018:	00010000 	.word	0x00010000
    401c:	00000050 	.word	0x00000050
    4020:	00000000 	.word	0x00000000
    4024:	00027200 	.word	0x00027200
    4028:	00027600 	.word	0x00027600
    402c:	50000100 	.word	0x50000100
    4030:	0000027a 	.word	0x0000027a
    4034:	00000290 	.word	0x00000290
    4038:	00530001 	.word	0x00530001
    403c:	00000000 	.word	0x00000000
    4040:	90000000 	.word	0x90000000
    4044:	94000002 	.word	0x94000002
    4048:	01000002 	.word	0x01000002
    404c:	00005000 	.word	0x00005000
    4050:	00000000 	.word	0x00000000
    4054:	02a80000 	.word	0x02a80000
    4058:	02ac0000 	.word	0x02ac0000
    405c:	00010000 	.word	0x00010000
    4060:	00000050 	.word	0x00000050
    4064:	00000000 	.word	0x00000000
    4068:	0002c000 	.word	0x0002c000
    406c:	0002c200 	.word	0x0002c200
    4070:	50000100 	.word	0x50000100
	...
    407c:	000002e0 	.word	0x000002e0
    4080:	000002ec 	.word	0x000002ec
    4084:	ee500001 	.word	0xee500001
    4088:	0c000002 	.word	0x0c000002
    408c:	01000003 	.word	0x01000003
    4090:	031a5000 	.word	0x031a5000
    4094:	031e0000 	.word	0x031e0000
    4098:	00010000 	.word	0x00010000
    409c:	00000050 	.word	0x00000050
    40a0:	00000000 	.word	0x00000000
    40a4:	0002ec00 	.word	0x0002ec00
    40a8:	0002ee00 	.word	0x0002ee00
    40ac:	50000100 	.word	0x50000100
    40b0:	0000030c 	.word	0x0000030c
    40b4:	0000031a 	.word	0x0000031a
    40b8:	1e500001 	.word	0x1e500001
    40bc:	1e000003 	.word	0x1e000003
    40c0:	01000003 	.word	0x01000003
    40c4:	00005000 	.word	0x00005000
    40c8:	00000000 	.word	0x00000000
    40cc:	02e60000 	.word	0x02e60000
    40d0:	02ea0000 	.word	0x02ea0000
    40d4:	00010000 	.word	0x00010000
    40d8:	0002ee53 	.word	0x0002ee53
    40dc:	0002f600 	.word	0x0002f600
    40e0:	53000100 	.word	0x53000100
    40e4:	0000031a 	.word	0x0000031a
    40e8:	0000031c 	.word	0x0000031c
    40ec:	00530001 	.word	0x00530001
    40f0:	00000000 	.word	0x00000000
    40f4:	04000000 	.word	0x04000000
    40f8:	1a000003 	.word	0x1a000003
    40fc:	01000003 	.word	0x01000003
    4100:	031e5200 	.word	0x031e5200
    4104:	03240000 	.word	0x03240000
    4108:	00010000 	.word	0x00010000
    410c:	00000052 	.word	0x00000052
    4110:	00000000 	.word	0x00000000
    4114:	00032400 	.word	0x00032400
    4118:	00033000 	.word	0x00033000
    411c:	50000100 	.word	0x50000100
	...
    4128:	00000330 	.word	0x00000330
    412c:	00000332 	.word	0x00000332
    4130:	00500001 	.word	0x00500001
    4134:	00000000 	.word	0x00000000
    4138:	38000000 	.word	0x38000000
    413c:	3a000003 	.word	0x3a000003
    4140:	01000003 	.word	0x01000003
    4144:	033a5d00 	.word	0x033a5d00
    4148:	033c0000 	.word	0x033c0000
    414c:	00020000 	.word	0x00020000
    4150:	033c047d 	.word	0x033c047d
    4154:	03440000 	.word	0x03440000
    4158:	00020000 	.word	0x00020000
    415c:	0000087d 	.word	0x0000087d
    4160:	00000000 	.word	0x00000000
    4164:	03440000 	.word	0x03440000
    4168:	03460000 	.word	0x03460000
    416c:	00010000 	.word	0x00010000
    4170:	0003465d 	.word	0x0003465d
    4174:	00034a00 	.word	0x00034a00
    4178:	7d000200 	.word	0x7d000200
    417c:	00034a04 	.word	0x00034a04
    4180:	00035200 	.word	0x00035200
    4184:	7d000200 	.word	0x7d000200
    4188:	00000008 	.word	0x00000008
    418c:	00000000 	.word	0x00000000
    4190:	00034400 	.word	0x00034400
    4194:	00034800 	.word	0x00034800
    4198:	50000100 	.word	0x50000100
	...
    41a4:	00000354 	.word	0x00000354
    41a8:	00000356 	.word	0x00000356
    41ac:	565d0001 	.word	0x565d0001
    41b0:	58000003 	.word	0x58000003
    41b4:	02000003 	.word	0x02000003
    41b8:	58047d00 	.word	0x58047d00
    41bc:	60000003 	.word	0x60000003
    41c0:	02000003 	.word	0x02000003
    41c4:	00087d00 	.word	0x00087d00
    41c8:	00000000 	.word	0x00000000
    41cc:	60000000 	.word	0x60000000
    41d0:	62000003 	.word	0x62000003
    41d4:	01000003 	.word	0x01000003
    41d8:	03625d00 	.word	0x03625d00
    41dc:	03640000 	.word	0x03640000
    41e0:	00020000 	.word	0x00020000
    41e4:	0364047d 	.word	0x0364047d
    41e8:	036c0000 	.word	0x036c0000
    41ec:	00020000 	.word	0x00020000
    41f0:	0000087d 	.word	0x0000087d
    41f4:	00000000 	.word	0x00000000
    41f8:	036c0000 	.word	0x036c0000
    41fc:	036e0000 	.word	0x036e0000
    4200:	00010000 	.word	0x00010000
    4204:	00036e5d 	.word	0x00036e5d
    4208:	00037000 	.word	0x00037000
    420c:	7d000200 	.word	0x7d000200
    4210:	00037004 	.word	0x00037004
    4214:	00037800 	.word	0x00037800
    4218:	7d000200 	.word	0x7d000200
    421c:	00000008 	.word	0x00000008
    4220:	00000000 	.word	0x00000000
    4224:	00037800 	.word	0x00037800
    4228:	00037a00 	.word	0x00037a00
    422c:	5d000100 	.word	0x5d000100
    4230:	0000037a 	.word	0x0000037a
    4234:	0000037c 	.word	0x0000037c
    4238:	047d0002 	.word	0x047d0002
    423c:	0000037c 	.word	0x0000037c
    4240:	00000384 	.word	0x00000384
    4244:	087d0002 	.word	0x087d0002
	...
    4250:	00000018 	.word	0x00000018
    4254:	00000022 	.word	0x00000022
    4258:	00500001 	.word	0x00500001
    425c:	00000000 	.word	0x00000000
    4260:	1c000000 	.word	0x1c000000
    4264:	22000000 	.word	0x22000000
    4268:	01000000 	.word	0x01000000
    426c:	00225300 	.word	0x00225300
    4270:	002c0000 	.word	0x002c0000
    4274:	00010000 	.word	0x00010000
    4278:	00000050 	.word	0x00000050
    427c:	00000000 	.word	0x00000000
    4280:	00003800 	.word	0x00003800
    4284:	00004400 	.word	0x00004400
    4288:	50000100 	.word	0x50000100
	...
    4294:	0000005c 	.word	0x0000005c
    4298:	00000060 	.word	0x00000060
    429c:	605d0001 	.word	0x605d0001
    42a0:	64000000 	.word	0x64000000
    42a4:	02000000 	.word	0x02000000
    42a8:	64047d00 	.word	0x64047d00
    42ac:	90000000 	.word	0x90000000
    42b0:	02000000 	.word	0x02000000
    42b4:	00087d00 	.word	0x00087d00
    42b8:	00000000 	.word	0x00000000
    42bc:	90000000 	.word	0x90000000
    42c0:	94000000 	.word	0x94000000
    42c4:	01000000 	.word	0x01000000
    42c8:	00945d00 	.word	0x00945d00
    42cc:	00980000 	.word	0x00980000
    42d0:	00020000 	.word	0x00020000
    42d4:	0098047d 	.word	0x0098047d
    42d8:	00c80000 	.word	0x00c80000
    42dc:	00020000 	.word	0x00020000
    42e0:	0000087d 	.word	0x0000087d
    42e4:	00000000 	.word	0x00000000
    42e8:	00900000 	.word	0x00900000
    42ec:	009e0000 	.word	0x009e0000
    42f0:	00010000 	.word	0x00010000
    42f4:	00000050 	.word	0x00000050
    42f8:	00000000 	.word	0x00000000
    42fc:	00009000 	.word	0x00009000
    4300:	0000ba00 	.word	0x0000ba00
    4304:	51000100 	.word	0x51000100
    4308:	000000bc 	.word	0x000000bc
    430c:	000000c0 	.word	0x000000c0
    4310:	00510001 	.word	0x00510001
    4314:	00000000 	.word	0x00000000
    4318:	96000000 	.word	0x96000000
    431c:	9e000000 	.word	0x9e000000
    4320:	01000000 	.word	0x01000000
    4324:	009e5300 	.word	0x009e5300
    4328:	00ba0000 	.word	0x00ba0000
    432c:	00010000 	.word	0x00010000
    4330:	0000bc50 	.word	0x0000bc50
    4334:	0000c000 	.word	0x0000c000
    4338:	50000100 	.word	0x50000100
	...
    4344:	000000c8 	.word	0x000000c8
    4348:	000000ca 	.word	0x000000ca
    434c:	ca5d0001 	.word	0xca5d0001
    4350:	e0000000 	.word	0xe0000000
    4354:	02000000 	.word	0x02000000
    4358:	00087d00 	.word	0x00087d00
    435c:	00000000 	.word	0x00000000
    4360:	74000000 	.word	0x74000000
    4364:	76000000 	.word	0x76000000
    4368:	01000000 	.word	0x01000000
    436c:	00765d00 	.word	0x00765d00
    4370:	00a40000 	.word	0x00a40000
    4374:	00020000 	.word	0x00020000
    4378:	0000087d 	.word	0x0000087d
    437c:	00000000 	.word	0x00000000
    4380:	007c0000 	.word	0x007c0000
    4384:	00820000 	.word	0x00820000
    4388:	00020000 	.word	0x00020000
    438c:	0082047d 	.word	0x0082047d
    4390:	008a0000 	.word	0x008a0000
    4394:	00010000 	.word	0x00010000
    4398:	00008a53 	.word	0x00008a53
    439c:	0000a400 	.word	0x0000a400
    43a0:	7d000200 	.word	0x7d000200
    43a4:	00000004 	.word	0x00000004
    43a8:	00000000 	.word	0x00000000
    43ac:	00009600 	.word	0x00009600
    43b0:	00009800 	.word	0x00009800
    43b4:	50000100 	.word	0x50000100
	...
    43c0:	000000c4 	.word	0x000000c4
    43c4:	000000ce 	.word	0x000000ce
    43c8:	00500001 	.word	0x00500001
    43cc:	00000000 	.word	0x00000000
    43d0:	c8000000 	.word	0xc8000000
    43d4:	cc000000 	.word	0xcc000000
    43d8:	01000000 	.word	0x01000000
    43dc:	00d05300 	.word	0x00d05300
    43e0:	00d80000 	.word	0x00d80000
    43e4:	00010000 	.word	0x00010000
    43e8:	00000050 	.word	0x00000050
    43ec:	00000000 	.word	0x00000000
    43f0:	0000e400 	.word	0x0000e400
    43f4:	0000ee00 	.word	0x0000ee00
    43f8:	50000100 	.word	0x50000100
	...
    4404:	000000e8 	.word	0x000000e8
    4408:	000000ee 	.word	0x000000ee
    440c:	ee530001 	.word	0xee530001
    4410:	f8000000 	.word	0xf8000000
    4414:	01000000 	.word	0x01000000
    4418:	00005000 	.word	0x00005000
    441c:	00000000 	.word	0x00000000
    4420:	01080000 	.word	0x01080000
    4424:	01120000 	.word	0x01120000
    4428:	00010000 	.word	0x00010000
    442c:	00000050 	.word	0x00000050
    4430:	00000000 	.word	0x00000000
    4434:	00010c00 	.word	0x00010c00
    4438:	00011200 	.word	0x00011200
    443c:	53000100 	.word	0x53000100
    4440:	00000112 	.word	0x00000112
    4444:	0000011c 	.word	0x0000011c
    4448:	00500001 	.word	0x00500001
    444c:	00000000 	.word	0x00000000
    4450:	1c000000 	.word	0x1c000000
    4454:	26000001 	.word	0x26000001
    4458:	01000001 	.word	0x01000001
    445c:	00005000 	.word	0x00005000
    4460:	00000000 	.word	0x00000000
    4464:	01200000 	.word	0x01200000
    4468:	01260000 	.word	0x01260000
    446c:	00010000 	.word	0x00010000
    4470:	00012653 	.word	0x00012653
    4474:	00013000 	.word	0x00013000
    4478:	50000100 	.word	0x50000100
	...
    4484:	0000016c 	.word	0x0000016c
    4488:	00000176 	.word	0x00000176
    448c:	00500001 	.word	0x00500001
    4490:	00000000 	.word	0x00000000
    4494:	70000000 	.word	0x70000000
    4498:	76000001 	.word	0x76000001
    449c:	01000001 	.word	0x01000001
    44a0:	01765300 	.word	0x01765300
    44a4:	01800000 	.word	0x01800000
    44a8:	00010000 	.word	0x00010000
    44ac:	00000050 	.word	0x00000050
    44b0:	00000000 	.word	0x00000000
    44b4:	0001ac00 	.word	0x0001ac00
    44b8:	0001b200 	.word	0x0001b200
    44bc:	50000100 	.word	0x50000100
	...
    44c8:	000001c8 	.word	0x000001c8
    44cc:	000001d6 	.word	0x000001d6
    44d0:	d6500001 	.word	0xd6500001
    44d4:	80000001 	.word	0x80000001
    44d8:	01000002 	.word	0x01000002
    44dc:	00005c00 	.word	0x00005c00
    44e0:	00000000 	.word	0x00000000
    44e4:	022a0000 	.word	0x022a0000
    44e8:	022c0000 	.word	0x022c0000
    44ec:	00010000 	.word	0x00010000
    44f0:	00023e53 	.word	0x00023e53
    44f4:	00024000 	.word	0x00024000
    44f8:	53000100 	.word	0x53000100
    44fc:	00000250 	.word	0x00000250
    4500:	00000252 	.word	0x00000252
    4504:	62530001 	.word	0x62530001
    4508:	64000002 	.word	0x64000002
    450c:	01000002 	.word	0x01000002
    4510:	00005300 	.word	0x00005300
    4514:	00000000 	.word	0x00000000
    4518:	01e40000 	.word	0x01e40000
    451c:	021a0000 	.word	0x021a0000
    4520:	00010000 	.word	0x00010000
    4524:	00021c52 	.word	0x00021c52
    4528:	00022600 	.word	0x00022600
    452c:	52000100 	.word	0x52000100
	...
    4538:	00000330 	.word	0x00000330
    453c:	00000366 	.word	0x00000366
    4540:	00500001 	.word	0x00500001
    4544:	00000000 	.word	0x00000000
    4548:	32000000 	.word	0x32000000
    454c:	3a000003 	.word	0x3a000003
    4550:	01000003 	.word	0x01000003
    4554:	03485300 	.word	0x03485300
    4558:	03500000 	.word	0x03500000
    455c:	00010000 	.word	0x00010000
    4560:	00035e53 	.word	0x00035e53
    4564:	00036000 	.word	0x00036000
    4568:	53000100 	.word	0x53000100
	...
    4574:	00000346 	.word	0x00000346
    4578:	00000348 	.word	0x00000348
    457c:	5c530001 	.word	0x5c530001
    4580:	5e000003 	.word	0x5e000003
    4584:	01000003 	.word	0x01000003
    4588:	03625300 	.word	0x03625300
    458c:	03740000 	.word	0x03740000
    4590:	00010000 	.word	0x00010000
    4594:	00000053 	.word	0x00000053
    4598:	00000000 	.word	0x00000000
    459c:	00038400 	.word	0x00038400
    45a0:	00039000 	.word	0x00039000
    45a4:	50000100 	.word	0x50000100
	...
    45b0:	0000007c 	.word	0x0000007c
    45b4:	00000084 	.word	0x00000084
    45b8:	84500001 	.word	0x84500001
    45bc:	a4000000 	.word	0xa4000000
    45c0:	01000000 	.word	0x01000000
    45c4:	00005200 	.word	0x00005200
    45c8:	00000000 	.word	0x00000000
    45cc:	00900000 	.word	0x00900000
    45d0:	00920000 	.word	0x00920000
    45d4:	00010000 	.word	0x00010000
    45d8:	00009650 	.word	0x00009650
    45dc:	00009800 	.word	0x00009800
    45e0:	50000100 	.word	0x50000100
	...
    45ec:	00000020 	.word	0x00000020
    45f0:	00000032 	.word	0x00000032
    45f4:	00510001 	.word	0x00510001
    45f8:	00000000 	.word	0x00000000
    45fc:	74000000 	.word	0x74000000
    4600:	82000000 	.word	0x82000000
    4604:	01000000 	.word	0x01000000
    4608:	00825d00 	.word	0x00825d00
    460c:	00b20000 	.word	0x00b20000
    4610:	00020000 	.word	0x00020000
    4614:	0000087d 	.word	0x0000087d
    4618:	00000000 	.word	0x00000000
    461c:	00740000 	.word	0x00740000
    4620:	008c0000 	.word	0x008c0000
    4624:	00010000 	.word	0x00010000
    4628:	00000050 	.word	0x00000050
    462c:	00000000 	.word	0x00000000
    4630:	00007400 	.word	0x00007400
    4634:	00007600 	.word	0x00007600
    4638:	51000100 	.word	0x51000100
    463c:	00000076 	.word	0x00000076
    4640:	00000080 	.word	0x00000080
    4644:	00530001 	.word	0x00530001
    4648:	00000000 	.word	0x00000000
    464c:	90000000 	.word	0x90000000
    4650:	92000000 	.word	0x92000000
    4654:	01000000 	.word	0x01000000
    4658:	009a5000 	.word	0x009a5000
    465c:	009c0000 	.word	0x009c0000
    4660:	00010000 	.word	0x00010000
    4664:	00009e50 	.word	0x00009e50
    4668:	0000b200 	.word	0x0000b200
    466c:	50000100 	.word	0x50000100
	...
    4678:	000000e4 	.word	0x000000e4
    467c:	000000f6 	.word	0x000000f6
    4680:	00510001 	.word	0x00510001
    4684:	00000000 	.word	0x00000000
    4688:	18000000 	.word	0x18000000
    468c:	2a000001 	.word	0x2a000001
    4690:	01000001 	.word	0x01000001
    4694:	00005100 	.word	0x00005100
    4698:	00000000 	.word	0x00000000
    469c:	014c0000 	.word	0x014c0000
    46a0:	014e0000 	.word	0x014e0000
    46a4:	00010000 	.word	0x00010000
    46a8:	00000051 	.word	0x00000051
    46ac:	00000000 	.word	0x00000000
    46b0:	00015400 	.word	0x00015400
    46b4:	00015600 	.word	0x00015600
    46b8:	50000100 	.word	0x50000100
	...
    46c4:	000001e4 	.word	0x000001e4
    46c8:	000001f6 	.word	0x000001f6
    46cc:	00510001 	.word	0x00510001
    46d0:	00000000 	.word	0x00000000
    46d4:	18000000 	.word	0x18000000
    46d8:	22000002 	.word	0x22000002
    46dc:	01000002 	.word	0x01000002
    46e0:	00005000 	.word	0x00005000
    46e4:	00000000 	.word	0x00000000
    46e8:	02240000 	.word	0x02240000
    46ec:	02280000 	.word	0x02280000
    46f0:	00010000 	.word	0x00010000
    46f4:	00000051 	.word	0x00000051
    46f8:	00000000 	.word	0x00000000
    46fc:	00023000 	.word	0x00023000
    4700:	00026c00 	.word	0x00026c00
    4704:	50000100 	.word	0x50000100
	...
    4710:	00000230 	.word	0x00000230
    4714:	00000232 	.word	0x00000232
    4718:	32510001 	.word	0x32510001
    471c:	3c000002 	.word	0x3c000002
    4720:	01000002 	.word	0x01000002
    4724:	023c5300 	.word	0x023c5300
    4728:	027a0000 	.word	0x027a0000
    472c:	00010000 	.word	0x00010000
    4730:	00000051 	.word	0x00000051
    4734:	00000000 	.word	0x00000000
    4738:	00024000 	.word	0x00024000
    473c:	00025a00 	.word	0x00025a00
    4740:	52000100 	.word	0x52000100
    4744:	0000025a 	.word	0x0000025a
    4748:	0000027a 	.word	0x0000027a
    474c:	005c0001 	.word	0x005c0001
    4750:	00000000 	.word	0x00000000
    4754:	36000000 	.word	0x36000000
    4758:	5a000002 	.word	0x5a000002
    475c:	01000002 	.word	0x01000002
    4760:	00005c00 	.word	0x00005c00
    4764:	00000000 	.word	0x00000000
    4768:	027c0000 	.word	0x027c0000
    476c:	027e0000 	.word	0x027e0000
    4770:	00010000 	.word	0x00010000
    4774:	00000051 	.word	0x00000051
    4778:	00000000 	.word	0x00000000
    477c:	00028c00 	.word	0x00028c00
    4780:	0002a000 	.word	0x0002a000
    4784:	5d000100 	.word	0x5d000100
    4788:	000002a0 	.word	0x000002a0
    478c:	000002cc 	.word	0x000002cc
    4790:	107d0002 	.word	0x107d0002
    4794:	000002cc 	.word	0x000002cc
    4798:	00000328 	.word	0x00000328
    479c:	307d0002 	.word	0x307d0002
	...
    47a8:	0000028c 	.word	0x0000028c
    47ac:	0000028e 	.word	0x0000028e
    47b0:	d4500001 	.word	0xd4500001
    47b4:	28000002 	.word	0x28000002
    47b8:	02000003 	.word	0x02000003
    47bc:	00047d00 	.word	0x00047d00
    47c0:	00000000 	.word	0x00000000
    47c4:	8c000000 	.word	0x8c000000
    47c8:	a6000002 	.word	0xa6000002
    47cc:	01000002 	.word	0x01000002
    47d0:	02a65100 	.word	0x02a65100
    47d4:	03280000 	.word	0x03280000
    47d8:	00010000 	.word	0x00010000
    47dc:	00000056 	.word	0x00000056
    47e0:	00000000 	.word	0x00000000
    47e4:	00029400 	.word	0x00029400
    47e8:	00029a00 	.word	0x00029a00
    47ec:	53000100 	.word	0x53000100
    47f0:	000002aa 	.word	0x000002aa
    47f4:	000002c2 	.word	0x000002c2
    47f8:	c6520001 	.word	0xc6520001
    47fc:	ce000002 	.word	0xce000002
    4800:	01000002 	.word	0x01000002
    4804:	00005300 	.word	0x00005300
    4808:	00000000 	.word	0x00000000
    480c:	02e60000 	.word	0x02e60000
    4810:	02ee0000 	.word	0x02ee0000
    4814:	00010000 	.word	0x00010000
    4818:	00000053 	.word	0x00000053
    481c:	00000000 	.word	0x00000000
    4820:	00032800 	.word	0x00032800
    4824:	00032a00 	.word	0x00032a00
    4828:	5d000100 	.word	0x5d000100
    482c:	0000032a 	.word	0x0000032a
    4830:	0000032e 	.word	0x0000032e
    4834:	047d0002 	.word	0x047d0002
    4838:	0000032e 	.word	0x0000032e
    483c:	000003bc 	.word	0x000003bc
    4840:	107d0002 	.word	0x107d0002
	...
    484c:	00000328 	.word	0x00000328
    4850:	00000330 	.word	0x00000330
    4854:	32500001 	.word	0x32500001
    4858:	bc000003 	.word	0xbc000003
    485c:	02000003 	.word	0x02000003
    4860:	00047d00 	.word	0x00047d00
	...
    486c:	0a000000 	.word	0x0a000000
    4870:	01000000 	.word	0x01000000
    4874:	000a5d00 	.word	0x000a5d00
    4878:	00540000 	.word	0x00540000
    487c:	00020000 	.word	0x00020000
    4880:	0000087d 	.word	0x0000087d
    4884:	00000000 	.word	0x00000000
    4888:	00260000 	.word	0x00260000
    488c:	00380000 	.word	0x00380000
    4890:	00010000 	.word	0x00010000
    4894:	00000053 	.word	0x00000053
	...
    48a0:	00000400 	.word	0x00000400
    48a4:	5d000100 	.word	0x5d000100
    48a8:	00000004 	.word	0x00000004
    48ac:	00000010 	.word	0x00000010
    48b0:	047d0002 	.word	0x047d0002
    48b4:	00000010 	.word	0x00000010
    48b8:	00000028 	.word	0x00000028
    48bc:	087d0002 	.word	0x087d0002
	...
    48cc:	0000000c 	.word	0x0000000c
    48d0:	0c500001 	.word	0x0c500001
    48d4:	1c000000 	.word	0x1c000000
    48d8:	01000000 	.word	0x01000000
    48dc:	00005100 	.word	0x00005100
	...
    48e8:	000c0000 	.word	0x000c0000
    48ec:	00010000 	.word	0x00010000
    48f0:	00000c50 	.word	0x00000c50
    48f4:	00003000 	.word	0x00003000
    48f8:	54000100 	.word	0x54000100
	...
    4908:	00000004 	.word	0x00000004
    490c:	045d0001 	.word	0x045d0001
    4910:	48000000 	.word	0x48000000
    4914:	02000000 	.word	0x02000000
    4918:	00107d00 	.word	0x00107d00
    491c:	00000000 	.word	0x00000000
    4920:	48000000 	.word	0x48000000
    4924:	4c000000 	.word	0x4c000000
    4928:	01000000 	.word	0x01000000
    492c:	004c5d00 	.word	0x004c5d00
    4930:	00c80000 	.word	0x00c80000
    4934:	00020000 	.word	0x00020000
    4938:	0000107d 	.word	0x0000107d
	...
    4944:	00040000 	.word	0x00040000
    4948:	00010000 	.word	0x00010000
    494c:	0000045d 	.word	0x0000045d
    4950:	0000fc00 	.word	0x0000fc00
    4954:	7d000200 	.word	0x7d000200
    4958:	0000000c 	.word	0x0000000c
	...
    4964:	00002000 	.word	0x00002000
    4968:	50000100 	.word	0x50000100
    496c:	00000020 	.word	0x00000020
    4970:	000000fc 	.word	0x000000fc
    4974:	00560001 	.word	0x00560001
	...
    4980:	1c000000 	.word	0x1c000000
    4984:	01000000 	.word	0x01000000
    4988:	001c5100 	.word	0x001c5100
    498c:	00fc0000 	.word	0x00fc0000
    4990:	00010000 	.word	0x00010000
    4994:	00000055 	.word	0x00000055
	...
    49a0:	00001400 	.word	0x00001400
    49a4:	52000100 	.word	0x52000100
    49a8:	00000014 	.word	0x00000014
    49ac:	00000064 	.word	0x00000064
    49b0:	64540001 	.word	0x64540001
    49b4:	b8000000 	.word	0xb8000000
    49b8:	01000000 	.word	0x01000000
    49bc:	00005000 	.word	0x00005000
    49c0:	00000000 	.word	0x00000000
    49c4:	00400000 	.word	0x00400000
    49c8:	00500000 	.word	0x00500000
    49cc:	00010000 	.word	0x00010000
    49d0:	00000050 	.word	0x00000050
    49d4:	00000000 	.word	0x00000000
    49d8:	00001400 	.word	0x00001400
    49dc:	00007000 	.word	0x00007000
    49e0:	52000100 	.word	0x52000100
    49e4:	000000f8 	.word	0x000000f8
    49e8:	000000fc 	.word	0x000000fc
    49ec:	00520001 	.word	0x00520001
    49f0:	00000000 	.word	0x00000000
    49f4:	2c000000 	.word	0x2c000000
    49f8:	50000000 	.word	0x50000000
    49fc:	01000000 	.word	0x01000000
    4a00:	00605000 	.word	0x00605000
    4a04:	00b80000 	.word	0x00b80000
    4a08:	00010000 	.word	0x00010000
    4a0c:	0000b85c 	.word	0x0000b85c
    4a10:	0000fc00 	.word	0x0000fc00
    4a14:	50000100 	.word	0x50000100
	...
    4a20:	0000002c 	.word	0x0000002c
    4a24:	00000058 	.word	0x00000058
    4a28:	5c540001 	.word	0x5c540001
    4a2c:	a4000000 	.word	0xa4000000
    4a30:	01000000 	.word	0x01000000
    4a34:	00b45100 	.word	0x00b45100
    4a38:	00fc0000 	.word	0x00fc0000
    4a3c:	00010000 	.word	0x00010000
    4a40:	00000054 	.word	0x00000054
    4a44:	00000000 	.word	0x00000000
    4a48:	00001c00 	.word	0x00001c00
    4a4c:	00005c00 	.word	0x00005c00
    4a50:	51000100 	.word	0x51000100
    4a54:	000000a4 	.word	0x000000a4
    4a58:	000000dc 	.word	0x000000dc
    4a5c:	f0510001 	.word	0xf0510001
    4a60:	fc000000 	.word	0xfc000000
    4a64:	01000000 	.word	0x01000000
    4a68:	00005100 	.word	0x00005100
	...
    4a74:	00080000 	.word	0x00080000
    4a78:	00010000 	.word	0x00010000
    4a7c:	0000085d 	.word	0x0000085d
    4a80:	0000d000 	.word	0x0000d000
    4a84:	7d000200 	.word	0x7d000200
    4a88:	00000008 	.word	0x00000008
	...
    4a94:	00001800 	.word	0x00001800
    4a98:	50000100 	.word	0x50000100
    4a9c:	00000018 	.word	0x00000018
    4aa0:	00000020 	.word	0x00000020
    4aa4:	20540001 	.word	0x20540001
    4aa8:	38000000 	.word	0x38000000
    4aac:	01000000 	.word	0x01000000
    4ab0:	00385000 	.word	0x00385000
    4ab4:	00d00000 	.word	0x00d00000
    4ab8:	00010000 	.word	0x00010000
    4abc:	00000054 	.word	0x00000054
	...
    4ac8:	00002c00 	.word	0x00002c00
    4acc:	51000100 	.word	0x51000100
    4ad0:	000000a4 	.word	0x000000a4
    4ad4:	000000b0 	.word	0x000000b0
    4ad8:	c4510001 	.word	0xc4510001
    4adc:	d0000000 	.word	0xd0000000
    4ae0:	01000000 	.word	0x01000000
    4ae4:	00005100 	.word	0x00005100
	...
    4af0:	00380000 	.word	0x00380000
    4af4:	00010000 	.word	0x00010000
    4af8:	00003852 	.word	0x00003852
    4afc:	00006000 	.word	0x00006000
    4b00:	5c000100 	.word	0x5c000100
    4b04:	00000060 	.word	0x00000060
    4b08:	00000090 	.word	0x00000090
    4b0c:	a0520001 	.word	0xa0520001
    4b10:	d0000000 	.word	0xd0000000
    4b14:	01000000 	.word	0x01000000
    4b18:	00005200 	.word	0x00005200
    4b1c:	00000000 	.word	0x00000000
    4b20:	000c0000 	.word	0x000c0000
    4b24:	00300000 	.word	0x00300000
    4b28:	00010000 	.word	0x00010000
    4b2c:	0000a45c 	.word	0x0000a45c
    4b30:	0000d000 	.word	0x0000d000
    4b34:	5c000100 	.word	0x5c000100
	...
    4b40:	00000028 	.word	0x00000028
    4b44:	0000002c 	.word	0x0000002c
    4b48:	2c530001 	.word	0x2c530001
    4b4c:	b0000000 	.word	0xb0000000
    4b50:	01000000 	.word	0x01000000
    4b54:	00c45100 	.word	0x00c45100
    4b58:	00d00000 	.word	0x00d00000
    4b5c:	00010000 	.word	0x00010000
    4b60:	00000051 	.word	0x00000051
    4b64:	00000000 	.word	0x00000000
    4b68:	00003400 	.word	0x00003400
    4b6c:	00005c00 	.word	0x00005c00
    4b70:	53000100 	.word	0x53000100
    4b74:	00000070 	.word	0x00000070
    4b78:	00000074 	.word	0x00000074
    4b7c:	74500001 	.word	0x74500001
    4b80:	84000000 	.word	0x84000000
    4b84:	01000000 	.word	0x01000000
    4b88:	00845300 	.word	0x00845300
    4b8c:	00c80000 	.word	0x00c80000
    4b90:	00010000 	.word	0x00010000
    4b94:	00000050 	.word	0x00000050
	...
    4ba0:	00000800 	.word	0x00000800
    4ba4:	5d000100 	.word	0x5d000100
    4ba8:	00000008 	.word	0x00000008
    4bac:	0000009c 	.word	0x0000009c
    4bb0:	147d0002 	.word	0x147d0002
	...
    4bc0:	00000020 	.word	0x00000020
    4bc4:	20500001 	.word	0x20500001
    4bc8:	9c000000 	.word	0x9c000000
    4bcc:	01000000 	.word	0x01000000
    4bd0:	00005500 	.word	0x00005500
	...
    4bdc:	003c0000 	.word	0x003c0000
    4be0:	00010000 	.word	0x00010000
    4be4:	00003c51 	.word	0x00003c51
    4be8:	00009c00 	.word	0x00009c00
    4bec:	58000100 	.word	0x58000100
	...
    4bfc:	0000003c 	.word	0x0000003c
    4c00:	3c520001 	.word	0x3c520001
    4c04:	9c000000 	.word	0x9c000000
    4c08:	01000000 	.word	0x01000000
    4c0c:	00005600 	.word	0x00005600
	...
    4c18:	003c0000 	.word	0x003c0000
    4c1c:	00010000 	.word	0x00010000
    4c20:	00003c53 	.word	0x00003c53
    4c24:	00009c00 	.word	0x00009c00
    4c28:	57000100 	.word	0x57000100
	...
    4c38:	00000004 	.word	0x00000004
    4c3c:	045d0001 	.word	0x045d0001
    4c40:	10000000 	.word	0x10000000
    4c44:	02000000 	.word	0x02000000
    4c48:	10247d00 	.word	0x10247d00
    4c4c:	0c000000 	.word	0x0c000000
    4c50:	02000001 	.word	0x02000001
    4c54:	00307d00 	.word	0x00307d00
	...
    4c60:	24000000 	.word	0x24000000
    4c64:	01000000 	.word	0x01000000
    4c68:	00245000 	.word	0x00245000
    4c6c:	00c00000 	.word	0x00c00000
    4c70:	00020000 	.word	0x00020000
    4c74:	00c0047d 	.word	0x00c0047d
    4c78:	00d40000 	.word	0x00d40000
    4c7c:	00020000 	.word	0x00020000
    4c80:	00d47091 	.word	0x00d47091
    4c84:	00e80000 	.word	0x00e80000
    4c88:	00020000 	.word	0x00020000
    4c8c:	00e8047d 	.word	0x00e8047d
    4c90:	00f40000 	.word	0x00f40000
    4c94:	00020000 	.word	0x00020000
    4c98:	00f47091 	.word	0x00f47091
    4c9c:	010c0000 	.word	0x010c0000
    4ca0:	00020000 	.word	0x00020000
    4ca4:	0000047d 	.word	0x0000047d
	...
    4cb0:	00240000 	.word	0x00240000
    4cb4:	00010000 	.word	0x00010000
    4cb8:	00002451 	.word	0x00002451
    4cbc:	00010c00 	.word	0x00010c00
    4cc0:	57000100 	.word	0x57000100
	...
    4ccc:	00000044 	.word	0x00000044
    4cd0:	000000c0 	.word	0x000000c0
    4cd4:	d45c0001 	.word	0xd45c0001
    4cd8:	dc000000 	.word	0xdc000000
    4cdc:	01000000 	.word	0x01000000
    4ce0:	00f85c00 	.word	0x00f85c00
    4ce4:	01040000 	.word	0x01040000
    4ce8:	00010000 	.word	0x00010000
    4cec:	0000005c 	.word	0x0000005c
    4cf0:	00000000 	.word	0x00000000
	...

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00003041 	andeq	r3, r0, r1, asr #32
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000026 	andeq	r0, r0, r6, lsr #32
  10:	524f4305 	subpl	r4, pc, #335544320	; 0x14000000
  14:	2d584554 	cfldr64cs	mvdx4, [r8, #-336]
  18:	0600334d 	streq	r3, [r0], -sp, asr #6
  1c:	084d070a 	stmdaeq	sp, {r1, r3, r8, r9, sl}^
  20:	12020901 	andne	r0, r2, #16384	; 0x4000
  24:	15011404 	strne	r1, [r1, #-1028]
  28:	18031701 	stmdane	r3, {r0, r8, r9, sl, ip}
  2c:	1a011901 	bne	46438 <__Stack_Size+0x46038>
  30:	Address 0x00000030 is out of bounds.


Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
   0:	ffffffff 	undefined instruction 0xffffffff
	...
  20:	00000ecc 	andeq	r0, r0, ip, asr #29
  24:	00000ed0 	ldrdeq	r0, [r0], -r0
  28:	00000ed4 	ldrdeq	r0, [r0], -r4
  2c:	00000eee 	andeq	r0, r0, lr, ror #29
	...
  38:	00000ecc 	andeq	r0, r0, ip, asr #29
  3c:	00000ed0 	ldrdeq	r0, [r0], -r0
  40:	00000ed4 	ldrdeq	r0, [r0], -r4
  44:	00000eee 	andeq	r0, r0, lr, ror #29
	...
  50:	00000eee 	andeq	r0, r0, lr, ror #29
  54:	00000ef0 	strdeq	r0, [r0], -r0
  58:	00000ef4 	strdeq	r0, [r0], -r4
  5c:	00000f10 	andeq	r0, r0, r0, lsl pc
	...
  68:	00000eee 	andeq	r0, r0, lr, ror #29
  6c:	00000ef0 	strdeq	r0, [r0], -r0
  70:	00000ef4 	strdeq	r0, [r0], -r4
  74:	00000f10 	andeq	r0, r0, r0, lsl pc
	...
  80:	00000f10 	andeq	r0, r0, r0, lsl pc
  84:	00000f12 	andeq	r0, r0, r2, lsl pc
  88:	00000f16 	andeq	r0, r0, r6, lsl pc
  8c:	00000f34 	andeq	r0, r0, r4, lsr pc
	...
  98:	00000f10 	andeq	r0, r0, r0, lsl pc
  9c:	00000f12 	andeq	r0, r0, r2, lsl pc
  a0:	00000f16 	andeq	r0, r0, r6, lsl pc
  a4:	00000f34 	andeq	r0, r0, r4, lsr pc
	...
  b0:	0000125a 	andeq	r1, r0, sl, asr r2
  b4:	0000125e 	andeq	r1, r0, lr, asr r2
  b8:	00001260 	andeq	r1, r0, r0, ror #4
  bc:	0000127a 	andeq	r1, r0, sl, ror r2
	...
  c8:	000012ae 	andeq	r1, r0, lr, lsr #5
  cc:	000012b2 	strheq	r1, [r0], -r2
  d0:	000012b4 	strheq	r1, [r0], -r4
  d4:	000012c0 	andeq	r1, r0, r0, asr #5
	...
  e0:	000013cc 	andeq	r1, r0, ip, asr #7
  e4:	000013ce 	andeq	r1, r0, lr, asr #7
  e8:	000013d6 	ldrdeq	r1, [r0], -r6
  ec:	000013e2 	andeq	r1, r0, r2, ror #7
  f0:	000013d2 	ldrdeq	r1, [r0], -r2
  f4:	000013d4 	ldrdeq	r1, [r0], -r4
	...
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
		if (nextpose_[i] > pose_[i]) {
 100:	000013e2 	andeq	r1, r0, r2, ror #7

/* set up for an interpolation from pose to nextpose over TIME
 milliseconds by setting servo speeds. */
void BioloidControllerEx_interpolateSetup(int time) {
	int i;
	int frames = (time/frameLength) + 1;
 104:	000013f2 	strdeq	r1, [r0], -r2
 108:	000013f4 	strdeq	r1, [r0], -r4
	nextframe_ = getMillis() + frameLength;
 10c:	00001406 	andeq	r1, r0, r6, lsl #8
	...
 118:	0000042e 	andeq	r0, r0, lr, lsr #8
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
 11c:	0000043c 	andeq	r0, r0, ip, lsr r4
 120:	0000044a 	andeq	r0, r0, sl, asr #8
 124:	0000044e 	andeq	r0, r0, lr, asr #8
		if (nextpose_[i] > pose_[i]) {
 128:	0000043e 	andeq	r0, r0, lr, lsr r4
 12c:	00000448 	andeq	r0, r0, r8, asr #8
	...
			speed_[i] = (nextpose_[i] - pose_[i]) / frames + 1;
		} else {
			speed_[i] = (pose_[i] - nextpose_[i]) / frames + 1;
 138:	000000b8 	strheq	r0, [r0], -r8
 13c:	000000ba 	strheq	r0, [r0], -sl
	PrintString("BioloidEX BioloidControllerEx_interpolateSetup nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// set speed each servo...
	for (i = 0; i < poseSize; i++) {
 140:	000000bc 	strheq	r0, [r0], -ip
 144:	000000ca 	andeq	r0, r0, sl, asr #1
	...
		TxD_Dec_U16(speed_[i]);
		PrintString("\n");
#endif
	}
	interpolating = 1;
}
 150:	00000166 	andeq	r0, r0, r6, ror #2
 154:	00000168 	andeq	r0, r0, r8, ror #2
 158:	0000016c 	andeq	r0, r0, ip, ror #2
 15c:	000001b6 	strheq	r0, [r0], -r6
	...
 168:	000002fa 	strdeq	r0, [r0], -sl
	PrintString("\n");
#endif
}

/* new-style setup */
void Bioloid_Setup(int servo_cnt) {
 16c:	000002fc 	strdeq	r0, [r0], -ip
 170:	000002fe 	strdeq	r0, [r0], -lr
	/**id_ = (unsigned char *) malloc(servo_cnt * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
 174:	00000326 	andeq	r0, r0, r6, lsr #6
	...
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 180:	000003b6 	strheq	r0, [r0], -r6
		nextpose_[i] = 512;
 184:	000003bc 	strheq	r0, [r0], -ip
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
		id_[i] = i + 1;
 188:	000003c0 	andeq	r0, r0, r0, asr #7
		pose_[i] = 512;
 18c:	000003de 	ldrdeq	r0, [r0], -lr
	...
	 pose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(servo_cnt * sizeof(unsigned int));
	 speed_ = (int *) malloc(servo_cnt * sizeof(int));*/
	// initialize
	poseSize = servo_cnt;
	for (i = 0; i < poseSize; i++) {
 198:	00000454 	andeq	r0, r0, r4, asr r4
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	interpolating = 0;
 19c:	00000456 	andeq	r0, r0, r6, asr r4
 1a0:	00000458 	andeq	r0, r0, r8, asr r4
	nextframe_ = getMillis();
 1a4:	00000488 	andeq	r0, r0, r8, lsl #9
	...
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
 1b0:	00000064 	andeq	r0, r0, r4, rrx
 1b4:	00000066 	andeq	r0, r0, r6, rrx
 1b8:	00000068 	andeq	r0, r0, r8, rrx
 1bc:	00000074 	andeq	r0, r0, r4, ror r0
	...
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
 1c8:	000000b8 	strheq	r0, [r0], -r8
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
 1cc:	000000be 	strheq	r0, [r0], -lr
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 1d0:	000000c0 	andeq	r0, r0, r0, asr #1
transition_t * sequence;                    // sequence we are running
int transitions;                    // how many transitions we have left to load


//  initializes serial1 transmit at baud, 8-N-1
void BioloidControllerEx() {
 1d4:	000001bc 	strheq	r0, [r0], -ip
	...
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
 1e0:	000000b8 	strheq	r0, [r0], -r8
		pose_[i] = 512;
		nextpose_[i] = 512;
 1e4:	000000be 	strheq	r0, [r0], -lr
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
		id_[i] = i + 1;
		pose_[i] = 512;
 1e8:	000001b8 	strheq	r0, [r0], -r8
		nextpose_[i] = 512;
 1ec:	000001ba 	strheq	r0, [r0], -sl
	/**id_ = (unsigned char *) malloc(AX12_MAX_SERVOS * sizeof(unsigned char));
	 pose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 nextpose_ = (unsigned int *) malloc(AX12_MAX_SERVOS * sizeof(unsigned int));
	 speed_ = (int *) malloc(AX12_MAX_SERVOS * sizeof(int));*/
	// initialize
	for (i = 0; i < AX12_MAX_SERVOS; i++) {
 1f0:	000000c0 	andeq	r0, r0, r0, asr #1
		id_[i] = i + 1;
		pose_[i] = 512;
		nextpose_[i] = 512;
	}
	frameLength = BIOLOID_FRAME_LENGTH;
 1f4:	000001b6 	strheq	r0, [r0], -r6
	...
	interpolating = 0;
	nextframe_ = getMillis();
 200:	000000b8 	strheq	r0, [r0], -r8
 204:	000000be 	strheq	r0, [r0], -lr
#ifdef MILLIS
	PrintString("BioloidEX nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
}
 208:	000001b8 	strheq	r0, [r0], -r8
 20c:	000001ba 	strheq	r0, [r0], -sl
 210:	00000168 	andeq	r0, r0, r8, ror #2
 214:	000001b6 	strheq	r0, [r0], -r6
 218:	000000d4 	ldrdeq	r0, [r0], -r4
 21c:	000000d6 	ldrdeq	r0, [r0], -r6
 220:	000000cc 	andeq	r0, r0, ip, asr #1
#endif
		mDelay(25);
	}
}
/* write pose out to servos using sync write. */
void BioloidControllerEx_writePose() {
 224:	000000ce 	andeq	r0, r0, lr, asr #1
 228:	000000c0 	andeq	r0, r0, r0, asr #1
	int temp;
	dxl_set_txpacket_id (BROADCAST_ID);
 22c:	000000c8 	andeq	r0, r0, r8, asr #1
	...
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
 238:	0000034e 	andeq	r0, r0, lr, asr #6
	dxl_set_txpacket_parameter(1, 2);
 23c:	00000352 	andeq	r0, r0, r2, asr r3
 240:	000003b8 	strheq	r0, [r0], -r8
 244:	000003ba 	strheq	r0, [r0], -sl
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 248:	00000354 	andeq	r0, r0, r4, asr r3
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
 24c:	000003b6 	strheq	r0, [r0], -r6
	...
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 258:	000003b6 	strheq	r0, [r0], -r6
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
 25c:	000003b8 	strheq	r0, [r0], -r8
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 260:	000003ba 	strheq	r0, [r0], -sl
 264:	000003c4 	andeq	r0, r0, r4, asr #7
	...
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
 270:	0000011e 	andeq	r0, r0, lr, lsl r1
 274:	00000120 	andeq	r0, r0, r0, lsr #2
	int i;
	for (i = 0; i < poseSize; i++) {
		//temp = pose_[i] >> BIOLOID_SHIFT;
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
 278:	00000126 	andeq	r0, r0, r6, lsr #2
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
 27c:	0000014a 	andeq	r0, r0, sl, asr #2
	dxl_set_txpacket_id (BROADCAST_ID);
	dxl_set_txpacket_instruction (INST_SYNC_WRITE);
	dxl_set_txpacket_parameter(0, AXM_GOAL_POSITION_L);
	dxl_set_txpacket_parameter(1, 2);
	int i;
	for (i = 0; i < poseSize; i++) {
 280:	00000122 	andeq	r0, r0, r2, lsr #2
 284:	00000124 	andeq	r0, r0, r4, lsr #2
	...
		temp = pose_[i];
		dxl_set_txpacket_parameter(2 + 3 * i, id_[i]);
		dxl_set_txpacket_parameter(2 + 3 * i + 1, dxl_get_lowbyte(temp));
		dxl_set_txpacket_parameter(2 + 3 * i + 2, dxl_get_highbyte(temp));
	}
	dxl_set_txpacket_length((2 + 1) * poseSize + 4);
 290:	0000011e 	andeq	r0, r0, lr, lsl r1
 294:	00000120 	andeq	r0, r0, r0, lsr #2
	dxl_txrx_packet();
 298:	00000130 	andeq	r0, r0, r0, lsr r1
	u16 CommStatus = dxl_get_result();
 29c:	0000014a 	andeq	r0, r0, sl, asr #2
#ifdef USING_PC_UART
	if (CommStatus == DXL_RXSUCCESS)
 2a0:	00000122 	andeq	r0, r0, r2, lsr #2
		PrintErrorCode();
 2a4:	00000124 	andeq	r0, r0, r4, lsr #2
	...
	else
		PrintCommStatus(CommStatus);
#endif
}
 2b0:	0000014a 	andeq	r0, r0, sl, asr #2
 2b4:	0000015e 	andeq	r0, r0, lr, asr r1
 2b8:	00000188 	andeq	r0, r0, r8, lsl #3
	}
	interpolating = 1;
}
/* interpolate our pose, this should be called at about 30Hz. */
#define WAIT_SLOP_FACTOR 10
int BioloidControllerEx_interpolateStep(bool fWait) {
 2bc:	0000018e 	andeq	r0, r0, lr, lsl #3
	...

	if (interpolating == 0)
		return 0;
	int i;
	int complete = poseSize;
 2c8:	0000014a 	andeq	r0, r0, sl, asr #2
	if (!fWait) {
 2cc:	0000015e 	andeq	r0, r0, lr, asr r1
		if (getMillis() < (nextframe_ - WAIT_SLOP_FACTOR)) {
 2d0:	00000188 	andeq	r0, r0, r8, lsl #3
 2d4:	0000018e 	andeq	r0, r0, lr, lsl #3
	...
			return (getMillis() - nextframe_); // We still have some time to do something...
 2e0:	0000015e 	andeq	r0, r0, lr, asr r1
 2e4:	00000182 	andeq	r0, r0, r2, lsl #3
#ifdef MILLIS
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	while (getMillis() < nextframe_);
 2e8:	00000186 	andeq	r0, r0, r6, lsl #3
 2ec:	00000188 	andeq	r0, r0, r8, lsl #3
	...
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 2f8:	0000015e 	andeq	r0, r0, lr, asr r1
 2fc:	00000160 	andeq	r0, r0, r0, ror #2
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_-Millis ");
	Printu32d(getMillis());
	PrintString("\n");
#endif

	nextframe_ = getMillis() + frameLength;
 300:	00000186 	andeq	r0, r0, r6, lsl #3
 304:	00000188 	andeq	r0, r0, r8, lsl #3
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 308:	0000016a 	andeq	r0, r0, sl, ror #2
		int diff = nextpose_[i] - pose_[i];
 30c:	00000182 	andeq	r0, r0, r2, lsl #3
	...
 318:	00000078 	andeq	r0, r0, r8, ror r0
 31c:	0000007a 	andeq	r0, r0, sl, ror r0
		if (diff == 0) {
 320:	0000007c 	andeq	r0, r0, ip, ror r0
			complete--;
		} else {
			if (diff > 0) {
				if (diff < speed_[i]) {
 324:	0000007e 	andeq	r0, r0, lr, ror r0
	...
					pose_[i] = nextpose_[i];
 330:	00000078 	andeq	r0, r0, r8, ror r0
					complete--;
 334:	0000007a 	andeq	r0, r0, sl, ror r0
				} else
					pose_[i] += speed_[i];
			} else {
				if ((-diff) < speed_[i]) {
 338:	0000007c 	andeq	r0, r0, ip, ror r0
 33c:	0000007e 	andeq	r0, r0, lr, ror r0
	...
					pose_[i] = nextpose_[i];
					complete--;
				} else
					pose_[i] -= speed_[i];
 348:	0000001c 	andeq	r0, r0, ip, lsl r0
	PrintString("BioloidEX  BioloidControllerEx_interpolateStep nextframe_ (Millis + framelength) ");
	Printu32d(nextframe_);
	PrintString("\n");
#endif
	// update each servo
	for (i = 0; i < poseSize; i++) {
 34c:	00000024 	andeq	r0, r0, r4, lsr #32
 350:	00000070 	andeq	r0, r0, r0, ror r0
		TxD_Dec_U16(pose_[i]);
		PrintString("\n");
#endif

	}
	if (complete <= 0)
 354:	0000010c 	andeq	r0, r0, ip, lsl #2
		interpolating = 0;
 358:	00000044 	andeq	r0, r0, r4, asr #32
	BioloidControllerEx_writePose();
 35c:	00000058 	andeq	r0, r0, r8, asr r0
	...
	return 0;
}
 368:	ffffffff 	undefined instruction 0xffffffff
	...
